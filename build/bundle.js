webpackJsonp([1],[function(n,c,t){t(212),t(248),n.exports=t(109)},,,,,,,,,,,,,,,,,,,,,,,function(module,exports,__webpack_require__){eval("\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanM/M2JiYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICBmdW5jdGlvbiBvbigpIHtcbiAgICBzZWxmLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies.\n */\n\nvar keys = __webpack_require__(224);\nvar hasBinary = __webpack_require__(229);\nvar sliceBuffer = __webpack_require__(226);\nvar base64encoder = __webpack_require__(227);\nvar after = __webpack_require__(225);\nvar utf8 = __webpack_require__(231);\n\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\nvar isAndroid = navigator.userAgent.match(/Android/i);\n\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\nvar isPhantomJS = /PhantomJS/i.test(navigator.userAgent);\n\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\nvar dontSendBlobs = isAndroid || isPhantomJS;\n\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = __webpack_require__(228);\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if ('function' == typeof supportsBinary) {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n\n  if ('function' == typeof utf8encode) {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  var data = (packet.data === undefined)\n    ? undefined\n    : packet.data.buffer || packet.data;\n\n  if (global.ArrayBuffer && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (Blob && data instanceof global.Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  }\n\n  // might be an object with { base64: true, data: dataAsBase64String }\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n\n};\n\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n\n/**\n * Encode packet helpers for binary types\n */\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\n  resultBuffer[0] = packets[packet.type];\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i+1] = contentArray[i];\n  }\n\n  return callback(resultBuffer.buffer);\n}\n\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var fr = new FileReader();\n  fr.onload = function() {\n    packet.data = fr.result;\n    exports.encodePacket(packet, supportsBinary, true, callback);\n  };\n  return fr.readAsArrayBuffer(packet.data);\n}\n\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n\n  return callback(blob);\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n  if (Blob && packet.data instanceof Blob) {\n    var fr = new FileReader();\n    fr.onload = function() {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n    return fr.readAsDataURL(packet.data);\n  }\n\n  var b64data;\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n  message += global.btoa(b64data);\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  // String data\n  if (typeof data == 'string' || data === undefined) {\n    if (data.charAt(0) == 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      try {\n        data = utf8.decode(data);\n      } catch (e) {\n        return err;\n      }\n    }\n    var type = data.charAt(0);\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n  return { type: packetslist[type], data: rest };\n};\n\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  if (!global.ArrayBuffer) {\n    return { type: type, data: { base64: true, data: msg.substr(1) } };\n  }\n\n  var data = base64encoder.decode(msg.substr(1));\n\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary == 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  var isBinary = hasBinary(packets);\n\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  var eachWithIndex = function(i, el, cb) {\n    each(el, function(error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data != 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var packet;\n  if (data == '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = ''\n    , n, msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (':' != chr) {\n      length += chr;\n    } else {\n      if ('' == length || (length != (n = Number(length)))) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      msg = data.substr(i + 1, n);\n\n      if (length != msg.length) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      if (msg.length) {\n        packet = exports.decodePacket(msg, binaryType, true);\n\n        if (err.type == packet.type && err.data == packet.data) {\n          // parser error in individual packet - ignoring payload\n          return callback(err, 0, 1);\n        }\n\n        var ret = callback(packet, i + n, l);\n        if (false === ret) return;\n      }\n\n      // advance cursor\n      i += n;\n      length = '';\n    }\n  }\n\n  if (length != '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsArrayBuffer = function(packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(data) {\n      return doneCallback(null, data);\n    });\n  }\n\n  map(packets, encodeOne, function(err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function(acc, p) {\n      var len;\n      if (typeof p === 'string'){\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n\n    var resultArray = new Uint8Array(totalLength);\n\n    var bufferIndex = 0;\n    encodedPackets.forEach(function(p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n      if (isString) {\n        var view = new Uint8Array(p.length);\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n        ab = view.buffer;\n      }\n\n      if (isString) { // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else { // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n\n      var lenStr = ab.byteLength.toString();\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n      resultArray[bufferIndex++] = 255;\n\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n\n    return callback(resultArray.buffer);\n  });\n};\n\n/**\n * Encode as Blob\n */\n\nexports.encodePayloadAsBlob = function(packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n\n      var len = (encoded instanceof ArrayBuffer)\n        ? encoded.byteLength\n        : encoded.size;\n\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n      lengthAry[lenStr.length] = 255;\n\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(new Blob(results));\n  });\n};\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n\n  var numberTooLong = false;\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n\n    for (var i = 1; ; i++) {\n      if (tailArray[i] == 255) break;\n\n      if (msgLength.length > 310) {\n        numberTooLong = true;\n        break;\n      }\n\n      msgLength += tailArray[i];\n    }\n\n    if(numberTooLong) return callback(err, 0, 1);\n\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n\n  var total = buffers.length;\n  buffers.forEach(function(buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvbGliL2Jyb3dzZXIuanM/YTJkMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztB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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLEVBQUU7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnknKTtcbnZhciBzbGljZUJ1ZmZlciA9IHJlcXVpcmUoJ2FycmF5YnVmZmVyLnNsaWNlJyk7XG52YXIgYmFzZTY0ZW5jb2RlciA9IHJlcXVpcmUoJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgndXRmOCcpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZC9pKTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG4gKiBVcGxvYWRpbmcgYSBCbG9iIHdpdGggUGhhbnRvbUpTIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LCBhcyByZXBvcnRlZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGlzUGhhbnRvbUpTID0gL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblxuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5cbnZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46ICAgICAwICAgIC8vIG5vbi13c1xuICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuICAsIHBpbmc6ICAgICAyXG4gICwgcG9uZzogICAgIDNcbiAgLCBtZXNzYWdlOiAgNFxuICAsIHVwZ3JhZGU6ICA1XG4gICwgbm9vcDogICAgIDZcbn07XG5cbnZhciBwYWNrZXRzbGlzdCA9IGtleXMocGFja2V0cyk7XG5cbi8qKlxuICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gKi9cblxudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSBibG9iIGFwaSBldmVuIGZvciBibG9iIGJ1aWxkZXIgd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYiA9IHJlcXVpcmUoJ2Jsb2InKTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0LlxuICpcbiAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA1aGVsbG8gd29ybGRcbiAqICAgICAzXG4gKiAgICAgNFxuICpcbiAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB1dGY4ZW5jb2RlLCBjYWxsYmFjaykge1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXRmOGVuY29kZSkge1xuICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuICBpZiAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoQmxvYiAmJiBkYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlNjQpIHtcbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cbiAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSkpIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG59O1xuXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuICAvLyBwYWNrZXQgZGF0YSBpcyBhbiBvYmplY3QgeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHBhY2tldC5kYXRhID0gZnIucmVzdWx0O1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHRydWUsIGNhbGxiYWNrKTtcbiAgfTtcbiAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgaWYgKEJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgdmFyIGI2NGRhdGE7XG4gIHRyeSB7XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG4gICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhc2ljW2ldID0gdHlwZWRbaV07XG4gICAgfVxuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcbiAgfVxuICBtZXNzYWdlICs9IGdsb2JhbC5idG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycgfHwgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09ICdiJykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc3Vic3RyKDEpLCBiaW5hcnlUeXBlKTtcbiAgICB9XG5cbiAgICBpZiAodXRmOGRlY29kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IHV0ZjguZGVjb2RlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdHlwZSA9IGRhdGEuY2hhckF0KDApO1xuXG4gICAgaWYgKE51bWJlcih0eXBlKSAhPSB0eXBlIHx8ICFwYWNrZXRzbGlzdFt0eXBlXSkge1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zdWJzdHJpbmcoMSkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0gfTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXNBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgdHlwZSA9IGFzQXJyYXlbMF07XG4gIHZhciByZXN0ID0gc2xpY2VCdWZmZXIoZGF0YSwgMSk7XG4gIGlmIChCbG9iICYmIGJpbmFyeVR5cGUgPT09ICdibG9iJykge1xuICAgIHJlc3QgPSBuZXcgQmxvYihbcmVzdF0pO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiByZXN0IH07XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgaWYgKCFnbG9iYWwuQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG4gIH1cblxuICB2YXIgZGF0YSA9IGJhc2U2NGVuY29kZXIuZGVjb2RlKG1zZy5zdWJzdHIoMSkpO1xuXG4gIGlmIChiaW5hcnlUeXBlID09PSAnYmxvYicgJiYgQmxvYikge1xuICAgIGRhdGEgPSBuZXcgQmxvYihbZGF0YV0pO1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKS5cbiAqXG4gKiAgICAgPGxlbmd0aD46ZGF0YVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDExOmhlbGxvIHdvcmxkMjpoaVxuICpcbiAqIElmIGFueSBjb250ZW50cyBhcmUgYmluYXJ5LCB0aGV5IHdpbGwgYmUgZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5ncy4gQmFzZTY0XG4gKiBlbmNvZGVkIHN0cmluZ3MgYXJlIG1hcmtlZCB3aXRoIGEgYiBiZWZvcmUgdGhlIGxlbmd0aCBzcGVjaWZpZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWQgPSBmdW5jdGlvbiAocGFja2V0cywgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuICB9XG5cbiAgdmFyIGlzQmluYXJ5ID0gaGFzQmluYXJ5KHBhY2tldHMpO1xuXG4gIGlmIChzdXBwb3J0c0JpbmFyeSAmJiBpc0JpbmFyeSkge1xuICAgIGlmIChCbG9iICYmICFkb250U2VuZEJsb2JzKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCAhaXNCaW5hcnkgPyBmYWxzZSA6IHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIHBhY2tldDtcbiAgaWYgKGRhdGEgPT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gJydcbiAgICAsIG4sIG1zZztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNociA9IGRhdGEuY2hhckF0KGkpO1xuXG4gICAgaWYgKCc6JyAhPSBjaHIpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgnJyA9PSBsZW5ndGggfHwgKGxlbmd0aCAhPSAobiA9IE51bWJlcihsZW5ndGgpKSkpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgICBpZiAobGVuZ3RoICE9IG1zZy5sZW5ndGgpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1zZy5sZW5ndGgpIHtcbiAgICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCB0cnVlKTtcblxuICAgICAgICBpZiAoZXJyLnR5cGUgPT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0ID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGFkdmFuY2UgY3Vyc29yXG4gICAgICBpICs9IG47XG4gICAgICBsZW5ndGggPSAnJztcbiAgICB9XG4gIH1cblxuICBpZiAobGVuZ3RoICE9ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuICpcbiAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcbiAqIDI1NT48ZGF0YT5cbiAqXG4gKiBFeGFtcGxlOlxuICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCBlbmNvZGVkUGFja2V0cykge1xuICAgIHZhciB0b3RhbExlbmd0aCA9IGVuY29kZWRQYWNrZXRzLnJlZHVjZShmdW5jdGlvbihhY2MsIHApIHtcbiAgICAgIHZhciBsZW47XG4gICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgbGVuID0gcC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSBwLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjICsgbGVuLnRvU3RyaW5nKCkubGVuZ3RoICsgbGVuICsgMjsgLy8gc3RyaW5nL2JpbmFyeSBpZGVudGlmaWVyICsgc2VwYXJhdG9yID0gMlxuICAgIH0sIDApO1xuXG4gICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG4gICAgdmFyIGJ1ZmZlckluZGV4ID0gMDtcbiAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiBwID09PSAnc3RyaW5nJztcbiAgICAgIHZhciBhYiA9IHA7XG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShwLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYWIgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RyaW5nKSB7IC8vIG5vdCB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDA7XG4gICAgICB9IGVsc2UgeyAvLyB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5TdHIgPSBhYi5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblxuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSB2aWV3W2ldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEFycmF5LmJ1ZmZlcik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFbmNvZGUgYXMgQmxvYlxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYiA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgdmFyIGJpbmFyeUlkZW50aWZpZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAxO1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWQubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVkID0gdmlldy5idWZmZXI7XG4gICAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gKGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgPyBlbmNvZGVkLmJ5dGVMZW5ndGhcbiAgICAgICAgOiBlbmNvZGVkLnNpemU7XG5cbiAgICAgIHZhciBsZW5TdHIgPSBsZW4udG9TdHJpbmcoKTtcbiAgICAgIHZhciBsZW5ndGhBcnkgPSBuZXcgVWludDhBcnJheShsZW5TdHIubGVuZ3RoICsgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW5ndGhBcnlbaV0gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgbGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdID0gMjU1O1xuXG4gICAgICBpZiAoQmxvYikge1xuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgYmxvYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEJsb2IocmVzdWx0cykpO1xuICB9KTtcbn07XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcbiAqIGludGVycHJldGluZyBlYWNoIGJ5dGUgYXMgYSBrZXkgY29kZSBmb3IgZW50cmllcyBtYXJrZWQgdG8gc3RhcnQgd2l0aCAwLiBTZWVcbiAqIGRlc2NyaXB0aW9uIG9mIGVuY29kZVBheWxvYWRBc0JpbmFyeVxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gIHZhciBidWZmZXJzID0gW107XG5cbiAgdmFyIG51bWJlclRvb0xvbmcgPSBmYWxzZTtcbiAgd2hpbGUgKGJ1ZmZlclRhaWwuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGFpbEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7XG4gICAgdmFyIGlzU3RyaW5nID0gdGFpbEFycmF5WzBdID09PSAwO1xuICAgIHZhciBtc2dMZW5ndGggPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAxOyA7IGkrKykge1xuICAgICAgaWYgKHRhaWxBcnJheVtpXSA9PSAyNTUpIGJyZWFrO1xuXG4gICAgICBpZiAobXNnTGVuZ3RoLmxlbmd0aCA+IDMxMCkge1xuICAgICAgICBudW1iZXJUb29Mb25nID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG1zZ0xlbmd0aCArPSB0YWlsQXJyYXlbaV07XG4gICAgfVxuXG4gICAgaWYobnVtYmVyVG9vTG9uZykgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMiArIG1zZ0xlbmd0aC5sZW5ndGgpO1xuICAgIG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cbiAgICB2YXIgbXNnID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMCwgbXNnTGVuZ3RoKTtcbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1zZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHRvIHR5cGVkIGFycmF5c1xuICAgICAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShtc2cpO1xuICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1zZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHR5cGVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGJ1ZmZlcnMucHVzaChtc2cpO1xuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCBtc2dMZW5ndGgpO1xuICB9XG5cbiAgdmFyIHRvdGFsID0gYnVmZmVycy5sZW5ndGg7XG4gIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsIGkpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLmRlY29kZVBhY2tldChidWZmZXIsIGJpbmFyeVR5cGUsIHRydWUpLCBpLCB0b3RhbCk7XG4gIH0pO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvbGliL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");
},,,,,,,function(module,exports,__webpack_require__){eval("\n/**\n * Expose `debug()` as the module.\n */\n\nmodule.exports = debug;\n\n/**\n * Create a debugger with the given `name`.\n *\n * @param {String} name\n * @return {Type}\n * @api public\n */\n\nfunction debug(name) {\n  if (!debug.enabled(name)) return function(){};\n\n  return function(fmt){\n    fmt = coerce(fmt);\n\n    var curr = new Date;\n    var ms = curr - (debug[name] || curr);\n    debug[name] = curr;\n\n    fmt = name\n      + ' '\n      + fmt\n      + ' +' + debug.humanize(ms);\n\n    // This hackery is required for IE8\n    // where `console.log` doesn't have 'apply'\n    window.console\n      && console.log\n      && Function.prototype.apply.call(console.log, console, arguments);\n  }\n}\n\n/**\n * The currently active debug mode names.\n */\n\ndebug.names = [];\ndebug.skips = [];\n\n/**\n * Enables a debug mode by name. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} name\n * @api public\n */\n\ndebug.enable = function(name) {\n  try {\n    localStorage.debug = name;\n  } catch(e){}\n\n  var split = (name || '').split(/[\\s,]+/)\n    , len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    name = split[i].replace('*', '.*?');\n    if (name[0] === '-') {\n      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));\n    }\n    else {\n      debug.names.push(new RegExp('^' + name + '$'));\n    }\n  }\n};\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\ndebug.disable = function(){\n  debug.enable('');\n};\n\n/**\n * Humanize the given `ms`.\n *\n * @param {Number} m\n * @return {String}\n * @api private\n */\n\ndebug.humanize = function(ms) {\n  var sec = 1000\n    , min = 60 * 1000\n    , hour = 60 * min;\n\n  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';\n  if (ms >= min) return (ms / min).toFixed(1) + 'm';\n  if (ms >= sec) return (ms / sec | 0) + 's';\n  return ms + 'ms';\n};\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\ndebug.enabled = function(name) {\n  for (var i = 0, len = debug.skips.length; i < len; i++) {\n    if (debug.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (var i = 0, len = debug.names.length; i < len; i++) {\n    if (debug.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Coerce `val`.\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n// persist\n\ntry {\n  if (window.localStorage) debug.enable(localStorage.debug);\n} catch(e){}\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZGVidWcvZGVidWcuanM/OTU4NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtUeXBlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lKSB7XG4gIGlmICghZGVidWcuZW5hYmxlZChuYW1lKSkgcmV0dXJuIGZ1bmN0aW9uKCl7fTtcblxuICByZXR1cm4gZnVuY3Rpb24oZm10KXtcbiAgICBmbXQgPSBjb2VyY2UoZm10KTtcblxuICAgIHZhciBjdXJyID0gbmV3IERhdGU7XG4gICAgdmFyIG1zID0gY3VyciAtIChkZWJ1Z1tuYW1lXSB8fCBjdXJyKTtcbiAgICBkZWJ1Z1tuYW1lXSA9IGN1cnI7XG5cbiAgICBmbXQgPSBuYW1lXG4gICAgICArICcgJ1xuICAgICAgKyBmbXRcbiAgICAgICsgJyArJyArIGRlYnVnLmh1bWFuaXplKG1zKTtcblxuICAgIC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4XG4gICAgLy8gd2hlcmUgYGNvbnNvbGUubG9nYCBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICAgIHdpbmRvdy5jb25zb2xlXG4gICAgICAmJiBjb25zb2xlLmxvZ1xuICAgICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLlxuICovXG5cbmRlYnVnLm5hbWVzID0gW107XG5kZWJ1Zy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWUuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZGVidWcuZW5hYmxlID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5kZWJ1ZyA9IG5hbWU7XG4gIH0gY2F0Y2goZSl7fVxuXG4gIHZhciBzcGxpdCA9IChuYW1lIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pXG4gICAgLCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hbWUgPSBzcGxpdFtpXS5yZXBsYWNlKCcqJywgJy4qPycpO1xuICAgIGlmIChuYW1lWzBdID09PSAnLScpIHtcbiAgICAgIGRlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lLnN1YnN0cigxKSArICckJykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGRlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lICsgJyQnKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZGVidWcuZGlzYWJsZSA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnLmVuYWJsZSgnJyk7XG59O1xuXG4vKipcbiAqIEh1bWFuaXplIHRoZSBnaXZlbiBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5kZWJ1Zy5odW1hbml6ZSA9IGZ1bmN0aW9uKG1zKSB7XG4gIHZhciBzZWMgPSAxMDAwXG4gICAgLCBtaW4gPSA2MCAqIDEwMDBcbiAgICAsIGhvdXIgPSA2MCAqIG1pbjtcblxuICBpZiAobXMgPj0gaG91cikgcmV0dXJuIChtcyAvIGhvdXIpLnRvRml4ZWQoMSkgKyAnaCc7XG4gIGlmIChtcyA+PSBtaW4pIHJldHVybiAobXMgLyBtaW4pLnRvRml4ZWQoMSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzZWMpIHJldHVybiAobXMgLyBzZWMgfCAwKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5kZWJ1Zy5lbmFibGVkID0gZnVuY3Rpb24obmFtZSkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG4vLyBwZXJzaXN0XG5cbnRyeSB7XG4gIGlmICh3aW5kb3cubG9jYWxTdG9yYWdlKSBkZWJ1Zy5lbmFibGUobG9jYWxTdG9yYWdlLmRlYnVnKTtcbn0gY2F0Y2goZSl7fVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9kZWJ1Zy9kZWJ1Zy5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},,,,,,,,,,function(module,exports,__webpack_require__){eval("\nmodule.exports = function(a, b){\n  var fn = function(){};\n  fn.prototype = b.prototype;\n  a.prototype = new fn;\n  a.prototype.constructor = a;\n};//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2NvbXBvbmVudC1pbmhlcml0L2luZGV4LmpzPzhhNDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG4gIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vY29tcG9uZW50LWluaGVyaXQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(222);\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // This hackery is required for IE8,\n  // where the `console.log` function doesn't have 'apply'\n  return 'object' == typeof console\n    && 'function' == typeof console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      localStorage.removeItem('debug');\n    } else {\n      localStorage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = localStorage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2RlYnVnL2Jyb3dzZXIuanM/ZmYxOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIHJldHVybiAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOCxcbiAgLy8gd2hlcmUgdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGxvY2FsU3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9kZWJ1Zy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(104)();\nexports.push([module.id, ".map{position:absolute;top:0;bottom:0;width:100%;height:100%}a{text-decoration:none;color:#000;padding:0}a:hover,a:active{background-color:#FDF3E7;color:#000}.header{display:block;background:#7E8F7C;opacity:.9;width:10%;float:right;border-top-left-radius:10%;border-bottom-left-radius:10%}.list{padding:0;list-style-type:none;margin:0;display:table;border-collapse:collapse;border:none}.link{display:block;margin:none;font-weight:700;color:#FDF3E7;background-color:#7E8F7C;text-align:center;padding:2px;text-decoration:none;text-transform:uppercase}.listitem{float:left;display:block;position:relative;padding:10px 12px;cursor:pointer;-webkit-transition:all .2s;transition:all .2s}.listitem,ul li{font:12px serif}ul li ul{padding:0;position:absolute;top:48px;left:0;width:150px;box-shadow:none;display:none;opacity:0;visibility:hidden;-webkit-transiton:opacity .2s;-moz-transition:opacity .2s;-ms-transition:opacity .2s;-o-transition:opacity .2s;-transition:opacity .2s}#open-overlay:hover{display:block;opacity:1;visibility:visible}.title,.logo{text-align:center}*{margin:0;padding:0}#overlay{height:80%;width:80%;margin:0 auto;background:#FDF3E7;color:#3B3738;padding:10px;position:absolute;top:5%;left:10%;z-index:1000;display:none;border-radius:10px}#mask{position:fixed;top:0;left:0;background:rgba(126,143,124,.6);z-index:500;width:100%;height:100%;display:none}#overlay:target,#overlay:target+#mask{display:block;opacity:1}.close{display:block;position:absolute;top:-20px;right:-20px;height:40px;width:40px;line-height:40px;font-size:35px;text-align:center;font-weight:700;border-radius:40px}.close,#open-overlay,.button{background:#C63D0F;color:#FDF3E7;text-decoration:none}#open-overlay,.button{padding:10px 5px;display:inline-block;margin:20px;border-radius:10px}.button{box-shadow:none}p{font-family:\\"Trebuchet MS\\"}", ""]);//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZXMvbWFwc3R5bGVzLmNzcz9kM2YwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsK0JBQStCLGtCQUFrQixNQUFNLFNBQVMsV0FBVyxZQUFZLEVBQUUscUJBQXFCLFdBQVcsVUFBVSxpQkFBaUIseUJBQXlCLFdBQVcsUUFBUSxjQUFjLG1CQUFtQixXQUFXLFVBQVUsWUFBWSwyQkFBMkIsOEJBQThCLE1BQU0sVUFBVSxxQkFBcUIsU0FBUyxjQUFjLHlCQUF5QixZQUFZLE1BQU0sY0FBYyxZQUFZLGdCQUFnQixjQUFjLHlCQUF5QixrQkFBa0IsWUFBWSxxQkFBcUIseUJBQXlCLFVBQVUsV0FBVyxjQUFjLGtCQUFrQixrQkFBa0IsZUFBZSwyQkFBMkIsbUJBQW1CLGdCQUFnQixnQkFBZ0IsU0FBUyxVQUFVLGtCQUFrQixTQUFTLE9BQU8sWUFBWSxnQkFBZ0IsYUFBYSxVQUFVLGtCQUFrQiw4QkFBOEIsNEJBQTRCLDJCQUEyQiwwQkFBMEIsd0JBQXdCLG9CQUFvQixjQUFjLFVBQVUsbUJBQW1CLGFBQWEsa0JBQWtCLEVBQUUsU0FBUyxVQUFVLFNBQVMsV0FBVyxVQUFVLGNBQWMsbUJBQW1CLGNBQWMsYUFBYSxrQkFBa0IsT0FBTyxTQUFTLGFBQWEsYUFBYSxtQkFBbUIsTUFBTSxlQUFlLE1BQU0sT0FBTyxnQ0FBZ0MsWUFBWSxXQUFXLFlBQVksYUFBYSxzQ0FBc0MsY0FBYyxVQUFVLE9BQU8sY0FBYyxrQkFBa0IsVUFBVSxZQUFZLFlBQVksV0FBVyxpQkFBaUIsZUFBZSxrQkFBa0IsZ0JBQWdCLG1CQUFtQiw2QkFBNkIsbUJBQW1CLGNBQWMscUJBQXFCLHNCQUFzQixpQkFBaUIscUJBQXFCLFlBQVksbUJBQW1CLFFBQVEsZ0JBQWdCLEVBQUUsNkJBQTZCIiwiZmlsZSI6IjQzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkQ6XFxcXERvY3VtZW50ZW5cXFxcR2l0SHViUmVwb3NcXFxcbWFwLXByb2plY3RcXFxcbm9kZV9tb2R1bGVzXFxcXGNzcy1sb2FkZXJcXFxcY3NzVG9TdHJpbmcuanNcIikoKTtcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5tYXB7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7Ym90dG9tOjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX1he3RleHQtZGVjb3JhdGlvbjpub25lO2NvbG9yOiMwMDA7cGFkZGluZzowfWE6aG92ZXIsYTphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojRkRGM0U3O2NvbG9yOiMwMDB9LmhlYWRlcntkaXNwbGF5OmJsb2NrO2JhY2tncm91bmQ6IzdFOEY3QztvcGFjaXR5Oi45O3dpZHRoOjEwJTtmbG9hdDpyaWdodDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjEwJTtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjEwJX0ubGlzdHtwYWRkaW5nOjA7bGlzdC1zdHlsZS10eXBlOm5vbmU7bWFyZ2luOjA7ZGlzcGxheTp0YWJsZTtib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7Ym9yZGVyOm5vbmV9Lmxpbmt7ZGlzcGxheTpibG9jazttYXJnaW46bm9uZTtmb250LXdlaWdodDo3MDA7Y29sb3I6I0ZERjNFNztiYWNrZ3JvdW5kLWNvbG9yOiM3RThGN0M7dGV4dC1hbGlnbjpjZW50ZXI7cGFkZGluZzoycHg7dGV4dC1kZWNvcmF0aW9uOm5vbmU7dGV4dC10cmFuc2Zvcm06dXBwZXJjYXNlfS5saXN0aXRlbXtmbG9hdDpsZWZ0O2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmU7cGFkZGluZzoxMHB4IDEycHg7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMnM7dHJhbnNpdGlvbjphbGwgLjJzfS5saXN0aXRlbSx1bCBsaXtmb250OjEycHggc2VyaWZ9dWwgbGkgdWx7cGFkZGluZzowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDo0OHB4O2xlZnQ6MDt3aWR0aDoxNTBweDtib3gtc2hhZG93Om5vbmU7ZGlzcGxheTpub25lO29wYWNpdHk6MDt2aXNpYmlsaXR5OmhpZGRlbjstd2Via2l0LXRyYW5zaXRvbjpvcGFjaXR5IC4yczstbW96LXRyYW5zaXRpb246b3BhY2l0eSAuMnM7LW1zLXRyYW5zaXRpb246b3BhY2l0eSAuMnM7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IC4yczstdHJhbnNpdGlvbjpvcGFjaXR5IC4yc30jb3Blbi1vdmVybGF5OmhvdmVye2Rpc3BsYXk6YmxvY2s7b3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZX0udGl0bGUsLmxvZ297dGV4dC1hbGlnbjpjZW50ZXJ9KnttYXJnaW46MDtwYWRkaW5nOjB9I292ZXJsYXl7aGVpZ2h0OjgwJTt3aWR0aDo4MCU7bWFyZ2luOjAgYXV0bztiYWNrZ3JvdW5kOiNGREYzRTc7Y29sb3I6IzNCMzczODtwYWRkaW5nOjEwcHg7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUlO2xlZnQ6MTAlO3otaW5kZXg6MTAwMDtkaXNwbGF5Om5vbmU7Ym9yZGVyLXJhZGl1czoxMHB4fSNtYXNre3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtiYWNrZ3JvdW5kOnJnYmEoMTI2LDE0MywxMjQsLjYpO3otaW5kZXg6NTAwO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ZGlzcGxheTpub25lfSNvdmVybGF5OnRhcmdldCwjb3ZlcmxheTp0YXJnZXQrI21hc2t7ZGlzcGxheTpibG9jaztvcGFjaXR5OjF9LmNsb3Nle2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7dG9wOi0yMHB4O3JpZ2h0Oi0yMHB4O2hlaWdodDo0MHB4O3dpZHRoOjQwcHg7bGluZS1oZWlnaHQ6NDBweDtmb250LXNpemU6MzVweDt0ZXh0LWFsaWduOmNlbnRlcjtmb250LXdlaWdodDo3MDA7Ym9yZGVyLXJhZGl1czo0MHB4fS5jbG9zZSwjb3Blbi1vdmVybGF5LC5idXR0b257YmFja2dyb3VuZDojQzYzRDBGO2NvbG9yOiNGREYzRTc7dGV4dC1kZWNvcmF0aW9uOm5vbmV9I29wZW4tb3ZlcmxheSwuYnV0dG9ue3BhZGRpbmc6MTBweCA1cHg7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luOjIwcHg7Ym9yZGVyLXJhZGl1czoxMHB4fS5idXR0b257Ym94LXNoYWRvdzpub25lfXB7Zm9udC1mYW1pbHk6XFxcIlRyZWJ1Y2hldCBNU1xcXCJ9XCIsIFwiXCJdKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi9wb3N0Y3NzLWxvYWRlciEuL3N0eWxlcy9tYXBzdHlsZXMuY3NzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=')},,,,,,,,,,,,,,,,,,,,,,function(module,exports,__webpack_require__){eval("/**\n * Module dependencies.\n */\n\nvar parser = __webpack_require__(24);\nvar Emitter = __webpack_require__(23);\n\n/**\n * Module exports.\n */\n\nmodule.exports = Transport;\n\n/**\n * Transport abstract constructor.\n *\n * @param {Object} options.\n * @api private\n */\n\nfunction Transport (opts) {\n  this.path = opts.path;\n  this.hostname = opts.hostname;\n  this.port = opts.port;\n  this.secure = opts.secure;\n  this.query = opts.query;\n  this.timestampParam = opts.timestampParam;\n  this.timestampRequests = opts.timestampRequests;\n  this.readyState = '';\n  this.agent = opts.agent || false;\n  this.socket = opts.socket;\n  this.enablesXDR = opts.enablesXDR;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Transport.prototype);\n\n/**\n * A counter used to prevent collisions in the timestamps used\n * for cache busting.\n */\n\nTransport.timestamps = 0;\n\n/**\n * Emits an error.\n *\n * @param {String} str\n * @return {Transport} for chaining\n * @api public\n */\n\nTransport.prototype.onError = function (msg, desc) {\n  var err = new Error(msg);\n  err.type = 'TransportError';\n  err.description = desc;\n  this.emit('error', err);\n  return this;\n};\n\n/**\n * Opens the transport.\n *\n * @api public\n */\n\nTransport.prototype.open = function () {\n  if ('closed' == this.readyState || '' == this.readyState) {\n    this.readyState = 'opening';\n    this.doOpen();\n  }\n\n  return this;\n};\n\n/**\n * Closes the transport.\n *\n * @api private\n */\n\nTransport.prototype.close = function () {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    this.doClose();\n    this.onClose();\n  }\n\n  return this;\n};\n\n/**\n * Sends multiple packets.\n *\n * @param {Array} packets\n * @api private\n */\n\nTransport.prototype.send = function(packets){\n  if ('open' == this.readyState) {\n    this.write(packets);\n  } else {\n    throw new Error('Transport not open');\n  }\n};\n\n/**\n * Called upon open\n *\n * @api private\n */\n\nTransport.prototype.onOpen = function () {\n  this.readyState = 'open';\n  this.writable = true;\n  this.emit('open');\n};\n\n/**\n * Called with data.\n *\n * @param {String} data\n * @api private\n */\n\nTransport.prototype.onData = function(data){\n  var packet = parser.decodePacket(data, this.socket.binaryType);\n  this.onPacket(packet);\n};\n\n/**\n * Called with a decoded packet.\n */\n\nTransport.prototype.onPacket = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon close.\n *\n * @api private\n */\n\nTransport.prototype.onClose = function () {\n  this.readyState = 'closed';\n  this.emit('close');\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzPzYwZmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFVBQVU7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblxuLyoqXG4gKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBUcmFuc3BvcnQgKG9wdHMpIHtcbiAgdGhpcy5wYXRoID0gb3B0cy5wYXRoO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0O1xuICB0aGlzLnNlY3VyZSA9IG9wdHMuc2VjdXJlO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW07XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuc29ja2V0ID0gb3B0cy5zb2NrZXQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEEgY291bnRlciB1c2VkIHRvIHByZXZlbnQgY29sbGlzaW9ucyBpbiB0aGUgdGltZXN0YW1wcyB1c2VkXG4gKiBmb3IgY2FjaGUgYnVzdGluZy5cbiAqL1xuXG5UcmFuc3BvcnQudGltZXN0YW1wcyA9IDA7XG5cbi8qKlxuICogRW1pdHMgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKG1zZywgZGVzYykge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci50eXBlID0gJ1RyYW5zcG9ydEVycm9yJztcbiAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgICB0aGlzLmRvT3BlbigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLmRvQ2xvc2UoKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBtdWx0aXBsZSBwYWNrZXRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgbm90IG9wZW4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBvcGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgcGFja2V0ID0gcGFyc2VyLmRlY29kZVBhY2tldChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcbiAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBhIGRlY29kZWQgcGFja2V0LlxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("// browser shim for xmlhttprequest module\nvar hasCORS = __webpack_require__(232);\n\nmodule.exports = function(opts) {\n  var xdomain = opts.xdomain;\n\n  // scheme must be same when usign XDomainRequest\n  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n  var xscheme = opts.xscheme;\n\n  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.\n  // https://github.com/Automattic/engine.io-client/pull/217\n  var enablesXDR = opts.enablesXDR;\n\n  // XMLHttpRequest can be disabled on IE\n  try {\n    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n      return new XMLHttpRequest();\n    }\n  } catch (e) { }\n\n  // Use XDomainRequest for IE8 if enablesXDR is true\n  // because loading bar keeps flashing when using jsonp-polling\n  // https://github.com/yujiosaka/socke.io-ie8-loading-example\n  try {\n    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {\n      return new XDomainRequest();\n    }\n  } catch (e) { }\n\n  if (!xdomain) {\n    try {\n      return new ActiveXObject('Microsoft.XMLHTTP');\n    } catch(e) { }\n  }\n}\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanM/NjNjYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxZQUFZOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxZQUFZOztBQUVmO0FBQ0E7QUFDQTtBQUNBLEtBQUssV0FBVztBQUNoQjtBQUNBIiwiZmlsZSI6IjY2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcbnZhciBoYXNDT1JTID0gcmVxdWlyZSgnaGFzLWNvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHZhciB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuXG4gIC8vIHNjaGVtZSBtdXN0IGJlIHNhbWUgd2hlbiB1c2lnbiBYRG9tYWluUmVxdWVzdFxuICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG4gIHZhciB4c2NoZW1lID0gb3B0cy54c2NoZW1lO1xuXG4gIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZsb3cgb2Ygbm90IHNlbmRpbmcgY29va2llLCB0aGVyZWZvcmUgaXQgc2hvdWxkIGJlIGRpc2FibGVkIGFzIGEgZGVmYXVsdC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvZW5naW5lLmlvLWNsaWVudC9wdWxsLzIxN1xuICB2YXIgZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgb24gSUVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGZvciBJRTggaWYgZW5hYmxlc1hEUiBpcyB0cnVlXG4gIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoKGUpIHsgfVxuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvbGliL3htbGh0dHByZXF1ZXN0LmpzXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\n\nexports.encode = function (obj) {\n  var str = '';\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (str.length) str += '&';\n      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n    }\n  }\n\n  return str;\n};\n\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\n\nexports.decode = function(qs){\n  var qry = {};\n  var pairs = qs.split('&');\n  for (var i = 0, l = pairs.length; i < l; i++) {\n    var pair = pairs[i].split('=');\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n  }\n  return qry;\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L3BhcnNlcXMvaW5kZXguanM/MGIwOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI2Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xuICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xuICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XG4gIHZhciBxcnkgPSB7fTtcbiAgdmFyIHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gIH1cbiAgcmV0dXJuIHFyeTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9wYXJzZXFzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n/**\n * Module dependencies.\n */\n\nvar debug = __webpack_require__(31)('socket.io-parser');\nvar json = __webpack_require__(242);\nvar isArray = __webpack_require__(102);\nvar Emitter = __webpack_require__(23);\nvar binary = __webpack_require__(241);\nvar isBuf = __webpack_require__(101);\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'BINARY_EVENT',\n  'ACK',\n  'BINARY_ACK',\n  'ERROR'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n    encodeAsBinary(obj, callback);\n  }\n  else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n  var str = '';\n  var nsp = false;\n\n  // first is type\n  str += obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n    str += obj.attachments;\n    str += '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' != obj.nsp) {\n    nsp = true;\n    str += obj.nsp;\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    if (nsp) {\n      str += ',';\n      nsp = false;\n    }\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    if (nsp) str += ',';\n    str += json.stringify(obj.data);\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an ecoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if ('string' == typeof obj) {\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  }\n  else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  }\n  else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var p = {};\n  var i = 0;\n\n  // look up type\n  p.type = Number(str.charAt(0));\n  if (null == exports.types[p.type]) return error();\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {\n    var buf = '';\n    while (str.charAt(++i) != '-') {\n      buf += str.charAt(i);\n      if (i == str.length) break;\n    }\n    if (buf != Number(buf) || str.charAt(i) != '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' == str.charAt(i + 1)) {\n    p.nsp = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' == c) break;\n      p.nsp += c;\n      if (i == str.length) break;\n    }\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    p.id = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      p.id += str.charAt(i);\n      if (i == str.length) break;\n    }\n    p.id = Number(p.id);\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    try {\n      p.data = json.parse(str.substr(i));\n    } catch(e){\n      return error();\n    }\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(data){\n  return {\n    type: exports.ERROR,\n    data: 'parser error'\n  };\n}\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vc29ja2V0LmlvLXBhcnNlci9pbmRleC5qcz80YjU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIganNvbiA9IHJlcXVpcmUoJ2pzb24zJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdCSU5BUllfRVZFTlQnLFxuICAnQUNLJyxcbiAgJ0JJTkFSWV9BQ0snLFxuICAnRVJST1InXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG5zcCA9IGZhbHNlO1xuXG4gIC8vIGZpcnN0IGlzIHR5cGVcbiAgc3RyICs9IG9iai50eXBlO1xuXG4gIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cztcbiAgICBzdHIgKz0gJy0nO1xuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgaWYgKG9iai5uc3AgJiYgJy8nICE9IG9iai5uc3ApIHtcbiAgICBuc3AgPSB0cnVlO1xuICAgIHN0ciArPSBvYmoubnNwO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIGlmIChuc3ApIHtcbiAgICAgIHN0ciArPSAnLCc7XG4gICAgICBuc3AgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RyICs9IG9iai5pZDtcbiAgfVxuXG4gIC8vIGpzb24gZGF0YVxuICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgIGlmIChuc3ApIHN0ciArPSAnLCc7XG4gICAgc3RyICs9IGpzb24uc3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBvYmopIHtcbiAgICBwYWNrZXQgPSBkZWNvZGVTdHJpbmcob2JqKTtcbiAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgcCA9IHt9O1xuICB2YXIgaSA9IDA7XG5cbiAgLy8gbG9vayB1cCB0eXBlXG4gIHAudHlwZSA9IE51bWJlcihzdHIuY2hhckF0KDApKTtcbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSByZXR1cm4gZXJyb3IoKTtcblxuICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHAudHlwZSkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9ICctJykge1xuICAgICAgYnVmICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGJ1ZiAhPSBOdW1iZXIoYnVmKSB8fCBzdHIuY2hhckF0KGkpICE9ICctJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGF0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICBwLm5zcCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT0gYykgYnJlYWs7XG4gICAgICBwLm5zcCArPSBjO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIHAuaWQgPSBOdW1iZXIocC5pZCk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHAuZGF0YSA9IGpzb24ucGFyc2Uoc3RyLnN1YnN0cihpKSk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBlcnJvcigpO1xuICAgIH1cbiAgfVxuXG4gIGRlYnVnKCdkZWNvZGVkICVzIGFzICVqJywgc3RyLCBwKTtcbiAgcmV0dXJuIHA7XG59XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykgeyAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3RcbiAgICB2YXIgcGFja2V0ID0gYmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuICAgIHRoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5pc2hlZFJlY29uc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVjb25QYWNrID0gbnVsbDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59O1xuXG5mdW5jdGlvbiBlcnJvcihkYXRhKXtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLkVSUk9SLFxuICAgIGRhdGE6ICdwYXJzZXIgZXJyb3InXG4gIH07XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L3NvY2tldC5pby1wYXJzZXIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("function hasRender(Class) {\n  var prototype = Class.prototype;\n  if (!prototype) {\n    return false;\n  }\n\n  return typeof prototype.render === 'function';\n}\n\nfunction descendsFromReactComponent(Class, React) {\n  if (!React.Component) {\n    return false;\n  }\n\n  var Base = Object.getPrototypeOf(Class);\n  while (Base) {\n    if (Base === React.Component) {\n      return true;\n    }\n\n    Base = Object.getPrototypeOf(Base);\n  }\n\n  return false;\n}\n\nfunction isReactClassish(Class, React) {\n  if (typeof Class !== 'function') {\n    return false;\n  }\n\n  // React 0.13\n  if (hasRender(Class) || descendsFromReactComponent(Class, React)) {\n    return true;\n  }\n\n  // React 0.12 and earlier\n  if (Class.type && hasRender(Class.type)) {\n    return true;\n  }\n\n  return false;\n}\n\nmodule.exports = isReactClassish;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvaXNSZWFjdENsYXNzaXNoLmpzP2RhODYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBoYXNSZW5kZXIoQ2xhc3MpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENsYXNzLnByb3RvdHlwZTtcbiAgaWYgKCFwcm90b3R5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHlwZW9mIHByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGRlc2NlbmRzRnJvbVJlYWN0Q29tcG9uZW50KENsYXNzLCBSZWFjdCkge1xuICBpZiAoIVJlYWN0LkNvbXBvbmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBCYXNlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKENsYXNzKTtcbiAgd2hpbGUgKEJhc2UpIHtcbiAgICBpZiAoQmFzZSA9PT0gUmVhY3QuQ29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBCYXNlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKEJhc2UpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1JlYWN0Q2xhc3Npc2goQ2xhc3MsIFJlYWN0KSB7XG4gIGlmICh0eXBlb2YgQ2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBSZWFjdCAwLjEzXG4gIGlmIChoYXNSZW5kZXIoQ2xhc3MpIHx8IGRlc2NlbmRzRnJvbVJlYWN0Q29tcG9uZW50KENsYXNzLCBSZWFjdCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFJlYWN0IDAuMTIgYW5kIGVhcmxpZXJcbiAgaWYgKENsYXNzLnR5cGUgJiYgaGFzUmVuZGVyKENsYXNzLnR5cGUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNSZWFjdENsYXNzaXNoO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LWhvdC1sb2FkZXIvaXNSZWFjdENsYXNzaXNoLmpzXG4gKiogbW9kdWxlIGlkID0gNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},,,,,,,,,,,,,,,,,,,,,,,,function(module,exports,__webpack_require__){eval("\n/**\n * Module dependencies.\n */\n\nvar url = __webpack_require__(96);\nvar eio = __webpack_require__(216);\nvar Socket = __webpack_require__(95);\nvar Emitter = __webpack_require__(23);\nvar parser = __webpack_require__(68);\nvar on = __webpack_require__(94);\nvar bind = __webpack_require__(97);\nvar object = __webpack_require__(239);\nvar debug = __webpack_require__(31)('socket.io-client:manager');\nvar indexOf = __webpack_require__(100);\nvar Backoff = __webpack_require__(215);\n\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager(uri, opts){\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n  if (uri && ('object' == typeof uri)) {\n    opts = uri;\n    uri = undefined;\n  }\n  opts = opts || {};\n\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connected = [];\n  this.encoding = false;\n  this.packetBuffer = [];\n  this.encoder = new parser.Encoder();\n  this.decoder = new parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\nManager.prototype.emitAll = function() {\n  this.emit.apply(this, arguments);\n  for (var nsp in this.nsps) {\n    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n  }\n};\n\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\nManager.prototype.updateSocketIds = function(){\n  for (var nsp in this.nsps) {\n    this.nsps[nsp].id = this.engine.id;\n  }\n};\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Manager.prototype);\n\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function(v){\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionAttempts = function(v){\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelay = function(v){\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function(v){\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelayMax = function(v){\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.timeout = function(v){\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\nManager.prototype.maybeReconnectOnOpen = function() {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n\n\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\nManager.prototype.open =\nManager.prototype.connect = function(fn){\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false;\n\n  // emit `open`\n  var openSub = on(socket, 'open', function() {\n    self.onopen();\n    fn && fn();\n  });\n\n  // emit `connect_error`\n  var errorSub = on(socket, 'error', function(data){\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  });\n\n  // emit `connect_timeout`\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout);\n\n    // set timer\n    var timer = setTimeout(function(){\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n\n    this.subs.push({\n      destroy: function(){\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n\n  return this;\n};\n\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\nManager.prototype.onopen = function(){\n  debug('open');\n\n  // clear old subs\n  this.cleanup();\n\n  // mark as open\n  this.readyState = 'open';\n  this.emit('open');\n\n  // add new subs\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n};\n\n/**\n * Called with data.\n *\n * @api private\n */\n\nManager.prototype.ondata = function(data){\n  this.decoder.add(data);\n};\n\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\nManager.prototype.ondecoded = function(packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\nManager.prototype.onerror = function(err){\n  debug('error', err);\n  this.emitAll('error', err);\n};\n\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\nManager.prototype.socket = function(nsp){\n  var socket = this.nsps[nsp];\n  if (!socket) {\n    socket = new Socket(this, nsp);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connect', function(){\n      socket.id = self.engine.id;\n      if (!~indexOf(self.connected, socket)) {\n        self.connected.push(socket);\n      }\n    });\n  }\n  return socket;\n};\n\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\nManager.prototype.destroy = function(socket){\n  var index = indexOf(this.connected, socket);\n  if (~index) this.connected.splice(index, 1);\n  if (this.connected.length) return;\n\n  this.close();\n};\n\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nManager.prototype.packet = function(packet){\n  debug('writing packet %j', packet);\n  var self = this;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function(encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i]);\n      }\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else { // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\nManager.prototype.processPacketQueue = function() {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\nManager.prototype.cleanup = function(){\n  var sub;\n  while (sub = this.subs.shift()) sub.destroy();\n\n  this.packetBuffer = [];\n  this.encoding = false;\n\n  this.decoder.destroy();\n};\n\n/**\n * Close the current socket.\n *\n * @api private\n */\n\nManager.prototype.close =\nManager.prototype.disconnect = function(){\n  this.skipReconnect = true;\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.engine && this.engine.close();\n};\n\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\nManager.prototype.onclose = function(reason){\n  debug('close');\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\nManager.prototype.reconnect = function(){\n  if (this.reconnecting || this.skipReconnect) return this;\n\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n\n    this.reconnecting = true;\n    var timer = setTimeout(function(){\n      if (self.skipReconnect) return;\n\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts);\n\n      // check again for the case socket closed in above events\n      if (self.skipReconnect) return;\n\n      self.open(function(err){\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n\n    this.subs.push({\n      destroy: function(){\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\nManager.prototype.onreconnect = function(){\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9tYW5hZ2VyLmpzP2U4MjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsT0FBTztBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI5My5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCcuL3VybCcpO1xudmFyIGVpbyA9IHJlcXVpcmUoJ2VuZ2luZS5pby1jbGllbnQnKTtcbnZhciBTb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBvYmplY3QgPSByZXF1aXJlKCdvYmplY3QtY29tcG9uZW50Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIEJhY2tvZmYgPSByZXF1aXJlKCdiYWNrbzInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlcjtcblxuLyoqXG4gKiBgTWFuYWdlcmAgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVuZ2luZSBpbnN0YW5jZSBvciBlbmdpbmUgdXJpL29wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1hbmFnZXIodXJpLCBvcHRzKXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuICB0aGlzLm5zcHMgPSB7fTtcbiAgdGhpcy5zdWJzID0gW107XG4gIHRoaXMub3B0cyA9IG9wdHM7XG4gIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG4gIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuICB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3Iob3B0cy5yYW5kb21pemF0aW9uRmFjdG9yIHx8IDAuNSk7XG4gIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG4gIH0pO1xuICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLnVyaSA9IHVyaTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBbXTtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IHBhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICB0aGlzLm5zcHNbbnNwXS5lbWl0LmFwcGx5KHRoaXMubnNwc1tuc3BdLCBhcmd1bWVudHMpO1xuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBgc29ja2V0LmlkYCBvZiBhbGwgc29ja2V0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uKCl7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICB0aGlzLm5zcHNbbnNwXS5pZCA9IHRoaXMuZW5naW5lLmlkO1xuICB9XG59O1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3RcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0Sml0dGVyKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgdGhpcy5fdGltZW91dCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24oKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub3BlbiA9XG5NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oZm4pe1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbigpIHtcbiAgICBzZWxmLm9ub3BlbigpO1xuICAgIGZuICYmIGZuKCk7XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfZXJyb3JgXG4gIHZhciBlcnJvclN1YiA9IG9uKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcbiAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLnN1YnMucHVzaChvcGVuU3ViKTtcbiAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbih0aGlzLmRlY29kZXIsICdkZWNvZGVkJywgYmluZCh0aGlzLCAnb25kZWNvZGVkJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZXJyb3InLCBiaW5kKHRoaXMsICdvbmVycm9yJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICB0aGlzLmVtaXRBbGwoJ2Vycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uKG5zcCl7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCl7XG4gICAgICBzb2NrZXQuaWQgPSBzZWxmLmVuZ2luZS5pZDtcbiAgICAgIGlmICghfmluZGV4T2Yoc2VsZi5jb25uZWN0ZWQsIHNvY2tldCkpIHtcbiAgICAgICAgc2VsZi5jb25uZWN0ZWQucHVzaChzb2NrZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzb2NrZXQ7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc29ja2V0IGNsb3NlLlxuICpcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oc29ja2V0KXtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RlZCwgc29ja2V0KTtcbiAgaWYgKH5pbmRleCkgdGhpcy5jb25uZWN0ZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKHRoaXMuY29ubmVjdGVkLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGRlYnVnKCd3cml0aW5nIHBhY2tldCAlaicsIHBhY2tldCk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uKGVuY29kZWRQYWNrZXRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7IC8vIGFkZCBwYWNrZXQgdG8gdGhlIHF1ZXVlXG4gICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG4gKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oKXtcbiAgdmFyIHN1YjtcbiAgd2hpbGUgKHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpKSBzdWIuZGVzdHJveSgpO1xuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xufTtcblxuLyoqXG4gKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPVxuTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbmdpbmUgJiYgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5jbGVhbnVwKCk7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbik7XG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgIGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG4gICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICBkZWJ1Zygnd2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0JywgZGVsYXkpO1xuXG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgZGVidWcoJ2F0dGVtcHRpbmcgcmVjb25uZWN0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9hdHRlbXB0Jywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0aW5nJywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcblxuICAgICAgLy8gY2hlY2sgYWdhaW4gZm9yIHRoZSBjYXNlIHNvY2tldCBjbG9zZWQgaW4gYWJvdmUgZXZlbnRzXG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIHNlbGYub3BlbihmdW5jdGlvbihlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnJlY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcbiAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3QnLCBhdHRlbXB0KTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("\n/**\n * Module exports.\n */\n\nmodule.exports = on;\n\n/**\n * Helper for subscriptions.\n *\n * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\n * @param {String} event name\n * @param {Function} callback\n * @api public\n */\n\nfunction on(obj, ev, fn) {\n  obj.on(ev, fn);\n  return {\n    destroy: function(){\n      obj.removeListener(ev, fn);\n    }\n  };\n}\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9vbi5qcz81MGU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBvbihvYmosIGV2LCBmbikge1xuICBvYmoub24oZXYsIGZuKTtcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKGV2LCBmbik7XG4gICAgfVxuICB9O1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n/**\n * Module dependencies.\n */\n\nvar parser = __webpack_require__(68);\nvar Emitter = __webpack_require__(23);\nvar toArray = __webpack_require__(243);\nvar on = __webpack_require__(94);\nvar bind = __webpack_require__(97);\nvar debug = __webpack_require__(31)('socket.io-client:socket');\nvar hasBin = __webpack_require__(237);\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = Socket;\n\n/**\n * Internal events (blacklisted).\n * These events can't be emitted by the user.\n *\n * @api private\n */\n\nvar events = {\n  connect: 1,\n  connect_error: 1,\n  connect_timeout: 1,\n  disconnect: 1,\n  error: 1,\n  reconnect: 1,\n  reconnect_attempt: 1,\n  reconnect_failed: 1,\n  reconnect_error: 1,\n  reconnecting: 1\n};\n\n/**\n * Shortcut to `Emitter#emit`.\n */\n\nvar emit = Emitter.prototype.emit;\n\n/**\n * `Socket` constructor.\n *\n * @api public\n */\n\nfunction Socket(io, nsp){\n  this.io = io;\n  this.nsp = nsp;\n  this.json = this; // compat\n  this.ids = 0;\n  this.acks = {};\n  if (this.io.autoConnect) this.open();\n  this.receiveBuffer = [];\n  this.sendBuffer = [];\n  this.connected = false;\n  this.disconnected = true;\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Subscribe to open, close and packet events\n *\n * @api private\n */\n\nSocket.prototype.subEvents = function() {\n  if (this.subs) return;\n\n  var io = this.io;\n  this.subs = [\n    on(io, 'open', bind(this, 'onopen')),\n    on(io, 'packet', bind(this, 'onpacket')),\n    on(io, 'close', bind(this, 'onclose'))\n  ];\n};\n\n/**\n * \"Opens\" the socket.\n *\n * @api public\n */\n\nSocket.prototype.open =\nSocket.prototype.connect = function(){\n  if (this.connected) return this;\n\n  this.subEvents();\n  this.io.open(); // ensure open\n  if ('open' == this.io.readyState) this.onopen();\n  return this;\n};\n\n/**\n * Sends a `message` event.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.send = function(){\n  var args = toArray(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n\n/**\n * Override `emit`.\n * If the event is in `events`, it's emitted normally.\n *\n * @param {String} event name\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.emit = function(ev){\n  if (events.hasOwnProperty(ev)) {\n    emit.apply(this, arguments);\n    return this;\n  }\n\n  var args = toArray(arguments);\n  var parserType = parser.EVENT; // default\n  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary\n  var packet = { type: parserType, data: args };\n\n  // event ack callback\n  if ('function' == typeof args[args.length - 1]) {\n    debug('emitting packet with ack id %d', this.ids);\n    this.acks[this.ids] = args.pop();\n    packet.id = this.ids++;\n  }\n\n  if (this.connected) {\n    this.packet(packet);\n  } else {\n    this.sendBuffer.push(packet);\n  }\n\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.packet = function(packet){\n  packet.nsp = this.nsp;\n  this.io.packet(packet);\n};\n\n/**\n * Called upon engine `open`.\n *\n * @api private\n */\n\nSocket.prototype.onopen = function(){\n  debug('transport is open - connecting');\n\n  // write connect packet if necessary\n  if ('/' != this.nsp) {\n    this.packet({ type: parser.CONNECT });\n  }\n};\n\n/**\n * Called upon engine `close`.\n *\n * @param {String} reason\n * @api private\n */\n\nSocket.prototype.onclose = function(reason){\n  debug('close (%s)', reason);\n  this.connected = false;\n  this.disconnected = true;\n  delete this.id;\n  this.emit('disconnect', reason);\n};\n\n/**\n * Called with socket packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onpacket = function(packet){\n  if (packet.nsp != this.nsp) return;\n\n  switch (packet.type) {\n    case parser.CONNECT:\n      this.onconnect();\n      break;\n\n    case parser.EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.BINARY_EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.ACK:\n      this.onack(packet);\n      break;\n\n    case parser.BINARY_ACK:\n      this.onack(packet);\n      break;\n\n    case parser.DISCONNECT:\n      this.ondisconnect();\n      break;\n\n    case parser.ERROR:\n      this.emit('error', packet.data);\n      break;\n  }\n};\n\n/**\n * Called upon a server event.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onevent = function(packet){\n  var args = packet.data || [];\n  debug('emitting event %j', args);\n\n  if (null != packet.id) {\n    debug('attaching ack callback to event');\n    args.push(this.ack(packet.id));\n  }\n\n  if (this.connected) {\n    emit.apply(this, args);\n  } else {\n    this.receiveBuffer.push(args);\n  }\n};\n\n/**\n * Produces an ack callback to emit with an event.\n *\n * @api private\n */\n\nSocket.prototype.ack = function(id){\n  var self = this;\n  var sent = false;\n  return function(){\n    // prevent double callbacks\n    if (sent) return;\n    sent = true;\n    var args = toArray(arguments);\n    debug('sending ack %j', args);\n\n    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;\n    self.packet({\n      type: type,\n      id: id,\n      data: args\n    });\n  };\n};\n\n/**\n * Called upon a server acknowlegement.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onack = function(packet){\n  debug('calling ack %s with %j', packet.id, packet.data);\n  var fn = this.acks[packet.id];\n  fn.apply(this, packet.data);\n  delete this.acks[packet.id];\n};\n\n/**\n * Called upon server connect.\n *\n * @api private\n */\n\nSocket.prototype.onconnect = function(){\n  this.connected = true;\n  this.disconnected = false;\n  this.emit('connect');\n  this.emitBuffered();\n};\n\n/**\n * Emit buffered events (received and emitted).\n *\n * @api private\n */\n\nSocket.prototype.emitBuffered = function(){\n  var i;\n  for (i = 0; i < this.receiveBuffer.length; i++) {\n    emit.apply(this, this.receiveBuffer[i]);\n  }\n  this.receiveBuffer = [];\n\n  for (i = 0; i < this.sendBuffer.length; i++) {\n    this.packet(this.sendBuffer[i]);\n  }\n  this.sendBuffer = [];\n};\n\n/**\n * Called upon server disconnect.\n *\n * @api private\n */\n\nSocket.prototype.ondisconnect = function(){\n  debug('server disconnect (%s)', this.nsp);\n  this.destroy();\n  this.onclose('io server disconnect');\n};\n\n/**\n * Called upon forced client/server side disconnections,\n * this method ensures the manager stops tracking us and\n * that reconnections don't get triggered for this.\n *\n * @api private.\n */\n\nSocket.prototype.destroy = function(){\n  if (this.subs) {\n    // clean subscriptions to avoid reconnections\n    for (var i = 0; i < this.subs.length; i++) {\n      this.subs[i].destroy();\n    }\n    this.subs = null;\n  }\n\n  this.io.destroy(this);\n};\n\n/**\n * Disconnects the socket manually.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.close =\nSocket.prototype.disconnect = function(){\n  if (this.connected) {\n    debug('performing disconnect (%s)', this.nsp);\n    this.packet({ type: parser.DISCONNECT });\n  }\n\n  // remove socket from pool\n  this.destroy();\n\n  if (this.connected) {\n    // fire events\n    this.onclose('io client disconnect');\n  }\n  return this;\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanM/YzNkYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHFCQUFxQixrQ0FBa0MsRUFBRTtBQUN6RCxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUEsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHRvQXJyYXkgPSByZXF1aXJlKCd0by1hcnJheScpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBoYXNCaW4gPSByZXF1aXJlKCdoYXMtYmluYXJ5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIEludGVybmFsIGV2ZW50cyAoYmxhY2tsaXN0ZWQpLlxuICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIGV2ZW50cyA9IHtcbiAgY29ubmVjdDogMSxcbiAgY29ubmVjdF9lcnJvcjogMSxcbiAgY29ubmVjdF90aW1lb3V0OiAxLFxuICBkaXNjb25uZWN0OiAxLFxuICBlcnJvcjogMSxcbiAgcmVjb25uZWN0OiAxLFxuICByZWNvbm5lY3RfYXR0ZW1wdDogMSxcbiAgcmVjb25uZWN0X2ZhaWxlZDogMSxcbiAgcmVjb25uZWN0X2Vycm9yOiAxLFxuICByZWNvbm5lY3Rpbmc6IDFcbn07XG5cbi8qKlxuICogU2hvcnRjdXQgdG8gYEVtaXR0ZXIjZW1pdGAuXG4gKi9cblxudmFyIGVtaXQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG4vKipcbiAqIGBTb2NrZXRgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0KGlvLCBuc3Ape1xuICB0aGlzLmlvID0gaW87XG4gIHRoaXMubnNwID0gbnNwO1xuICB0aGlzLmpzb24gPSB0aGlzOyAvLyBjb21wYXRcbiAgdGhpcy5pZHMgPSAwO1xuICB0aGlzLmFja3MgPSB7fTtcbiAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zdWJFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuXG4gIHZhciBpbyA9IHRoaXMuaW87XG4gIHRoaXMuc3VicyA9IFtcbiAgICBvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksXG4gICAgb24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSxcbiAgICBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKVxuICBdO1xufTtcblxuLyoqXG4gKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub3BlbiA9XG5Tb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuc3ViRXZlbnRzKCk7XG4gIHRoaXMuaW8ub3BlbigpOyAvLyBlbnN1cmUgb3BlblxuICBpZiAoJ29wZW4nID09IHRoaXMuaW8ucmVhZHlTdGF0ZSkgdGhpcy5vbm9wZW4oKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbigpe1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBlbWl0YC5cbiAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXYpe1xuICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICB2YXIgcGFyc2VyVHlwZSA9IHBhcnNlci5FVkVOVDsgLy8gZGVmYXVsdFxuICBpZiAoaGFzQmluKGFyZ3MpKSB7IHBhcnNlclR5cGUgPSBwYXJzZXIuQklOQVJZX0VWRU5UOyB9IC8vIGJpbmFyeVxuICB2YXIgcGFja2V0ID0geyB0eXBlOiBwYXJzZXJUeXBlLCBkYXRhOiBhcmdzIH07XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcbiAgICBkZWJ1ZygnZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkJywgdGhpcy5pZHMpO1xuICAgIHRoaXMuYWNrc1t0aGlzLmlkc10gPSBhcmdzLnBvcCgpO1xuICAgIHBhY2tldC5pZCA9IHRoaXMuaWRzKys7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cbiAgLy8gd3JpdGUgY29ubmVjdCBwYWNrZXQgaWYgbmVjZXNzYXJ5XG4gIGlmICgnLycgIT0gdGhpcy5uc3ApIHtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5DT05ORUNUIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgY2xvc2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbil7XG4gIGRlYnVnKCdjbG9zZSAoJXMpJywgcmVhc29uKTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBkZWxldGUgdGhpcy5pZDtcbiAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgcmVhc29uKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgaWYgKHBhY2tldC5uc3AgIT0gdGhpcy5uc3ApIHJldHVybjtcblxuICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgY2FzZSBwYXJzZXIuQ09OTkVDVDpcbiAgICAgIHRoaXMub25jb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6XG4gICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FUlJPUjpcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBwYWNrZXQuZGF0YSk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZXZlbnQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICBkZWJ1ZygnZW1pdHRpbmcgZXZlbnQgJWonLCBhcmdzKTtcblxuICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICBkZWJ1ZygnYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudCcpO1xuICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uKGlkKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VudCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3NcbiAgICBpZiAoc2VudCkgcmV0dXJuO1xuICAgIHNlbnQgPSB0cnVlO1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIGRlYnVnKCdzZW5kaW5nIGFjayAlaicsIGFyZ3MpO1xuXG4gICAgdmFyIHR5cGUgPSBoYXNCaW4oYXJncykgPyBwYXJzZXIuQklOQVJZX0FDSyA6IHBhcnNlci5BQ0s7XG4gICAgc2VsZi5wYWNrZXQoe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGRhdGE6IGFyZ3NcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gIHZhciBmbiA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICBmbi5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gIGRlbGV0ZSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xufTtcblxuLyoqXG4gKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3NlcnZlciBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gIHRoaXMuZGVzdHJveSgpO1xuICB0aGlzLm9uY2xvc2UoJ2lvIHNlcnZlciBkaXNjb25uZWN0Jyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG4gKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuICogdGhhdCByZWNvbm5lY3Rpb25zIGRvbid0IGdldCB0cmlnZ2VyZWQgZm9yIHRoaXMuXG4gKlxuICogQGFwaSBwcml2YXRlLlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLnN1YnMpIHtcbiAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanNcbiAqKiBtb2R1bGUgaWQgPSA5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module dependencies.\n */\n\nvar parseuri = __webpack_require__(240);\nvar debug = __webpack_require__(31)('socket.io-client:url');\n\n/**\n * Module exports.\n */\n\nmodule.exports = url;\n\n/**\n * URL parser.\n *\n * @param {String} url\n * @param {Object} An object meant to mimic window.location.\n *                 Defaults to window.location.\n * @api public\n */\n\nfunction url(uri, loc){\n  var obj = uri;\n\n  // default to window.location\n  var loc = loc || global.location;\n  if (null == uri) uri = loc.protocol + '//' + loc.host;\n\n  // relative path support\n  if ('string' == typeof uri) {\n    if ('/' == uri.charAt(0)) {\n      if ('/' == uri.charAt(1)) {\n        uri = loc.protocol + uri;\n      } else {\n        uri = loc.hostname + uri;\n      }\n    }\n\n    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n      debug('protocol-less url %s', uri);\n      if ('undefined' != typeof loc) {\n        uri = loc.protocol + '//' + uri;\n      } else {\n        uri = 'https://' + uri;\n      }\n    }\n\n    // parse\n    debug('parse %s', uri);\n    obj = parseuri(uri);\n  }\n\n  // make sure we treat `localhost:80` and `localhost` equally\n  if (!obj.port) {\n    if (/^(http|ws)$/.test(obj.protocol)) {\n      obj.port = '80';\n    }\n    else if (/^(http|ws)s$/.test(obj.protocol)) {\n      obj.port = '443';\n    }\n  }\n\n  obj.path = obj.path || '/';\n\n  // define unique id\n  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;\n  // define href\n  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));\n\n  return obj;\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L2xpYi91cmwuanM/ZjU2YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI5Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwodXJpLCBsb2Mpe1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIHZhciBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdDtcblxuICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSBsb2MuaG9zdG5hbWUgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcbiAgICAgIGRlYnVnKCdwcm90b2NvbC1sZXNzIHVybCAlcycsIHVyaSk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGxvYykge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gJ2h0dHBzOi8vJyArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwYXJzZVxuICAgIGRlYnVnKCdwYXJzZSAlcycsIHVyaSk7XG4gICAgb2JqID0gcGFyc2V1cmkodXJpKTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSB0cmVhdCBgbG9jYWxob3N0OjgwYCBhbmQgYGxvY2FsaG9zdGAgZXF1YWxseVxuICBpZiAoIW9iai5wb3J0KSB7XG4gICAgaWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc4MCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgb2JqLmhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIG9iai5ob3N0ICsgKGxvYyAmJiBsb2MucG9ydCA9PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L2xpYi91cmwuanNcbiAqKiBtb2R1bGUgaWQgPSA5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/**\n * Slice reference.\n */\n\nvar slice = [].slice;\n\n/**\n * Bind `obj` to `fn`.\n *\n * @param {Object} obj\n * @param {Function|String} fn or string\n * @return {Function}\n * @api public\n */\n\nmodule.exports = function(obj, fn){\n  if ('string' == typeof fn) fn = obj[fn];\n  if ('function' != typeof fn) throw new Error('bind() requires a function');\n  var args = slice.call(arguments, 2);\n  return function(){\n    return fn.apply(obj, args.concat(slice.call(arguments)));\n  }\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vY29tcG9uZW50LWJpbmQvaW5kZXguanM/MWQyNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZ0JBQWdCO0FBQzNCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNsaWNlIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuLyoqXG4gKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uJyk7XG4gIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vY29tcG9uZW50LWJpbmQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies\n */\n\nvar XMLHttpRequest = __webpack_require__(66);\nvar XHR = __webpack_require__(220);\nvar JSONP = __webpack_require__(219);\nvar websocket = __webpack_require__(221);\n\n/**\n * Export transports.\n */\n\nexports.polling = polling;\nexports.websocket = websocket;\n\n/**\n * Polling transport polymorphic constructor.\n * Decides on xhr vs jsonp based on feature detection.\n *\n * @api private\n */\n\nfunction polling(opts){\n  var xhr;\n  var xd = false;\n  var xs = false;\n  var jsonp = false !== opts.jsonp;\n\n  if (global.location) {\n    var isSSL = 'https:' == location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    xd = opts.hostname != location.hostname || port != opts.port;\n    xs = opts.secure != isSSL;\n  }\n\n  opts.xdomain = xd;\n  opts.xscheme = xs;\n  xhr = new XMLHttpRequest(opts);\n\n  if ('open' in xhr && !opts.forceJSONP) {\n    return new XHR(opts);\n  } else {\n    if (!jsonp) throw new Error('JSONP disabled');\n    return new JSONP(opts);\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcz8zYjgwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ijk4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3QnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcob3B0cyl7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("/**\n * Module dependencies.\n */\n\nvar Transport = __webpack_require__(65);\nvar parseqs = __webpack_require__(67);\nvar parser = __webpack_require__(24);\nvar inherit = __webpack_require__(41);\nvar debug = __webpack_require__(42)('engine.io-client:polling');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Polling;\n\n/**\n * Is XHR2 supported?\n */\n\nvar hasXHR2 = (function() {\n  var XMLHttpRequest = __webpack_require__(66);\n  var xhr = new XMLHttpRequest({ xdomain: false });\n  return null != xhr.responseType;\n})();\n\n/**\n * Polling interface.\n *\n * @param {Object} opts\n * @api private\n */\n\nfunction Polling(opts){\n  var forceBase64 = (opts && opts.forceBase64);\n  if (!hasXHR2 || forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(Polling, Transport);\n\n/**\n * Transport name.\n */\n\nPolling.prototype.name = 'polling';\n\n/**\n * Opens the socket (triggers polling). We write a PING message to determine\n * when the transport is open.\n *\n * @api private\n */\n\nPolling.prototype.doOpen = function(){\n  this.poll();\n};\n\n/**\n * Pauses polling.\n *\n * @param {Function} callback upon buffers are flushed and transport is paused\n * @api private\n */\n\nPolling.prototype.pause = function(onPause){\n  var pending = 0;\n  var self = this;\n\n  this.readyState = 'pausing';\n\n  function pause(){\n    debug('paused');\n    self.readyState = 'paused';\n    onPause();\n  }\n\n  if (this.polling || !this.writable) {\n    var total = 0;\n\n    if (this.polling) {\n      debug('we are currently polling - waiting to pause');\n      total++;\n      this.once('pollComplete', function(){\n        debug('pre-pause polling complete');\n        --total || pause();\n      });\n    }\n\n    if (!this.writable) {\n      debug('we are currently writing - waiting to pause');\n      total++;\n      this.once('drain', function(){\n        debug('pre-pause writing complete');\n        --total || pause();\n      });\n    }\n  } else {\n    pause();\n  }\n};\n\n/**\n * Starts polling cycle.\n *\n * @api public\n */\n\nPolling.prototype.poll = function(){\n  debug('polling');\n  this.polling = true;\n  this.doPoll();\n  this.emit('poll');\n};\n\n/**\n * Overloads onData to detect payloads.\n *\n * @api private\n */\n\nPolling.prototype.onData = function(data){\n  var self = this;\n  debug('polling got data %s', data);\n  var callback = function(packet, index, total) {\n    // if its the first message we consider the transport open\n    if ('opening' == self.readyState) {\n      self.onOpen();\n    }\n\n    // if its a close packet, we close the ongoing requests\n    if ('close' == packet.type) {\n      self.onClose();\n      return false;\n    }\n\n    // otherwise bypass onData and handle the message\n    self.onPacket(packet);\n  };\n\n  // decode payload\n  parser.decodePayload(data, this.socket.binaryType, callback);\n\n  // if an event did not trigger closing\n  if ('closed' != this.readyState) {\n    // if we got data we're not polling\n    this.polling = false;\n    this.emit('pollComplete');\n\n    if ('open' == this.readyState) {\n      this.poll();\n    } else {\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\n    }\n  }\n};\n\n/**\n * For polling, send a close packet.\n *\n * @api private\n */\n\nPolling.prototype.doClose = function(){\n  var self = this;\n\n  function close(){\n    debug('writing close packet');\n    self.write([{ type: 'close' }]);\n  }\n\n  if ('open' == this.readyState) {\n    debug('transport open - closing');\n    close();\n  } else {\n    // in case we're trying to close while\n    // handshaking is in progress (GH-164)\n    debug('transport not open - deferring close');\n    this.once('open', close);\n  }\n};\n\n/**\n * Writes a packets payload.\n *\n * @param {Array} data packets\n * @param {Function} drain callback\n * @api private\n */\n\nPolling.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n  var callbackfn = function() {\n    self.writable = true;\n    self.emit('drain');\n  };\n\n  var self = this;\n  parser.encodePayload(packets, this.supportsBinary, function(data) {\n    self.doWrite(data, callbackfn);\n  });\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nPolling.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'https' : 'http';\n  var port = '';\n\n  // cache busting is forced\n  if (false !== this.timestampRequests) {\n    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;\n  }\n\n  if (!this.supportsBinary && !query.sid) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // avoid port if default for schema\n  if (this.port && (('https' == schema && this.port != 443) ||\n     ('http' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  return schema + '://' + this.hostname + port + this.path + query;\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLmpzPzZiNjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ijk5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuLyoqXG4gKiBJcyBYSFIyIHN1cHBvcnRlZD9cbiAqL1xuXG52YXIgaGFzWEhSMiA9IChmdW5jdGlvbigpIHtcbiAgdmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3QnKTtcbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSkoKTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUG9sbGluZyhvcHRzKXtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmICghaGFzWEhSMiB8fCBmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFBvbGxpbmcsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUubmFtZSA9ICdwb2xsaW5nJztcblxuLyoqXG4gKiBPcGVucyB0aGUgc29ja2V0ICh0cmlnZ2VycyBwb2xsaW5nKS4gV2Ugd3JpdGUgYSBQSU5HIG1lc3NhZ2UgdG8gZGV0ZXJtaW5lXG4gKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbigpe1xuICB0aGlzLnBvbGwoKTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHBvbGxpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKG9uUGF1c2Upe1xuICB2YXIgcGVuZGluZyA9IDA7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgZnVuY3Rpb24gcGF1c2UoKXtcbiAgICBkZWJ1ZygncGF1c2VkJyk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgncG9sbENvbXBsZXRlJywgZnVuY3Rpb24oKXtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgd3JpdGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKXtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXVzZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdwb2xsaW5nJyk7XG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBkZWJ1ZygncG9sbGluZyBnb3QgZGF0YSAlcycsIGRhdGEpO1xuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbihwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICBpZiAoJ29wZW5pbmcnID09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgaWYgKCdjbG9zZScgPT0gcGFja2V0LnR5cGUpIHtcbiAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH07XG5cbiAgLy8gZGVjb2RlIHBheWxvYWRcbiAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXG4gIC8vIGlmIGFuIGV2ZW50IGRpZCBub3QgdHJpZ2dlciBjbG9zaW5nXG4gIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UoKXtcbiAgICBkZWJ1Zygnd3JpdGluZyBjbG9zZSBwYWNrZXQnKTtcbiAgICBzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuICB9XG5cbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9O1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgcGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24oZGF0YSkge1xuICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuICBpZiAoZmFsc2UgIT09IHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9ICtuZXcgRGF0ZSArICctJyArIFRyYW5zcG9ydC50aW1lc3RhbXBzKys7XG4gIH1cblxuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ2h0dHBzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MykgfHxcbiAgICAgKCdodHRwJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgdGhpcy5ob3N0bmFtZSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vaW5kZXhvZi9pbmRleC5qcz81ZTE5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9pbmRleG9mL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {\nmodule.exports = isBuf;\n\n/**\n * Returns true if obj is a buffer or an arraybuffer.\n *\n * @api private\n */\n\nfunction isBuf(obj) {\n  return (global.Buffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer);\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanM/NzUzZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9zb2NrZXQuaW8tcGFyc2VyL2lzLWJ1ZmZlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vc29ja2V0LmlvLXBhcnNlci9+L2lzYXJyYXkvaW5kZXguanM/MWM1ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTAyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9zb2NrZXQuaW8tcGFyc2VyL34vaXNhcnJheS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("module.exports = function(module) {\r\n	if(!module.webpackPolyfill) {\r\n		module.deprecate = function() {};\r\n		module.paths = [];\r\n		// module.parent = undefined by default\r\n		module.children = [];\r\n		module.webpackPolyfill = 1;\r\n	}\r\n	return module;\r\n}\r\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2MzYzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTAzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwM1xuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval('module.exports = function() {\r\n	var list = [];\r\n	list.toString = function toString() {\r\n		var result = [];\r\n		for(var i = 0; i < this.length; i++) {\r\n			var item = this[i];\r\n			if(item[2]) {\r\n				result.push("@media " + item[2] + "{" + item[1] + "}");\r\n			} else {\r\n				result.push(item[1]);\r\n			}\r\n		}\r\n		return result.join("");\r\n	};\r\n	return list;\r\n}//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvY3NzVG9TdHJpbmcuanM/ZDA0YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEwNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlci9jc3NUb1N0cmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com\n (c) 2010-2013, Vladimir Agafonkin\n (c) 2010-2011, CloudMade\n*/\n(function (window, document, undefined) {\r\nvar oldL = window.L,\r\n    L = {};\r\n\r\nL.version = '0.7.2';\r\n\r\n// define Leaflet for Node module pattern loaders, including Browserify\r\nif (typeof module === 'object' && typeof module.exports === 'object') {\r\n	module.exports = L;\r\n\r\n// define Leaflet as an AMD module\r\n} else if (true) {\r\n	!(__WEBPACK_AMD_DEFINE_FACTORY__ = (L), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n}\r\n\r\n// define Leaflet as a global L variable, saving the original L to restore later if needed\r\n\r\nL.noConflict = function () {\r\n	window.L = oldL;\r\n	return this;\r\n};\r\n\r\nwindow.L = L;\r\n\n\n/*\r\n * L.Util contains various utility functions used throughout Leaflet code.\r\n */\r\n\r\nL.Util = {\r\n	extend: function (dest) { // (Object[, Object, ...]) ->\r\n		var sources = Array.prototype.slice.call(arguments, 1),\r\n		    i, j, len, src;\r\n\r\n		for (j = 0, len = sources.length; j < len; j++) {\r\n			src = sources[j] || {};\r\n			for (i in src) {\r\n				if (src.hasOwnProperty(i)) {\r\n					dest[i] = src[i];\r\n				}\r\n			}\r\n		}\r\n		return dest;\r\n	},\r\n\r\n	bind: function (fn, obj) { // (Function, Object) -> Function\r\n		var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;\r\n		return function () {\r\n			return fn.apply(obj, args || arguments);\r\n		};\r\n	},\r\n\r\n	stamp: (function () {\r\n		var lastId = 0,\r\n		    key = '_leaflet_id';\r\n		return function (obj) {\r\n			obj[key] = obj[key] || ++lastId;\r\n			return obj[key];\r\n		};\r\n	}()),\r\n\r\n	invokeEach: function (obj, method, context) {\r\n		var i, args;\r\n\r\n		if (typeof obj === 'object') {\r\n			args = Array.prototype.slice.call(arguments, 3);\r\n\r\n			for (i in obj) {\r\n				method.apply(context, [i, obj[i]].concat(args));\r\n			}\r\n			return true;\r\n		}\r\n\r\n		return false;\r\n	},\r\n\r\n	limitExecByInterval: function (fn, time, context) {\r\n		var lock, execOnUnlock;\r\n\r\n		return function wrapperFn() {\r\n			var args = arguments;\r\n\r\n			if (lock) {\r\n				execOnUnlock = true;\r\n				return;\r\n			}\r\n\r\n			lock = true;\r\n\r\n			setTimeout(function () {\r\n				lock = false;\r\n\r\n				if (execOnUnlock) {\r\n					wrapperFn.apply(context, args);\r\n					execOnUnlock = false;\r\n				}\r\n			}, time);\r\n\r\n			fn.apply(context, args);\r\n		};\r\n	},\r\n\r\n	falseFn: function () {\r\n		return false;\r\n	},\r\n\r\n	formatNum: function (num, digits) {\r\n		var pow = Math.pow(10, digits || 5);\r\n		return Math.round(num * pow) / pow;\r\n	},\r\n\r\n	trim: function (str) {\r\n		return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n	},\r\n\r\n	splitWords: function (str) {\r\n		return L.Util.trim(str).split(/\\s+/);\r\n	},\r\n\r\n	setOptions: function (obj, options) {\r\n		obj.options = L.extend({}, obj.options, options);\r\n		return obj.options;\r\n	},\r\n\r\n	getParamString: function (obj, existingUrl, uppercase) {\r\n		var params = [];\r\n		for (var i in obj) {\r\n			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n		}\r\n		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n	},\r\n	template: function (str, data) {\r\n		return str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\r\n			var value = data[key];\r\n			if (value === undefined) {\r\n				throw new Error('No value provided for variable ' + str);\r\n			} else if (typeof value === 'function') {\r\n				value = value(data);\r\n			}\r\n			return value;\r\n		});\r\n	},\r\n\r\n	isArray: Array.isArray || function (obj) {\r\n		return (Object.prototype.toString.call(obj) === '[object Array]');\r\n	},\r\n\r\n	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\r\n};\r\n\r\n(function () {\r\n\r\n	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\r\n	function getPrefixed(name) {\r\n		var i, fn,\r\n		    prefixes = ['webkit', 'moz', 'o', 'ms'];\r\n\r\n		for (i = 0; i < prefixes.length && !fn; i++) {\r\n			fn = window[prefixes[i] + name];\r\n		}\r\n\r\n		return fn;\r\n	}\r\n\r\n	var lastTime = 0;\r\n\r\n	function timeoutDefer(fn) {\r\n		var time = +new Date(),\r\n		    timeToCall = Math.max(0, 16 - (time - lastTime));\r\n\r\n		lastTime = time + timeToCall;\r\n		return window.setTimeout(fn, timeToCall);\r\n	}\r\n\r\n	var requestFn = window.requestAnimationFrame ||\r\n	        getPrefixed('RequestAnimationFrame') || timeoutDefer;\r\n\r\n	var cancelFn = window.cancelAnimationFrame ||\r\n	        getPrefixed('CancelAnimationFrame') ||\r\n	        getPrefixed('CancelRequestAnimationFrame') ||\r\n	        function (id) { window.clearTimeout(id); };\r\n\r\n\r\n	L.Util.requestAnimFrame = function (fn, context, immediate, element) {\r\n		fn = L.bind(fn, context);\r\n\r\n		if (immediate && requestFn === timeoutDefer) {\r\n			fn();\r\n		} else {\r\n			return requestFn.call(window, fn, element);\r\n		}\r\n	};\r\n\r\n	L.Util.cancelAnimFrame = function (id) {\r\n		if (id) {\r\n			cancelFn.call(window, id);\r\n		}\r\n	};\r\n\r\n}());\r\n\r\n// shortcuts for most used utility functions\r\nL.extend = L.Util.extend;\r\nL.bind = L.Util.bind;\r\nL.stamp = L.Util.stamp;\r\nL.setOptions = L.Util.setOptions;\r\n\n\n/*\r\n * L.Class powers the OOP facilities of the library.\r\n * Thanks to John Resig and Dean Edwards for inspiration!\r\n */\r\n\r\nL.Class = function () {};\r\n\r\nL.Class.extend = function (props) {\r\n\r\n	// extended class with the new prototype\r\n	var NewClass = function () {\r\n\r\n		// call the constructor\r\n		if (this.initialize) {\r\n			this.initialize.apply(this, arguments);\r\n		}\r\n\r\n		// call all constructor hooks\r\n		if (this._initHooks) {\r\n			this.callInitHooks();\r\n		}\r\n	};\r\n\r\n	// instantiate class without calling constructor\r\n	var F = function () {};\r\n	F.prototype = this.prototype;\r\n\r\n	var proto = new F();\r\n	proto.constructor = NewClass;\r\n\r\n	NewClass.prototype = proto;\r\n\r\n	//inherit parent's statics\r\n	for (var i in this) {\r\n		if (this.hasOwnProperty(i) && i !== 'prototype') {\r\n			NewClass[i] = this[i];\r\n		}\r\n	}\r\n\r\n	// mix static properties into the class\r\n	if (props.statics) {\r\n		L.extend(NewClass, props.statics);\r\n		delete props.statics;\r\n	}\r\n\r\n	// mix includes into the prototype\r\n	if (props.includes) {\r\n		L.Util.extend.apply(null, [proto].concat(props.includes));\r\n		delete props.includes;\r\n	}\r\n\r\n	// merge options\r\n	if (props.options && proto.options) {\r\n		props.options = L.extend({}, proto.options, props.options);\r\n	}\r\n\r\n	// mix given properties into the prototype\r\n	L.extend(proto, props);\r\n\r\n	proto._initHooks = [];\r\n\r\n	var parent = this;\r\n	// jshint camelcase: false\r\n	NewClass.__super__ = parent.prototype;\r\n\r\n	// add method for calling all hooks\r\n	proto.callInitHooks = function () {\r\n\r\n		if (this._initHooksCalled) { return; }\r\n\r\n		if (parent.prototype.callInitHooks) {\r\n			parent.prototype.callInitHooks.call(this);\r\n		}\r\n\r\n		this._initHooksCalled = true;\r\n\r\n		for (var i = 0, len = proto._initHooks.length; i < len; i++) {\r\n			proto._initHooks[i].call(this);\r\n		}\r\n	};\r\n\r\n	return NewClass;\r\n};\r\n\r\n\r\n// method for adding properties to prototype\r\nL.Class.include = function (props) {\r\n	L.extend(this.prototype, props);\r\n};\r\n\r\n// merge new default options to the Class\r\nL.Class.mergeOptions = function (options) {\r\n	L.extend(this.prototype.options, options);\r\n};\r\n\r\n// add a constructor hook\r\nL.Class.addInitHook = function (fn) { // (Function) || (String, args...)\r\n	var args = Array.prototype.slice.call(arguments, 1);\r\n\r\n	var init = typeof fn === 'function' ? fn : function () {\r\n		this[fn].apply(this, args);\r\n	};\r\n\r\n	this.prototype._initHooks = this.prototype._initHooks || [];\r\n	this.prototype._initHooks.push(init);\r\n};\r\n\n\n/*\r\n * L.Mixin.Events is used to add custom events functionality to Leaflet classes.\r\n */\r\n\r\nvar eventsKey = '_leaflet_events';\r\n\r\nL.Mixin = {};\r\n\r\nL.Mixin.Events = {\r\n\r\n	addEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])\r\n\r\n		// types can be a map of types/handlers\r\n		if (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }\r\n\r\n		var events = this[eventsKey] = this[eventsKey] || {},\r\n		    contextId = context && context !== this && L.stamp(context),\r\n		    i, len, event, type, indexKey, indexLenKey, typeIndex;\r\n\r\n		// types can be a string of space-separated words\r\n		types = L.Util.splitWords(types);\r\n\r\n		for (i = 0, len = types.length; i < len; i++) {\r\n			event = {\r\n				action: fn,\r\n				context: context || this\r\n			};\r\n			type = types[i];\r\n\r\n			if (contextId) {\r\n				// store listeners of a particular context in a separate hash (if it has an id)\r\n				// gives a major performance boost when removing thousands of map layers\r\n\r\n				indexKey = type + '_idx';\r\n				indexLenKey = indexKey + '_len';\r\n\r\n				typeIndex = events[indexKey] = events[indexKey] || {};\r\n\r\n				if (!typeIndex[contextId]) {\r\n					typeIndex[contextId] = [];\r\n\r\n					// keep track of the number of keys in the index to quickly check if it's empty\r\n					events[indexLenKey] = (events[indexLenKey] || 0) + 1;\r\n				}\r\n\r\n				typeIndex[contextId].push(event);\r\n\r\n\r\n			} else {\r\n				events[type] = events[type] || [];\r\n				events[type].push(event);\r\n			}\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	hasEventListeners: function (type) { // (String) -> Boolean\r\n		var events = this[eventsKey];\r\n		return !!events && ((type in events && events[type].length > 0) ||\r\n		                    (type + '_idx' in events && events[type + '_idx_len'] > 0));\r\n	},\r\n\r\n	removeEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])\r\n\r\n		if (!this[eventsKey]) {\r\n			return this;\r\n		}\r\n\r\n		if (!types) {\r\n			return this.clearAllEventListeners();\r\n		}\r\n\r\n		if (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }\r\n\r\n		var events = this[eventsKey],\r\n		    contextId = context && context !== this && L.stamp(context),\r\n		    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;\r\n\r\n		types = L.Util.splitWords(types);\r\n\r\n		for (i = 0, len = types.length; i < len; i++) {\r\n			type = types[i];\r\n			indexKey = type + '_idx';\r\n			indexLenKey = indexKey + '_len';\r\n\r\n			typeIndex = events[indexKey];\r\n\r\n			if (!fn) {\r\n				// clear all listeners for a type if function isn't specified\r\n				delete events[type];\r\n				delete events[indexKey];\r\n				delete events[indexLenKey];\r\n\r\n			} else {\r\n				listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];\r\n\r\n				if (listeners) {\r\n					for (j = listeners.length - 1; j >= 0; j--) {\r\n						if ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {\r\n							removed = listeners.splice(j, 1);\r\n							// set the old action to a no-op, because it is possible\r\n							// that the listener is being iterated over as part of a dispatch\r\n							removed[0].action = L.Util.falseFn;\r\n						}\r\n					}\r\n\r\n					if (context && typeIndex && (listeners.length === 0)) {\r\n						delete typeIndex[contextId];\r\n						events[indexLenKey]--;\r\n					}\r\n				}\r\n			}\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	clearAllEventListeners: function () {\r\n		delete this[eventsKey];\r\n		return this;\r\n	},\r\n\r\n	fireEvent: function (type, data) { // (String[, Object])\r\n		if (!this.hasEventListeners(type)) {\r\n			return this;\r\n		}\r\n\r\n		var event = L.Util.extend({}, data, { type: type, target: this });\r\n\r\n		var events = this[eventsKey],\r\n		    listeners, i, len, typeIndex, contextId;\r\n\r\n		if (events[type]) {\r\n			// make sure adding/removing listeners inside other listeners won't cause infinite loop\r\n			listeners = events[type].slice();\r\n\r\n			for (i = 0, len = listeners.length; i < len; i++) {\r\n				listeners[i].action.call(listeners[i].context, event);\r\n			}\r\n		}\r\n\r\n		// fire event for the context-indexed listeners as well\r\n		typeIndex = events[type + '_idx'];\r\n\r\n		for (contextId in typeIndex) {\r\n			listeners = typeIndex[contextId].slice();\r\n\r\n			if (listeners) {\r\n				for (i = 0, len = listeners.length; i < len; i++) {\r\n					listeners[i].action.call(listeners[i].context, event);\r\n				}\r\n			}\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	addOneTimeEventListener: function (types, fn, context) {\r\n\r\n		if (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }\r\n\r\n		var handler = L.bind(function () {\r\n			this\r\n			    .removeEventListener(types, fn, context)\r\n			    .removeEventListener(types, handler, context);\r\n		}, this);\r\n\r\n		return this\r\n		    .addEventListener(types, fn, context)\r\n		    .addEventListener(types, handler, context);\r\n	}\r\n};\r\n\r\nL.Mixin.Events.on = L.Mixin.Events.addEventListener;\r\nL.Mixin.Events.off = L.Mixin.Events.removeEventListener;\r\nL.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;\r\nL.Mixin.Events.fire = L.Mixin.Events.fireEvent;\r\n\n\n/*\r\n * L.Browser handles different browser and feature detections for internal Leaflet use.\r\n */\r\n\r\n(function () {\r\n\r\n	var ie = 'ActiveXObject' in window,\r\n		ielt9 = ie && !document.addEventListener,\r\n\r\n	    // terrible browser detection to work around Safari / iOS / Android browser bugs\r\n	    ua = navigator.userAgent.toLowerCase(),\r\n	    webkit = ua.indexOf('webkit') !== -1,\r\n	    chrome = ua.indexOf('chrome') !== -1,\r\n	    phantomjs = ua.indexOf('phantom') !== -1,\r\n	    android = ua.indexOf('android') !== -1,\r\n	    android23 = ua.search('android [23]') !== -1,\r\n		gecko = ua.indexOf('gecko') !== -1,\r\n\r\n	    mobile = typeof orientation !== undefined + '',\r\n	    msPointer = window.navigator && window.navigator.msPointerEnabled &&\r\n	              window.navigator.msMaxTouchPoints && !window.PointerEvent,\r\n		pointer = (window.PointerEvent && window.navigator.pointerEnabled && window.navigator.maxTouchPoints) ||\r\n				  msPointer,\r\n	    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||\r\n	             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&\r\n	              window.matchMedia('(min-resolution:144dpi)').matches),\r\n\r\n	    doc = document.documentElement,\r\n	    ie3d = ie && ('transition' in doc.style),\r\n	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,\r\n	    gecko3d = 'MozPerspective' in doc.style,\r\n	    opera3d = 'OTransition' in doc.style,\r\n	    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;\r\n\r\n\r\n	// PhantomJS has 'ontouchstart' in document.documentElement, but doesn't actually support touch.\r\n	// https://github.com/Leaflet/Leaflet/pull/1434#issuecomment-13843151\r\n\r\n	var touch = !window.L_NO_TOUCH && !phantomjs && (function () {\r\n\r\n		var startName = 'ontouchstart';\r\n\r\n		// IE10+ (We simulate these into touch* events in L.DomEvent and L.DomEvent.Pointer) or WebKit, etc.\r\n		if (pointer || (startName in doc)) {\r\n			return true;\r\n		}\r\n\r\n		// Firefox/Gecko\r\n		var div = document.createElement('div'),\r\n		    supported = false;\r\n\r\n		if (!div.setAttribute) {\r\n			return false;\r\n		}\r\n		div.setAttribute(startName, 'return;');\r\n\r\n		if (typeof div[startName] === 'function') {\r\n			supported = true;\r\n		}\r\n\r\n		div.removeAttribute(startName);\r\n		div = null;\r\n\r\n		return supported;\r\n	}());\r\n\r\n\r\n	L.Browser = {\r\n		ie: ie,\r\n		ielt9: ielt9,\r\n		webkit: webkit,\r\n		gecko: gecko && !webkit && !window.opera && !ie,\r\n\r\n		android: android,\r\n		android23: android23,\r\n\r\n		chrome: chrome,\r\n\r\n		ie3d: ie3d,\r\n		webkit3d: webkit3d,\r\n		gecko3d: gecko3d,\r\n		opera3d: opera3d,\r\n		any3d: any3d,\r\n\r\n		mobile: mobile,\r\n		mobileWebkit: mobile && webkit,\r\n		mobileWebkit3d: mobile && webkit3d,\r\n		mobileOpera: mobile && window.opera,\r\n\r\n		touch: touch,\r\n		msPointer: msPointer,\r\n		pointer: pointer,\r\n\r\n		retina: retina\r\n	};\r\n\r\n}());\r\n\n\n/*\r\n * L.Point represents a point with x and y coordinates.\r\n */\r\n\r\nL.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {\r\n	this.x = (round ? Math.round(x) : x);\r\n	this.y = (round ? Math.round(y) : y);\r\n};\r\n\r\nL.Point.prototype = {\r\n\r\n	clone: function () {\r\n		return new L.Point(this.x, this.y);\r\n	},\r\n\r\n	// non-destructive, returns a new point\r\n	add: function (point) {\r\n		return this.clone()._add(L.point(point));\r\n	},\r\n\r\n	// destructive, used directly for performance in situations where it's safe to modify existing point\r\n	_add: function (point) {\r\n		this.x += point.x;\r\n		this.y += point.y;\r\n		return this;\r\n	},\r\n\r\n	subtract: function (point) {\r\n		return this.clone()._subtract(L.point(point));\r\n	},\r\n\r\n	_subtract: function (point) {\r\n		this.x -= point.x;\r\n		this.y -= point.y;\r\n		return this;\r\n	},\r\n\r\n	divideBy: function (num) {\r\n		return this.clone()._divideBy(num);\r\n	},\r\n\r\n	_divideBy: function (num) {\r\n		this.x /= num;\r\n		this.y /= num;\r\n		return this;\r\n	},\r\n\r\n	multiplyBy: function (num) {\r\n		return this.clone()._multiplyBy(num);\r\n	},\r\n\r\n	_multiplyBy: function (num) {\r\n		this.x *= num;\r\n		this.y *= num;\r\n		return this;\r\n	},\r\n\r\n	round: function () {\r\n		return this.clone()._round();\r\n	},\r\n\r\n	_round: function () {\r\n		this.x = Math.round(this.x);\r\n		this.y = Math.round(this.y);\r\n		return this;\r\n	},\r\n\r\n	floor: function () {\r\n		return this.clone()._floor();\r\n	},\r\n\r\n	_floor: function () {\r\n		this.x = Math.floor(this.x);\r\n		this.y = Math.floor(this.y);\r\n		return this;\r\n	},\r\n\r\n	distanceTo: function (point) {\r\n		point = L.point(point);\r\n\r\n		var x = point.x - this.x,\r\n		    y = point.y - this.y;\r\n\r\n		return Math.sqrt(x * x + y * y);\r\n	},\r\n\r\n	equals: function (point) {\r\n		point = L.point(point);\r\n\r\n		return point.x === this.x &&\r\n		       point.y === this.y;\r\n	},\r\n\r\n	contains: function (point) {\r\n		point = L.point(point);\r\n\r\n		return Math.abs(point.x) <= Math.abs(this.x) &&\r\n		       Math.abs(point.y) <= Math.abs(this.y);\r\n	},\r\n\r\n	toString: function () {\r\n		return 'Point(' +\r\n		        L.Util.formatNum(this.x) + ', ' +\r\n		        L.Util.formatNum(this.y) + ')';\r\n	}\r\n};\r\n\r\nL.point = function (x, y, round) {\r\n	if (x instanceof L.Point) {\r\n		return x;\r\n	}\r\n	if (L.Util.isArray(x)) {\r\n		return new L.Point(x[0], x[1]);\r\n	}\r\n	if (x === undefined || x === null) {\r\n		return x;\r\n	}\r\n	return new L.Point(x, y, round);\r\n};\r\n\n\n/*\r\n * L.Bounds represents a rectangular area on the screen in pixel coordinates.\r\n */\r\n\r\nL.Bounds = function (a, b) { //(Point, Point) or Point[]\r\n	if (!a) { return; }\r\n\r\n	var points = b ? [a, b] : a;\r\n\r\n	for (var i = 0, len = points.length; i < len; i++) {\r\n		this.extend(points[i]);\r\n	}\r\n};\r\n\r\nL.Bounds.prototype = {\r\n	// extend the bounds to contain the given point\r\n	extend: function (point) { // (Point)\r\n		point = L.point(point);\r\n\r\n		if (!this.min && !this.max) {\r\n			this.min = point.clone();\r\n			this.max = point.clone();\r\n		} else {\r\n			this.min.x = Math.min(point.x, this.min.x);\r\n			this.max.x = Math.max(point.x, this.max.x);\r\n			this.min.y = Math.min(point.y, this.min.y);\r\n			this.max.y = Math.max(point.y, this.max.y);\r\n		}\r\n		return this;\r\n	},\r\n\r\n	getCenter: function (round) { // (Boolean) -> Point\r\n		return new L.Point(\r\n		        (this.min.x + this.max.x) / 2,\r\n		        (this.min.y + this.max.y) / 2, round);\r\n	},\r\n\r\n	getBottomLeft: function () { // -> Point\r\n		return new L.Point(this.min.x, this.max.y);\r\n	},\r\n\r\n	getTopRight: function () { // -> Point\r\n		return new L.Point(this.max.x, this.min.y);\r\n	},\r\n\r\n	getSize: function () {\r\n		return this.max.subtract(this.min);\r\n	},\r\n\r\n	contains: function (obj) { // (Bounds) or (Point) -> Boolean\r\n		var min, max;\r\n\r\n		if (typeof obj[0] === 'number' || obj instanceof L.Point) {\r\n			obj = L.point(obj);\r\n		} else {\r\n			obj = L.bounds(obj);\r\n		}\r\n\r\n		if (obj instanceof L.Bounds) {\r\n			min = obj.min;\r\n			max = obj.max;\r\n		} else {\r\n			min = max = obj;\r\n		}\r\n\r\n		return (min.x >= this.min.x) &&\r\n		       (max.x <= this.max.x) &&\r\n		       (min.y >= this.min.y) &&\r\n		       (max.y <= this.max.y);\r\n	},\r\n\r\n	intersects: function (bounds) { // (Bounds) -> Boolean\r\n		bounds = L.bounds(bounds);\r\n\r\n		var min = this.min,\r\n		    max = this.max,\r\n		    min2 = bounds.min,\r\n		    max2 = bounds.max,\r\n		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\r\n		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n\r\n		return xIntersects && yIntersects;\r\n	},\r\n\r\n	isValid: function () {\r\n		return !!(this.min && this.max);\r\n	}\r\n};\r\n\r\nL.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])\r\n	if (!a || a instanceof L.Bounds) {\r\n		return a;\r\n	}\r\n	return new L.Bounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.\r\n */\r\n\r\nL.Transformation = function (a, b, c, d) {\r\n	this._a = a;\r\n	this._b = b;\r\n	this._c = c;\r\n	this._d = d;\r\n};\r\n\r\nL.Transformation.prototype = {\r\n	transform: function (point, scale) { // (Point, Number) -> Point\r\n		return this._transform(point.clone(), scale);\r\n	},\r\n\r\n	// destructive transform (faster)\r\n	_transform: function (point, scale) {\r\n		scale = scale || 1;\r\n		point.x = scale * (this._a * point.x + this._b);\r\n		point.y = scale * (this._c * point.y + this._d);\r\n		return point;\r\n	},\r\n\r\n	untransform: function (point, scale) {\r\n		scale = scale || 1;\r\n		return new L.Point(\r\n		        (point.x / scale - this._b) / this._a,\r\n		        (point.y / scale - this._d) / this._c);\r\n	}\r\n};\r\n\n\n/*\r\n * L.DomUtil contains various utility functions for working with DOM.\r\n */\r\n\r\nL.DomUtil = {\r\n	get: function (id) {\r\n		return (typeof id === 'string' ? document.getElementById(id) : id);\r\n	},\r\n\r\n	getStyle: function (el, style) {\r\n\r\n		var value = el.style[style];\r\n\r\n		if (!value && el.currentStyle) {\r\n			value = el.currentStyle[style];\r\n		}\r\n\r\n		if ((!value || value === 'auto') && document.defaultView) {\r\n			var css = document.defaultView.getComputedStyle(el, null);\r\n			value = css ? css[style] : null;\r\n		}\r\n\r\n		return value === 'auto' ? null : value;\r\n	},\r\n\r\n	getViewportOffset: function (element) {\r\n\r\n		var top = 0,\r\n		    left = 0,\r\n		    el = element,\r\n		    docBody = document.body,\r\n		    docEl = document.documentElement,\r\n		    pos;\r\n\r\n		do {\r\n			top  += el.offsetTop  || 0;\r\n			left += el.offsetLeft || 0;\r\n\r\n			//add borders\r\n			top += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;\r\n			left += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;\r\n\r\n			pos = L.DomUtil.getStyle(el, 'position');\r\n\r\n			if (el.offsetParent === docBody && pos === 'absolute') { break; }\r\n\r\n			if (pos === 'fixed') {\r\n				top  += docBody.scrollTop  || docEl.scrollTop  || 0;\r\n				left += docBody.scrollLeft || docEl.scrollLeft || 0;\r\n				break;\r\n			}\r\n\r\n			if (pos === 'relative' && !el.offsetLeft) {\r\n				var width = L.DomUtil.getStyle(el, 'width'),\r\n				    maxWidth = L.DomUtil.getStyle(el, 'max-width'),\r\n				    r = el.getBoundingClientRect();\r\n\r\n				if (width !== 'none' || maxWidth !== 'none') {\r\n					left += r.left + el.clientLeft;\r\n				}\r\n\r\n				//calculate full y offset since we're breaking out of the loop\r\n				top += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);\r\n\r\n				break;\r\n			}\r\n\r\n			el = el.offsetParent;\r\n\r\n		} while (el);\r\n\r\n		el = element;\r\n\r\n		do {\r\n			if (el === docBody) { break; }\r\n\r\n			top  -= el.scrollTop  || 0;\r\n			left -= el.scrollLeft || 0;\r\n\r\n			el = el.parentNode;\r\n		} while (el);\r\n\r\n		return new L.Point(left, top);\r\n	},\r\n\r\n	documentIsLtr: function () {\r\n		if (!L.DomUtil._docIsLtrCached) {\r\n			L.DomUtil._docIsLtrCached = true;\r\n			L.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';\r\n		}\r\n		return L.DomUtil._docIsLtr;\r\n	},\r\n\r\n	create: function (tagName, className, container) {\r\n\r\n		var el = document.createElement(tagName);\r\n		el.className = className;\r\n\r\n		if (container) {\r\n			container.appendChild(el);\r\n		}\r\n\r\n		return el;\r\n	},\r\n\r\n	hasClass: function (el, name) {\r\n		if (el.classList !== undefined) {\r\n			return el.classList.contains(name);\r\n		}\r\n		var className = L.DomUtil._getClass(el);\r\n		return className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n	},\r\n\r\n	addClass: function (el, name) {\r\n		if (el.classList !== undefined) {\r\n			var classes = L.Util.splitWords(name);\r\n			for (var i = 0, len = classes.length; i < len; i++) {\r\n				el.classList.add(classes[i]);\r\n			}\r\n		} else if (!L.DomUtil.hasClass(el, name)) {\r\n			var className = L.DomUtil._getClass(el);\r\n			L.DomUtil._setClass(el, (className ? className + ' ' : '') + name);\r\n		}\r\n	},\r\n\r\n	removeClass: function (el, name) {\r\n		if (el.classList !== undefined) {\r\n			el.classList.remove(name);\r\n		} else {\r\n			L.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n		}\r\n	},\r\n\r\n	_setClass: function (el, name) {\r\n		if (el.className.baseVal === undefined) {\r\n			el.className = name;\r\n		} else {\r\n			// in case of SVG element\r\n			el.className.baseVal = name;\r\n		}\r\n	},\r\n\r\n	_getClass: function (el) {\r\n		return el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n	},\r\n\r\n	setOpacity: function (el, value) {\r\n\r\n		if ('opacity' in el.style) {\r\n			el.style.opacity = value;\r\n\r\n		} else if ('filter' in el.style) {\r\n\r\n			var filter = false,\r\n			    filterName = 'DXImageTransform.Microsoft.Alpha';\r\n\r\n			// filters collection throws an error if we try to retrieve a filter that doesn't exist\r\n			try {\r\n				filter = el.filters.item(filterName);\r\n			} catch (e) {\r\n				// don't set opacity to 1 if we haven't already set an opacity,\r\n				// it isn't needed and breaks transparent pngs.\r\n				if (value === 1) { return; }\r\n			}\r\n\r\n			value = Math.round(value * 100);\r\n\r\n			if (filter) {\r\n				filter.Enabled = (value !== 100);\r\n				filter.Opacity = value;\r\n			} else {\r\n				el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\r\n			}\r\n		}\r\n	},\r\n\r\n	testProp: function (props) {\r\n\r\n		var style = document.documentElement.style;\r\n\r\n		for (var i = 0; i < props.length; i++) {\r\n			if (props[i] in style) {\r\n				return props[i];\r\n			}\r\n		}\r\n		return false;\r\n	},\r\n\r\n	getTranslateString: function (point) {\r\n		// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate\r\n		// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care\r\n		// (same speed either way), Opera 12 doesn't support translate3d\r\n\r\n		var is3d = L.Browser.webkit3d,\r\n		    open = 'translate' + (is3d ? '3d' : '') + '(',\r\n		    close = (is3d ? ',0' : '') + ')';\r\n\r\n		return open + point.x + 'px,' + point.y + 'px' + close;\r\n	},\r\n\r\n	getScaleString: function (scale, origin) {\r\n\r\n		var preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),\r\n		    scaleStr = ' scale(' + scale + ') ';\r\n\r\n		return preTranslateStr + scaleStr;\r\n	},\r\n\r\n	setPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])\r\n\r\n		// jshint camelcase: false\r\n		el._leaflet_pos = point;\r\n\r\n		if (!disable3D && L.Browser.any3d) {\r\n			el.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);\r\n		} else {\r\n			el.style.left = point.x + 'px';\r\n			el.style.top = point.y + 'px';\r\n		}\r\n	},\r\n\r\n	getPosition: function (el) {\r\n		// this method is only used for elements previously positioned using setPosition,\r\n		// so it's safe to cache the position for performance\r\n\r\n		// jshint camelcase: false\r\n		return el._leaflet_pos;\r\n	}\r\n};\r\n\r\n\r\n// prefix style property names\r\n\r\nL.DomUtil.TRANSFORM = L.DomUtil.testProp(\r\n        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n\r\n// webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n// the same for the transitionend event, in particular the Android 4.1 stock browser\r\n\r\nL.DomUtil.TRANSITION = L.DomUtil.testProp(\r\n        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n\r\nL.DomUtil.TRANSITION_END =\r\n        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?\r\n        L.DomUtil.TRANSITION + 'End' : 'transitionend';\r\n\r\n(function () {\r\n    if ('onselectstart' in document) {\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);\r\n            }\r\n        });\r\n    } else {\r\n        var userSelectProperty = L.DomUtil.testProp(\r\n            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\r\n\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    var style = document.documentElement.style;\r\n                    this._userSelect = style[userSelectProperty];\r\n                    style[userSelectProperty] = 'none';\r\n                }\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    document.documentElement.style[userSelectProperty] = this._userSelect;\r\n                    delete this._userSelect;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n	L.extend(L.DomUtil, {\r\n		disableImageDrag: function () {\r\n			L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);\r\n		},\r\n\r\n		enableImageDrag: function () {\r\n			L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);\r\n		}\r\n	});\r\n})();\r\n\n\n/*\r\n * L.LatLng represents a geographical point with latitude and longitude coordinates.\r\n */\r\n\r\nL.LatLng = function (lat, lng, alt) { // (Number, Number, Number)\r\n	lat = parseFloat(lat);\r\n	lng = parseFloat(lng);\r\n\r\n	if (isNaN(lat) || isNaN(lng)) {\r\n		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\r\n	}\r\n\r\n	this.lat = lat;\r\n	this.lng = lng;\r\n\r\n	if (alt !== undefined) {\r\n		this.alt = parseFloat(alt);\r\n	}\r\n};\r\n\r\nL.extend(L.LatLng, {\r\n	DEG_TO_RAD: Math.PI / 180,\r\n	RAD_TO_DEG: 180 / Math.PI,\r\n	MAX_MARGIN: 1.0E-9 // max margin of error for the \"equals\" check\r\n});\r\n\r\nL.LatLng.prototype = {\r\n	equals: function (obj) { // (LatLng) -> Boolean\r\n		if (!obj) { return false; }\r\n\r\n		obj = L.latLng(obj);\r\n\r\n		var margin = Math.max(\r\n		        Math.abs(this.lat - obj.lat),\r\n		        Math.abs(this.lng - obj.lng));\r\n\r\n		return margin <= L.LatLng.MAX_MARGIN;\r\n	},\r\n\r\n	toString: function (precision) { // (Number) -> String\r\n		return 'LatLng(' +\r\n		        L.Util.formatNum(this.lat, precision) + ', ' +\r\n		        L.Util.formatNum(this.lng, precision) + ')';\r\n	},\r\n\r\n	// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula\r\n	// TODO move to projection code, LatLng shouldn't know about Earth\r\n	distanceTo: function (other) { // (LatLng) -> Number\r\n		other = L.latLng(other);\r\n\r\n		var R = 6378137, // earth radius in meters\r\n		    d2r = L.LatLng.DEG_TO_RAD,\r\n		    dLat = (other.lat - this.lat) * d2r,\r\n		    dLon = (other.lng - this.lng) * d2r,\r\n		    lat1 = this.lat * d2r,\r\n		    lat2 = other.lat * d2r,\r\n		    sin1 = Math.sin(dLat / 2),\r\n		    sin2 = Math.sin(dLon / 2);\r\n\r\n		var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);\r\n\r\n		return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n	},\r\n\r\n	wrap: function (a, b) { // (Number, Number) -> LatLng\r\n		var lng = this.lng;\r\n\r\n		a = a || -180;\r\n		b = b ||  180;\r\n\r\n		lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);\r\n\r\n		return new L.LatLng(this.lat, lng);\r\n	}\r\n};\r\n\r\nL.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)\r\n	if (a instanceof L.LatLng) {\r\n		return a;\r\n	}\r\n	if (L.Util.isArray(a)) {\r\n		if (typeof a[0] === 'number' || typeof a[0] === 'string') {\r\n			return new L.LatLng(a[0], a[1], a[2]);\r\n		} else {\r\n			return null;\r\n		}\r\n	}\r\n	if (a === undefined || a === null) {\r\n		return a;\r\n	}\r\n	if (typeof a === 'object' && 'lat' in a) {\r\n		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);\r\n	}\r\n	if (b === undefined) {\r\n		return null;\r\n	}\r\n	return new L.LatLng(a, b);\r\n};\r\n\r\n\n\n/*\r\n * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.\r\n */\r\n\r\nL.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])\r\n	if (!southWest) { return; }\r\n\r\n	var latlngs = northEast ? [southWest, northEast] : southWest;\r\n\r\n	for (var i = 0, len = latlngs.length; i < len; i++) {\r\n		this.extend(latlngs[i]);\r\n	}\r\n};\r\n\r\nL.LatLngBounds.prototype = {\r\n	// extend the bounds to contain the given point or bounds\r\n	extend: function (obj) { // (LatLng) or (LatLngBounds)\r\n		if (!obj) { return this; }\r\n\r\n		var latLng = L.latLng(obj);\r\n		if (latLng !== null) {\r\n			obj = latLng;\r\n		} else {\r\n			obj = L.latLngBounds(obj);\r\n		}\r\n\r\n		if (obj instanceof L.LatLng) {\r\n			if (!this._southWest && !this._northEast) {\r\n				this._southWest = new L.LatLng(obj.lat, obj.lng);\r\n				this._northEast = new L.LatLng(obj.lat, obj.lng);\r\n			} else {\r\n				this._southWest.lat = Math.min(obj.lat, this._southWest.lat);\r\n				this._southWest.lng = Math.min(obj.lng, this._southWest.lng);\r\n\r\n				this._northEast.lat = Math.max(obj.lat, this._northEast.lat);\r\n				this._northEast.lng = Math.max(obj.lng, this._northEast.lng);\r\n			}\r\n		} else if (obj instanceof L.LatLngBounds) {\r\n			this.extend(obj._southWest);\r\n			this.extend(obj._northEast);\r\n		}\r\n		return this;\r\n	},\r\n\r\n	// extend the bounds by a percentage\r\n	pad: function (bufferRatio) { // (Number) -> LatLngBounds\r\n		var sw = this._southWest,\r\n		    ne = this._northEast,\r\n		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\r\n		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n\r\n		return new L.LatLngBounds(\r\n		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\r\n		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n	},\r\n\r\n	getCenter: function () { // -> LatLng\r\n		return new L.LatLng(\r\n		        (this._southWest.lat + this._northEast.lat) / 2,\r\n		        (this._southWest.lng + this._northEast.lng) / 2);\r\n	},\r\n\r\n	getSouthWest: function () {\r\n		return this._southWest;\r\n	},\r\n\r\n	getNorthEast: function () {\r\n		return this._northEast;\r\n	},\r\n\r\n	getNorthWest: function () {\r\n		return new L.LatLng(this.getNorth(), this.getWest());\r\n	},\r\n\r\n	getSouthEast: function () {\r\n		return new L.LatLng(this.getSouth(), this.getEast());\r\n	},\r\n\r\n	getWest: function () {\r\n		return this._southWest.lng;\r\n	},\r\n\r\n	getSouth: function () {\r\n		return this._southWest.lat;\r\n	},\r\n\r\n	getEast: function () {\r\n		return this._northEast.lng;\r\n	},\r\n\r\n	getNorth: function () {\r\n		return this._northEast.lat;\r\n	},\r\n\r\n	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\r\n		if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {\r\n			obj = L.latLng(obj);\r\n		} else {\r\n			obj = L.latLngBounds(obj);\r\n		}\r\n\r\n		var sw = this._southWest,\r\n		    ne = this._northEast,\r\n		    sw2, ne2;\r\n\r\n		if (obj instanceof L.LatLngBounds) {\r\n			sw2 = obj.getSouthWest();\r\n			ne2 = obj.getNorthEast();\r\n		} else {\r\n			sw2 = ne2 = obj;\r\n		}\r\n\r\n		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n	},\r\n\r\n	intersects: function (bounds) { // (LatLngBounds)\r\n		bounds = L.latLngBounds(bounds);\r\n\r\n		var sw = this._southWest,\r\n		    ne = this._northEast,\r\n		    sw2 = bounds.getSouthWest(),\r\n		    ne2 = bounds.getNorthEast(),\r\n\r\n		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\r\n		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n\r\n		return latIntersects && lngIntersects;\r\n	},\r\n\r\n	toBBoxString: function () {\r\n		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n	},\r\n\r\n	equals: function (bounds) { // (LatLngBounds)\r\n		if (!bounds) { return false; }\r\n\r\n		bounds = L.latLngBounds(bounds);\r\n\r\n		return this._southWest.equals(bounds.getSouthWest()) &&\r\n		       this._northEast.equals(bounds.getNorthEast());\r\n	},\r\n\r\n	isValid: function () {\r\n		return !!(this._southWest && this._northEast);\r\n	}\r\n};\r\n\r\n//TODO International date line?\r\n\r\nL.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)\r\n	if (!a || a instanceof L.LatLngBounds) {\r\n		return a;\r\n	}\r\n	return new L.LatLngBounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Projection contains various geographical projections used by CRS classes.\r\n */\r\n\r\nL.Projection = {};\r\n\n\n/*\r\n * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.\r\n */\r\n\r\nL.Projection.SphericalMercator = {\r\n	MAX_LATITUDE: 85.0511287798,\r\n\r\n	project: function (latlng) { // (LatLng) -> Point\r\n		var d = L.LatLng.DEG_TO_RAD,\r\n		    max = this.MAX_LATITUDE,\r\n		    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n		    x = latlng.lng * d,\r\n		    y = lat * d;\r\n\r\n		y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));\r\n\r\n		return new L.Point(x, y);\r\n	},\r\n\r\n	unproject: function (point) { // (Point, Boolean) -> LatLng\r\n		var d = L.LatLng.RAD_TO_DEG,\r\n		    lng = point.x * d,\r\n		    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;\r\n\r\n		return new L.LatLng(lat, lng);\r\n	}\r\n};\r\n\n\n/*\r\n * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.\r\n */\r\n\r\nL.Projection.LonLat = {\r\n	project: function (latlng) {\r\n		return new L.Point(latlng.lng, latlng.lat);\r\n	},\r\n\r\n	unproject: function (point) {\r\n		return new L.LatLng(point.y, point.x);\r\n	}\r\n};\r\n\n\n/*\r\n * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.\r\n */\r\n\r\nL.CRS = {\r\n	latLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point\r\n		var projectedPoint = this.projection.project(latlng),\r\n		    scale = this.scale(zoom);\r\n\r\n		return this.transformation._transform(projectedPoint, scale);\r\n	},\r\n\r\n	pointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng\r\n		var scale = this.scale(zoom),\r\n		    untransformedPoint = this.transformation.untransform(point, scale);\r\n\r\n		return this.projection.unproject(untransformedPoint);\r\n	},\r\n\r\n	project: function (latlng) {\r\n		return this.projection.project(latlng);\r\n	},\r\n\r\n	scale: function (zoom) {\r\n		return 256 * Math.pow(2, zoom);\r\n	},\r\n\r\n	getSize: function (zoom) {\r\n		var s = this.scale(zoom);\r\n		return L.point(s, s);\r\n	}\r\n};\r\n\n\n/*\n * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.\n */\n\nL.CRS.Simple = L.extend({}, L.CRS, {\n	projection: L.Projection.LonLat,\n	transformation: new L.Transformation(1, 0, -1, 0),\n\n	scale: function (zoom) {\n		return Math.pow(2, zoom);\n	}\n});\n\n\n/*\r\n * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping\r\n * and is used by Leaflet by default.\r\n */\r\n\r\nL.CRS.EPSG3857 = L.extend({}, L.CRS, {\r\n	code: 'EPSG:3857',\r\n\r\n	projection: L.Projection.SphericalMercator,\r\n	transformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),\r\n\r\n	project: function (latlng) { // (LatLng) -> Point\r\n		var projectedPoint = this.projection.project(latlng),\r\n		    earthRadius = 6378137;\r\n		return projectedPoint.multiplyBy(earthRadius);\r\n	}\r\n});\r\n\r\nL.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {\r\n	code: 'EPSG:900913'\r\n});\r\n\n\n/*\r\n * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.\r\n */\r\n\r\nL.CRS.EPSG4326 = L.extend({}, L.CRS, {\r\n	code: 'EPSG:4326',\r\n\r\n	projection: L.Projection.LonLat,\r\n	transformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)\r\n});\r\n\n\n/*\r\n * L.Map is the central class of the API - it is used to create a map.\r\n */\r\n\r\nL.Map = L.Class.extend({\r\n\r\n	includes: L.Mixin.Events,\r\n\r\n	options: {\r\n		crs: L.CRS.EPSG3857,\r\n\r\n		/*\r\n		center: LatLng,\r\n		zoom: Number,\r\n		layers: Array,\r\n		*/\r\n\r\n		fadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,\r\n		trackResize: true,\r\n		markerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d\r\n	},\r\n\r\n	initialize: function (id, options) { // (HTMLElement or String, Object)\r\n		options = L.setOptions(this, options);\r\n\r\n\r\n		this._initContainer(id);\r\n		this._initLayout();\r\n\r\n		// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n		this._onResize = L.bind(this._onResize, this);\r\n\r\n		this._initEvents();\r\n\r\n		if (options.maxBounds) {\r\n			this.setMaxBounds(options.maxBounds);\r\n		}\r\n\r\n		if (options.center && options.zoom !== undefined) {\r\n			this.setView(L.latLng(options.center), options.zoom, {reset: true});\r\n		}\r\n\r\n		this._handlers = [];\r\n\r\n		this._layers = {};\r\n		this._zoomBoundLayers = {};\r\n		this._tileLayersNum = 0;\r\n\r\n		this.callInitHooks();\r\n\r\n		this._addLayers(options.layers);\r\n	},\r\n\r\n\r\n	// public methods that modify map state\r\n\r\n	// replaced by animation-powered implementation in Map.PanAnimation.js\r\n	setView: function (center, zoom) {\r\n		zoom = zoom === undefined ? this.getZoom() : zoom;\r\n		this._resetView(L.latLng(center), this._limitZoom(zoom));\r\n		return this;\r\n	},\r\n\r\n	setZoom: function (zoom, options) {\r\n		if (!this._loaded) {\r\n			this._zoom = this._limitZoom(zoom);\r\n			return this;\r\n		}\r\n		return this.setView(this.getCenter(), zoom, {zoom: options});\r\n	},\r\n\r\n	zoomIn: function (delta, options) {\r\n		return this.setZoom(this._zoom + (delta || 1), options);\r\n	},\r\n\r\n	zoomOut: function (delta, options) {\r\n		return this.setZoom(this._zoom - (delta || 1), options);\r\n	},\r\n\r\n	setZoomAround: function (latlng, zoom, options) {\r\n		var scale = this.getZoomScale(zoom),\r\n		    viewHalf = this.getSize().divideBy(2),\r\n		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\r\n		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\r\n		return this.setView(newCenter, zoom, {zoom: options});\r\n	},\r\n\r\n	fitBounds: function (bounds, options) {\r\n\r\n		options = options || {};\r\n		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);\r\n\r\n		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\r\n		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\r\n\r\n		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR)),\r\n		    paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\r\n		    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n		    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\r\n		zoom = options && options.maxZoom ? Math.min(options.maxZoom, zoom) : zoom;\r\n\r\n		return this.setView(center, zoom, options);\r\n	},\r\n\r\n	fitWorld: function (options) {\r\n		return this.fitBounds([[-90, -180], [90, 180]], options);\r\n	},\r\n\r\n	panTo: function (center, options) { // (LatLng)\r\n		return this.setView(center, this._zoom, {pan: options});\r\n	},\r\n\r\n	panBy: function (offset) { // (Point)\r\n		// replaced with animated panBy in Map.PanAnimation.js\r\n		this.fire('movestart');\r\n\r\n		this._rawPanBy(L.point(offset));\r\n\r\n		this.fire('move');\r\n		return this.fire('moveend');\r\n	},\r\n\r\n	setMaxBounds: function (bounds) {\r\n		bounds = L.latLngBounds(bounds);\r\n\r\n		this.options.maxBounds = bounds;\r\n\r\n		if (!bounds) {\r\n			return this.off('moveend', this._panInsideMaxBounds, this);\r\n		}\r\n\r\n		if (this._loaded) {\r\n			this._panInsideMaxBounds();\r\n		}\r\n\r\n		return this.on('moveend', this._panInsideMaxBounds, this);\r\n	},\r\n\r\n	panInsideBounds: function (bounds, options) {\r\n		var center = this.getCenter(),\r\n			newCenter = this._limitCenter(center, this._zoom, bounds);\r\n\r\n		if (center.equals(newCenter)) { return this; }\r\n\r\n		return this.panTo(newCenter, options);\r\n	},\r\n\r\n	addLayer: function (layer) {\r\n		// TODO method is too big, refactor\r\n\r\n		var id = L.stamp(layer);\r\n\r\n		if (this._layers[id]) { return this; }\r\n\r\n		this._layers[id] = layer;\r\n\r\n		// TODO getMaxZoom, getMinZoom in ILayer (instead of options)\r\n		if (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {\r\n			this._zoomBoundLayers[id] = layer;\r\n			this._updateZoomLevels();\r\n		}\r\n\r\n		// TODO looks ugly, refactor!!!\r\n		if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n			this._tileLayersNum++;\r\n			this._tileLayersToLoad++;\r\n			layer.on('load', this._onTileLayerLoad, this);\r\n		}\r\n\r\n		if (this._loaded) {\r\n			this._layerAdd(layer);\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	removeLayer: function (layer) {\r\n		var id = L.stamp(layer);\r\n\r\n		if (!this._layers[id]) { return this; }\r\n\r\n		if (this._loaded) {\r\n			layer.onRemove(this);\r\n		}\r\n\r\n		delete this._layers[id];\r\n\r\n		if (this._loaded) {\r\n			this.fire('layerremove', {layer: layer});\r\n		}\r\n\r\n		if (this._zoomBoundLayers[id]) {\r\n			delete this._zoomBoundLayers[id];\r\n			this._updateZoomLevels();\r\n		}\r\n\r\n		// TODO looks ugly, refactor\r\n		if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n			this._tileLayersNum--;\r\n			this._tileLayersToLoad--;\r\n			layer.off('load', this._onTileLayerLoad, this);\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	hasLayer: function (layer) {\r\n		if (!layer) { return false; }\r\n\r\n		return (L.stamp(layer) in this._layers);\r\n	},\r\n\r\n	eachLayer: function (method, context) {\r\n		for (var i in this._layers) {\r\n			method.call(context, this._layers[i]);\r\n		}\r\n		return this;\r\n	},\r\n\r\n	invalidateSize: function (options) {\r\n		if (!this._loaded) { return this; }\r\n\r\n		options = L.extend({\r\n			animate: false,\r\n			pan: true\r\n		}, options === true ? {animate: true} : options);\r\n\r\n		var oldSize = this.getSize();\r\n		this._sizeChanged = true;\r\n		this._initialCenter = null;\r\n\r\n		var newSize = this.getSize(),\r\n		    oldCenter = oldSize.divideBy(2).round(),\r\n		    newCenter = newSize.divideBy(2).round(),\r\n		    offset = oldCenter.subtract(newCenter);\r\n\r\n		if (!offset.x && !offset.y) { return this; }\r\n\r\n		if (options.animate && options.pan) {\r\n			this.panBy(offset);\r\n\r\n		} else {\r\n			if (options.pan) {\r\n				this._rawPanBy(offset);\r\n			}\r\n\r\n			this.fire('move');\r\n\r\n			if (options.debounceMoveend) {\r\n				clearTimeout(this._sizeTimer);\r\n				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);\r\n			} else {\r\n				this.fire('moveend');\r\n			}\r\n		}\r\n\r\n		return this.fire('resize', {\r\n			oldSize: oldSize,\r\n			newSize: newSize\r\n		});\r\n	},\r\n\r\n	// TODO handler.addTo\r\n	addHandler: function (name, HandlerClass) {\r\n		if (!HandlerClass) { return this; }\r\n\r\n		var handler = this[name] = new HandlerClass(this);\r\n\r\n		this._handlers.push(handler);\r\n\r\n		if (this.options[name]) {\r\n			handler.enable();\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	remove: function () {\r\n		if (this._loaded) {\r\n			this.fire('unload');\r\n		}\r\n\r\n		this._initEvents('off');\r\n\r\n		try {\r\n			// throws error in IE6-8\r\n			delete this._container._leaflet;\r\n		} catch (e) {\r\n			this._container._leaflet = undefined;\r\n		}\r\n\r\n		this._clearPanes();\r\n		if (this._clearControlPos) {\r\n			this._clearControlPos();\r\n		}\r\n\r\n		this._clearHandlers();\r\n\r\n		return this;\r\n	},\r\n\r\n\r\n	// public methods for getting map state\r\n\r\n	getCenter: function () { // (Boolean) -> LatLng\r\n		this._checkIfLoaded();\r\n\r\n		if (this._initialCenter && !this._moved()) {\r\n			return this._initialCenter;\r\n		}\r\n		return this.layerPointToLatLng(this._getCenterLayerPoint());\r\n	},\r\n\r\n	getZoom: function () {\r\n		return this._zoom;\r\n	},\r\n\r\n	getBounds: function () {\r\n		var bounds = this.getPixelBounds(),\r\n		    sw = this.unproject(bounds.getBottomLeft()),\r\n		    ne = this.unproject(bounds.getTopRight());\r\n\r\n		return new L.LatLngBounds(sw, ne);\r\n	},\r\n\r\n	getMinZoom: function () {\r\n		return this.options.minZoom === undefined ?\r\n			(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :\r\n			this.options.minZoom;\r\n	},\r\n\r\n	getMaxZoom: function () {\r\n		return this.options.maxZoom === undefined ?\r\n			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n			this.options.maxZoom;\r\n	},\r\n\r\n	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n		bounds = L.latLngBounds(bounds);\r\n\r\n		var zoom = this.getMinZoom() - (inside ? 1 : 0),\r\n		    maxZoom = this.getMaxZoom(),\r\n		    size = this.getSize(),\r\n\r\n		    nw = bounds.getNorthWest(),\r\n		    se = bounds.getSouthEast(),\r\n\r\n		    zoomNotFound = true,\r\n		    boundsSize;\r\n\r\n		padding = L.point(padding || [0, 0]);\r\n\r\n		do {\r\n			zoom++;\r\n			boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);\r\n			zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;\r\n\r\n		} while (zoomNotFound && zoom <= maxZoom);\r\n\r\n		if (zoomNotFound && inside) {\r\n			return null;\r\n		}\r\n\r\n		return inside ? zoom : zoom - 1;\r\n	},\r\n\r\n	getSize: function () {\r\n		if (!this._size || this._sizeChanged) {\r\n			this._size = new L.Point(\r\n				this._container.clientWidth,\r\n				this._container.clientHeight);\r\n\r\n			this._sizeChanged = false;\r\n		}\r\n		return this._size.clone();\r\n	},\r\n\r\n	getPixelBounds: function () {\r\n		var topLeftPoint = this._getTopLeftPoint();\r\n		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n	},\r\n\r\n	getPixelOrigin: function () {\r\n		this._checkIfLoaded();\r\n		return this._initialTopLeftPoint;\r\n	},\r\n\r\n	getPanes: function () {\r\n		return this._panes;\r\n	},\r\n\r\n	getContainer: function () {\r\n		return this._container;\r\n	},\r\n\r\n\r\n	// TODO replace with universal implementation after refactoring projections\r\n\r\n	getZoomScale: function (toZoom) {\r\n		var crs = this.options.crs;\r\n		return crs.scale(toZoom) / crs.scale(this._zoom);\r\n	},\r\n\r\n	getScaleZoom: function (scale) {\r\n		return this._zoom + (Math.log(scale) / Math.LN2);\r\n	},\r\n\r\n\r\n	// conversion methods\r\n\r\n	project: function (latlng, zoom) { // (LatLng[, Number]) -> Point\r\n		zoom = zoom === undefined ? this._zoom : zoom;\r\n		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);\r\n	},\r\n\r\n	unproject: function (point, zoom) { // (Point[, Number]) -> LatLng\r\n		zoom = zoom === undefined ? this._zoom : zoom;\r\n		return this.options.crs.pointToLatLng(L.point(point), zoom);\r\n	},\r\n\r\n	layerPointToLatLng: function (point) { // (Point)\r\n		var projectedPoint = L.point(point).add(this.getPixelOrigin());\r\n		return this.unproject(projectedPoint);\r\n	},\r\n\r\n	latLngToLayerPoint: function (latlng) { // (LatLng)\r\n		var projectedPoint = this.project(L.latLng(latlng))._round();\r\n		return projectedPoint._subtract(this.getPixelOrigin());\r\n	},\r\n\r\n	containerPointToLayerPoint: function (point) { // (Point)\r\n		return L.point(point).subtract(this._getMapPanePos());\r\n	},\r\n\r\n	layerPointToContainerPoint: function (point) { // (Point)\r\n		return L.point(point).add(this._getMapPanePos());\r\n	},\r\n\r\n	containerPointToLatLng: function (point) {\r\n		var layerPoint = this.containerPointToLayerPoint(L.point(point));\r\n		return this.layerPointToLatLng(layerPoint);\r\n	},\r\n\r\n	latLngToContainerPoint: function (latlng) {\r\n		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));\r\n	},\r\n\r\n	mouseEventToContainerPoint: function (e) { // (MouseEvent)\r\n		return L.DomEvent.getMousePosition(e, this._container);\r\n	},\r\n\r\n	mouseEventToLayerPoint: function (e) { // (MouseEvent)\r\n		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n	},\r\n\r\n	mouseEventToLatLng: function (e) { // (MouseEvent)\r\n		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n	},\r\n\r\n\r\n	// map initialization methods\r\n\r\n	_initContainer: function (id) {\r\n		var container = this._container = L.DomUtil.get(id);\r\n\r\n		if (!container) {\r\n			throw new Error('Map container not found.');\r\n		} else if (container._leaflet) {\r\n			throw new Error('Map container is already initialized.');\r\n		}\r\n\r\n		container._leaflet = true;\r\n	},\r\n\r\n	_initLayout: function () {\r\n		var container = this._container;\r\n\r\n		L.DomUtil.addClass(container, 'leaflet-container' +\r\n			(L.Browser.touch ? ' leaflet-touch' : '') +\r\n			(L.Browser.retina ? ' leaflet-retina' : '') +\r\n			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n			(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));\r\n\r\n		var position = L.DomUtil.getStyle(container, 'position');\r\n\r\n		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\r\n			container.style.position = 'relative';\r\n		}\r\n\r\n		this._initPanes();\r\n\r\n		if (this._initControlPos) {\r\n			this._initControlPos();\r\n		}\r\n	},\r\n\r\n	_initPanes: function () {\r\n		var panes = this._panes = {};\r\n\r\n		this._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);\r\n\r\n		this._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);\r\n		panes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);\r\n		panes.shadowPane = this._createPane('leaflet-shadow-pane');\r\n		panes.overlayPane = this._createPane('leaflet-overlay-pane');\r\n		panes.markerPane = this._createPane('leaflet-marker-pane');\r\n		panes.popupPane = this._createPane('leaflet-popup-pane');\r\n\r\n		var zoomHide = ' leaflet-zoom-hide';\r\n\r\n		if (!this.options.markerZoomAnimation) {\r\n			L.DomUtil.addClass(panes.markerPane, zoomHide);\r\n			L.DomUtil.addClass(panes.shadowPane, zoomHide);\r\n			L.DomUtil.addClass(panes.popupPane, zoomHide);\r\n		}\r\n	},\r\n\r\n	_createPane: function (className, container) {\r\n		return L.DomUtil.create('div', className, container || this._panes.objectsPane);\r\n	},\r\n\r\n	_clearPanes: function () {\r\n		this._container.removeChild(this._mapPane);\r\n	},\r\n\r\n	_addLayers: function (layers) {\r\n		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];\r\n\r\n		for (var i = 0, len = layers.length; i < len; i++) {\r\n			this.addLayer(layers[i]);\r\n		}\r\n	},\r\n\r\n\r\n	// private methods that modify map state\r\n\r\n	_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {\r\n\r\n		var zoomChanged = (this._zoom !== zoom);\r\n\r\n		if (!afterZoomAnim) {\r\n			this.fire('movestart');\r\n\r\n			if (zoomChanged) {\r\n				this.fire('zoomstart');\r\n			}\r\n		}\r\n\r\n		this._zoom = zoom;\r\n		this._initialCenter = center;\r\n\r\n		this._initialTopLeftPoint = this._getNewTopLeftPoint(center);\r\n\r\n		if (!preserveMapOffset) {\r\n			L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\r\n		} else {\r\n			this._initialTopLeftPoint._add(this._getMapPanePos());\r\n		}\r\n\r\n		this._tileLayersToLoad = this._tileLayersNum;\r\n\r\n		var loading = !this._loaded;\r\n		this._loaded = true;\r\n\r\n		this.fire('viewreset', {hard: !preserveMapOffset});\r\n\r\n		if (loading) {\r\n			this.fire('load');\r\n			this.eachLayer(this._layerAdd, this);\r\n		}\r\n\r\n		this.fire('move');\r\n\r\n		if (zoomChanged || afterZoomAnim) {\r\n			this.fire('zoomend');\r\n		}\r\n\r\n		this.fire('moveend', {hard: !preserveMapOffset});\r\n	},\r\n\r\n	_rawPanBy: function (offset) {\r\n		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n	},\r\n\r\n	_getZoomSpan: function () {\r\n		return this.getMaxZoom() - this.getMinZoom();\r\n	},\r\n\r\n	_updateZoomLevels: function () {\r\n		var i,\r\n			minZoom = Infinity,\r\n			maxZoom = -Infinity,\r\n			oldZoomSpan = this._getZoomSpan();\r\n\r\n		for (i in this._zoomBoundLayers) {\r\n			var layer = this._zoomBoundLayers[i];\r\n			if (!isNaN(layer.options.minZoom)) {\r\n				minZoom = Math.min(minZoom, layer.options.minZoom);\r\n			}\r\n			if (!isNaN(layer.options.maxZoom)) {\r\n				maxZoom = Math.max(maxZoom, layer.options.maxZoom);\r\n			}\r\n		}\r\n\r\n		if (i === undefined) { // we have no tilelayers\r\n			this._layersMaxZoom = this._layersMinZoom = undefined;\r\n		} else {\r\n			this._layersMaxZoom = maxZoom;\r\n			this._layersMinZoom = minZoom;\r\n		}\r\n\r\n		if (oldZoomSpan !== this._getZoomSpan()) {\r\n			this.fire('zoomlevelschange');\r\n		}\r\n	},\r\n\r\n	_panInsideMaxBounds: function () {\r\n		this.panInsideBounds(this.options.maxBounds);\r\n	},\r\n\r\n	_checkIfLoaded: function () {\r\n		if (!this._loaded) {\r\n			throw new Error('Set map center and zoom first.');\r\n		}\r\n	},\r\n\r\n	// map events\r\n\r\n	_initEvents: function (onOff) {\r\n		if (!L.DomEvent) { return; }\r\n\r\n		onOff = onOff || 'on';\r\n\r\n		L.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);\r\n\r\n		var events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',\r\n		              'mouseleave', 'mousemove', 'contextmenu'],\r\n		    i, len;\r\n\r\n		for (i = 0, len = events.length; i < len; i++) {\r\n			L.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);\r\n		}\r\n\r\n		if (this.options.trackResize) {\r\n			L.DomEvent[onOff](window, 'resize', this._onResize, this);\r\n		}\r\n	},\r\n\r\n	_onResize: function () {\r\n		L.Util.cancelAnimFrame(this._resizeRequest);\r\n		this._resizeRequest = L.Util.requestAnimFrame(\r\n		        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);\r\n	},\r\n\r\n	_onMouseClick: function (e) {\r\n		if (!this._loaded || (!e._simulated &&\r\n		        ((this.dragging && this.dragging.moved()) ||\r\n		         (this.boxZoom  && this.boxZoom.moved()))) ||\r\n		            L.DomEvent._skipped(e)) { return; }\r\n\r\n		this.fire('preclick');\r\n		this._fireMouseEvent(e);\r\n	},\r\n\r\n	_fireMouseEvent: function (e) {\r\n		if (!this._loaded || L.DomEvent._skipped(e)) { return; }\r\n\r\n		var type = e.type;\r\n\r\n		type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));\r\n\r\n		if (!this.hasEventListeners(type)) { return; }\r\n\r\n		if (type === 'contextmenu') {\r\n			L.DomEvent.preventDefault(e);\r\n		}\r\n\r\n		var containerPoint = this.mouseEventToContainerPoint(e),\r\n		    layerPoint = this.containerPointToLayerPoint(containerPoint),\r\n		    latlng = this.layerPointToLatLng(layerPoint);\r\n\r\n		this.fire(type, {\r\n			latlng: latlng,\r\n			layerPoint: layerPoint,\r\n			containerPoint: containerPoint,\r\n			originalEvent: e\r\n		});\r\n	},\r\n\r\n	_onTileLayerLoad: function () {\r\n		this._tileLayersToLoad--;\r\n		if (this._tileLayersNum && !this._tileLayersToLoad) {\r\n			this.fire('tilelayersload');\r\n		}\r\n	},\r\n\r\n	_clearHandlers: function () {\r\n		for (var i = 0, len = this._handlers.length; i < len; i++) {\r\n			this._handlers[i].disable();\r\n		}\r\n	},\r\n\r\n	whenReady: function (callback, context) {\r\n		if (this._loaded) {\r\n			callback.call(context || this, this);\r\n		} else {\r\n			this.on('load', callback, context);\r\n		}\r\n		return this;\r\n	},\r\n\r\n	_layerAdd: function (layer) {\r\n		layer.onAdd(this);\r\n		this.fire('layeradd', {layer: layer});\r\n	},\r\n\r\n\r\n	// private methods for getting map state\r\n\r\n	_getMapPanePos: function () {\r\n		return L.DomUtil.getPosition(this._mapPane);\r\n	},\r\n\r\n	_moved: function () {\r\n		var pos = this._getMapPanePos();\r\n		return pos && !pos.equals([0, 0]);\r\n	},\r\n\r\n	_getTopLeftPoint: function () {\r\n		return this.getPixelOrigin().subtract(this._getMapPanePos());\r\n	},\r\n\r\n	_getNewTopLeftPoint: function (center, zoom) {\r\n		var viewHalf = this.getSize()._divideBy(2);\r\n		// TODO round on display, not calculation to increase precision?\r\n		return this.project(center, zoom)._subtract(viewHalf)._round();\r\n	},\r\n\r\n	_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {\r\n		var topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());\r\n		return this.project(latlng, newZoom)._subtract(topLeft);\r\n	},\r\n\r\n	// layer point of the current center\r\n	_getCenterLayerPoint: function () {\r\n		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n	},\r\n\r\n	// offset of the specified place to the current center in pixels\r\n	_getCenterOffset: function (latlng) {\r\n		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n	},\r\n\r\n	// adjust center for view to get inside bounds\r\n	_limitCenter: function (center, zoom, bounds) {\r\n\r\n		if (!bounds) { return center; }\r\n\r\n		var centerPoint = this.project(center, zoom),\r\n		    viewHalf = this.getSize().divideBy(2),\r\n		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\r\n		return this.unproject(centerPoint.add(offset), zoom);\r\n	},\r\n\r\n	// adjust offset for view to get inside bounds\r\n	_limitOffset: function (offset, bounds) {\r\n		if (!bounds) { return offset; }\r\n\r\n		var viewBounds = this.getPixelBounds(),\r\n		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\r\n		return offset.add(this._getBoundsOffset(newBounds, bounds));\r\n	},\r\n\r\n	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n		var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),\r\n		    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),\r\n\r\n		    dx = this._rebound(nwOffset.x, -seOffset.x),\r\n		    dy = this._rebound(nwOffset.y, -seOffset.y);\r\n\r\n		return new L.Point(dx, dy);\r\n	},\r\n\r\n	_rebound: function (left, right) {\r\n		return left + right > 0 ?\r\n			Math.round(left - right) / 2 :\r\n			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n	},\r\n\r\n	_limitZoom: function (zoom) {\r\n		var min = this.getMinZoom(),\r\n		    max = this.getMaxZoom();\r\n\r\n		return Math.max(min, Math.min(max, zoom));\r\n	}\r\n});\r\n\r\nL.map = function (id, options) {\r\n	return new L.Map(id, options);\r\n};\r\n\n\n/*\r\n * Mercator projection that takes into account that the Earth is not a perfect sphere.\r\n * Less popular than spherical mercator; used by projections like EPSG:3395.\r\n */\r\n\r\nL.Projection.Mercator = {\r\n	MAX_LATITUDE: 85.0840591556,\r\n\r\n	R_MINOR: 6356752.314245179,\r\n	R_MAJOR: 6378137,\r\n\r\n	project: function (latlng) { // (LatLng) -> Point\r\n		var d = L.LatLng.DEG_TO_RAD,\r\n		    max = this.MAX_LATITUDE,\r\n		    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n		    r = this.R_MAJOR,\r\n		    r2 = this.R_MINOR,\r\n		    x = latlng.lng * d * r,\r\n		    y = lat * d,\r\n		    tmp = r2 / r,\r\n		    eccent = Math.sqrt(1.0 - tmp * tmp),\r\n		    con = eccent * Math.sin(y);\r\n\r\n		con = Math.pow((1 - con) / (1 + con), eccent * 0.5);\r\n\r\n		var ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;\r\n		y = -r * Math.log(ts);\r\n\r\n		return new L.Point(x, y);\r\n	},\r\n\r\n	unproject: function (point) { // (Point, Boolean) -> LatLng\r\n		var d = L.LatLng.RAD_TO_DEG,\r\n		    r = this.R_MAJOR,\r\n		    r2 = this.R_MINOR,\r\n		    lng = point.x * d / r,\r\n		    tmp = r2 / r,\r\n		    eccent = Math.sqrt(1 - (tmp * tmp)),\r\n		    ts = Math.exp(- point.y / r),\r\n		    phi = (Math.PI / 2) - 2 * Math.atan(ts),\r\n		    numIter = 15,\r\n		    tol = 1e-7,\r\n		    i = numIter,\r\n		    dphi = 0.1,\r\n		    con;\r\n\r\n		while ((Math.abs(dphi) > tol) && (--i > 0)) {\r\n			con = eccent * Math.sin(phi);\r\n			dphi = (Math.PI / 2) - 2 * Math.atan(ts *\r\n			            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;\r\n			phi += dphi;\r\n		}\r\n\r\n		return new L.LatLng(phi * d, lng);\r\n	}\r\n};\r\n\n\n\r\nL.CRS.EPSG3395 = L.extend({}, L.CRS, {\r\n	code: 'EPSG:3395',\r\n\r\n	projection: L.Projection.Mercator,\r\n\r\n	transformation: (function () {\r\n		var m = L.Projection.Mercator,\r\n		    r = m.R_MAJOR,\r\n		    scale = 0.5 / (Math.PI * r);\r\n\r\n		return new L.Transformation(scale, 0.5, -scale, 0.5);\r\n	}())\r\n});\r\n\n\n/*\r\n * L.TileLayer is used for standard xyz-numbered tile layers.\r\n */\r\n\r\nL.TileLayer = L.Class.extend({\r\n	includes: L.Mixin.Events,\r\n\r\n	options: {\r\n		minZoom: 0,\r\n		maxZoom: 18,\r\n		tileSize: 256,\r\n		subdomains: 'abc',\r\n		errorTileUrl: '',\r\n		attribution: '',\r\n		zoomOffset: 0,\r\n		opacity: 1,\r\n		/*\r\n		maxNativeZoom: null,\r\n		zIndex: null,\r\n		tms: false,\r\n		continuousWorld: false,\r\n		noWrap: false,\r\n		zoomReverse: false,\r\n		detectRetina: false,\r\n		reuseTiles: false,\r\n		bounds: false,\r\n		*/\r\n		unloadInvisibleTiles: L.Browser.mobile,\r\n		updateWhenIdle: L.Browser.mobile\r\n	},\r\n\r\n	initialize: function (url, options) {\r\n		options = L.setOptions(this, options);\r\n\r\n		// detecting retina displays, adjusting tileSize and zoom levels\r\n		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {\r\n\r\n			options.tileSize = Math.floor(options.tileSize / 2);\r\n			options.zoomOffset++;\r\n\r\n			if (options.minZoom > 0) {\r\n				options.minZoom--;\r\n			}\r\n			this.options.maxZoom--;\r\n		}\r\n\r\n		if (options.bounds) {\r\n			options.bounds = L.latLngBounds(options.bounds);\r\n		}\r\n\r\n		this._url = url;\r\n\r\n		var subdomains = this.options.subdomains;\r\n\r\n		if (typeof subdomains === 'string') {\r\n			this.options.subdomains = subdomains.split('');\r\n		}\r\n	},\r\n\r\n	onAdd: function (map) {\r\n		this._map = map;\r\n		this._animated = map._zoomAnimated;\r\n\r\n		// create a container div for tiles\r\n		this._initContainer();\r\n\r\n		// set up events\r\n		map.on({\r\n			'viewreset': this._reset,\r\n			'moveend': this._update\r\n		}, this);\r\n\r\n		if (this._animated) {\r\n			map.on({\r\n				'zoomanim': this._animateZoom,\r\n				'zoomend': this._endZoomAnim\r\n			}, this);\r\n		}\r\n\r\n		if (!this.options.updateWhenIdle) {\r\n			this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);\r\n			map.on('move', this._limitedUpdate, this);\r\n		}\r\n\r\n		this._reset();\r\n		this._update();\r\n	},\r\n\r\n	addTo: function (map) {\r\n		map.addLayer(this);\r\n		return this;\r\n	},\r\n\r\n	onRemove: function (map) {\r\n		this._container.parentNode.removeChild(this._container);\r\n\r\n		map.off({\r\n			'viewreset': this._reset,\r\n			'moveend': this._update\r\n		}, this);\r\n\r\n		if (this._animated) {\r\n			map.off({\r\n				'zoomanim': this._animateZoom,\r\n				'zoomend': this._endZoomAnim\r\n			}, this);\r\n		}\r\n\r\n		if (!this.options.updateWhenIdle) {\r\n			map.off('move', this._limitedUpdate, this);\r\n		}\r\n\r\n		this._container = null;\r\n		this._map = null;\r\n	},\r\n\r\n	bringToFront: function () {\r\n		var pane = this._map._panes.tilePane;\r\n\r\n		if (this._container) {\r\n			pane.appendChild(this._container);\r\n			this._setAutoZIndex(pane, Math.max);\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	bringToBack: function () {\r\n		var pane = this._map._panes.tilePane;\r\n\r\n		if (this._container) {\r\n			pane.insertBefore(this._container, pane.firstChild);\r\n			this._setAutoZIndex(pane, Math.min);\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	getAttribution: function () {\r\n		return this.options.attribution;\r\n	},\r\n\r\n	getContainer: function () {\r\n		return this._container;\r\n	},\r\n\r\n	setOpacity: function (opacity) {\r\n		this.options.opacity = opacity;\r\n\r\n		if (this._map) {\r\n			this._updateOpacity();\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	setZIndex: function (zIndex) {\r\n		this.options.zIndex = zIndex;\r\n		this._updateZIndex();\r\n\r\n		return this;\r\n	},\r\n\r\n	setUrl: function (url, noRedraw) {\r\n		this._url = url;\r\n\r\n		if (!noRedraw) {\r\n			this.redraw();\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	redraw: function () {\r\n		if (this._map) {\r\n			this._reset({hard: true});\r\n			this._update();\r\n		}\r\n		return this;\r\n	},\r\n\r\n	_updateZIndex: function () {\r\n		if (this._container && this.options.zIndex !== undefined) {\r\n			this._container.style.zIndex = this.options.zIndex;\r\n		}\r\n	},\r\n\r\n	_setAutoZIndex: function (pane, compare) {\r\n\r\n		var layers = pane.children,\r\n		    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min\r\n		    zIndex, i, len;\r\n\r\n		for (i = 0, len = layers.length; i < len; i++) {\r\n\r\n			if (layers[i] !== this._container) {\r\n				zIndex = parseInt(layers[i].style.zIndex, 10);\r\n\r\n				if (!isNaN(zIndex)) {\r\n					edgeZIndex = compare(edgeZIndex, zIndex);\r\n				}\r\n			}\r\n		}\r\n\r\n		this.options.zIndex = this._container.style.zIndex =\r\n		        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);\r\n	},\r\n\r\n	_updateOpacity: function () {\r\n		var i,\r\n		    tiles = this._tiles;\r\n\r\n		if (L.Browser.ielt9) {\r\n			for (i in tiles) {\r\n				L.DomUtil.setOpacity(tiles[i], this.options.opacity);\r\n			}\r\n		} else {\r\n			L.DomUtil.setOpacity(this._container, this.options.opacity);\r\n		}\r\n	},\r\n\r\n	_initContainer: function () {\r\n		var tilePane = this._map._panes.tilePane;\r\n\r\n		if (!this._container) {\r\n			this._container = L.DomUtil.create('div', 'leaflet-layer');\r\n\r\n			this._updateZIndex();\r\n\r\n			if (this._animated) {\r\n				var className = 'leaflet-tile-container';\r\n\r\n				this._bgBuffer = L.DomUtil.create('div', className, this._container);\r\n				this._tileContainer = L.DomUtil.create('div', className, this._container);\r\n\r\n			} else {\r\n				this._tileContainer = this._container;\r\n			}\r\n\r\n			tilePane.appendChild(this._container);\r\n\r\n			if (this.options.opacity < 1) {\r\n				this._updateOpacity();\r\n			}\r\n		}\r\n	},\r\n\r\n	_reset: function (e) {\r\n		for (var key in this._tiles) {\r\n			this.fire('tileunload', {tile: this._tiles[key]});\r\n		}\r\n\r\n		this._tiles = {};\r\n		this._tilesToLoad = 0;\r\n\r\n		if (this.options.reuseTiles) {\r\n			this._unusedTiles = [];\r\n		}\r\n\r\n		this._tileContainer.innerHTML = '';\r\n\r\n		if (this._animated && e && e.hard) {\r\n			this._clearBgBuffer();\r\n		}\r\n\r\n		this._initContainer();\r\n	},\r\n\r\n	_getTileSize: function () {\r\n		var map = this._map,\r\n		    zoom = map.getZoom() + this.options.zoomOffset,\r\n		    zoomN = this.options.maxNativeZoom,\r\n		    tileSize = this.options.tileSize;\r\n\r\n		if (zoomN && zoom > zoomN) {\r\n			tileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);\r\n		}\r\n\r\n		return tileSize;\r\n	},\r\n\r\n	_update: function () {\r\n\r\n		if (!this._map) { return; }\r\n\r\n		var map = this._map,\r\n		    bounds = map.getPixelBounds(),\r\n		    zoom = map.getZoom(),\r\n		    tileSize = this._getTileSize();\r\n\r\n		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n			return;\r\n		}\r\n\r\n		var tileBounds = L.bounds(\r\n		        bounds.min.divideBy(tileSize)._floor(),\r\n		        bounds.max.divideBy(tileSize)._floor());\r\n\r\n		this._addTilesFromCenterOut(tileBounds);\r\n\r\n		if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {\r\n			this._removeOtherTiles(tileBounds);\r\n		}\r\n	},\r\n\r\n	_addTilesFromCenterOut: function (bounds) {\r\n		var queue = [],\r\n		    center = bounds.getCenter();\r\n\r\n		var j, i, point;\r\n\r\n		for (j = bounds.min.y; j <= bounds.max.y; j++) {\r\n			for (i = bounds.min.x; i <= bounds.max.x; i++) {\r\n				point = new L.Point(i, j);\r\n\r\n				if (this._tileShouldBeLoaded(point)) {\r\n					queue.push(point);\r\n				}\r\n			}\r\n		}\r\n\r\n		var tilesToLoad = queue.length;\r\n\r\n		if (tilesToLoad === 0) { return; }\r\n\r\n		// load tiles in order of their distance to center\r\n		queue.sort(function (a, b) {\r\n			return a.distanceTo(center) - b.distanceTo(center);\r\n		});\r\n\r\n		var fragment = document.createDocumentFragment();\r\n\r\n		// if its the first batch of tiles to load\r\n		if (!this._tilesToLoad) {\r\n			this.fire('loading');\r\n		}\r\n\r\n		this._tilesToLoad += tilesToLoad;\r\n\r\n		for (i = 0; i < tilesToLoad; i++) {\r\n			this._addTile(queue[i], fragment);\r\n		}\r\n\r\n		this._tileContainer.appendChild(fragment);\r\n	},\r\n\r\n	_tileShouldBeLoaded: function (tilePoint) {\r\n		if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {\r\n			return false; // already loaded\r\n		}\r\n\r\n		var options = this.options;\r\n\r\n		if (!options.continuousWorld) {\r\n			var limit = this._getWrapTileNum();\r\n\r\n			// don't load if exceeds world bounds\r\n			if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||\r\n				tilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }\r\n		}\r\n\r\n		if (options.bounds) {\r\n			var tileSize = options.tileSize,\r\n			    nwPoint = tilePoint.multiplyBy(tileSize),\r\n			    sePoint = nwPoint.add([tileSize, tileSize]),\r\n			    nw = this._map.unproject(nwPoint),\r\n			    se = this._map.unproject(sePoint);\r\n\r\n			// TODO temporary hack, will be removed after refactoring projections\r\n			// https://github.com/Leaflet/Leaflet/issues/1618\r\n			if (!options.continuousWorld && !options.noWrap) {\r\n				nw = nw.wrap();\r\n				se = se.wrap();\r\n			}\r\n\r\n			if (!options.bounds.intersects([nw, se])) { return false; }\r\n		}\r\n\r\n		return true;\r\n	},\r\n\r\n	_removeOtherTiles: function (bounds) {\r\n		var kArr, x, y, key;\r\n\r\n		for (key in this._tiles) {\r\n			kArr = key.split(':');\r\n			x = parseInt(kArr[0], 10);\r\n			y = parseInt(kArr[1], 10);\r\n\r\n			// remove tile if it's out of bounds\r\n			if (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {\r\n				this._removeTile(key);\r\n			}\r\n		}\r\n	},\r\n\r\n	_removeTile: function (key) {\r\n		var tile = this._tiles[key];\r\n\r\n		this.fire('tileunload', {tile: tile, url: tile.src});\r\n\r\n		if (this.options.reuseTiles) {\r\n			L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');\r\n			this._unusedTiles.push(tile);\r\n\r\n		} else if (tile.parentNode === this._tileContainer) {\r\n			this._tileContainer.removeChild(tile);\r\n		}\r\n\r\n		// for https://github.com/CloudMade/Leaflet/issues/137\r\n		if (!L.Browser.android) {\r\n			tile.onload = null;\r\n			tile.src = L.Util.emptyImageUrl;\r\n		}\r\n\r\n		delete this._tiles[key];\r\n	},\r\n\r\n	_addTile: function (tilePoint, container) {\r\n		var tilePos = this._getTilePos(tilePoint);\r\n\r\n		// get unused tile - or create a new tile\r\n		var tile = this._getTile();\r\n\r\n		/*\r\n		Chrome 20 layouts much faster with top/left (verify with timeline, frames)\r\n		Android 4 browser has display issues with top/left and requires transform instead\r\n		(other browsers don't currently care) - see debug/hacks/jitter.html for an example\r\n		*/\r\n		L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);\r\n\r\n		this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;\r\n\r\n		this._loadTile(tile, tilePoint);\r\n\r\n		if (tile.parentNode !== this._tileContainer) {\r\n			container.appendChild(tile);\r\n		}\r\n	},\r\n\r\n	_getZoomForUrl: function () {\r\n\r\n		var options = this.options,\r\n		    zoom = this._map.getZoom();\r\n\r\n		if (options.zoomReverse) {\r\n			zoom = options.maxZoom - zoom;\r\n		}\r\n\r\n		zoom += options.zoomOffset;\r\n\r\n		return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;\r\n	},\r\n\r\n	_getTilePos: function (tilePoint) {\r\n		var origin = this._map.getPixelOrigin(),\r\n		    tileSize = this._getTileSize();\r\n\r\n		return tilePoint.multiplyBy(tileSize).subtract(origin);\r\n	},\r\n\r\n	// image-specific code (override to implement e.g. Canvas or SVG tile layer)\r\n\r\n	getTileUrl: function (tilePoint) {\r\n		return L.Util.template(this._url, L.extend({\r\n			s: this._getSubdomain(tilePoint),\r\n			z: tilePoint.z,\r\n			x: tilePoint.x,\r\n			y: tilePoint.y\r\n		}, this.options));\r\n	},\r\n\r\n	_getWrapTileNum: function () {\r\n		var crs = this._map.options.crs,\r\n		    size = crs.getSize(this._map.getZoom());\r\n		return size.divideBy(this._getTileSize())._floor();\r\n	},\r\n\r\n	_adjustTilePoint: function (tilePoint) {\r\n\r\n		var limit = this._getWrapTileNum();\r\n\r\n		// wrap tile coordinates\r\n		if (!this.options.continuousWorld && !this.options.noWrap) {\r\n			tilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;\r\n		}\r\n\r\n		if (this.options.tms) {\r\n			tilePoint.y = limit.y - tilePoint.y - 1;\r\n		}\r\n\r\n		tilePoint.z = this._getZoomForUrl();\r\n	},\r\n\r\n	_getSubdomain: function (tilePoint) {\r\n		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n		return this.options.subdomains[index];\r\n	},\r\n\r\n	_getTile: function () {\r\n		if (this.options.reuseTiles && this._unusedTiles.length > 0) {\r\n			var tile = this._unusedTiles.pop();\r\n			this._resetTile(tile);\r\n			return tile;\r\n		}\r\n		return this._createTile();\r\n	},\r\n\r\n	// Override if data stored on a tile needs to be cleaned up before reuse\r\n	_resetTile: function (/*tile*/) {},\r\n\r\n	_createTile: function () {\r\n		var tile = L.DomUtil.create('img', 'leaflet-tile');\r\n		tile.style.width = tile.style.height = this._getTileSize() + 'px';\r\n		tile.galleryimg = 'no';\r\n\r\n		tile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\r\n		if (L.Browser.ielt9 && this.options.opacity !== undefined) {\r\n			L.DomUtil.setOpacity(tile, this.options.opacity);\r\n		}\r\n		// without this hack, tiles disappear after zoom on Chrome for Android\r\n		// https://github.com/Leaflet/Leaflet/issues/2078\r\n		if (L.Browser.mobileWebkit3d) {\r\n			tile.style.WebkitBackfaceVisibility = 'hidden';\r\n		}\r\n		return tile;\r\n	},\r\n\r\n	_loadTile: function (tile, tilePoint) {\r\n		tile._layer  = this;\r\n		tile.onload  = this._tileOnLoad;\r\n		tile.onerror = this._tileOnError;\r\n\r\n		this._adjustTilePoint(tilePoint);\r\n		tile.src     = this.getTileUrl(tilePoint);\r\n\r\n		this.fire('tileloadstart', {\r\n			tile: tile,\r\n			url: tile.src\r\n		});\r\n	},\r\n\r\n	_tileLoaded: function () {\r\n		this._tilesToLoad--;\r\n\r\n		if (this._animated) {\r\n			L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\r\n		}\r\n\r\n		if (!this._tilesToLoad) {\r\n			this.fire('load');\r\n\r\n			if (this._animated) {\r\n				// clear scaled tiles after all new tiles are loaded (for performance)\r\n				clearTimeout(this._clearBgBufferTimer);\r\n				this._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);\r\n			}\r\n		}\r\n	},\r\n\r\n	_tileOnLoad: function () {\r\n		var layer = this._layer;\r\n\r\n		//Only if we are loading an actual image\r\n		if (this.src !== L.Util.emptyImageUrl) {\r\n			L.DomUtil.addClass(this, 'leaflet-tile-loaded');\r\n\r\n			layer.fire('tileload', {\r\n				tile: this,\r\n				url: this.src\r\n			});\r\n		}\r\n\r\n		layer._tileLoaded();\r\n	},\r\n\r\n	_tileOnError: function () {\r\n		var layer = this._layer;\r\n\r\n		layer.fire('tileerror', {\r\n			tile: this,\r\n			url: this.src\r\n		});\r\n\r\n		var newUrl = layer.options.errorTileUrl;\r\n		if (newUrl) {\r\n			this.src = newUrl;\r\n		}\r\n\r\n		layer._tileLoaded();\r\n	}\r\n});\r\n\r\nL.tileLayer = function (url, options) {\r\n	return new L.TileLayer(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.WMS is used for putting WMS tile layers on the map.\r\n */\r\n\r\nL.TileLayer.WMS = L.TileLayer.extend({\r\n\r\n	defaultWmsParams: {\r\n		service: 'WMS',\r\n		request: 'GetMap',\r\n		version: '1.1.1',\r\n		layers: '',\r\n		styles: '',\r\n		format: 'image/jpeg',\r\n		transparent: false\r\n	},\r\n\r\n	initialize: function (url, options) { // (String, Object)\r\n\r\n		this._url = url;\r\n\r\n		var wmsParams = L.extend({}, this.defaultWmsParams),\r\n		    tileSize = options.tileSize || this.options.tileSize;\r\n\r\n		if (options.detectRetina && L.Browser.retina) {\r\n			wmsParams.width = wmsParams.height = tileSize * 2;\r\n		} else {\r\n			wmsParams.width = wmsParams.height = tileSize;\r\n		}\r\n\r\n		for (var i in options) {\r\n			// all keys that are not TileLayer options go to WMS params\r\n			if (!this.options.hasOwnProperty(i) && i !== 'crs') {\r\n				wmsParams[i] = options[i];\r\n			}\r\n		}\r\n\r\n		this.wmsParams = wmsParams;\r\n\r\n		L.setOptions(this, options);\r\n	},\r\n\r\n	onAdd: function (map) {\r\n\r\n		this._crs = this.options.crs || map.options.crs;\r\n\r\n		this._wmsVersion = parseFloat(this.wmsParams.version);\r\n\r\n		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\r\n		this.wmsParams[projectionKey] = this._crs.code;\r\n\r\n		L.TileLayer.prototype.onAdd.call(this, map);\r\n	},\r\n\r\n	getTileUrl: function (tilePoint) { // (Point, Number) -> String\r\n\r\n		var map = this._map,\r\n		    tileSize = this.options.tileSize,\r\n\r\n		    nwPoint = tilePoint.multiplyBy(tileSize),\r\n		    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\r\n		    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),\r\n		    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),\r\n		    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?\r\n		        [se.y, nw.x, nw.y, se.x].join(',') :\r\n		        [nw.x, se.y, se.x, nw.y].join(','),\r\n\r\n		    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});\r\n\r\n		return url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;\r\n	},\r\n\r\n	setParams: function (params, noRedraw) {\r\n\r\n		L.extend(this.wmsParams, params);\r\n\r\n		if (!noRedraw) {\r\n			this.redraw();\r\n		}\r\n\r\n		return this;\r\n	}\r\n});\r\n\r\nL.tileLayer.wms = function (url, options) {\r\n	return new L.TileLayer.WMS(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.Canvas is a class that you can use as a base for creating\r\n * dynamically drawn Canvas-based tile layers.\r\n */\r\n\r\nL.TileLayer.Canvas = L.TileLayer.extend({\r\n	options: {\r\n		async: false\r\n	},\r\n\r\n	initialize: function (options) {\r\n		L.setOptions(this, options);\r\n	},\r\n\r\n	redraw: function () {\r\n		if (this._map) {\r\n			this._reset({hard: true});\r\n			this._update();\r\n		}\r\n\r\n		for (var i in this._tiles) {\r\n			this._redrawTile(this._tiles[i]);\r\n		}\r\n		return this;\r\n	},\r\n\r\n	_redrawTile: function (tile) {\r\n		this.drawTile(tile, tile._tilePoint, this._map._zoom);\r\n	},\r\n\r\n	_createTile: function () {\r\n		var tile = L.DomUtil.create('canvas', 'leaflet-tile');\r\n		tile.width = tile.height = this.options.tileSize;\r\n		tile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n		return tile;\r\n	},\r\n\r\n	_loadTile: function (tile, tilePoint) {\r\n		tile._layer = this;\r\n		tile._tilePoint = tilePoint;\r\n\r\n		this._redrawTile(tile);\r\n\r\n		if (!this.options.async) {\r\n			this.tileDrawn(tile);\r\n		}\r\n	},\r\n\r\n	drawTile: function (/*tile, tilePoint*/) {\r\n		// override with rendering code\r\n	},\r\n\r\n	tileDrawn: function (tile) {\r\n		this._tileOnLoad.call(tile);\r\n	}\r\n});\r\n\r\n\r\nL.tileLayer.canvas = function (options) {\r\n	return new L.TileLayer.Canvas(options);\r\n};\r\n\n\n/*\r\n * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).\r\n */\r\n\r\nL.ImageOverlay = L.Class.extend({\r\n	includes: L.Mixin.Events,\r\n\r\n	options: {\r\n		opacity: 1\r\n	},\r\n\r\n	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\r\n		this._url = url;\r\n		this._bounds = L.latLngBounds(bounds);\r\n\r\n		L.setOptions(this, options);\r\n	},\r\n\r\n	onAdd: function (map) {\r\n		this._map = map;\r\n\r\n		if (!this._image) {\r\n			this._initImage();\r\n		}\r\n\r\n		map._panes.overlayPane.appendChild(this._image);\r\n\r\n		map.on('viewreset', this._reset, this);\r\n\r\n		if (map.options.zoomAnimation && L.Browser.any3d) {\r\n			map.on('zoomanim', this._animateZoom, this);\r\n		}\r\n\r\n		this._reset();\r\n	},\r\n\r\n	onRemove: function (map) {\r\n		map.getPanes().overlayPane.removeChild(this._image);\r\n\r\n		map.off('viewreset', this._reset, this);\r\n\r\n		if (map.options.zoomAnimation) {\r\n			map.off('zoomanim', this._animateZoom, this);\r\n		}\r\n	},\r\n\r\n	addTo: function (map) {\r\n		map.addLayer(this);\r\n		return this;\r\n	},\r\n\r\n	setOpacity: function (opacity) {\r\n		this.options.opacity = opacity;\r\n		this._updateOpacity();\r\n		return this;\r\n	},\r\n\r\n	// TODO remove bringToFront/bringToBack duplication from TileLayer/Path\r\n	bringToFront: function () {\r\n		if (this._image) {\r\n			this._map._panes.overlayPane.appendChild(this._image);\r\n		}\r\n		return this;\r\n	},\r\n\r\n	bringToBack: function () {\r\n		var pane = this._map._panes.overlayPane;\r\n		if (this._image) {\r\n			pane.insertBefore(this._image, pane.firstChild);\r\n		}\r\n		return this;\r\n	},\r\n\r\n	setUrl: function (url) {\r\n		this._url = url;\r\n		this._image.src = this._url;\r\n	},\r\n\r\n	getAttribution: function () {\r\n		return this.options.attribution;\r\n	},\r\n\r\n	_initImage: function () {\r\n		this._image = L.DomUtil.create('img', 'leaflet-image-layer');\r\n\r\n		if (this._map.options.zoomAnimation && L.Browser.any3d) {\r\n			L.DomUtil.addClass(this._image, 'leaflet-zoom-animated');\r\n		} else {\r\n			L.DomUtil.addClass(this._image, 'leaflet-zoom-hide');\r\n		}\r\n\r\n		this._updateOpacity();\r\n\r\n		//TODO createImage util method to remove duplication\r\n		L.extend(this._image, {\r\n			galleryimg: 'no',\r\n			onselectstart: L.Util.falseFn,\r\n			onmousemove: L.Util.falseFn,\r\n			onload: L.bind(this._onImageLoad, this),\r\n			src: this._url\r\n		});\r\n	},\r\n\r\n	_animateZoom: function (e) {\r\n		var map = this._map,\r\n		    image = this._image,\r\n		    scale = map.getZoomScale(e.zoom),\r\n		    nw = this._bounds.getNorthWest(),\r\n		    se = this._bounds.getSouthEast(),\r\n\r\n		    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),\r\n		    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),\r\n		    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));\r\n\r\n		image.style[L.DomUtil.TRANSFORM] =\r\n		        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';\r\n	},\r\n\r\n	_reset: function () {\r\n		var image   = this._image,\r\n		    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\r\n		    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);\r\n\r\n		L.DomUtil.setPosition(image, topLeft);\r\n\r\n		image.style.width  = size.x + 'px';\r\n		image.style.height = size.y + 'px';\r\n	},\r\n\r\n	_onImageLoad: function () {\r\n		this.fire('load');\r\n	},\r\n\r\n	_updateOpacity: function () {\r\n		L.DomUtil.setOpacity(this._image, this.options.opacity);\r\n	}\r\n});\r\n\r\nL.imageOverlay = function (url, bounds, options) {\r\n	return new L.ImageOverlay(url, bounds, options);\r\n};\r\n\n\n/*\r\n * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.\r\n */\r\n\r\nL.Icon = L.Class.extend({\r\n	options: {\r\n		/*\r\n		iconUrl: (String) (required)\r\n		iconRetinaUrl: (String) (optional, used for retina devices if detected)\r\n		iconSize: (Point) (can be set through CSS)\r\n		iconAnchor: (Point) (centered by default, can be set in CSS with negative margins)\r\n		popupAnchor: (Point) (if not specified, popup opens in the anchor point)\r\n		shadowUrl: (String) (no shadow by default)\r\n		shadowRetinaUrl: (String) (optional, used for retina devices if detected)\r\n		shadowSize: (Point)\r\n		shadowAnchor: (Point)\r\n		*/\r\n		className: ''\r\n	},\r\n\r\n	initialize: function (options) {\r\n		L.setOptions(this, options);\r\n	},\r\n\r\n	createIcon: function (oldIcon) {\r\n		return this._createIcon('icon', oldIcon);\r\n	},\r\n\r\n	createShadow: function (oldIcon) {\r\n		return this._createIcon('shadow', oldIcon);\r\n	},\r\n\r\n	_createIcon: function (name, oldIcon) {\r\n		var src = this._getIconUrl(name);\r\n\r\n		if (!src) {\r\n			if (name === 'icon') {\r\n				throw new Error('iconUrl not set in Icon options (see the docs).');\r\n			}\r\n			return null;\r\n		}\r\n\r\n		var img;\r\n		if (!oldIcon || oldIcon.tagName !== 'IMG') {\r\n			img = this._createImg(src);\r\n		} else {\r\n			img = this._createImg(src, oldIcon);\r\n		}\r\n		this._setIconStyles(img, name);\r\n\r\n		return img;\r\n	},\r\n\r\n	_setIconStyles: function (img, name) {\r\n		var options = this.options,\r\n		    size = L.point(options[name + 'Size']),\r\n		    anchor;\r\n\r\n		if (name === 'shadow') {\r\n			anchor = L.point(options.shadowAnchor || options.iconAnchor);\r\n		} else {\r\n			anchor = L.point(options.iconAnchor);\r\n		}\r\n\r\n		if (!anchor && size) {\r\n			anchor = size.divideBy(2, true);\r\n		}\r\n\r\n		img.className = 'leaflet-marker-' + name + ' ' + options.className;\r\n\r\n		if (anchor) {\r\n			img.style.marginLeft = (-anchor.x) + 'px';\r\n			img.style.marginTop  = (-anchor.y) + 'px';\r\n		}\r\n\r\n		if (size) {\r\n			img.style.width  = size.x + 'px';\r\n			img.style.height = size.y + 'px';\r\n		}\r\n	},\r\n\r\n	_createImg: function (src, el) {\r\n		el = el || document.createElement('img');\r\n		el.src = src;\r\n		return el;\r\n	},\r\n\r\n	_getIconUrl: function (name) {\r\n		if (L.Browser.retina && this.options[name + 'RetinaUrl']) {\r\n			return this.options[name + 'RetinaUrl'];\r\n		}\r\n		return this.options[name + 'Url'];\r\n	}\r\n});\r\n\r\nL.icon = function (options) {\r\n	return new L.Icon(options);\r\n};\r\n\n\n/*\n * L.Icon.Default is the blue marker icon used by default in Leaflet.\n */\n\nL.Icon.Default = L.Icon.extend({\n\n	options: {\n		iconSize: [25, 41],\n		iconAnchor: [12, 41],\n		popupAnchor: [1, -34],\n\n		shadowSize: [41, 41]\n	},\n\n	_getIconUrl: function (name) {\n		var key = name + 'Url';\n\n		if (this.options[key]) {\n			return this.options[key];\n		}\n\n		if (L.Browser.retina && name === 'icon') {\n			name += '-2x';\n		}\n\n		var path = L.Icon.Default.imagePath;\n\n		if (!path) {\n			throw new Error('Couldn\\'t autodetect L.Icon.Default.imagePath, set it manually.');\n		}\n\n		return path + '/marker-' + name + '.png';\n	}\n});\n\nL.Icon.Default.imagePath = (function () {\n	var scripts = document.getElementsByTagName('script'),\n	    leafletRe = /[\\/^]leaflet[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n\n	var i, len, src, matches, path;\n\n	for (i = 0, len = scripts.length; i < len; i++) {\n		src = scripts[i].src;\n		matches = src.match(leafletRe);\n\n		if (matches) {\n			path = src.split(leafletRe)[0];\n			return (path ? path + '/' : '') + 'images';\n		}\n	}\n}());\n\n\n/*\r\n * L.Marker is used to display clickable/draggable icons on the map.\r\n */\r\n\r\nL.Marker = L.Class.extend({\r\n\r\n	includes: L.Mixin.Events,\r\n\r\n	options: {\r\n		icon: new L.Icon.Default(),\r\n		title: '',\r\n		alt: '',\r\n		clickable: true,\r\n		draggable: false,\r\n		keyboard: true,\r\n		zIndexOffset: 0,\r\n		opacity: 1,\r\n		riseOnHover: false,\r\n		riseOffset: 250\r\n	},\r\n\r\n	initialize: function (latlng, options) {\r\n		L.setOptions(this, options);\r\n		this._latlng = L.latLng(latlng);\r\n	},\r\n\r\n	onAdd: function (map) {\r\n		this._map = map;\r\n\r\n		map.on('viewreset', this.update, this);\r\n\r\n		this._initIcon();\r\n		this.update();\r\n		this.fire('add');\r\n\r\n		if (map.options.zoomAnimation && map.options.markerZoomAnimation) {\r\n			map.on('zoomanim', this._animateZoom, this);\r\n		}\r\n	},\r\n\r\n	addTo: function (map) {\r\n		map.addLayer(this);\r\n		return this;\r\n	},\r\n\r\n	onRemove: function (map) {\r\n		if (this.dragging) {\r\n			this.dragging.disable();\r\n		}\r\n\r\n		this._removeIcon();\r\n		this._removeShadow();\r\n\r\n		this.fire('remove');\r\n\r\n		map.off({\r\n			'viewreset': this.update,\r\n			'zoomanim': this._animateZoom\r\n		}, this);\r\n\r\n		this._map = null;\r\n	},\r\n\r\n	getLatLng: function () {\r\n		return this._latlng;\r\n	},\r\n\r\n	setLatLng: function (latlng) {\r\n		this._latlng = L.latLng(latlng);\r\n\r\n		this.update();\r\n\r\n		return this.fire('move', { latlng: this._latlng });\r\n	},\r\n\r\n	setZIndexOffset: function (offset) {\r\n		this.options.zIndexOffset = offset;\r\n		this.update();\r\n\r\n		return this;\r\n	},\r\n\r\n	setIcon: function (icon) {\r\n\r\n		this.options.icon = icon;\r\n\r\n		if (this._map) {\r\n			this._initIcon();\r\n			this.update();\r\n		}\r\n\r\n		if (this._popup) {\r\n			this.bindPopup(this._popup);\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	update: function () {\r\n		if (this._icon) {\r\n			var pos = this._map.latLngToLayerPoint(this._latlng).round();\r\n			this._setPos(pos);\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	_initIcon: function () {\r\n		var options = this.options,\r\n		    map = this._map,\r\n		    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),\r\n		    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';\r\n\r\n		var icon = options.icon.createIcon(this._icon),\r\n			addIcon = false;\r\n\r\n		// if we're not reusing the icon, remove the old one and init new one\r\n		if (icon !== this._icon) {\r\n			if (this._icon) {\r\n				this._removeIcon();\r\n			}\r\n			addIcon = true;\r\n\r\n			if (options.title) {\r\n				icon.title = options.title;\r\n			}\r\n			\r\n			if (options.alt) {\r\n				icon.alt = options.alt;\r\n			}\r\n		}\r\n\r\n		L.DomUtil.addClass(icon, classToAdd);\r\n\r\n		if (options.keyboard) {\r\n			icon.tabIndex = '0';\r\n		}\r\n\r\n		this._icon = icon;\r\n\r\n		this._initInteraction();\r\n\r\n		if (options.riseOnHover) {\r\n			L.DomEvent\r\n				.on(icon, 'mouseover', this._bringToFront, this)\r\n				.on(icon, 'mouseout', this._resetZIndex, this);\r\n		}\r\n\r\n		var newShadow = options.icon.createShadow(this._shadow),\r\n			addShadow = false;\r\n\r\n		if (newShadow !== this._shadow) {\r\n			this._removeShadow();\r\n			addShadow = true;\r\n		}\r\n\r\n		if (newShadow) {\r\n			L.DomUtil.addClass(newShadow, classToAdd);\r\n		}\r\n		this._shadow = newShadow;\r\n\r\n\r\n		if (options.opacity < 1) {\r\n			this._updateOpacity();\r\n		}\r\n\r\n\r\n		var panes = this._map._panes;\r\n\r\n		if (addIcon) {\r\n			panes.markerPane.appendChild(this._icon);\r\n		}\r\n\r\n		if (newShadow && addShadow) {\r\n			panes.shadowPane.appendChild(this._shadow);\r\n		}\r\n	},\r\n\r\n	_removeIcon: function () {\r\n		if (this.options.riseOnHover) {\r\n			L.DomEvent\r\n			    .off(this._icon, 'mouseover', this._bringToFront)\r\n			    .off(this._icon, 'mouseout', this._resetZIndex);\r\n		}\r\n\r\n		this._map._panes.markerPane.removeChild(this._icon);\r\n\r\n		this._icon = null;\r\n	},\r\n\r\n	_removeShadow: function () {\r\n		if (this._shadow) {\r\n			this._map._panes.shadowPane.removeChild(this._shadow);\r\n		}\r\n		this._shadow = null;\r\n	},\r\n\r\n	_setPos: function (pos) {\r\n		L.DomUtil.setPosition(this._icon, pos);\r\n\r\n		if (this._shadow) {\r\n			L.DomUtil.setPosition(this._shadow, pos);\r\n		}\r\n\r\n		this._zIndex = pos.y + this.options.zIndexOffset;\r\n\r\n		this._resetZIndex();\r\n	},\r\n\r\n	_updateZIndex: function (offset) {\r\n		this._icon.style.zIndex = this._zIndex + offset;\r\n	},\r\n\r\n	_animateZoom: function (opt) {\r\n		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\r\n\r\n		this._setPos(pos);\r\n	},\r\n\r\n	_initInteraction: function () {\r\n\r\n		if (!this.options.clickable) { return; }\r\n\r\n		// TODO refactor into something shared with Map/Path/etc. to DRY it up\r\n\r\n		var icon = this._icon,\r\n		    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];\r\n\r\n		L.DomUtil.addClass(icon, 'leaflet-clickable');\r\n		L.DomEvent.on(icon, 'click', this._onMouseClick, this);\r\n		L.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\r\n\r\n		for (var i = 0; i < events.length; i++) {\r\n			L.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\r\n		}\r\n\r\n		if (L.Handler.MarkerDrag) {\r\n			this.dragging = new L.Handler.MarkerDrag(this);\r\n\r\n			if (this.options.draggable) {\r\n				this.dragging.enable();\r\n			}\r\n		}\r\n	},\r\n\r\n	_onMouseClick: function (e) {\r\n		var wasDragged = this.dragging && this.dragging.moved();\r\n\r\n		if (this.hasEventListeners(e.type) || wasDragged) {\r\n			L.DomEvent.stopPropagation(e);\r\n		}\r\n\r\n		if (wasDragged) { return; }\r\n\r\n		if ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n		this.fire(e.type, {\r\n			originalEvent: e,\r\n			latlng: this._latlng\r\n		});\r\n	},\r\n\r\n	_onKeyPress: function (e) {\r\n		if (e.keyCode === 13) {\r\n			this.fire('click', {\r\n				originalEvent: e,\r\n				latlng: this._latlng\r\n			});\r\n		}\r\n	},\r\n\r\n	_fireMouseEvent: function (e) {\r\n\r\n		this.fire(e.type, {\r\n			originalEvent: e,\r\n			latlng: this._latlng\r\n		});\r\n\r\n		// TODO proper custom event propagation\r\n		// this line will always be called if marker is in a FeatureGroup\r\n		if (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {\r\n			L.DomEvent.preventDefault(e);\r\n		}\r\n		if (e.type !== 'mousedown') {\r\n			L.DomEvent.stopPropagation(e);\r\n		} else {\r\n			L.DomEvent.preventDefault(e);\r\n		}\r\n	},\r\n\r\n	setOpacity: function (opacity) {\r\n		this.options.opacity = opacity;\r\n		if (this._map) {\r\n			this._updateOpacity();\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	_updateOpacity: function () {\r\n		L.DomUtil.setOpacity(this._icon, this.options.opacity);\r\n		if (this._shadow) {\r\n			L.DomUtil.setOpacity(this._shadow, this.options.opacity);\r\n		}\r\n	},\r\n\r\n	_bringToFront: function () {\r\n		this._updateZIndex(this.options.riseOffset);\r\n	},\r\n\r\n	_resetZIndex: function () {\r\n		this._updateZIndex(0);\r\n	}\r\n});\r\n\r\nL.marker = function (latlng, options) {\r\n	return new L.Marker(latlng, options);\r\n};\r\n\n\n/*\n * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)\n * to use with L.Marker.\n */\n\nL.DivIcon = L.Icon.extend({\n	options: {\n		iconSize: [12, 12], // also can be set through CSS\n		/*\n		iconAnchor: (Point)\n		popupAnchor: (Point)\n		html: (String)\n		bgPos: (Point)\n		*/\n		className: 'leaflet-div-icon',\n		html: false\n	},\n\n	createIcon: function (oldIcon) {\n		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n		    options = this.options;\n\n		if (options.html !== false) {\n			div.innerHTML = options.html;\n		} else {\n			div.innerHTML = '';\n		}\n\n		if (options.bgPos) {\n			div.style.backgroundPosition =\n			        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';\n		}\n\n		this._setIconStyles(div, 'icon');\n		return div;\n	},\n\n	createShadow: function () {\n		return null;\n	}\n});\n\nL.divIcon = function (options) {\n	return new L.DivIcon(options);\n};\n\n\n/*\r\n * L.Popup is used for displaying popups on the map.\r\n */\r\n\r\nL.Map.mergeOptions({\r\n	closePopupOnClick: true\r\n});\r\n\r\nL.Popup = L.Class.extend({\r\n	includes: L.Mixin.Events,\r\n\r\n	options: {\r\n		minWidth: 50,\r\n		maxWidth: 300,\r\n		// maxHeight: null,\r\n		autoPan: true,\r\n		closeButton: true,\r\n		offset: [0, 7],\r\n		autoPanPadding: [5, 5],\r\n		// autoPanPaddingTopLeft: null,\r\n		// autoPanPaddingBottomRight: null,\r\n		keepInView: false,\r\n		className: '',\r\n		zoomAnimation: true\r\n	},\r\n\r\n	initialize: function (options, source) {\r\n		L.setOptions(this, options);\r\n\r\n		this._source = source;\r\n		this._animated = L.Browser.any3d && this.options.zoomAnimation;\r\n		this._isOpen = false;\r\n	},\r\n\r\n	onAdd: function (map) {\r\n		this._map = map;\r\n\r\n		if (!this._container) {\r\n			this._initLayout();\r\n		}\r\n\r\n		var animFade = map.options.fadeAnimation;\r\n\r\n		if (animFade) {\r\n			L.DomUtil.setOpacity(this._container, 0);\r\n		}\r\n		map._panes.popupPane.appendChild(this._container);\r\n\r\n		map.on(this._getEvents(), this);\r\n\r\n		this.update();\r\n\r\n		if (animFade) {\r\n			L.DomUtil.setOpacity(this._container, 1);\r\n		}\r\n\r\n		this.fire('open');\r\n\r\n		map.fire('popupopen', {popup: this});\r\n\r\n		if (this._source) {\r\n			this._source.fire('popupopen', {popup: this});\r\n		}\r\n	},\r\n\r\n	addTo: function (map) {\r\n		map.addLayer(this);\r\n		return this;\r\n	},\r\n\r\n	openOn: function (map) {\r\n		map.openPopup(this);\r\n		return this;\r\n	},\r\n\r\n	onRemove: function (map) {\r\n		map._panes.popupPane.removeChild(this._container);\r\n\r\n		L.Util.falseFn(this._container.offsetWidth); // force reflow\r\n\r\n		map.off(this._getEvents(), this);\r\n\r\n		if (map.options.fadeAnimation) {\r\n			L.DomUtil.setOpacity(this._container, 0);\r\n		}\r\n\r\n		this._map = null;\r\n\r\n		this.fire('close');\r\n\r\n		map.fire('popupclose', {popup: this});\r\n\r\n		if (this._source) {\r\n			this._source.fire('popupclose', {popup: this});\r\n		}\r\n	},\r\n\r\n	getLatLng: function () {\r\n		return this._latlng;\r\n	},\r\n\r\n	setLatLng: function (latlng) {\r\n		this._latlng = L.latLng(latlng);\r\n		if (this._map) {\r\n			this._updatePosition();\r\n			this._adjustPan();\r\n		}\r\n		return this;\r\n	},\r\n\r\n	getContent: function () {\r\n		return this._content;\r\n	},\r\n\r\n	setContent: function (content) {\r\n		this._content = content;\r\n		this.update();\r\n		return this;\r\n	},\r\n\r\n	update: function () {\r\n		if (!this._map) { return; }\r\n\r\n		this._container.style.visibility = 'hidden';\r\n\r\n		this._updateContent();\r\n		this._updateLayout();\r\n		this._updatePosition();\r\n\r\n		this._container.style.visibility = '';\r\n\r\n		this._adjustPan();\r\n	},\r\n\r\n	_getEvents: function () {\r\n		var events = {\r\n			viewreset: this._updatePosition\r\n		};\r\n\r\n		if (this._animated) {\r\n			events.zoomanim = this._zoomAnimation;\r\n		}\r\n		if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\r\n			events.preclick = this._close;\r\n		}\r\n		if (this.options.keepInView) {\r\n			events.moveend = this._adjustPan;\r\n		}\r\n\r\n		return events;\r\n	},\r\n\r\n	_close: function () {\r\n		if (this._map) {\r\n			this._map.closePopup(this);\r\n		}\r\n	},\r\n\r\n	_initLayout: function () {\r\n		var prefix = 'leaflet-popup',\r\n			containerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +\r\n			        (this._animated ? 'animated' : 'hide'),\r\n			container = this._container = L.DomUtil.create('div', containerClass),\r\n			closeButton;\r\n\r\n		if (this.options.closeButton) {\r\n			closeButton = this._closeButton =\r\n			        L.DomUtil.create('a', prefix + '-close-button', container);\r\n			closeButton.href = '#close';\r\n			closeButton.innerHTML = '&#215;';\r\n			L.DomEvent.disableClickPropagation(closeButton);\r\n\r\n			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);\r\n		}\r\n\r\n		var wrapper = this._wrapper =\r\n		        L.DomUtil.create('div', prefix + '-content-wrapper', container);\r\n		L.DomEvent.disableClickPropagation(wrapper);\r\n\r\n		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);\r\n\r\n		L.DomEvent.disableScrollPropagation(this._contentNode);\r\n		L.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);\r\n\r\n		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);\r\n		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);\r\n	},\r\n\r\n	_updateContent: function () {\r\n		if (!this._content) { return; }\r\n\r\n		if (typeof this._content === 'string') {\r\n			this._contentNode.innerHTML = this._content;\r\n		} else {\r\n			while (this._contentNode.hasChildNodes()) {\r\n				this._contentNode.removeChild(this._contentNode.firstChild);\r\n			}\r\n			this._contentNode.appendChild(this._content);\r\n		}\r\n		this.fire('contentupdate');\r\n	},\r\n\r\n	_updateLayout: function () {\r\n		var container = this._contentNode,\r\n		    style = container.style;\r\n\r\n		style.width = '';\r\n		style.whiteSpace = 'nowrap';\r\n\r\n		var width = container.offsetWidth;\r\n		width = Math.min(width, this.options.maxWidth);\r\n		width = Math.max(width, this.options.minWidth);\r\n\r\n		style.width = (width + 1) + 'px';\r\n		style.whiteSpace = '';\r\n\r\n		style.height = '';\r\n\r\n		var height = container.offsetHeight,\r\n		    maxHeight = this.options.maxHeight,\r\n		    scrolledClass = 'leaflet-popup-scrolled';\r\n\r\n		if (maxHeight && height > maxHeight) {\r\n			style.height = maxHeight + 'px';\r\n			L.DomUtil.addClass(container, scrolledClass);\r\n		} else {\r\n			L.DomUtil.removeClass(container, scrolledClass);\r\n		}\r\n\r\n		this._containerWidth = this._container.offsetWidth;\r\n	},\r\n\r\n	_updatePosition: function () {\r\n		if (!this._map) { return; }\r\n\r\n		var pos = this._map.latLngToLayerPoint(this._latlng),\r\n		    animated = this._animated,\r\n		    offset = L.point(this.options.offset);\r\n\r\n		if (animated) {\r\n			L.DomUtil.setPosition(this._container, pos);\r\n		}\r\n\r\n		this._containerBottom = -offset.y - (animated ? 0 : pos.y);\r\n		this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);\r\n\r\n		// bottom position the popup in case the height of the popup changes (images loading etc)\r\n		this._container.style.bottom = this._containerBottom + 'px';\r\n		this._container.style.left = this._containerLeft + 'px';\r\n	},\r\n\r\n	_zoomAnimation: function (opt) {\r\n		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);\r\n\r\n		L.DomUtil.setPosition(this._container, pos);\r\n	},\r\n\r\n	_adjustPan: function () {\r\n		if (!this.options.autoPan) { return; }\r\n\r\n		var map = this._map,\r\n		    containerHeight = this._container.offsetHeight,\r\n		    containerWidth = this._containerWidth,\r\n\r\n		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\r\n		if (this._animated) {\r\n			layerPos._add(L.DomUtil.getPosition(this._container));\r\n		}\r\n\r\n		var containerPos = map.layerPointToContainerPoint(layerPos),\r\n		    padding = L.point(this.options.autoPanPadding),\r\n		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\r\n		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\r\n		    size = map.getSize(),\r\n		    dx = 0,\r\n		    dy = 0;\r\n\r\n		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n			dx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n		}\r\n		if (containerPos.x - dx - paddingTL.x < 0) { // left\r\n			dx = containerPos.x - paddingTL.x;\r\n		}\r\n		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n			dy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n		}\r\n		if (containerPos.y - dy - paddingTL.y < 0) { // top\r\n			dy = containerPos.y - paddingTL.y;\r\n		}\r\n\r\n		if (dx || dy) {\r\n			map\r\n			    .fire('autopanstart')\r\n			    .panBy([dx, dy]);\r\n		}\r\n	},\r\n\r\n	_onCloseButtonClick: function (e) {\r\n		this._close();\r\n		L.DomEvent.stop(e);\r\n	}\r\n});\r\n\r\nL.popup = function (options, source) {\r\n	return new L.Popup(options, source);\r\n};\r\n\r\n\r\nL.Map.include({\r\n	openPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])\r\n		this.closePopup();\r\n\r\n		if (!(popup instanceof L.Popup)) {\r\n			var content = popup;\r\n\r\n			popup = new L.Popup(options)\r\n			    .setLatLng(latlng)\r\n			    .setContent(content);\r\n		}\r\n		popup._isOpen = true;\r\n\r\n		this._popup = popup;\r\n		return this.addLayer(popup);\r\n	},\r\n\r\n	closePopup: function (popup) {\r\n		if (!popup || popup === this._popup) {\r\n			popup = this._popup;\r\n			this._popup = null;\r\n		}\r\n		if (popup) {\r\n			this.removeLayer(popup);\r\n			popup._isOpen = false;\r\n		}\r\n		return this;\r\n	}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Marker, adding popup-related methods.\r\n */\r\n\r\nL.Marker.include({\r\n	openPopup: function () {\r\n		if (this._popup && this._map && !this._map.hasLayer(this._popup)) {\r\n			this._popup.setLatLng(this._latlng);\r\n			this._map.openPopup(this._popup);\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	closePopup: function () {\r\n		if (this._popup) {\r\n			this._popup._close();\r\n		}\r\n		return this;\r\n	},\r\n\r\n	togglePopup: function () {\r\n		if (this._popup) {\r\n			if (this._popup._isOpen) {\r\n				this.closePopup();\r\n			} else {\r\n				this.openPopup();\r\n			}\r\n		}\r\n		return this;\r\n	},\r\n\r\n	bindPopup: function (content, options) {\r\n		var anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);\r\n\r\n		anchor = anchor.add(L.Popup.prototype.options.offset);\r\n\r\n		if (options && options.offset) {\r\n			anchor = anchor.add(options.offset);\r\n		}\r\n\r\n		options = L.extend({offset: anchor}, options);\r\n\r\n		if (!this._popupHandlersAdded) {\r\n			this\r\n			    .on('click', this.togglePopup, this)\r\n			    .on('remove', this.closePopup, this)\r\n			    .on('move', this._movePopup, this);\r\n			this._popupHandlersAdded = true;\r\n		}\r\n\r\n		if (content instanceof L.Popup) {\r\n			L.setOptions(content, options);\r\n			this._popup = content;\r\n		} else {\r\n			this._popup = new L.Popup(options, this)\r\n				.setContent(content);\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	setPopupContent: function (content) {\r\n		if (this._popup) {\r\n			this._popup.setContent(content);\r\n		}\r\n		return this;\r\n	},\r\n\r\n	unbindPopup: function () {\r\n		if (this._popup) {\r\n			this._popup = null;\r\n			this\r\n			    .off('click', this.togglePopup, this)\r\n			    .off('remove', this.closePopup, this)\r\n			    .off('move', this._movePopup, this);\r\n			this._popupHandlersAdded = false;\r\n		}\r\n		return this;\r\n	},\r\n\r\n	getPopup: function () {\r\n		return this._popup;\r\n	},\r\n\r\n	_movePopup: function (e) {\r\n		this._popup.setLatLng(e.latlng);\r\n	}\r\n});\r\n\n\n/*\r\n * L.LayerGroup is a class to combine several layers into one so that\r\n * you can manipulate the group (e.g. add/remove it) as one layer.\r\n */\r\n\r\nL.LayerGroup = L.Class.extend({\r\n	initialize: function (layers) {\r\n		this._layers = {};\r\n\r\n		var i, len;\r\n\r\n		if (layers) {\r\n			for (i = 0, len = layers.length; i < len; i++) {\r\n				this.addLayer(layers[i]);\r\n			}\r\n		}\r\n	},\r\n\r\n	addLayer: function (layer) {\r\n		var id = this.getLayerId(layer);\r\n\r\n		this._layers[id] = layer;\r\n\r\n		if (this._map) {\r\n			this._map.addLayer(layer);\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	removeLayer: function (layer) {\r\n		var id = layer in this._layers ? layer : this.getLayerId(layer);\r\n\r\n		if (this._map && this._layers[id]) {\r\n			this._map.removeLayer(this._layers[id]);\r\n		}\r\n\r\n		delete this._layers[id];\r\n\r\n		return this;\r\n	},\r\n\r\n	hasLayer: function (layer) {\r\n		if (!layer) { return false; }\r\n\r\n		return (layer in this._layers || this.getLayerId(layer) in this._layers);\r\n	},\r\n\r\n	clearLayers: function () {\r\n		this.eachLayer(this.removeLayer, this);\r\n		return this;\r\n	},\r\n\r\n	invoke: function (methodName) {\r\n		var args = Array.prototype.slice.call(arguments, 1),\r\n		    i, layer;\r\n\r\n		for (i in this._layers) {\r\n			layer = this._layers[i];\r\n\r\n			if (layer[methodName]) {\r\n				layer[methodName].apply(layer, args);\r\n			}\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	onAdd: function (map) {\r\n		this._map = map;\r\n		this.eachLayer(map.addLayer, map);\r\n	},\r\n\r\n	onRemove: function (map) {\r\n		this.eachLayer(map.removeLayer, map);\r\n		this._map = null;\r\n	},\r\n\r\n	addTo: function (map) {\r\n		map.addLayer(this);\r\n		return this;\r\n	},\r\n\r\n	eachLayer: function (method, context) {\r\n		for (var i in this._layers) {\r\n			method.call(context, this._layers[i]);\r\n		}\r\n		return this;\r\n	},\r\n\r\n	getLayer: function (id) {\r\n		return this._layers[id];\r\n	},\r\n\r\n	getLayers: function () {\r\n		var layers = [];\r\n\r\n		for (var i in this._layers) {\r\n			layers.push(this._layers[i]);\r\n		}\r\n		return layers;\r\n	},\r\n\r\n	setZIndex: function (zIndex) {\r\n		return this.invoke('setZIndex', zIndex);\r\n	},\r\n\r\n	getLayerId: function (layer) {\r\n		return L.stamp(layer);\r\n	}\r\n});\r\n\r\nL.layerGroup = function (layers) {\r\n	return new L.LayerGroup(layers);\r\n};\r\n\n\n/*\r\n * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods\r\n * shared between a group of interactive layers (like vectors or markers).\r\n */\r\n\r\nL.FeatureGroup = L.LayerGroup.extend({\r\n	includes: L.Mixin.Events,\r\n\r\n	statics: {\r\n		EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'\r\n	},\r\n\r\n	addLayer: function (layer) {\r\n		if (this.hasLayer(layer)) {\r\n			return this;\r\n		}\r\n\r\n		if ('on' in layer) {\r\n			layer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n		}\r\n\r\n		L.LayerGroup.prototype.addLayer.call(this, layer);\r\n\r\n		if (this._popupContent && layer.bindPopup) {\r\n			layer.bindPopup(this._popupContent, this._popupOptions);\r\n		}\r\n\r\n		return this.fire('layeradd', {layer: layer});\r\n	},\r\n\r\n	removeLayer: function (layer) {\r\n		if (!this.hasLayer(layer)) {\r\n			return this;\r\n		}\r\n		if (layer in this._layers) {\r\n			layer = this._layers[layer];\r\n		}\r\n\r\n		layer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\r\n		L.LayerGroup.prototype.removeLayer.call(this, layer);\r\n\r\n		if (this._popupContent) {\r\n			this.invoke('unbindPopup');\r\n		}\r\n\r\n		return this.fire('layerremove', {layer: layer});\r\n	},\r\n\r\n	bindPopup: function (content, options) {\r\n		this._popupContent = content;\r\n		this._popupOptions = options;\r\n		return this.invoke('bindPopup', content, options);\r\n	},\r\n\r\n	openPopup: function (latlng) {\r\n		// open popup on the first layer\r\n		for (var id in this._layers) {\r\n			this._layers[id].openPopup(latlng);\r\n			break;\r\n		}\r\n		return this;\r\n	},\r\n\r\n	setStyle: function (style) {\r\n		return this.invoke('setStyle', style);\r\n	},\r\n\r\n	bringToFront: function () {\r\n		return this.invoke('bringToFront');\r\n	},\r\n\r\n	bringToBack: function () {\r\n		return this.invoke('bringToBack');\r\n	},\r\n\r\n	getBounds: function () {\r\n		var bounds = new L.LatLngBounds();\r\n\r\n		this.eachLayer(function (layer) {\r\n			bounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());\r\n		});\r\n\r\n		return bounds;\r\n	},\r\n\r\n	_propagateEvent: function (e) {\r\n		e = L.extend({\r\n			layer: e.target,\r\n			target: this\r\n		}, e);\r\n		this.fire(e.type, e);\r\n	}\r\n});\r\n\r\nL.featureGroup = function (layers) {\r\n	return new L.FeatureGroup(layers);\r\n};\r\n\n\n/*\r\n * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.\r\n */\r\n\r\nL.Path = L.Class.extend({\r\n	includes: [L.Mixin.Events],\r\n\r\n	statics: {\r\n		// how much to extend the clip area around the map view\r\n		// (relative to its size, e.g. 0.5 is half the screen in each direction)\r\n		// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)\r\n		CLIP_PADDING: (function () {\r\n			var max = L.Browser.mobile ? 1280 : 2000,\r\n			    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;\r\n			return Math.max(0, Math.min(0.5, target));\r\n		})()\r\n	},\r\n\r\n	options: {\r\n		stroke: true,\r\n		color: '#0033ff',\r\n		dashArray: null,\r\n		lineCap: null,\r\n		lineJoin: null,\r\n		weight: 5,\r\n		opacity: 0.5,\r\n\r\n		fill: false,\r\n		fillColor: null, //same as color by default\r\n		fillOpacity: 0.2,\r\n\r\n		clickable: true\r\n	},\r\n\r\n	initialize: function (options) {\r\n		L.setOptions(this, options);\r\n	},\r\n\r\n	onAdd: function (map) {\r\n		this._map = map;\r\n\r\n		if (!this._container) {\r\n			this._initElements();\r\n			this._initEvents();\r\n		}\r\n\r\n		this.projectLatlngs();\r\n		this._updatePath();\r\n\r\n		if (this._container) {\r\n			this._map._pathRoot.appendChild(this._container);\r\n		}\r\n\r\n		this.fire('add');\r\n\r\n		map.on({\r\n			'viewreset': this.projectLatlngs,\r\n			'moveend': this._updatePath\r\n		}, this);\r\n	},\r\n\r\n	addTo: function (map) {\r\n		map.addLayer(this);\r\n		return this;\r\n	},\r\n\r\n	onRemove: function (map) {\r\n		map._pathRoot.removeChild(this._container);\r\n\r\n		// Need to fire remove event before we set _map to null as the event hooks might need the object\r\n		this.fire('remove');\r\n		this._map = null;\r\n\r\n		if (L.Browser.vml) {\r\n			this._container = null;\r\n			this._stroke = null;\r\n			this._fill = null;\r\n		}\r\n\r\n		map.off({\r\n			'viewreset': this.projectLatlngs,\r\n			'moveend': this._updatePath\r\n		}, this);\r\n	},\r\n\r\n	projectLatlngs: function () {\r\n		// do all projection stuff here\r\n	},\r\n\r\n	setStyle: function (style) {\r\n		L.setOptions(this, style);\r\n\r\n		if (this._container) {\r\n			this._updateStyle();\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	redraw: function () {\r\n		if (this._map) {\r\n			this.projectLatlngs();\r\n			this._updatePath();\r\n		}\r\n		return this;\r\n	}\r\n});\r\n\r\nL.Map.include({\r\n	_updatePathViewport: function () {\r\n		var p = L.Path.CLIP_PADDING,\r\n		    size = this.getSize(),\r\n		    panePos = L.DomUtil.getPosition(this._mapPane),\r\n		    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),\r\n		    max = min.add(size.multiplyBy(1 + p * 2)._round());\r\n\r\n		this._pathViewport = new L.Bounds(min, max);\r\n	}\r\n});\r\n\n\n/*\r\n * Extends L.Path with SVG-specific rendering code.\r\n */\r\n\r\nL.Path.SVG_NS = 'http://www.w3.org/2000/svg';\r\n\r\nL.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);\r\n\r\nL.Path = L.Path.extend({\r\n	statics: {\r\n		SVG: L.Browser.svg\r\n	},\r\n\r\n	bringToFront: function () {\r\n		var root = this._map._pathRoot,\r\n		    path = this._container;\r\n\r\n		if (path && root.lastChild !== path) {\r\n			root.appendChild(path);\r\n		}\r\n		return this;\r\n	},\r\n\r\n	bringToBack: function () {\r\n		var root = this._map._pathRoot,\r\n		    path = this._container,\r\n		    first = root.firstChild;\r\n\r\n		if (path && first !== path) {\r\n			root.insertBefore(path, first);\r\n		}\r\n		return this;\r\n	},\r\n\r\n	getPathString: function () {\r\n		// form path string here\r\n	},\r\n\r\n	_createElement: function (name) {\r\n		return document.createElementNS(L.Path.SVG_NS, name);\r\n	},\r\n\r\n	_initElements: function () {\r\n		this._map._initPathRoot();\r\n		this._initPath();\r\n		this._initStyle();\r\n	},\r\n\r\n	_initPath: function () {\r\n		this._container = this._createElement('g');\r\n\r\n		this._path = this._createElement('path');\r\n\r\n		if (this.options.className) {\r\n			L.DomUtil.addClass(this._path, this.options.className);\r\n		}\r\n\r\n		this._container.appendChild(this._path);\r\n	},\r\n\r\n	_initStyle: function () {\r\n		if (this.options.stroke) {\r\n			this._path.setAttribute('stroke-linejoin', 'round');\r\n			this._path.setAttribute('stroke-linecap', 'round');\r\n		}\r\n		if (this.options.fill) {\r\n			this._path.setAttribute('fill-rule', 'evenodd');\r\n		}\r\n		if (this.options.pointerEvents) {\r\n			this._path.setAttribute('pointer-events', this.options.pointerEvents);\r\n		}\r\n		if (!this.options.clickable && !this.options.pointerEvents) {\r\n			this._path.setAttribute('pointer-events', 'none');\r\n		}\r\n		this._updateStyle();\r\n	},\r\n\r\n	_updateStyle: function () {\r\n		if (this.options.stroke) {\r\n			this._path.setAttribute('stroke', this.options.color);\r\n			this._path.setAttribute('stroke-opacity', this.options.opacity);\r\n			this._path.setAttribute('stroke-width', this.options.weight);\r\n			if (this.options.dashArray) {\r\n				this._path.setAttribute('stroke-dasharray', this.options.dashArray);\r\n			} else {\r\n				this._path.removeAttribute('stroke-dasharray');\r\n			}\r\n			if (this.options.lineCap) {\r\n				this._path.setAttribute('stroke-linecap', this.options.lineCap);\r\n			}\r\n			if (this.options.lineJoin) {\r\n				this._path.setAttribute('stroke-linejoin', this.options.lineJoin);\r\n			}\r\n		} else {\r\n			this._path.setAttribute('stroke', 'none');\r\n		}\r\n		if (this.options.fill) {\r\n			this._path.setAttribute('fill', this.options.fillColor || this.options.color);\r\n			this._path.setAttribute('fill-opacity', this.options.fillOpacity);\r\n		} else {\r\n			this._path.setAttribute('fill', 'none');\r\n		}\r\n	},\r\n\r\n	_updatePath: function () {\r\n		var str = this.getPathString();\r\n		if (!str) {\r\n			// fix webkit empty string parsing bug\r\n			str = 'M0 0';\r\n		}\r\n		this._path.setAttribute('d', str);\r\n	},\r\n\r\n	// TODO remove duplication with L.Map\r\n	_initEvents: function () {\r\n		if (this.options.clickable) {\r\n			if (L.Browser.svg || !L.Browser.vml) {\r\n				L.DomUtil.addClass(this._path, 'leaflet-clickable');\r\n			}\r\n\r\n			L.DomEvent.on(this._container, 'click', this._onMouseClick, this);\r\n\r\n			var events = ['dblclick', 'mousedown', 'mouseover',\r\n			              'mouseout', 'mousemove', 'contextmenu'];\r\n			for (var i = 0; i < events.length; i++) {\r\n				L.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);\r\n			}\r\n		}\r\n	},\r\n\r\n	_onMouseClick: function (e) {\r\n		if (this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n		this._fireMouseEvent(e);\r\n	},\r\n\r\n	_fireMouseEvent: function (e) {\r\n		if (!this.hasEventListeners(e.type)) { return; }\r\n\r\n		var map = this._map,\r\n		    containerPoint = map.mouseEventToContainerPoint(e),\r\n		    layerPoint = map.containerPointToLayerPoint(containerPoint),\r\n		    latlng = map.layerPointToLatLng(layerPoint);\r\n\r\n		this.fire(e.type, {\r\n			latlng: latlng,\r\n			layerPoint: layerPoint,\r\n			containerPoint: containerPoint,\r\n			originalEvent: e\r\n		});\r\n\r\n		if (e.type === 'contextmenu') {\r\n			L.DomEvent.preventDefault(e);\r\n		}\r\n		if (e.type !== 'mousemove') {\r\n			L.DomEvent.stopPropagation(e);\r\n		}\r\n	}\r\n});\r\n\r\nL.Map.include({\r\n	_initPathRoot: function () {\r\n		if (!this._pathRoot) {\r\n			this._pathRoot = L.Path.prototype._createElement('svg');\r\n			this._panes.overlayPane.appendChild(this._pathRoot);\r\n\r\n			if (this.options.zoomAnimation && L.Browser.any3d) {\r\n				L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');\r\n\r\n				this.on({\r\n					'zoomanim': this._animatePathZoom,\r\n					'zoomend': this._endPathZoom\r\n				});\r\n			} else {\r\n				L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');\r\n			}\r\n\r\n			this.on('moveend', this._updateSvgViewport);\r\n			this._updateSvgViewport();\r\n		}\r\n	},\r\n\r\n	_animatePathZoom: function (e) {\r\n		var scale = this.getZoomScale(e.zoom),\r\n		    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);\r\n\r\n		this._pathRoot.style[L.DomUtil.TRANSFORM] =\r\n		        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';\r\n\r\n		this._pathZooming = true;\r\n	},\r\n\r\n	_endPathZoom: function () {\r\n		this._pathZooming = false;\r\n	},\r\n\r\n	_updateSvgViewport: function () {\r\n\r\n		if (this._pathZooming) {\r\n			// Do not update SVGs while a zoom animation is going on otherwise the animation will break.\r\n			// When the zoom animation ends we will be updated again anyway\r\n			// This fixes the case where you do a momentum move and zoom while the move is still ongoing.\r\n			return;\r\n		}\r\n\r\n		this._updatePathViewport();\r\n\r\n		var vp = this._pathViewport,\r\n		    min = vp.min,\r\n		    max = vp.max,\r\n		    width = max.x - min.x,\r\n		    height = max.y - min.y,\r\n		    root = this._pathRoot,\r\n		    pane = this._panes.overlayPane;\r\n\r\n		// Hack to make flicker on drag end on mobile webkit less irritating\r\n		if (L.Browser.mobileWebkit) {\r\n			pane.removeChild(root);\r\n		}\r\n\r\n		L.DomUtil.setPosition(root, min);\r\n		root.setAttribute('width', width);\r\n		root.setAttribute('height', height);\r\n		root.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));\r\n\r\n		if (L.Browser.mobileWebkit) {\r\n			pane.appendChild(root);\r\n		}\r\n	}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.\r\n */\r\n\r\nL.Path.include({\r\n\r\n	bindPopup: function (content, options) {\r\n\r\n		if (content instanceof L.Popup) {\r\n			this._popup = content;\r\n		} else {\r\n			if (!this._popup || options) {\r\n				this._popup = new L.Popup(options, this);\r\n			}\r\n			this._popup.setContent(content);\r\n		}\r\n\r\n		if (!this._popupHandlersAdded) {\r\n			this\r\n			    .on('click', this._openPopup, this)\r\n			    .on('remove', this.closePopup, this);\r\n\r\n			this._popupHandlersAdded = true;\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	unbindPopup: function () {\r\n		if (this._popup) {\r\n			this._popup = null;\r\n			this\r\n			    .off('click', this._openPopup)\r\n			    .off('remove', this.closePopup);\r\n\r\n			this._popupHandlersAdded = false;\r\n		}\r\n		return this;\r\n	},\r\n\r\n	openPopup: function (latlng) {\r\n\r\n		if (this._popup) {\r\n			// open the popup from one of the path's points if not specified\r\n			latlng = latlng || this._latlng ||\r\n			         this._latlngs[Math.floor(this._latlngs.length / 2)];\r\n\r\n			this._openPopup({latlng: latlng});\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	closePopup: function () {\r\n		if (this._popup) {\r\n			this._popup._close();\r\n		}\r\n		return this;\r\n	},\r\n\r\n	_openPopup: function (e) {\r\n		this._popup.setLatLng(e.latlng);\r\n		this._map.openPopup(this._popup);\r\n	}\r\n});\r\n\n\n/*\r\n * Vector rendering for IE6-8 through VML.\r\n * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\r\n */\r\n\r\nL.Browser.vml = !L.Browser.svg && (function () {\r\n	try {\r\n		var div = document.createElement('div');\r\n		div.innerHTML = '<v:shape adj=\"1\"/>';\r\n\r\n		var shape = div.firstChild;\r\n		shape.style.behavior = 'url(#default#VML)';\r\n\r\n		return shape && (typeof shape.adj === 'object');\r\n\r\n	} catch (e) {\r\n		return false;\r\n	}\r\n}());\r\n\r\nL.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({\r\n	statics: {\r\n		VML: true,\r\n		CLIP_PADDING: 0.02\r\n	},\r\n\r\n	_createElement: (function () {\r\n		try {\r\n			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\r\n			return function (name) {\r\n				return document.createElement('<lvml:' + name + ' class=\"lvml\">');\r\n			};\r\n		} catch (e) {\r\n			return function (name) {\r\n				return document.createElement(\r\n				        '<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\r\n			};\r\n		}\r\n	}()),\r\n\r\n	_initPath: function () {\r\n		var container = this._container = this._createElement('shape');\r\n\r\n		L.DomUtil.addClass(container, 'leaflet-vml-shape' +\r\n			(this.options.className ? ' ' + this.options.className : ''));\r\n\r\n		if (this.options.clickable) {\r\n			L.DomUtil.addClass(container, 'leaflet-clickable');\r\n		}\r\n\r\n		container.coordsize = '1 1';\r\n\r\n		this._path = this._createElement('path');\r\n		container.appendChild(this._path);\r\n\r\n		this._map._pathRoot.appendChild(container);\r\n	},\r\n\r\n	_initStyle: function () {\r\n		this._updateStyle();\r\n	},\r\n\r\n	_updateStyle: function () {\r\n		var stroke = this._stroke,\r\n		    fill = this._fill,\r\n		    options = this.options,\r\n		    container = this._container;\r\n\r\n		container.stroked = options.stroke;\r\n		container.filled = options.fill;\r\n\r\n		if (options.stroke) {\r\n			if (!stroke) {\r\n				stroke = this._stroke = this._createElement('stroke');\r\n				stroke.endcap = 'round';\r\n				container.appendChild(stroke);\r\n			}\r\n			stroke.weight = options.weight + 'px';\r\n			stroke.color = options.color;\r\n			stroke.opacity = options.opacity;\r\n\r\n			if (options.dashArray) {\r\n				stroke.dashStyle = L.Util.isArray(options.dashArray) ?\r\n				    options.dashArray.join(' ') :\r\n				    options.dashArray.replace(/( *, *)/g, ' ');\r\n			} else {\r\n				stroke.dashStyle = '';\r\n			}\r\n			if (options.lineCap) {\r\n				stroke.endcap = options.lineCap.replace('butt', 'flat');\r\n			}\r\n			if (options.lineJoin) {\r\n				stroke.joinstyle = options.lineJoin;\r\n			}\r\n\r\n		} else if (stroke) {\r\n			container.removeChild(stroke);\r\n			this._stroke = null;\r\n		}\r\n\r\n		if (options.fill) {\r\n			if (!fill) {\r\n				fill = this._fill = this._createElement('fill');\r\n				container.appendChild(fill);\r\n			}\r\n			fill.color = options.fillColor || options.color;\r\n			fill.opacity = options.fillOpacity;\r\n\r\n		} else if (fill) {\r\n			container.removeChild(fill);\r\n			this._fill = null;\r\n		}\r\n	},\r\n\r\n	_updatePath: function () {\r\n		var style = this._container.style;\r\n\r\n		style.display = 'none';\r\n		this._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug\r\n		style.display = '';\r\n	}\r\n});\r\n\r\nL.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {\r\n	_initPathRoot: function () {\r\n		if (this._pathRoot) { return; }\r\n\r\n		var root = this._pathRoot = document.createElement('div');\r\n		root.className = 'leaflet-vml-container';\r\n		this._panes.overlayPane.appendChild(root);\r\n\r\n		this.on('moveend', this._updatePathViewport);\r\n		this._updatePathViewport();\r\n	}\r\n});\r\n\n\n/*\r\n * Vector rendering for all browsers that support canvas.\r\n */\r\n\r\nL.Browser.canvas = (function () {\r\n	return !!document.createElement('canvas').getContext;\r\n}());\r\n\r\nL.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({\r\n	statics: {\r\n		//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value\r\n		CANVAS: true,\r\n		SVG: false\r\n	},\r\n\r\n	redraw: function () {\r\n		if (this._map) {\r\n			this.projectLatlngs();\r\n			this._requestUpdate();\r\n		}\r\n		return this;\r\n	},\r\n\r\n	setStyle: function (style) {\r\n		L.setOptions(this, style);\r\n\r\n		if (this._map) {\r\n			this._updateStyle();\r\n			this._requestUpdate();\r\n		}\r\n		return this;\r\n	},\r\n\r\n	onRemove: function (map) {\r\n		map\r\n		    .off('viewreset', this.projectLatlngs, this)\r\n		    .off('moveend', this._updatePath, this);\r\n\r\n		if (this.options.clickable) {\r\n			this._map.off('click', this._onClick, this);\r\n			this._map.off('mousemove', this._onMouseMove, this);\r\n		}\r\n\r\n		this._requestUpdate();\r\n		\r\n		this.fire('remove');\r\n		this._map = null;\r\n	},\r\n\r\n	_requestUpdate: function () {\r\n		if (this._map && !L.Path._updateRequest) {\r\n			L.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);\r\n		}\r\n	},\r\n\r\n	_fireMapMoveEnd: function () {\r\n		L.Path._updateRequest = null;\r\n		this.fire('moveend');\r\n	},\r\n\r\n	_initElements: function () {\r\n		this._map._initPathRoot();\r\n		this._ctx = this._map._canvasCtx;\r\n	},\r\n\r\n	_updateStyle: function () {\r\n		var options = this.options;\r\n\r\n		if (options.stroke) {\r\n			this._ctx.lineWidth = options.weight;\r\n			this._ctx.strokeStyle = options.color;\r\n		}\r\n		if (options.fill) {\r\n			this._ctx.fillStyle = options.fillColor || options.color;\r\n		}\r\n	},\r\n\r\n	_drawPath: function () {\r\n		var i, j, len, len2, point, drawMethod;\r\n\r\n		this._ctx.beginPath();\r\n\r\n		for (i = 0, len = this._parts.length; i < len; i++) {\r\n			for (j = 0, len2 = this._parts[i].length; j < len2; j++) {\r\n				point = this._parts[i][j];\r\n				drawMethod = (j === 0 ? 'move' : 'line') + 'To';\r\n\r\n				this._ctx[drawMethod](point.x, point.y);\r\n			}\r\n			// TODO refactor ugly hack\r\n			if (this instanceof L.Polygon) {\r\n				this._ctx.closePath();\r\n			}\r\n		}\r\n	},\r\n\r\n	_checkIfEmpty: function () {\r\n		return !this._parts.length;\r\n	},\r\n\r\n	_updatePath: function () {\r\n		if (this._checkIfEmpty()) { return; }\r\n\r\n		var ctx = this._ctx,\r\n		    options = this.options;\r\n\r\n		this._drawPath();\r\n		ctx.save();\r\n		this._updateStyle();\r\n\r\n		if (options.fill) {\r\n			ctx.globalAlpha = options.fillOpacity;\r\n			ctx.fill();\r\n		}\r\n\r\n		if (options.stroke) {\r\n			ctx.globalAlpha = options.opacity;\r\n			ctx.stroke();\r\n		}\r\n\r\n		ctx.restore();\r\n\r\n		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\r\n	},\r\n\r\n	_initEvents: function () {\r\n		if (this.options.clickable) {\r\n			// TODO dblclick\r\n			this._map.on('mousemove', this._onMouseMove, this);\r\n			this._map.on('click', this._onClick, this);\r\n		}\r\n	},\r\n\r\n	_onClick: function (e) {\r\n		if (this._containsPoint(e.layerPoint)) {\r\n			this.fire('click', e);\r\n		}\r\n	},\r\n\r\n	_onMouseMove: function (e) {\r\n		if (!this._map || this._map._animatingZoom) { return; }\r\n\r\n		// TODO don't do on each move\r\n		if (this._containsPoint(e.layerPoint)) {\r\n			this._ctx.canvas.style.cursor = 'pointer';\r\n			this._mouseInside = true;\r\n			this.fire('mouseover', e);\r\n\r\n		} else if (this._mouseInside) {\r\n			this._ctx.canvas.style.cursor = '';\r\n			this._mouseInside = false;\r\n			this.fire('mouseout', e);\r\n		}\r\n	}\r\n});\r\n\r\nL.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {\r\n	_initPathRoot: function () {\r\n		var root = this._pathRoot,\r\n		    ctx;\r\n\r\n		if (!root) {\r\n			root = this._pathRoot = document.createElement('canvas');\r\n			root.style.position = 'absolute';\r\n			ctx = this._canvasCtx = root.getContext('2d');\r\n\r\n			ctx.lineCap = 'round';\r\n			ctx.lineJoin = 'round';\r\n\r\n			this._panes.overlayPane.appendChild(root);\r\n\r\n			if (this.options.zoomAnimation) {\r\n				this._pathRoot.className = 'leaflet-zoom-animated';\r\n				this.on('zoomanim', this._animatePathZoom);\r\n				this.on('zoomend', this._endPathZoom);\r\n			}\r\n			this.on('moveend', this._updateCanvasViewport);\r\n			this._updateCanvasViewport();\r\n		}\r\n	},\r\n\r\n	_updateCanvasViewport: function () {\r\n		// don't redraw while zooming. See _updateSvgViewport for more details\r\n		if (this._pathZooming) { return; }\r\n		this._updatePathViewport();\r\n\r\n		var vp = this._pathViewport,\r\n		    min = vp.min,\r\n		    size = vp.max.subtract(min),\r\n		    root = this._pathRoot;\r\n\r\n		//TODO check if this works properly on mobile webkit\r\n		L.DomUtil.setPosition(root, min);\r\n		root.width = size.x;\r\n		root.height = size.y;\r\n		root.getContext('2d').translate(-min.x, -min.y);\r\n	}\r\n});\r\n\n\n/*\r\n * L.LineUtil contains different utility functions for line segments\r\n * and polylines (clipping, simplification, distances, etc.)\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations for this file\r\n\r\nL.LineUtil = {\r\n\r\n	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n	// Improves rendering performance dramatically by lessening the number of points to draw.\r\n\r\n	simplify: function (/*Point[]*/ points, /*Number*/ tolerance) {\r\n		if (!tolerance || !points.length) {\r\n			return points.slice();\r\n		}\r\n\r\n		var sqTolerance = tolerance * tolerance;\r\n\r\n		// stage 1: vertex reduction\r\n		points = this._reducePoints(points, sqTolerance);\r\n\r\n		// stage 2: Douglas-Peucker simplification\r\n		points = this._simplifyDP(points, sqTolerance);\r\n\r\n		return points;\r\n	},\r\n\r\n	// distance from a point to a segment between two points\r\n	pointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));\r\n	},\r\n\r\n	closestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n		return this._sqClosestPointOnSegment(p, p1, p2);\r\n	},\r\n\r\n	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\r\n	_simplifyDP: function (points, sqTolerance) {\r\n\r\n		var len = points.length,\r\n		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\r\n		    markers = new ArrayConstructor(len);\r\n\r\n		markers[0] = markers[len - 1] = 1;\r\n\r\n		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n\r\n		var i,\r\n		    newPoints = [];\r\n\r\n		for (i = 0; i < len; i++) {\r\n			if (markers[i]) {\r\n				newPoints.push(points[i]);\r\n			}\r\n		}\r\n\r\n		return newPoints;\r\n	},\r\n\r\n	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {\r\n\r\n		var maxSqDist = 0,\r\n		    index, i, sqDist;\r\n\r\n		for (i = first + 1; i <= last - 1; i++) {\r\n			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n\r\n			if (sqDist > maxSqDist) {\r\n				index = i;\r\n				maxSqDist = sqDist;\r\n			}\r\n		}\r\n\r\n		if (maxSqDist > sqTolerance) {\r\n			markers[index] = 1;\r\n\r\n			this._simplifyDPStep(points, markers, sqTolerance, first, index);\r\n			this._simplifyDPStep(points, markers, sqTolerance, index, last);\r\n		}\r\n	},\r\n\r\n	// reduce points that are too close to each other to a single point\r\n	_reducePoints: function (points, sqTolerance) {\r\n		var reducedPoints = [points[0]];\r\n\r\n		for (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n			if (this._sqDist(points[i], points[prev]) > sqTolerance) {\r\n				reducedPoints.push(points[i]);\r\n				prev = i;\r\n			}\r\n		}\r\n		if (prev < len - 1) {\r\n			reducedPoints.push(points[len - 1]);\r\n		}\r\n		return reducedPoints;\r\n	},\r\n\r\n	// Cohen-Sutherland line clipping algorithm.\r\n	// Used to avoid rendering parts of a polyline that are not currently visible.\r\n\r\n	clipSegment: function (a, b, bounds, useLastCode) {\r\n		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),\r\n		    codeB = this._getBitCode(b, bounds),\r\n\r\n		    codeOut, p, newCode;\r\n\r\n		// save 2nd code to avoid calculating it on the next segment\r\n		this._lastCode = codeB;\r\n\r\n		while (true) {\r\n			// if a,b is inside the clip window (trivial accept)\r\n			if (!(codeA | codeB)) {\r\n				return [a, b];\r\n			// if a,b is outside the clip window (trivial reject)\r\n			} else if (codeA & codeB) {\r\n				return false;\r\n			// other cases\r\n			} else {\r\n				codeOut = codeA || codeB;\r\n				p = this._getEdgeIntersection(a, b, codeOut, bounds);\r\n				newCode = this._getBitCode(p, bounds);\r\n\r\n				if (codeOut === codeA) {\r\n					a = p;\r\n					codeA = newCode;\r\n				} else {\r\n					b = p;\r\n					codeB = newCode;\r\n				}\r\n			}\r\n		}\r\n	},\r\n\r\n	_getEdgeIntersection: function (a, b, code, bounds) {\r\n		var dx = b.x - a.x,\r\n		    dy = b.y - a.y,\r\n		    min = bounds.min,\r\n		    max = bounds.max;\r\n\r\n		if (code & 8) { // top\r\n			return new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);\r\n		} else if (code & 4) { // bottom\r\n			return new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);\r\n		} else if (code & 2) { // right\r\n			return new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);\r\n		} else if (code & 1) { // left\r\n			return new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);\r\n		}\r\n	},\r\n\r\n	_getBitCode: function (/*Point*/ p, bounds) {\r\n		var code = 0;\r\n\r\n		if (p.x < bounds.min.x) { // left\r\n			code |= 1;\r\n		} else if (p.x > bounds.max.x) { // right\r\n			code |= 2;\r\n		}\r\n		if (p.y < bounds.min.y) { // bottom\r\n			code |= 4;\r\n		} else if (p.y > bounds.max.y) { // top\r\n			code |= 8;\r\n		}\r\n\r\n		return code;\r\n	},\r\n\r\n	// square distance (to avoid unnecessary Math.sqrt calls)\r\n	_sqDist: function (p1, p2) {\r\n		var dx = p2.x - p1.x,\r\n		    dy = p2.y - p1.y;\r\n		return dx * dx + dy * dy;\r\n	},\r\n\r\n	// return closest point on segment or distance to that point\r\n	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {\r\n		var x = p1.x,\r\n		    y = p1.y,\r\n		    dx = p2.x - x,\r\n		    dy = p2.y - y,\r\n		    dot = dx * dx + dy * dy,\r\n		    t;\r\n\r\n		if (dot > 0) {\r\n			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n\r\n			if (t > 1) {\r\n				x = p2.x;\r\n				y = p2.y;\r\n			} else if (t > 0) {\r\n				x += dx * t;\r\n				y += dy * t;\r\n			}\r\n		}\r\n\r\n		dx = p.x - x;\r\n		dy = p.y - y;\r\n\r\n		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);\r\n	}\r\n};\r\n\n\n/*\r\n * L.Polyline is used to display polylines on a map.\r\n */\r\n\r\nL.Polyline = L.Path.extend({\r\n	initialize: function (latlngs, options) {\r\n		L.Path.prototype.initialize.call(this, options);\r\n\r\n		this._latlngs = this._convertLatLngs(latlngs);\r\n	},\r\n\r\n	options: {\r\n		// how much to simplify the polyline on each zoom level\r\n		// more = better performance and smoother look, less = more accurate\r\n		smoothFactor: 1.0,\r\n		noClip: false\r\n	},\r\n\r\n	projectLatlngs: function () {\r\n		this._originalPoints = [];\r\n\r\n		for (var i = 0, len = this._latlngs.length; i < len; i++) {\r\n			this._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);\r\n		}\r\n	},\r\n\r\n	getPathString: function () {\r\n		for (var i = 0, len = this._parts.length, str = ''; i < len; i++) {\r\n			str += this._getPathPartStr(this._parts[i]);\r\n		}\r\n		return str;\r\n	},\r\n\r\n	getLatLngs: function () {\r\n		return this._latlngs;\r\n	},\r\n\r\n	setLatLngs: function (latlngs) {\r\n		this._latlngs = this._convertLatLngs(latlngs);\r\n		return this.redraw();\r\n	},\r\n\r\n	addLatLng: function (latlng) {\r\n		this._latlngs.push(L.latLng(latlng));\r\n		return this.redraw();\r\n	},\r\n\r\n	spliceLatLngs: function () { // (Number index, Number howMany)\r\n		var removed = [].splice.apply(this._latlngs, arguments);\r\n		this._convertLatLngs(this._latlngs, true);\r\n		this.redraw();\r\n		return removed;\r\n	},\r\n\r\n	closestLayerPoint: function (p) {\r\n		var minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;\r\n\r\n		for (var j = 0, jLen = parts.length; j < jLen; j++) {\r\n			var points = parts[j];\r\n			for (var i = 1, len = points.length; i < len; i++) {\r\n				p1 = points[i - 1];\r\n				p2 = points[i];\r\n				var sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);\r\n				if (sqDist < minDistance) {\r\n					minDistance = sqDist;\r\n					minPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);\r\n				}\r\n			}\r\n		}\r\n		if (minPoint) {\r\n			minPoint.distance = Math.sqrt(minDistance);\r\n		}\r\n		return minPoint;\r\n	},\r\n\r\n	getBounds: function () {\r\n		return new L.LatLngBounds(this.getLatLngs());\r\n	},\r\n\r\n	_convertLatLngs: function (latlngs, overwrite) {\r\n		var i, len, target = overwrite ? latlngs : [];\r\n\r\n		for (i = 0, len = latlngs.length; i < len; i++) {\r\n			if (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {\r\n				return;\r\n			}\r\n			target[i] = L.latLng(latlngs[i]);\r\n		}\r\n		return target;\r\n	},\r\n\r\n	_initEvents: function () {\r\n		L.Path.prototype._initEvents.call(this);\r\n	},\r\n\r\n	_getPathPartStr: function (points) {\r\n		var round = L.Path.VML;\r\n\r\n		for (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {\r\n			p = points[j];\r\n			if (round) {\r\n				p._round();\r\n			}\r\n			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;\r\n		}\r\n		return str;\r\n	},\r\n\r\n	_clipPoints: function () {\r\n		var points = this._originalPoints,\r\n		    len = points.length,\r\n		    i, k, segment;\r\n\r\n		if (this.options.noClip) {\r\n			this._parts = [points];\r\n			return;\r\n		}\r\n\r\n		this._parts = [];\r\n\r\n		var parts = this._parts,\r\n		    vp = this._map._pathViewport,\r\n		    lu = L.LineUtil;\r\n\r\n		for (i = 0, k = 0; i < len - 1; i++) {\r\n			segment = lu.clipSegment(points[i], points[i + 1], vp, i);\r\n			if (!segment) {\r\n				continue;\r\n			}\r\n\r\n			parts[k] = parts[k] || [];\r\n			parts[k].push(segment[0]);\r\n\r\n			// if segment goes out of screen, or it's the last one, it's the end of the line part\r\n			if ((segment[1] !== points[i + 1]) || (i === len - 2)) {\r\n				parts[k].push(segment[1]);\r\n				k++;\r\n			}\r\n		}\r\n	},\r\n\r\n	// simplify each clipped part of the polyline\r\n	_simplifyPoints: function () {\r\n		var parts = this._parts,\r\n		    lu = L.LineUtil;\r\n\r\n		for (var i = 0, len = parts.length; i < len; i++) {\r\n			parts[i] = lu.simplify(parts[i], this.options.smoothFactor);\r\n		}\r\n	},\r\n\r\n	_updatePath: function () {\r\n		if (!this._map) { return; }\r\n\r\n		this._clipPoints();\r\n		this._simplifyPoints();\r\n\r\n		L.Path.prototype._updatePath.call(this);\r\n	}\r\n});\r\n\r\nL.polyline = function (latlngs, options) {\r\n	return new L.Polyline(latlngs, options);\r\n};\r\n\n\n/*\r\n * L.PolyUtil contains utility functions for polygons (clipping, etc.).\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations here\r\n\r\nL.PolyUtil = {};\r\n\r\n/*\r\n * Sutherland-Hodgeman polygon clipping algorithm.\r\n * Used to avoid rendering parts of a polygon that are not currently visible.\r\n */\r\nL.PolyUtil.clipPolygon = function (points, bounds) {\r\n	var clippedPoints,\r\n	    edges = [1, 4, 2, 8],\r\n	    i, j, k,\r\n	    a, b,\r\n	    len, edge, p,\r\n	    lu = L.LineUtil;\r\n\r\n	for (i = 0, len = points.length; i < len; i++) {\r\n		points[i]._code = lu._getBitCode(points[i], bounds);\r\n	}\r\n\r\n	// for each edge (left, bottom, right, top)\r\n	for (k = 0; k < 4; k++) {\r\n		edge = edges[k];\r\n		clippedPoints = [];\r\n\r\n		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\r\n			a = points[i];\r\n			b = points[j];\r\n\r\n			// if a is inside the clip window\r\n			if (!(a._code & edge)) {\r\n				// if b is outside the clip window (a->b goes out of screen)\r\n				if (b._code & edge) {\r\n					p = lu._getEdgeIntersection(b, a, edge, bounds);\r\n					p._code = lu._getBitCode(p, bounds);\r\n					clippedPoints.push(p);\r\n				}\r\n				clippedPoints.push(a);\r\n\r\n			// else if b is inside the clip window (a->b enters the screen)\r\n			} else if (!(b._code & edge)) {\r\n				p = lu._getEdgeIntersection(b, a, edge, bounds);\r\n				p._code = lu._getBitCode(p, bounds);\r\n				clippedPoints.push(p);\r\n			}\r\n		}\r\n		points = clippedPoints;\r\n	}\r\n\r\n	return points;\r\n};\r\n\n\n/*\r\n * L.Polygon is used to display polygons on a map.\r\n */\r\n\r\nL.Polygon = L.Polyline.extend({\r\n	options: {\r\n		fill: true\r\n	},\r\n\r\n	initialize: function (latlngs, options) {\r\n		L.Polyline.prototype.initialize.call(this, latlngs, options);\r\n		this._initWithHoles(latlngs);\r\n	},\r\n\r\n	_initWithHoles: function (latlngs) {\r\n		var i, len, hole;\r\n		if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n			this._latlngs = this._convertLatLngs(latlngs[0]);\r\n			this._holes = latlngs.slice(1);\r\n\r\n			for (i = 0, len = this._holes.length; i < len; i++) {\r\n				hole = this._holes[i] = this._convertLatLngs(this._holes[i]);\r\n				if (hole[0].equals(hole[hole.length - 1])) {\r\n					hole.pop();\r\n				}\r\n			}\r\n		}\r\n\r\n		// filter out last point if its equal to the first one\r\n		latlngs = this._latlngs;\r\n\r\n		if (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {\r\n			latlngs.pop();\r\n		}\r\n	},\r\n\r\n	projectLatlngs: function () {\r\n		L.Polyline.prototype.projectLatlngs.call(this);\r\n\r\n		// project polygon holes points\r\n		// TODO move this logic to Polyline to get rid of duplication\r\n		this._holePoints = [];\r\n\r\n		if (!this._holes) { return; }\r\n\r\n		var i, j, len, len2;\r\n\r\n		for (i = 0, len = this._holes.length; i < len; i++) {\r\n			this._holePoints[i] = [];\r\n\r\n			for (j = 0, len2 = this._holes[i].length; j < len2; j++) {\r\n				this._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);\r\n			}\r\n		}\r\n	},\r\n\r\n	setLatLngs: function (latlngs) {\r\n		if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n			this._initWithHoles(latlngs);\r\n			return this.redraw();\r\n		} else {\r\n			return L.Polyline.prototype.setLatLngs.call(this, latlngs);\r\n		}\r\n	},\r\n\r\n	_clipPoints: function () {\r\n		var points = this._originalPoints,\r\n		    newParts = [];\r\n\r\n		this._parts = [points].concat(this._holePoints);\r\n\r\n		if (this.options.noClip) { return; }\r\n\r\n		for (var i = 0, len = this._parts.length; i < len; i++) {\r\n			var clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);\r\n			if (clipped.length) {\r\n				newParts.push(clipped);\r\n			}\r\n		}\r\n\r\n		this._parts = newParts;\r\n	},\r\n\r\n	_getPathPartStr: function (points) {\r\n		var str = L.Polyline.prototype._getPathPartStr.call(this, points);\r\n		return str + (L.Browser.svg ? 'z' : 'x');\r\n	}\r\n});\r\n\r\nL.polygon = function (latlngs, options) {\r\n	return new L.Polygon(latlngs, options);\r\n};\r\n\n\n/*\r\n * Contains L.MultiPolyline and L.MultiPolygon layers.\r\n */\r\n\r\n(function () {\r\n	function createMulti(Klass) {\r\n\r\n		return L.FeatureGroup.extend({\r\n\r\n			initialize: function (latlngs, options) {\r\n				this._layers = {};\r\n				this._options = options;\r\n				this.setLatLngs(latlngs);\r\n			},\r\n\r\n			setLatLngs: function (latlngs) {\r\n				var i = 0,\r\n				    len = latlngs.length;\r\n\r\n				this.eachLayer(function (layer) {\r\n					if (i < len) {\r\n						layer.setLatLngs(latlngs[i++]);\r\n					} else {\r\n						this.removeLayer(layer);\r\n					}\r\n				}, this);\r\n\r\n				while (i < len) {\r\n					this.addLayer(new Klass(latlngs[i++], this._options));\r\n				}\r\n\r\n				return this;\r\n			},\r\n\r\n			getLatLngs: function () {\r\n				var latlngs = [];\r\n\r\n				this.eachLayer(function (layer) {\r\n					latlngs.push(layer.getLatLngs());\r\n				});\r\n\r\n				return latlngs;\r\n			}\r\n		});\r\n	}\r\n\r\n	L.MultiPolyline = createMulti(L.Polyline);\r\n	L.MultiPolygon = createMulti(L.Polygon);\r\n\r\n	L.multiPolyline = function (latlngs, options) {\r\n		return new L.MultiPolyline(latlngs, options);\r\n	};\r\n\r\n	L.multiPolygon = function (latlngs, options) {\r\n		return new L.MultiPolygon(latlngs, options);\r\n	};\r\n}());\r\n\n\n/*\r\n * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\r\n */\r\n\r\nL.Rectangle = L.Polygon.extend({\r\n	initialize: function (latLngBounds, options) {\r\n		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\r\n	},\r\n\r\n	setBounds: function (latLngBounds) {\r\n		this.setLatLngs(this._boundsToLatLngs(latLngBounds));\r\n	},\r\n\r\n	_boundsToLatLngs: function (latLngBounds) {\r\n		latLngBounds = L.latLngBounds(latLngBounds);\r\n		return [\r\n			latLngBounds.getSouthWest(),\r\n			latLngBounds.getNorthWest(),\r\n			latLngBounds.getNorthEast(),\r\n			latLngBounds.getSouthEast()\r\n		];\r\n	}\r\n});\r\n\r\nL.rectangle = function (latLngBounds, options) {\r\n	return new L.Rectangle(latLngBounds, options);\r\n};\r\n\n\n/*\r\n * L.Circle is a circle overlay (with a certain radius in meters).\r\n */\r\n\r\nL.Circle = L.Path.extend({\r\n	initialize: function (latlng, radius, options) {\r\n		L.Path.prototype.initialize.call(this, options);\r\n\r\n		this._latlng = L.latLng(latlng);\r\n		this._mRadius = radius;\r\n	},\r\n\r\n	options: {\r\n		fill: true\r\n	},\r\n\r\n	setLatLng: function (latlng) {\r\n		this._latlng = L.latLng(latlng);\r\n		return this.redraw();\r\n	},\r\n\r\n	setRadius: function (radius) {\r\n		this._mRadius = radius;\r\n		return this.redraw();\r\n	},\r\n\r\n	projectLatlngs: function () {\r\n		var lngRadius = this._getLngRadius(),\r\n		    latlng = this._latlng,\r\n		    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);\r\n\r\n		this._point = this._map.latLngToLayerPoint(latlng);\r\n		this._radius = Math.max(this._point.x - pointLeft.x, 1);\r\n	},\r\n\r\n	getBounds: function () {\r\n		var lngRadius = this._getLngRadius(),\r\n		    latRadius = (this._mRadius / 40075017) * 360,\r\n		    latlng = this._latlng;\r\n\r\n		return new L.LatLngBounds(\r\n		        [latlng.lat - latRadius, latlng.lng - lngRadius],\r\n		        [latlng.lat + latRadius, latlng.lng + lngRadius]);\r\n	},\r\n\r\n	getLatLng: function () {\r\n		return this._latlng;\r\n	},\r\n\r\n	getPathString: function () {\r\n		var p = this._point,\r\n		    r = this._radius;\r\n\r\n		if (this._checkIfEmpty()) {\r\n			return '';\r\n		}\r\n\r\n		if (L.Browser.svg) {\r\n			return 'M' + p.x + ',' + (p.y - r) +\r\n			       'A' + r + ',' + r + ',0,1,1,' +\r\n			       (p.x - 0.1) + ',' + (p.y - r) + ' z';\r\n		} else {\r\n			p._round();\r\n			r = Math.round(r);\r\n			return 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);\r\n		}\r\n	},\r\n\r\n	getRadius: function () {\r\n		return this._mRadius;\r\n	},\r\n\r\n	// TODO Earth hardcoded, move into projection code!\r\n\r\n	_getLatRadius: function () {\r\n		return (this._mRadius / 40075017) * 360;\r\n	},\r\n\r\n	_getLngRadius: function () {\r\n		return this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);\r\n	},\r\n\r\n	_checkIfEmpty: function () {\r\n		if (!this._map) {\r\n			return false;\r\n		}\r\n		var vp = this._map._pathViewport,\r\n		    r = this._radius,\r\n		    p = this._point;\r\n\r\n		return p.x - r > vp.max.x || p.y - r > vp.max.y ||\r\n		       p.x + r < vp.min.x || p.y + r < vp.min.y;\r\n	}\r\n});\r\n\r\nL.circle = function (latlng, radius, options) {\r\n	return new L.Circle(latlng, radius, options);\r\n};\r\n\n\n/*\r\n * L.CircleMarker is a circle overlay with a permanent pixel radius.\r\n */\r\n\r\nL.CircleMarker = L.Circle.extend({\r\n	options: {\r\n		radius: 10,\r\n		weight: 2\r\n	},\r\n\r\n	initialize: function (latlng, options) {\r\n		L.Circle.prototype.initialize.call(this, latlng, null, options);\r\n		this._radius = this.options.radius;\r\n	},\r\n\r\n	projectLatlngs: function () {\r\n		this._point = this._map.latLngToLayerPoint(this._latlng);\r\n	},\r\n\r\n	_updateStyle : function () {\r\n		L.Circle.prototype._updateStyle.call(this);\r\n		this.setRadius(this.options.radius);\r\n	},\r\n\r\n	setLatLng: function (latlng) {\r\n		L.Circle.prototype.setLatLng.call(this, latlng);\r\n		if (this._popup && this._popup._isOpen) {\r\n			this._popup.setLatLng(latlng);\r\n		}\r\n		return this;\r\n	},\r\n\r\n	setRadius: function (radius) {\r\n		this.options.radius = this._radius = radius;\r\n		return this.redraw();\r\n	},\r\n\r\n	getRadius: function () {\r\n		return this._radius;\r\n	}\r\n});\r\n\r\nL.circleMarker = function (latlng, options) {\r\n	return new L.CircleMarker(latlng, options);\r\n};\r\n\n\n/*\r\n * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.\r\n */\r\n\r\nL.Polyline.include(!L.Path.CANVAS ? {} : {\r\n	_containsPoint: function (p, closed) {\r\n		var i, j, k, len, len2, dist, part,\r\n		    w = this.options.weight / 2;\r\n\r\n		if (L.Browser.touch) {\r\n			w += 10; // polyline click tolerance on touch devices\r\n		}\r\n\r\n		for (i = 0, len = this._parts.length; i < len; i++) {\r\n			part = this._parts[i];\r\n			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n				if (!closed && (j === 0)) {\r\n					continue;\r\n				}\r\n\r\n				dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);\r\n\r\n				if (dist <= w) {\r\n					return true;\r\n				}\r\n			}\r\n		}\r\n		return false;\r\n	}\r\n});\r\n\n\n/*\r\n * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.\r\n */\r\n\r\nL.Polygon.include(!L.Path.CANVAS ? {} : {\r\n	_containsPoint: function (p) {\r\n		var inside = false,\r\n		    part, p1, p2,\r\n		    i, j, k,\r\n		    len, len2;\r\n\r\n		// TODO optimization: check if within bounds first\r\n\r\n		if (L.Polyline.prototype._containsPoint.call(this, p, true)) {\r\n			// click on polygon border\r\n			return true;\r\n		}\r\n\r\n		// ray casting algorithm for detecting if point is in polygon\r\n\r\n		for (i = 0, len = this._parts.length; i < len; i++) {\r\n			part = this._parts[i];\r\n\r\n			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n				p1 = part[j];\r\n				p2 = part[k];\r\n\r\n				if (((p1.y > p.y) !== (p2.y > p.y)) &&\r\n						(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\r\n					inside = !inside;\r\n				}\r\n			}\r\n		}\r\n\r\n		return inside;\r\n	}\r\n});\r\n\n\n/*\r\n * Extends L.Circle with Canvas-specific code.\r\n */\r\n\r\nL.Circle.include(!L.Path.CANVAS ? {} : {\r\n	_drawPath: function () {\r\n		var p = this._point;\r\n		this._ctx.beginPath();\r\n		this._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);\r\n	},\r\n\r\n	_containsPoint: function (p) {\r\n		var center = this._point,\r\n		    w2 = this.options.stroke ? this.options.weight / 2 : 0;\r\n\r\n		return (p.distanceTo(center) <= this._radius + w2);\r\n	}\r\n});\r\n\n\n/*\n * CircleMarker canvas specific drawing parts.\n */\n\nL.CircleMarker.include(!L.Path.CANVAS ? {} : {\n	_updateStyle: function () {\n		L.Path.prototype._updateStyle.call(this);\n	}\n});\n\n\n/*\r\n * L.GeoJSON turns any GeoJSON data into a Leaflet layer.\r\n */\r\n\r\nL.GeoJSON = L.FeatureGroup.extend({\r\n\r\n	initialize: function (geojson, options) {\r\n		L.setOptions(this, options);\r\n\r\n		this._layers = {};\r\n\r\n		if (geojson) {\r\n			this.addData(geojson);\r\n		}\r\n	},\r\n\r\n	addData: function (geojson) {\r\n		var features = L.Util.isArray(geojson) ? geojson : geojson.features,\r\n		    i, len, feature;\r\n\r\n		if (features) {\r\n			for (i = 0, len = features.length; i < len; i++) {\r\n				// Only add this if geometry or geometries are set and not null\r\n				feature = features[i];\r\n				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\r\n					this.addData(features[i]);\r\n				}\r\n			}\r\n			return this;\r\n		}\r\n\r\n		var options = this.options;\r\n\r\n		if (options.filter && !options.filter(geojson)) { return; }\r\n\r\n		var layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);\r\n		layer.feature = L.GeoJSON.asFeature(geojson);\r\n\r\n		layer.defaultOptions = layer.options;\r\n		this.resetStyle(layer);\r\n\r\n		if (options.onEachFeature) {\r\n			options.onEachFeature(geojson, layer);\r\n		}\r\n\r\n		return this.addLayer(layer);\r\n	},\r\n\r\n	resetStyle: function (layer) {\r\n		var style = this.options.style;\r\n		if (style) {\r\n			// reset any custom styles\r\n			L.Util.extend(layer.options, layer.defaultOptions);\r\n\r\n			this._setLayerStyle(layer, style);\r\n		}\r\n	},\r\n\r\n	setStyle: function (style) {\r\n		this.eachLayer(function (layer) {\r\n			this._setLayerStyle(layer, style);\r\n		}, this);\r\n	},\r\n\r\n	_setLayerStyle: function (layer, style) {\r\n		if (typeof style === 'function') {\r\n			style = style(layer.feature);\r\n		}\r\n		if (layer.setStyle) {\r\n			layer.setStyle(style);\r\n		}\r\n	}\r\n});\r\n\r\nL.extend(L.GeoJSON, {\r\n	geometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {\r\n		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\r\n		    coords = geometry.coordinates,\r\n		    layers = [],\r\n		    latlng, latlngs, i, len;\r\n\r\n		coordsToLatLng = coordsToLatLng || this.coordsToLatLng;\r\n\r\n		switch (geometry.type) {\r\n		case 'Point':\r\n			latlng = coordsToLatLng(coords);\r\n			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);\r\n\r\n		case 'MultiPoint':\r\n			for (i = 0, len = coords.length; i < len; i++) {\r\n				latlng = coordsToLatLng(coords[i]);\r\n				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));\r\n			}\r\n			return new L.FeatureGroup(layers);\r\n\r\n		case 'LineString':\r\n			latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);\r\n			return new L.Polyline(latlngs, vectorOptions);\r\n\r\n		case 'Polygon':\r\n			if (coords.length === 2 && !coords[1].length) {\r\n				throw new Error('Invalid GeoJSON object.');\r\n			}\r\n			latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n			return new L.Polygon(latlngs, vectorOptions);\r\n\r\n		case 'MultiLineString':\r\n			latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n			return new L.MultiPolyline(latlngs, vectorOptions);\r\n\r\n		case 'MultiPolygon':\r\n			latlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);\r\n			return new L.MultiPolygon(latlngs, vectorOptions);\r\n\r\n		case 'GeometryCollection':\r\n			for (i = 0, len = geometry.geometries.length; i < len; i++) {\r\n\r\n				layers.push(this.geometryToLayer({\r\n					geometry: geometry.geometries[i],\r\n					type: 'Feature',\r\n					properties: geojson.properties\r\n				}, pointToLayer, coordsToLatLng, vectorOptions));\r\n			}\r\n			return new L.FeatureGroup(layers);\r\n\r\n		default:\r\n			throw new Error('Invalid GeoJSON object.');\r\n		}\r\n	},\r\n\r\n	coordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng\r\n		return new L.LatLng(coords[1], coords[0], coords[2]);\r\n	},\r\n\r\n	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array\r\n		var latlng, i, len,\r\n		    latlngs = [];\r\n\r\n		for (i = 0, len = coords.length; i < len; i++) {\r\n			latlng = levelsDeep ?\r\n			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :\r\n			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);\r\n\r\n			latlngs.push(latlng);\r\n		}\r\n\r\n		return latlngs;\r\n	},\r\n\r\n	latLngToCoords: function (latlng) {\r\n		var coords = [latlng.lng, latlng.lat];\r\n\r\n		if (latlng.alt !== undefined) {\r\n			coords.push(latlng.alt);\r\n		}\r\n		return coords;\r\n	},\r\n\r\n	latLngsToCoords: function (latLngs) {\r\n		var coords = [];\r\n\r\n		for (var i = 0, len = latLngs.length; i < len; i++) {\r\n			coords.push(L.GeoJSON.latLngToCoords(latLngs[i]));\r\n		}\r\n\r\n		return coords;\r\n	},\r\n\r\n	getFeature: function (layer, newGeometry) {\r\n		return layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);\r\n	},\r\n\r\n	asFeature: function (geoJSON) {\r\n		if (geoJSON.type === 'Feature') {\r\n			return geoJSON;\r\n		}\r\n\r\n		return {\r\n			type: 'Feature',\r\n			properties: {},\r\n			geometry: geoJSON\r\n		};\r\n	}\r\n});\r\n\r\nvar PointToGeoJSON = {\r\n	toGeoJSON: function () {\r\n		return L.GeoJSON.getFeature(this, {\r\n			type: 'Point',\r\n			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())\r\n		});\r\n	}\r\n};\r\n\r\nL.Marker.include(PointToGeoJSON);\r\nL.Circle.include(PointToGeoJSON);\r\nL.CircleMarker.include(PointToGeoJSON);\r\n\r\nL.Polyline.include({\r\n	toGeoJSON: function () {\r\n		return L.GeoJSON.getFeature(this, {\r\n			type: 'LineString',\r\n			coordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())\r\n		});\r\n	}\r\n});\r\n\r\nL.Polygon.include({\r\n	toGeoJSON: function () {\r\n		var coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],\r\n		    i, len, hole;\r\n\r\n		coords[0].push(coords[0][0]);\r\n\r\n		if (this._holes) {\r\n			for (i = 0, len = this._holes.length; i < len; i++) {\r\n				hole = L.GeoJSON.latLngsToCoords(this._holes[i]);\r\n				hole.push(hole[0]);\r\n				coords.push(hole);\r\n			}\r\n		}\r\n\r\n		return L.GeoJSON.getFeature(this, {\r\n			type: 'Polygon',\r\n			coordinates: coords\r\n		});\r\n	}\r\n});\r\n\r\n(function () {\r\n	function multiToGeoJSON(type) {\r\n		return function () {\r\n			var coords = [];\r\n\r\n			this.eachLayer(function (layer) {\r\n				coords.push(layer.toGeoJSON().geometry.coordinates);\r\n			});\r\n\r\n			return L.GeoJSON.getFeature(this, {\r\n				type: type,\r\n				coordinates: coords\r\n			});\r\n		};\r\n	}\r\n\r\n	L.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});\r\n	L.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});\r\n\r\n	L.LayerGroup.include({\r\n		toGeoJSON: function () {\r\n\r\n			var geometry = this.feature && this.feature.geometry,\r\n				jsons = [],\r\n				json;\r\n\r\n			if (geometry && geometry.type === 'MultiPoint') {\r\n				return multiToGeoJSON('MultiPoint').call(this);\r\n			}\r\n\r\n			var isGeometryCollection = geometry && geometry.type === 'GeometryCollection';\r\n\r\n			this.eachLayer(function (layer) {\r\n				if (layer.toGeoJSON) {\r\n					json = layer.toGeoJSON();\r\n					jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));\r\n				}\r\n			});\r\n\r\n			if (isGeometryCollection) {\r\n				return L.GeoJSON.getFeature(this, {\r\n					geometries: jsons,\r\n					type: 'GeometryCollection'\r\n				});\r\n			}\r\n\r\n			return {\r\n				type: 'FeatureCollection',\r\n				features: jsons\r\n			};\r\n		}\r\n	});\r\n}());\r\n\r\nL.geoJson = function (geojson, options) {\r\n	return new L.GeoJSON(geojson, options);\r\n};\r\n\n\n/*\r\n * L.DomEvent contains functions for working with DOM events.\r\n */\r\n\r\nL.DomEvent = {\r\n	/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */\r\n	addListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])\r\n\r\n		var id = L.stamp(fn),\r\n		    key = '_leaflet_' + type + id,\r\n		    handler, originalHandler, newType;\r\n\r\n		if (obj[key]) { return this; }\r\n\r\n		handler = function (e) {\r\n			return fn.call(context || obj, e || L.DomEvent._getEvent());\r\n		};\r\n\r\n		if (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n			return this.addPointerListener(obj, type, handler, id);\r\n		}\r\n		if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {\r\n			this.addDoubleTapListener(obj, handler, id);\r\n		}\r\n\r\n		if ('addEventListener' in obj) {\r\n\r\n			if (type === 'mousewheel') {\r\n				obj.addEventListener('DOMMouseScroll', handler, false);\r\n				obj.addEventListener(type, handler, false);\r\n\r\n			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\r\n				originalHandler = handler;\r\n				newType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');\r\n\r\n				handler = function (e) {\r\n					if (!L.DomEvent._checkMouse(obj, e)) { return; }\r\n					return originalHandler(e);\r\n				};\r\n\r\n				obj.addEventListener(newType, handler, false);\r\n\r\n			} else if (type === 'click' && L.Browser.android) {\r\n				originalHandler = handler;\r\n				handler = function (e) {\r\n					return L.DomEvent._filterClick(e, originalHandler);\r\n				};\r\n\r\n				obj.addEventListener(type, handler, false);\r\n			} else {\r\n				obj.addEventListener(type, handler, false);\r\n			}\r\n\r\n		} else if ('attachEvent' in obj) {\r\n			obj.attachEvent('on' + type, handler);\r\n		}\r\n\r\n		obj[key] = handler;\r\n\r\n		return this;\r\n	},\r\n\r\n	removeListener: function (obj, type, fn) {  // (HTMLElement, String, Function)\r\n\r\n		var id = L.stamp(fn),\r\n		    key = '_leaflet_' + type + id,\r\n		    handler = obj[key];\r\n\r\n		if (!handler) { return this; }\r\n\r\n		if (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n			this.removePointerListener(obj, type, id);\r\n		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {\r\n			this.removeDoubleTapListener(obj, id);\r\n\r\n		} else if ('removeEventListener' in obj) {\r\n\r\n			if (type === 'mousewheel') {\r\n				obj.removeEventListener('DOMMouseScroll', handler, false);\r\n				obj.removeEventListener(type, handler, false);\r\n\r\n			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n				obj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);\r\n			} else {\r\n				obj.removeEventListener(type, handler, false);\r\n			}\r\n		} else if ('detachEvent' in obj) {\r\n			obj.detachEvent('on' + type, handler);\r\n		}\r\n\r\n		obj[key] = null;\r\n\r\n		return this;\r\n	},\r\n\r\n	stopPropagation: function (e) {\r\n\r\n		if (e.stopPropagation) {\r\n			e.stopPropagation();\r\n		} else {\r\n			e.cancelBubble = true;\r\n		}\r\n		L.DomEvent._skipped(e);\r\n\r\n		return this;\r\n	},\r\n\r\n	disableScrollPropagation: function (el) {\r\n		var stop = L.DomEvent.stopPropagation;\r\n\r\n		return L.DomEvent\r\n			.on(el, 'mousewheel', stop)\r\n			.on(el, 'MozMousePixelScroll', stop);\r\n	},\r\n\r\n	disableClickPropagation: function (el) {\r\n		var stop = L.DomEvent.stopPropagation;\r\n\r\n		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n			L.DomEvent.on(el, L.Draggable.START[i], stop);\r\n		}\r\n\r\n		return L.DomEvent\r\n			.on(el, 'click', L.DomEvent._fakeStop)\r\n			.on(el, 'dblclick', stop);\r\n	},\r\n\r\n	preventDefault: function (e) {\r\n\r\n		if (e.preventDefault) {\r\n			e.preventDefault();\r\n		} else {\r\n			e.returnValue = false;\r\n		}\r\n		return this;\r\n	},\r\n\r\n	stop: function (e) {\r\n		return L.DomEvent\r\n			.preventDefault(e)\r\n			.stopPropagation(e);\r\n	},\r\n\r\n	getMousePosition: function (e, container) {\r\n		if (!container) {\r\n			return new L.Point(e.clientX, e.clientY);\r\n		}\r\n\r\n		var rect = container.getBoundingClientRect();\r\n\r\n		return new L.Point(\r\n			e.clientX - rect.left - container.clientLeft,\r\n			e.clientY - rect.top - container.clientTop);\r\n	},\r\n\r\n	getWheelDelta: function (e) {\r\n\r\n		var delta = 0;\r\n\r\n		if (e.wheelDelta) {\r\n			delta = e.wheelDelta / 120;\r\n		}\r\n		if (e.detail) {\r\n			delta = -e.detail / 3;\r\n		}\r\n		return delta;\r\n	},\r\n\r\n	_skipEvents: {},\r\n\r\n	_fakeStop: function (e) {\r\n		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)\r\n		L.DomEvent._skipEvents[e.type] = true;\r\n	},\r\n\r\n	_skipped: function (e) {\r\n		var skipped = this._skipEvents[e.type];\r\n		// reset when checking, as it's only used in map container and propagates outside of the map\r\n		this._skipEvents[e.type] = false;\r\n		return skipped;\r\n	},\r\n\r\n	// check if element really left/entered the event target (for mouseenter/mouseleave)\r\n	_checkMouse: function (el, e) {\r\n\r\n		var related = e.relatedTarget;\r\n\r\n		if (!related) { return true; }\r\n\r\n		try {\r\n			while (related && (related !== el)) {\r\n				related = related.parentNode;\r\n			}\r\n		} catch (err) {\r\n			return false;\r\n		}\r\n		return (related !== el);\r\n	},\r\n\r\n	_getEvent: function () { // evil magic for IE\r\n		/*jshint noarg:false */\r\n		var e = window.event;\r\n		if (!e) {\r\n			var caller = arguments.callee.caller;\r\n			while (caller) {\r\n				e = caller['arguments'][0];\r\n				if (e && window.Event === e.constructor) {\r\n					break;\r\n				}\r\n				caller = caller.caller;\r\n			}\r\n		}\r\n		return e;\r\n	},\r\n\r\n	// this is a horrible workaround for a bug in Android where a single touch triggers two click events\r\n	_filterClick: function (e, handler) {\r\n		var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\r\n			elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\r\n\r\n		// are they closer together than 500ms yet more than 100ms?\r\n		// Android typically triggers them ~300ms apart while multiple listeners\r\n		// on the same event should be triggered far faster;\r\n		// or check if click is simulated on the element, and if it is, reject any non-simulated events\r\n\r\n		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\r\n			L.DomEvent.stop(e);\r\n			return;\r\n		}\r\n		L.DomEvent._lastClick = timeStamp;\r\n\r\n		return handler(e);\r\n	}\r\n};\r\n\r\nL.DomEvent.on = L.DomEvent.addListener;\r\nL.DomEvent.off = L.DomEvent.removeListener;\r\n\n\n/*\r\n * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.\r\n */\r\n\r\nL.Draggable = L.Class.extend({\r\n	includes: L.Mixin.Events,\r\n\r\n	statics: {\r\n		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],\r\n		END: {\r\n			mousedown: 'mouseup',\r\n			touchstart: 'touchend',\r\n			pointerdown: 'touchend',\r\n			MSPointerDown: 'touchend'\r\n		},\r\n		MOVE: {\r\n			mousedown: 'mousemove',\r\n			touchstart: 'touchmove',\r\n			pointerdown: 'touchmove',\r\n			MSPointerDown: 'touchmove'\r\n		}\r\n	},\r\n\r\n	initialize: function (element, dragStartTarget) {\r\n		this._element = element;\r\n		this._dragStartTarget = dragStartTarget || element;\r\n	},\r\n\r\n	enable: function () {\r\n		if (this._enabled) { return; }\r\n\r\n		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n			L.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n		}\r\n\r\n		this._enabled = true;\r\n	},\r\n\r\n	disable: function () {\r\n		if (!this._enabled) { return; }\r\n\r\n		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n			L.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n		}\r\n\r\n		this._enabled = false;\r\n		this._moved = false;\r\n	},\r\n\r\n	_onDown: function (e) {\r\n		this._moved = false;\r\n\r\n		if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }\r\n\r\n		L.DomEvent.stopPropagation(e);\r\n\r\n		if (L.Draggable._disabled) { return; }\r\n\r\n		L.DomUtil.disableImageDrag();\r\n		L.DomUtil.disableTextSelection();\r\n\r\n		if (this._moving) { return; }\r\n\r\n		var first = e.touches ? e.touches[0] : e;\r\n\r\n		this._startPoint = new L.Point(first.clientX, first.clientY);\r\n		this._startPos = this._newPos = L.DomUtil.getPosition(this._element);\r\n\r\n		L.DomEvent\r\n		    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)\r\n		    .on(document, L.Draggable.END[e.type], this._onUp, this);\r\n	},\r\n\r\n	_onMove: function (e) {\r\n		if (e.touches && e.touches.length > 1) {\r\n			this._moved = true;\r\n			return;\r\n		}\r\n\r\n		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\r\n		    newPoint = new L.Point(first.clientX, first.clientY),\r\n		    offset = newPoint.subtract(this._startPoint);\r\n\r\n		if (!offset.x && !offset.y) { return; }\r\n		if (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }\r\n\r\n		L.DomEvent.preventDefault(e);\r\n\r\n		if (!this._moved) {\r\n			this.fire('dragstart');\r\n\r\n			this._moved = true;\r\n			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);\r\n\r\n			L.DomUtil.addClass(document.body, 'leaflet-dragging');\r\n			this._lastTarget = e.target || e.srcElement;\r\n			L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');\r\n		}\r\n\r\n		this._newPos = this._startPos.add(offset);\r\n		this._moving = true;\r\n\r\n		L.Util.cancelAnimFrame(this._animRequest);\r\n		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);\r\n	},\r\n\r\n	_updatePosition: function () {\r\n		this.fire('predrag');\r\n		L.DomUtil.setPosition(this._element, this._newPos);\r\n		this.fire('drag');\r\n	},\r\n\r\n	_onUp: function () {\r\n		L.DomUtil.removeClass(document.body, 'leaflet-dragging');\r\n\r\n		if (this._lastTarget) {\r\n			L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');\r\n			this._lastTarget = null;\r\n		}\r\n\r\n		for (var i in L.Draggable.MOVE) {\r\n			L.DomEvent\r\n			    .off(document, L.Draggable.MOVE[i], this._onMove)\r\n			    .off(document, L.Draggable.END[i], this._onUp);\r\n		}\r\n\r\n		L.DomUtil.enableImageDrag();\r\n		L.DomUtil.enableTextSelection();\r\n\r\n		if (this._moved && this._moving) {\r\n			// ensure drag is not fired after dragend\r\n			L.Util.cancelAnimFrame(this._animRequest);\r\n\r\n			this.fire('dragend', {\r\n				distance: this._newPos.distanceTo(this._startPos)\r\n			});\r\n		}\r\n\r\n		this._moving = false;\r\n	}\r\n});\r\n\n\n/*\n	L.Handler is a base class for handler classes that are used internally to inject\n	interaction features like dragging to classes like Map and Marker.\n*/\n\nL.Handler = L.Class.extend({\n	initialize: function (map) {\n		this._map = map;\n	},\n\n	enable: function () {\n		if (this._enabled) { return; }\n\n		this._enabled = true;\n		this.addHooks();\n	},\n\n	disable: function () {\n		if (!this._enabled) { return; }\n\n		this._enabled = false;\n		this.removeHooks();\n	},\n\n	enabled: function () {\n		return !!this._enabled;\n	}\n});\n\n\n/*\n * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n */\n\nL.Map.mergeOptions({\n	dragging: true,\n\n	inertia: !L.Browser.android23,\n	inertiaDeceleration: 3400, // px/s^2\n	inertiaMaxSpeed: Infinity, // px/s\n	inertiaThreshold: L.Browser.touch ? 32 : 18, // ms\n	easeLinearity: 0.25,\n\n	// TODO refactor, move to CRS\n	worldCopyJump: false\n});\n\nL.Map.Drag = L.Handler.extend({\n	addHooks: function () {\n		if (!this._draggable) {\n			var map = this._map;\n\n			this._draggable = new L.Draggable(map._mapPane, map._container);\n\n			this._draggable.on({\n				'dragstart': this._onDragStart,\n				'drag': this._onDrag,\n				'dragend': this._onDragEnd\n			}, this);\n\n			if (map.options.worldCopyJump) {\n				this._draggable.on('predrag', this._onPreDrag, this);\n				map.on('viewreset', this._onViewReset, this);\n\n				map.whenReady(this._onViewReset, this);\n			}\n		}\n		this._draggable.enable();\n	},\n\n	removeHooks: function () {\n		this._draggable.disable();\n	},\n\n	moved: function () {\n		return this._draggable && this._draggable._moved;\n	},\n\n	_onDragStart: function () {\n		var map = this._map;\n\n		if (map._panAnim) {\n			map._panAnim.stop();\n		}\n\n		map\n		    .fire('movestart')\n		    .fire('dragstart');\n\n		if (map.options.inertia) {\n			this._positions = [];\n			this._times = [];\n		}\n	},\n\n	_onDrag: function () {\n		if (this._map.options.inertia) {\n			var time = this._lastTime = +new Date(),\n			    pos = this._lastPos = this._draggable._newPos;\n\n			this._positions.push(pos);\n			this._times.push(time);\n\n			if (time - this._times[0] > 200) {\n				this._positions.shift();\n				this._times.shift();\n			}\n		}\n\n		this._map\n		    .fire('move')\n		    .fire('drag');\n	},\n\n	_onViewReset: function () {\n		// TODO fix hardcoded Earth values\n		var pxCenter = this._map.getSize()._divideBy(2),\n		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n		this._worldWidth = this._map.project([0, 180]).x;\n	},\n\n	_onPreDrag: function () {\n		// TODO refactor to be able to adjust map pane position after zoom\n		var worldWidth = this._worldWidth,\n		    halfWidth = Math.round(worldWidth / 2),\n		    dx = this._initialWorldOffset,\n		    x = this._draggable._newPos.x,\n		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\n		this._draggable._newPos.x = newX;\n	},\n\n	_onDragEnd: function (e) {\n		var map = this._map,\n		    options = map.options,\n		    delay = +new Date() - this._lastTime,\n\n		    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];\n\n		map.fire('dragend', e);\n\n		if (noInertia) {\n			map.fire('moveend');\n\n		} else {\n\n			var direction = this._lastPos.subtract(this._positions[0]),\n			    duration = (this._lastTime + delay - this._times[0]) / 1000,\n			    ease = options.easeLinearity,\n\n			    speedVector = direction.multiplyBy(ease / duration),\n			    speed = speedVector.distanceTo([0, 0]),\n\n			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\n			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n			if (!offset.x || !offset.y) {\n				map.fire('moveend');\n\n			} else {\n				offset = map._limitOffset(offset, map.options.maxBounds);\n\n				L.Util.requestAnimFrame(function () {\n					map.panBy(offset, {\n						duration: decelerationDuration,\n						easeLinearity: ease,\n						noMoveStart: true\n					});\n				});\n			}\n		}\n	}\n});\n\nL.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);\n\n\n/*\n * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n	doubleClickZoom: true\n});\n\nL.Map.DoubleClickZoom = L.Handler.extend({\n	addHooks: function () {\n		this._map.on('dblclick', this._onDoubleClick, this);\n	},\n\n	removeHooks: function () {\n		this._map.off('dblclick', this._onDoubleClick, this);\n	},\n\n	_onDoubleClick: function (e) {\n		var map = this._map,\n		    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);\n\n		if (map.options.doubleClickZoom === 'center') {\n			map.setZoom(zoom);\n		} else {\n			map.setZoomAround(e.containerPoint, zoom);\n		}\n	}\n});\n\nL.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);\n\n\n/*\n * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n */\n\nL.Map.mergeOptions({\n	scrollWheelZoom: true\n});\n\nL.Map.ScrollWheelZoom = L.Handler.extend({\n	addHooks: function () {\n		L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n		L.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n		this._delta = 0;\n	},\n\n	removeHooks: function () {\n		L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);\n		L.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n	},\n\n	_onWheelScroll: function (e) {\n		var delta = L.DomEvent.getWheelDelta(e);\n\n		this._delta += delta;\n		this._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n		if (!this._startTime) {\n			this._startTime = +new Date();\n		}\n\n		var left = Math.max(40 - (+new Date() - this._startTime), 0);\n\n		clearTimeout(this._timer);\n		this._timer = setTimeout(L.bind(this._performZoom, this), left);\n\n		L.DomEvent.preventDefault(e);\n		L.DomEvent.stopPropagation(e);\n	},\n\n	_performZoom: function () {\n		var map = this._map,\n		    delta = this._delta,\n		    zoom = map.getZoom();\n\n		delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n		delta = Math.max(Math.min(delta, 4), -4);\n		delta = map._limitZoom(zoom + delta) - zoom;\n\n		this._delta = 0;\n		this._startTime = null;\n\n		if (!delta) { return; }\n\n		if (map.options.scrollWheelZoom === 'center') {\n			map.setZoom(zoom + delta);\n		} else {\n			map.setZoomAround(this._lastMousePos, zoom + delta);\n		}\n	}\n});\n\nL.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);\n\n\n/*\r\n * Extends the event handling code with double tap support for mobile browsers.\r\n */\r\n\r\nL.extend(L.DomEvent, {\r\n\r\n	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',\r\n	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',\r\n\r\n	// inspired by Zepto touch code by Thomas Fuchs\r\n	addDoubleTapListener: function (obj, handler, id) {\r\n		var last,\r\n		    doubleTap = false,\r\n		    delay = 250,\r\n		    touch,\r\n		    pre = '_leaflet_',\r\n		    touchstart = this._touchstart,\r\n		    touchend = this._touchend,\r\n		    trackedTouches = [];\r\n\r\n		function onTouchStart(e) {\r\n			var count;\r\n\r\n			if (L.Browser.pointer) {\r\n				trackedTouches.push(e.pointerId);\r\n				count = trackedTouches.length;\r\n			} else {\r\n				count = e.touches.length;\r\n			}\r\n			if (count > 1) {\r\n				return;\r\n			}\r\n\r\n			var now = Date.now(),\r\n				delta = now - (last || now);\r\n\r\n			touch = e.touches ? e.touches[0] : e;\r\n			doubleTap = (delta > 0 && delta <= delay);\r\n			last = now;\r\n		}\r\n\r\n		function onTouchEnd(e) {\r\n			if (L.Browser.pointer) {\r\n				var idx = trackedTouches.indexOf(e.pointerId);\r\n				if (idx === -1) {\r\n					return;\r\n				}\r\n				trackedTouches.splice(idx, 1);\r\n			}\r\n\r\n			if (doubleTap) {\r\n				if (L.Browser.pointer) {\r\n					// work around .type being readonly with MSPointer* events\r\n					var newTouch = { },\r\n						prop;\r\n\r\n					// jshint forin:false\r\n					for (var i in touch) {\r\n						prop = touch[i];\r\n						if (typeof prop === 'function') {\r\n							newTouch[i] = prop.bind(touch);\r\n						} else {\r\n							newTouch[i] = prop;\r\n						}\r\n					}\r\n					touch = newTouch;\r\n				}\r\n				touch.type = 'dblclick';\r\n				handler(touch);\r\n				last = null;\r\n			}\r\n		}\r\n		obj[pre + touchstart + id] = onTouchStart;\r\n		obj[pre + touchend + id] = onTouchEnd;\r\n\r\n		// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen\r\n		// will not come through to us, so we will lose track of how many touches are ongoing\r\n		var endElement = L.Browser.pointer ? document.documentElement : obj;\r\n\r\n		obj.addEventListener(touchstart, onTouchStart, false);\r\n		endElement.addEventListener(touchend, onTouchEnd, false);\r\n\r\n		if (L.Browser.pointer) {\r\n			endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	removeDoubleTapListener: function (obj, id) {\r\n		var pre = '_leaflet_';\r\n\r\n		obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);\r\n		(L.Browser.pointer ? document.documentElement : obj).removeEventListener(\r\n		        this._touchend, obj[pre + this._touchend + id], false);\r\n\r\n		if (L.Browser.pointer) {\r\n			document.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],\r\n				false);\r\n		}\r\n\r\n		return this;\r\n	}\r\n});\r\n\n\n/*\n * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n */\n\nL.extend(L.DomEvent, {\n\n	//static\n	POINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',\n	POINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',\n	POINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',\n	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',\n\n	_pointers: [],\n	_pointerDocumentListener: false,\n\n	// Provides a touch events wrapper for (ms)pointer events.\n	// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019\n	//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n	addPointerListener: function (obj, type, handler, id) {\n\n		switch (type) {\n		case 'touchstart':\n			return this.addPointerListenerStart(obj, type, handler, id);\n		case 'touchend':\n			return this.addPointerListenerEnd(obj, type, handler, id);\n		case 'touchmove':\n			return this.addPointerListenerMove(obj, type, handler, id);\n		default:\n			throw 'Unknown touch event type';\n		}\n	},\n\n	addPointerListenerStart: function (obj, type, handler, id) {\n		var pre = '_leaflet_',\n		    pointers = this._pointers;\n\n		var cb = function (e) {\n\n			L.DomEvent.preventDefault(e);\n\n			var alreadyInArray = false;\n			for (var i = 0; i < pointers.length; i++) {\n				if (pointers[i].pointerId === e.pointerId) {\n					alreadyInArray = true;\n					break;\n				}\n			}\n			if (!alreadyInArray) {\n				pointers.push(e);\n			}\n\n			e.touches = pointers.slice();\n			e.changedTouches = [e];\n\n			handler(e);\n		};\n\n		obj[pre + 'touchstart' + id] = cb;\n		obj.addEventListener(this.POINTER_DOWN, cb, false);\n\n		// need to also listen for end events to keep the _pointers list accurate\n		// this needs to be on the body and never go away\n		if (!this._pointerDocumentListener) {\n			var internalCb = function (e) {\n				for (var i = 0; i < pointers.length; i++) {\n					if (pointers[i].pointerId === e.pointerId) {\n						pointers.splice(i, 1);\n						break;\n					}\n				}\n			};\n			//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there\n			document.documentElement.addEventListener(this.POINTER_UP, internalCb, false);\n			document.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);\n\n			this._pointerDocumentListener = true;\n		}\n\n		return this;\n	},\n\n	addPointerListenerMove: function (obj, type, handler, id) {\n		var pre = '_leaflet_',\n		    touches = this._pointers;\n\n		function cb(e) {\n\n			// don't fire touch moves when mouse isn't down\n			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }\n\n			for (var i = 0; i < touches.length; i++) {\n				if (touches[i].pointerId === e.pointerId) {\n					touches[i] = e;\n					break;\n				}\n			}\n\n			e.touches = touches.slice();\n			e.changedTouches = [e];\n\n			handler(e);\n		}\n\n		obj[pre + 'touchmove' + id] = cb;\n		obj.addEventListener(this.POINTER_MOVE, cb, false);\n\n		return this;\n	},\n\n	addPointerListenerEnd: function (obj, type, handler, id) {\n		var pre = '_leaflet_',\n		    touches = this._pointers;\n\n		var cb = function (e) {\n			for (var i = 0; i < touches.length; i++) {\n				if (touches[i].pointerId === e.pointerId) {\n					touches.splice(i, 1);\n					break;\n				}\n			}\n\n			e.touches = touches.slice();\n			e.changedTouches = [e];\n\n			handler(e);\n		};\n\n		obj[pre + 'touchend' + id] = cb;\n		obj.addEventListener(this.POINTER_UP, cb, false);\n		obj.addEventListener(this.POINTER_CANCEL, cb, false);\n\n		return this;\n	},\n\n	removePointerListener: function (obj, type, id) {\n		var pre = '_leaflet_',\n		    cb = obj[pre + type + id];\n\n		switch (type) {\n		case 'touchstart':\n			obj.removeEventListener(this.POINTER_DOWN, cb, false);\n			break;\n		case 'touchmove':\n			obj.removeEventListener(this.POINTER_MOVE, cb, false);\n			break;\n		case 'touchend':\n			obj.removeEventListener(this.POINTER_UP, cb, false);\n			obj.removeEventListener(this.POINTER_CANCEL, cb, false);\n			break;\n		}\n\n		return this;\n	}\n});\n\n\n/*\n * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n */\n\nL.Map.mergeOptions({\n	touchZoom: L.Browser.touch && !L.Browser.android23,\n	bounceAtZoomLimits: true\n});\n\nL.Map.TouchZoom = L.Handler.extend({\n	addHooks: function () {\n		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n	},\n\n	removeHooks: function () {\n		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n	},\n\n	_onTouchStart: function (e) {\n		var map = this._map;\n\n		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\n		var p1 = map.mouseEventToLayerPoint(e.touches[0]),\n		    p2 = map.mouseEventToLayerPoint(e.touches[1]),\n		    viewCenter = map._getCenterLayerPoint();\n\n		this._startCenter = p1.add(p2)._divideBy(2);\n		this._startDist = p1.distanceTo(p2);\n\n		this._moved = false;\n		this._zooming = true;\n\n		this._centerOffset = viewCenter.subtract(this._startCenter);\n\n		if (map._panAnim) {\n			map._panAnim.stop();\n		}\n\n		L.DomEvent\n		    .on(document, 'touchmove', this._onTouchMove, this)\n		    .on(document, 'touchend', this._onTouchEnd, this);\n\n		L.DomEvent.preventDefault(e);\n	},\n\n	_onTouchMove: function (e) {\n		var map = this._map;\n\n		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\n		var p1 = map.mouseEventToLayerPoint(e.touches[0]),\n		    p2 = map.mouseEventToLayerPoint(e.touches[1]);\n\n		this._scale = p1.distanceTo(p2) / this._startDist;\n		this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);\n\n		if (this._scale === 1) { return; }\n\n		if (!map.options.bounceAtZoomLimits) {\n			if ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||\n			    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }\n		}\n\n		if (!this._moved) {\n			L.DomUtil.addClass(map._mapPane, 'leaflet-touching');\n\n			map\n			    .fire('movestart')\n			    .fire('zoomstart');\n\n			this._moved = true;\n		}\n\n		L.Util.cancelAnimFrame(this._animRequest);\n		this._animRequest = L.Util.requestAnimFrame(\n		        this._updateOnMove, this, true, this._map._container);\n\n		L.DomEvent.preventDefault(e);\n	},\n\n	_updateOnMove: function () {\n		var map = this._map,\n		    origin = this._getScaleOrigin(),\n		    center = map.layerPointToLatLng(origin),\n		    zoom = map.getScaleZoom(this._scale);\n\n		map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);\n	},\n\n	_onTouchEnd: function () {\n		if (!this._moved || !this._zooming) {\n			this._zooming = false;\n			return;\n		}\n\n		var map = this._map;\n\n		this._zooming = false;\n		L.DomUtil.removeClass(map._mapPane, 'leaflet-touching');\n		L.Util.cancelAnimFrame(this._animRequest);\n\n		L.DomEvent\n		    .off(document, 'touchmove', this._onTouchMove)\n		    .off(document, 'touchend', this._onTouchEnd);\n\n		var origin = this._getScaleOrigin(),\n		    center = map.layerPointToLatLng(origin),\n\n		    oldZoom = map.getZoom(),\n		    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,\n		    roundZoomDelta = (floatZoomDelta > 0 ?\n		            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),\n\n		    zoom = map._limitZoom(oldZoom + roundZoomDelta),\n		    scale = map.getZoomScale(zoom) / this._scale;\n\n		map._animateZoom(center, zoom, origin, scale);\n	},\n\n	_getScaleOrigin: function () {\n		var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);\n		return this._startCenter.add(centerOffset);\n	}\n});\n\nL.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n\n\n/*\n * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n */\n\nL.Map.mergeOptions({\n	tap: true,\n	tapTolerance: 15\n});\n\nL.Map.Tap = L.Handler.extend({\n	addHooks: function () {\n		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);\n	},\n\n	removeHooks: function () {\n		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);\n	},\n\n	_onDown: function (e) {\n		if (!e.touches) { return; }\n\n		L.DomEvent.preventDefault(e);\n\n		this._fireClick = true;\n\n		// don't simulate click or track longpress if more than 1 touch\n		if (e.touches.length > 1) {\n			this._fireClick = false;\n			clearTimeout(this._holdTimeout);\n			return;\n		}\n\n		var first = e.touches[0],\n		    el = first.target;\n\n		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);\n\n		// if touching a link, highlight it\n		if (el.tagName && el.tagName.toLowerCase() === 'a') {\n			L.DomUtil.addClass(el, 'leaflet-active');\n		}\n\n		// simulate long hold but setting a timeout\n		this._holdTimeout = setTimeout(L.bind(function () {\n			if (this._isTapValid()) {\n				this._fireClick = false;\n				this._onUp();\n				this._simulateEvent('contextmenu', first);\n			}\n		}, this), 1000);\n\n		L.DomEvent\n			.on(document, 'touchmove', this._onMove, this)\n			.on(document, 'touchend', this._onUp, this);\n	},\n\n	_onUp: function (e) {\n		clearTimeout(this._holdTimeout);\n\n		L.DomEvent\n			.off(document, 'touchmove', this._onMove, this)\n			.off(document, 'touchend', this._onUp, this);\n\n		if (this._fireClick && e && e.changedTouches) {\n\n			var first = e.changedTouches[0],\n			    el = first.target;\n\n			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n				L.DomUtil.removeClass(el, 'leaflet-active');\n			}\n\n			// simulate click if the touch didn't move too much\n			if (this._isTapValid()) {\n				this._simulateEvent('click', first);\n			}\n		}\n	},\n\n	_isTapValid: function () {\n		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n	},\n\n	_onMove: function (e) {\n		var first = e.touches[0];\n		this._newPos = new L.Point(first.clientX, first.clientY);\n	},\n\n	_simulateEvent: function (type, e) {\n		var simulatedEvent = document.createEvent('MouseEvents');\n\n		simulatedEvent._simulated = true;\n		e.target._simulatedClick = true;\n\n		simulatedEvent.initMouseEvent(\n		        type, true, true, window, 1,\n		        e.screenX, e.screenY,\n		        e.clientX, e.clientY,\n		        false, false, false, false, 0, null);\n\n		e.target.dispatchEvent(simulatedEvent);\n	}\n});\n\nif (L.Browser.touch && !L.Browser.pointer) {\n	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);\n}\n\n\n/*\n * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map\n  * (zoom to a selected bounding box), enabled by default.\n */\n\nL.Map.mergeOptions({\n	boxZoom: true\n});\n\nL.Map.BoxZoom = L.Handler.extend({\n	initialize: function (map) {\n		this._map = map;\n		this._container = map._container;\n		this._pane = map._panes.overlayPane;\n		this._moved = false;\n	},\n\n	addHooks: function () {\n		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);\n	},\n\n	removeHooks: function () {\n		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown);\n		this._moved = false;\n	},\n\n	moved: function () {\n		return this._moved;\n	},\n\n	_onMouseDown: function (e) {\n		this._moved = false;\n\n		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\n		L.DomUtil.disableTextSelection();\n		L.DomUtil.disableImageDrag();\n\n		this._startLayerPoint = this._map.mouseEventToLayerPoint(e);\n\n		L.DomEvent\n		    .on(document, 'mousemove', this._onMouseMove, this)\n		    .on(document, 'mouseup', this._onMouseUp, this)\n		    .on(document, 'keydown', this._onKeyDown, this);\n	},\n\n	_onMouseMove: function (e) {\n		if (!this._moved) {\n			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);\n			L.DomUtil.setPosition(this._box, this._startLayerPoint);\n\n			//TODO refactor: move cursor to styles\n			this._container.style.cursor = 'crosshair';\n			this._map.fire('boxzoomstart');\n		}\n\n		var startPoint = this._startLayerPoint,\n		    box = this._box,\n\n		    layerPoint = this._map.mouseEventToLayerPoint(e),\n		    offset = layerPoint.subtract(startPoint),\n\n		    newPos = new L.Point(\n		        Math.min(layerPoint.x, startPoint.x),\n		        Math.min(layerPoint.y, startPoint.y));\n\n		L.DomUtil.setPosition(box, newPos);\n\n		this._moved = true;\n\n		// TODO refactor: remove hardcoded 4 pixels\n		box.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';\n		box.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';\n	},\n\n	_finish: function () {\n		if (this._moved) {\n			this._pane.removeChild(this._box);\n			this._container.style.cursor = '';\n		}\n\n		L.DomUtil.enableTextSelection();\n		L.DomUtil.enableImageDrag();\n\n		L.DomEvent\n		    .off(document, 'mousemove', this._onMouseMove)\n		    .off(document, 'mouseup', this._onMouseUp)\n		    .off(document, 'keydown', this._onKeyDown);\n	},\n\n	_onMouseUp: function (e) {\n\n		this._finish();\n\n		var map = this._map,\n		    layerPoint = map.mouseEventToLayerPoint(e);\n\n		if (this._startLayerPoint.equals(layerPoint)) { return; }\n\n		var bounds = new L.LatLngBounds(\n		        map.layerPointToLatLng(this._startLayerPoint),\n		        map.layerPointToLatLng(layerPoint));\n\n		map.fitBounds(bounds);\n\n		map.fire('boxzoomend', {\n			boxZoomBounds: bounds\n		});\n	},\n\n	_onKeyDown: function (e) {\n		if (e.keyCode === 27) {\n			this._finish();\n		}\n	}\n});\n\nL.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);\n\n\n/*\n * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n	keyboard: true,\n	keyboardPanOffset: 80,\n	keyboardZoomOffset: 1\n});\n\nL.Map.Keyboard = L.Handler.extend({\n\n	keyCodes: {\n		left:    [37],\n		right:   [39],\n		down:    [40],\n		up:      [38],\n		zoomIn:  [187, 107, 61, 171],\n		zoomOut: [189, 109, 173]\n	},\n\n	initialize: function (map) {\n		this._map = map;\n\n		this._setPanOffset(map.options.keyboardPanOffset);\n		this._setZoomOffset(map.options.keyboardZoomOffset);\n	},\n\n	addHooks: function () {\n		var container = this._map._container;\n\n		// make the container focusable by tabbing\n		if (container.tabIndex === -1) {\n			container.tabIndex = '0';\n		}\n\n		L.DomEvent\n		    .on(container, 'focus', this._onFocus, this)\n		    .on(container, 'blur', this._onBlur, this)\n		    .on(container, 'mousedown', this._onMouseDown, this);\n\n		this._map\n		    .on('focus', this._addHooks, this)\n		    .on('blur', this._removeHooks, this);\n	},\n\n	removeHooks: function () {\n		this._removeHooks();\n\n		var container = this._map._container;\n\n		L.DomEvent\n		    .off(container, 'focus', this._onFocus, this)\n		    .off(container, 'blur', this._onBlur, this)\n		    .off(container, 'mousedown', this._onMouseDown, this);\n\n		this._map\n		    .off('focus', this._addHooks, this)\n		    .off('blur', this._removeHooks, this);\n	},\n\n	_onMouseDown: function () {\n		if (this._focused) { return; }\n\n		var body = document.body,\n		    docEl = document.documentElement,\n		    top = body.scrollTop || docEl.scrollTop,\n		    left = body.scrollLeft || docEl.scrollLeft;\n\n		this._map._container.focus();\n\n		window.scrollTo(left, top);\n	},\n\n	_onFocus: function () {\n		this._focused = true;\n		this._map.fire('focus');\n	},\n\n	_onBlur: function () {\n		this._focused = false;\n		this._map.fire('blur');\n	},\n\n	_setPanOffset: function (pan) {\n		var keys = this._panKeys = {},\n		    codes = this.keyCodes,\n		    i, len;\n\n		for (i = 0, len = codes.left.length; i < len; i++) {\n			keys[codes.left[i]] = [-1 * pan, 0];\n		}\n		for (i = 0, len = codes.right.length; i < len; i++) {\n			keys[codes.right[i]] = [pan, 0];\n		}\n		for (i = 0, len = codes.down.length; i < len; i++) {\n			keys[codes.down[i]] = [0, pan];\n		}\n		for (i = 0, len = codes.up.length; i < len; i++) {\n			keys[codes.up[i]] = [0, -1 * pan];\n		}\n	},\n\n	_setZoomOffset: function (zoom) {\n		var keys = this._zoomKeys = {},\n		    codes = this.keyCodes,\n		    i, len;\n\n		for (i = 0, len = codes.zoomIn.length; i < len; i++) {\n			keys[codes.zoomIn[i]] = zoom;\n		}\n		for (i = 0, len = codes.zoomOut.length; i < len; i++) {\n			keys[codes.zoomOut[i]] = -zoom;\n		}\n	},\n\n	_addHooks: function () {\n		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);\n	},\n\n	_removeHooks: function () {\n		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);\n	},\n\n	_onKeyDown: function (e) {\n		var key = e.keyCode,\n		    map = this._map;\n\n		if (key in this._panKeys) {\n\n			if (map._panAnim && map._panAnim._inProgress) { return; }\n\n			map.panBy(this._panKeys[key]);\n\n			if (map.options.maxBounds) {\n				map.panInsideBounds(map.options.maxBounds);\n			}\n\n		} else if (key in this._zoomKeys) {\n			map.setZoom(map.getZoom() + this._zoomKeys[key]);\n\n		} else {\n			return;\n		}\n\n		L.DomEvent.stop(e);\n	}\n});\n\nL.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);\n\n\n/*\n * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n */\n\nL.Handler.MarkerDrag = L.Handler.extend({\n	initialize: function (marker) {\n		this._marker = marker;\n	},\n\n	addHooks: function () {\n		var icon = this._marker._icon;\n		if (!this._draggable) {\n			this._draggable = new L.Draggable(icon, icon);\n		}\n\n		this._draggable\n			.on('dragstart', this._onDragStart, this)\n			.on('drag', this._onDrag, this)\n			.on('dragend', this._onDragEnd, this);\n		this._draggable.enable();\n		L.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');\n	},\n\n	removeHooks: function () {\n		this._draggable\n			.off('dragstart', this._onDragStart, this)\n			.off('drag', this._onDrag, this)\n			.off('dragend', this._onDragEnd, this);\n\n		this._draggable.disable();\n		L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');\n	},\n\n	moved: function () {\n		return this._draggable && this._draggable._moved;\n	},\n\n	_onDragStart: function () {\n		this._marker\n		    .closePopup()\n		    .fire('movestart')\n		    .fire('dragstart');\n	},\n\n	_onDrag: function () {\n		var marker = this._marker,\n		    shadow = marker._shadow,\n		    iconPos = L.DomUtil.getPosition(marker._icon),\n		    latlng = marker._map.layerPointToLatLng(iconPos);\n\n		// update shadow position\n		if (shadow) {\n			L.DomUtil.setPosition(shadow, iconPos);\n		}\n\n		marker._latlng = latlng;\n\n		marker\n		    .fire('move', {latlng: latlng})\n		    .fire('drag');\n	},\n\n	_onDragEnd: function (e) {\n		this._marker\n		    .fire('moveend')\n		    .fire('dragend', e);\n	}\n});\n\n\n/*\r\n * L.Control is a base class for implementing map controls. Handles positioning.\r\n * All other controls extend from this class.\r\n */\r\n\r\nL.Control = L.Class.extend({\r\n	options: {\r\n		position: 'topright'\r\n	},\r\n\r\n	initialize: function (options) {\r\n		L.setOptions(this, options);\r\n	},\r\n\r\n	getPosition: function () {\r\n		return this.options.position;\r\n	},\r\n\r\n	setPosition: function (position) {\r\n		var map = this._map;\r\n\r\n		if (map) {\r\n			map.removeControl(this);\r\n		}\r\n\r\n		this.options.position = position;\r\n\r\n		if (map) {\r\n			map.addControl(this);\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	getContainer: function () {\r\n		return this._container;\r\n	},\r\n\r\n	addTo: function (map) {\r\n		this._map = map;\r\n\r\n		var container = this._container = this.onAdd(map),\r\n		    pos = this.getPosition(),\r\n		    corner = map._controlCorners[pos];\r\n\r\n		L.DomUtil.addClass(container, 'leaflet-control');\r\n\r\n		if (pos.indexOf('bottom') !== -1) {\r\n			corner.insertBefore(container, corner.firstChild);\r\n		} else {\r\n			corner.appendChild(container);\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	removeFrom: function (map) {\r\n		var pos = this.getPosition(),\r\n		    corner = map._controlCorners[pos];\r\n\r\n		corner.removeChild(this._container);\r\n		this._map = null;\r\n\r\n		if (this.onRemove) {\r\n			this.onRemove(map);\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	_refocusOnMap: function () {\r\n		if (this._map) {\r\n			this._map.getContainer().focus();\r\n		}\r\n	}\r\n});\r\n\r\nL.control = function (options) {\r\n	return new L.Control(options);\r\n};\r\n\r\n\r\n// adds control-related methods to L.Map\r\n\r\nL.Map.include({\r\n	addControl: function (control) {\r\n		control.addTo(this);\r\n		return this;\r\n	},\r\n\r\n	removeControl: function (control) {\r\n		control.removeFrom(this);\r\n		return this;\r\n	},\r\n\r\n	_initControlPos: function () {\r\n		var corners = this._controlCorners = {},\r\n		    l = 'leaflet-',\r\n		    container = this._controlContainer =\r\n		            L.DomUtil.create('div', l + 'control-container', this._container);\r\n\r\n		function createCorner(vSide, hSide) {\r\n			var className = l + vSide + ' ' + l + hSide;\r\n\r\n			corners[vSide + hSide] = L.DomUtil.create('div', className, container);\r\n		}\r\n\r\n		createCorner('top', 'left');\r\n		createCorner('top', 'right');\r\n		createCorner('bottom', 'left');\r\n		createCorner('bottom', 'right');\r\n	},\r\n\r\n	_clearControlPos: function () {\r\n		this._container.removeChild(this._controlContainer);\r\n	}\r\n});\r\n\n\n/*\r\n * L.Control.Zoom is used for the default zoom buttons on the map.\r\n */\r\n\r\nL.Control.Zoom = L.Control.extend({\r\n	options: {\r\n		position: 'topleft',\r\n		zoomInText: '+',\r\n		zoomInTitle: 'Zoom in',\r\n		zoomOutText: '-',\r\n		zoomOutTitle: 'Zoom out'\r\n	},\r\n\r\n	onAdd: function (map) {\r\n		var zoomName = 'leaflet-control-zoom',\r\n		    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');\r\n\r\n		this._map = map;\r\n\r\n		this._zoomInButton  = this._createButton(\r\n		        this.options.zoomInText, this.options.zoomInTitle,\r\n		        zoomName + '-in',  container, this._zoomIn,  this);\r\n		this._zoomOutButton = this._createButton(\r\n		        this.options.zoomOutText, this.options.zoomOutTitle,\r\n		        zoomName + '-out', container, this._zoomOut, this);\r\n\r\n		this._updateDisabled();\r\n		map.on('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\r\n		return container;\r\n	},\r\n\r\n	onRemove: function (map) {\r\n		map.off('zoomend zoomlevelschange', this._updateDisabled, this);\r\n	},\r\n\r\n	_zoomIn: function (e) {\r\n		this._map.zoomIn(e.shiftKey ? 3 : 1);\r\n	},\r\n\r\n	_zoomOut: function (e) {\r\n		this._map.zoomOut(e.shiftKey ? 3 : 1);\r\n	},\r\n\r\n	_createButton: function (html, title, className, container, fn, context) {\r\n		var link = L.DomUtil.create('a', className, container);\r\n		link.innerHTML = html;\r\n		link.href = '#';\r\n		link.title = title;\r\n\r\n		var stop = L.DomEvent.stopPropagation;\r\n\r\n		L.DomEvent\r\n		    .on(link, 'click', stop)\r\n		    .on(link, 'mousedown', stop)\r\n		    .on(link, 'dblclick', stop)\r\n		    .on(link, 'click', L.DomEvent.preventDefault)\r\n		    .on(link, 'click', fn, context)\r\n		    .on(link, 'click', this._refocusOnMap, context);\r\n\r\n		return link;\r\n	},\r\n\r\n	_updateDisabled: function () {\r\n		var map = this._map,\r\n			className = 'leaflet-disabled';\r\n\r\n		L.DomUtil.removeClass(this._zoomInButton, className);\r\n		L.DomUtil.removeClass(this._zoomOutButton, className);\r\n\r\n		if (map._zoom === map.getMinZoom()) {\r\n			L.DomUtil.addClass(this._zoomOutButton, className);\r\n		}\r\n		if (map._zoom === map.getMaxZoom()) {\r\n			L.DomUtil.addClass(this._zoomInButton, className);\r\n		}\r\n	}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n	zoomControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n	if (this.options.zoomControl) {\r\n		this.zoomControl = new L.Control.Zoom();\r\n		this.addControl(this.zoomControl);\r\n	}\r\n});\r\n\r\nL.control.zoom = function (options) {\r\n	return new L.Control.Zoom(options);\r\n};\r\n\r\n\n\n/*\r\n * L.Control.Attribution is used for displaying attribution on the map (added by default).\r\n */\r\n\r\nL.Control.Attribution = L.Control.extend({\r\n	options: {\r\n		position: 'bottomright',\r\n		prefix: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\r\n	},\r\n\r\n	initialize: function (options) {\r\n		L.setOptions(this, options);\r\n\r\n		this._attributions = {};\r\n	},\r\n\r\n	onAdd: function (map) {\r\n		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');\r\n		L.DomEvent.disableClickPropagation(this._container);\r\n\r\n		for (var i in map._layers) {\r\n			if (map._layers[i].getAttribution) {\r\n				this.addAttribution(map._layers[i].getAttribution());\r\n			}\r\n		}\r\n		\r\n		map\r\n		    .on('layeradd', this._onLayerAdd, this)\r\n		    .on('layerremove', this._onLayerRemove, this);\r\n\r\n		this._update();\r\n\r\n		return this._container;\r\n	},\r\n\r\n	onRemove: function (map) {\r\n		map\r\n		    .off('layeradd', this._onLayerAdd)\r\n		    .off('layerremove', this._onLayerRemove);\r\n\r\n	},\r\n\r\n	setPrefix: function (prefix) {\r\n		this.options.prefix = prefix;\r\n		this._update();\r\n		return this;\r\n	},\r\n\r\n	addAttribution: function (text) {\r\n		if (!text) { return; }\r\n\r\n		if (!this._attributions[text]) {\r\n			this._attributions[text] = 0;\r\n		}\r\n		this._attributions[text]++;\r\n\r\n		this._update();\r\n\r\n		return this;\r\n	},\r\n\r\n	removeAttribution: function (text) {\r\n		if (!text) { return; }\r\n\r\n		if (this._attributions[text]) {\r\n			this._attributions[text]--;\r\n			this._update();\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	_update: function () {\r\n		if (!this._map) { return; }\r\n\r\n		var attribs = [];\r\n\r\n		for (var i in this._attributions) {\r\n			if (this._attributions[i]) {\r\n				attribs.push(i);\r\n			}\r\n		}\r\n\r\n		var prefixAndAttribs = [];\r\n\r\n		if (this.options.prefix) {\r\n			prefixAndAttribs.push(this.options.prefix);\r\n		}\r\n		if (attribs.length) {\r\n			prefixAndAttribs.push(attribs.join(', '));\r\n		}\r\n\r\n		this._container.innerHTML = prefixAndAttribs.join(' | ');\r\n	},\r\n\r\n	_onLayerAdd: function (e) {\r\n		if (e.layer.getAttribution) {\r\n			this.addAttribution(e.layer.getAttribution());\r\n		}\r\n	},\r\n\r\n	_onLayerRemove: function (e) {\r\n		if (e.layer.getAttribution) {\r\n			this.removeAttribution(e.layer.getAttribution());\r\n		}\r\n	}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n	attributionControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n	if (this.options.attributionControl) {\r\n		this.attributionControl = (new L.Control.Attribution()).addTo(this);\r\n	}\r\n});\r\n\r\nL.control.attribution = function (options) {\r\n	return new L.Control.Attribution(options);\r\n};\r\n\n\n/*\n * L.Control.Scale is used for displaying metric/imperial scale on the map.\n */\n\nL.Control.Scale = L.Control.extend({\n	options: {\n		position: 'bottomleft',\n		maxWidth: 100,\n		metric: true,\n		imperial: true,\n		updateWhenIdle: false\n	},\n\n	onAdd: function (map) {\n		this._map = map;\n\n		var className = 'leaflet-control-scale',\n		    container = L.DomUtil.create('div', className),\n		    options = this.options;\n\n		this._addScales(options, className, container);\n\n		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n		map.whenReady(this._update, this);\n\n		return container;\n	},\n\n	onRemove: function (map) {\n		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n	},\n\n	_addScales: function (options, className, container) {\n		if (options.metric) {\n			this._mScale = L.DomUtil.create('div', className + '-line', container);\n		}\n		if (options.imperial) {\n			this._iScale = L.DomUtil.create('div', className + '-line', container);\n		}\n	},\n\n	_update: function () {\n		var bounds = this._map.getBounds(),\n		    centerLat = bounds.getCenter().lat,\n		    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),\n		    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,\n\n		    size = this._map.getSize(),\n		    options = this.options,\n		    maxMeters = 0;\n\n		if (size.x > 0) {\n			maxMeters = dist * (options.maxWidth / size.x);\n		}\n\n		this._updateScales(options, maxMeters);\n	},\n\n	_updateScales: function (options, maxMeters) {\n		if (options.metric && maxMeters) {\n			this._updateMetric(maxMeters);\n		}\n\n		if (options.imperial && maxMeters) {\n			this._updateImperial(maxMeters);\n		}\n	},\n\n	_updateMetric: function (maxMeters) {\n		var meters = this._getRoundNum(maxMeters);\n\n		this._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';\n		this._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n	},\n\n	_updateImperial: function (maxMeters) {\n		var maxFeet = maxMeters * 3.2808399,\n		    scale = this._iScale,\n		    maxMiles, miles, feet;\n\n		if (maxFeet > 5280) {\n			maxMiles = maxFeet / 5280;\n			miles = this._getRoundNum(maxMiles);\n\n			scale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';\n			scale.innerHTML = miles + ' mi';\n\n		} else {\n			feet = this._getRoundNum(maxFeet);\n\n			scale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';\n			scale.innerHTML = feet + ' ft';\n		}\n	},\n\n	_getScaleWidth: function (ratio) {\n		return Math.round(this.options.maxWidth * ratio) - 10;\n	},\n\n	_getRoundNum: function (num) {\n		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n		    d = num / pow10;\n\n		d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n\n		return pow10 * d;\n	}\n});\n\nL.control.scale = function (options) {\n	return new L.Control.Scale(options);\n};\n\n\n/*\r\n * L.Control.Layers is a control to allow users to switch between different layers on the map.\r\n */\r\n\r\nL.Control.Layers = L.Control.extend({\r\n	options: {\r\n		collapsed: true,\r\n		position: 'topright',\r\n		autoZIndex: true\r\n	},\r\n\r\n	initialize: function (baseLayers, overlays, options) {\r\n		L.setOptions(this, options);\r\n\r\n		this._layers = {};\r\n		this._lastZIndex = 0;\r\n		this._handlingClick = false;\r\n\r\n		for (var i in baseLayers) {\r\n			this._addLayer(baseLayers[i], i);\r\n		}\r\n\r\n		for (i in overlays) {\r\n			this._addLayer(overlays[i], i, true);\r\n		}\r\n	},\r\n\r\n	onAdd: function (map) {\r\n		this._initLayout();\r\n		this._update();\r\n\r\n		map\r\n		    .on('layeradd', this._onLayerChange, this)\r\n		    .on('layerremove', this._onLayerChange, this);\r\n\r\n		return this._container;\r\n	},\r\n\r\n	onRemove: function (map) {\r\n		map\r\n		    .off('layeradd', this._onLayerChange, this)\r\n		    .off('layerremove', this._onLayerChange, this);\r\n	},\r\n\r\n	addBaseLayer: function (layer, name) {\r\n		this._addLayer(layer, name);\r\n		this._update();\r\n		return this;\r\n	},\r\n\r\n	addOverlay: function (layer, name) {\r\n		this._addLayer(layer, name, true);\r\n		this._update();\r\n		return this;\r\n	},\r\n\r\n	removeLayer: function (layer) {\r\n		var id = L.stamp(layer);\r\n		delete this._layers[id];\r\n		this._update();\r\n		return this;\r\n	},\r\n\r\n	_initLayout: function () {\r\n		var className = 'leaflet-control-layers',\r\n		    container = this._container = L.DomUtil.create('div', className);\r\n\r\n		//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released\r\n		container.setAttribute('aria-haspopup', true);\r\n\r\n		if (!L.Browser.touch) {\r\n			L.DomEvent\r\n				.disableClickPropagation(container)\r\n				.disableScrollPropagation(container);\r\n		} else {\r\n			L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);\r\n		}\r\n\r\n		var form = this._form = L.DomUtil.create('form', className + '-list');\r\n\r\n		if (this.options.collapsed) {\r\n			if (!L.Browser.android) {\r\n				L.DomEvent\r\n				    .on(container, 'mouseover', this._expand, this)\r\n				    .on(container, 'mouseout', this._collapse, this);\r\n			}\r\n			var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);\r\n			link.href = '#';\r\n			link.title = 'Layers';\r\n\r\n			if (L.Browser.touch) {\r\n				L.DomEvent\r\n				    .on(link, 'click', L.DomEvent.stop)\r\n				    .on(link, 'click', this._expand, this);\r\n			}\r\n			else {\r\n				L.DomEvent.on(link, 'focus', this._expand, this);\r\n			}\r\n			//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033\r\n			L.DomEvent.on(form, 'click', function () {\r\n				setTimeout(L.bind(this._onInputClick, this), 0);\r\n			}, this);\r\n\r\n			this._map.on('click', this._collapse, this);\r\n			// TODO keyboard accessibility\r\n		} else {\r\n			this._expand();\r\n		}\r\n\r\n		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);\r\n		this._separator = L.DomUtil.create('div', className + '-separator', form);\r\n		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);\r\n\r\n		container.appendChild(form);\r\n	},\r\n\r\n	_addLayer: function (layer, name, overlay) {\r\n		var id = L.stamp(layer);\r\n\r\n		this._layers[id] = {\r\n			layer: layer,\r\n			name: name,\r\n			overlay: overlay\r\n		};\r\n\r\n		if (this.options.autoZIndex && layer.setZIndex) {\r\n			this._lastZIndex++;\r\n			layer.setZIndex(this._lastZIndex);\r\n		}\r\n	},\r\n\r\n	_update: function () {\r\n		if (!this._container) {\r\n			return;\r\n		}\r\n\r\n		this._baseLayersList.innerHTML = '';\r\n		this._overlaysList.innerHTML = '';\r\n\r\n		var baseLayersPresent = false,\r\n		    overlaysPresent = false,\r\n		    i, obj;\r\n\r\n		for (i in this._layers) {\r\n			obj = this._layers[i];\r\n			this._addItem(obj);\r\n			overlaysPresent = overlaysPresent || obj.overlay;\r\n			baseLayersPresent = baseLayersPresent || !obj.overlay;\r\n		}\r\n\r\n		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\r\n	},\r\n\r\n	_onLayerChange: function (e) {\r\n		var obj = this._layers[L.stamp(e.layer)];\r\n\r\n		if (!obj) { return; }\r\n\r\n		if (!this._handlingClick) {\r\n			this._update();\r\n		}\r\n\r\n		var type = obj.overlay ?\r\n			(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :\r\n			(e.type === 'layeradd' ? 'baselayerchange' : null);\r\n\r\n		if (type) {\r\n			this._map.fire(type, obj);\r\n		}\r\n	},\r\n\r\n	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\r\n	_createRadioElement: function (name, checked) {\r\n\r\n		var radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"';\r\n		if (checked) {\r\n			radioHtml += ' checked=\"checked\"';\r\n		}\r\n		radioHtml += '/>';\r\n\r\n		var radioFragment = document.createElement('div');\r\n		radioFragment.innerHTML = radioHtml;\r\n\r\n		return radioFragment.firstChild;\r\n	},\r\n\r\n	_addItem: function (obj) {\r\n		var label = document.createElement('label'),\r\n		    input,\r\n		    checked = this._map.hasLayer(obj.layer);\r\n\r\n		if (obj.overlay) {\r\n			input = document.createElement('input');\r\n			input.type = 'checkbox';\r\n			input.className = 'leaflet-control-layers-selector';\r\n			input.defaultChecked = checked;\r\n		} else {\r\n			input = this._createRadioElement('leaflet-base-layers', checked);\r\n		}\r\n\r\n		input.layerId = L.stamp(obj.layer);\r\n\r\n		L.DomEvent.on(input, 'click', this._onInputClick, this);\r\n\r\n		var name = document.createElement('span');\r\n		name.innerHTML = ' ' + obj.name;\r\n\r\n		label.appendChild(input);\r\n		label.appendChild(name);\r\n\r\n		var container = obj.overlay ? this._overlaysList : this._baseLayersList;\r\n		container.appendChild(label);\r\n\r\n		return label;\r\n	},\r\n\r\n	_onInputClick: function () {\r\n		var i, input, obj,\r\n		    inputs = this._form.getElementsByTagName('input'),\r\n		    inputsLen = inputs.length;\r\n\r\n		this._handlingClick = true;\r\n\r\n		for (i = 0; i < inputsLen; i++) {\r\n			input = inputs[i];\r\n			obj = this._layers[input.layerId];\r\n\r\n			if (input.checked && !this._map.hasLayer(obj.layer)) {\r\n				this._map.addLayer(obj.layer);\r\n\r\n			} else if (!input.checked && this._map.hasLayer(obj.layer)) {\r\n				this._map.removeLayer(obj.layer);\r\n			}\r\n		}\r\n\r\n		this._handlingClick = false;\r\n\r\n		this._refocusOnMap();\r\n	},\r\n\r\n	_expand: function () {\r\n		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');\r\n	},\r\n\r\n	_collapse: function () {\r\n		this._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');\r\n	}\r\n});\r\n\r\nL.control.layers = function (baseLayers, overlays, options) {\r\n	return new L.Control.Layers(baseLayers, overlays, options);\r\n};\r\n\n\n/*\n * L.PosAnimation is used by Leaflet internally for pan animations.\n */\n\nL.PosAnimation = L.Class.extend({\n	includes: L.Mixin.Events,\n\n	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n		this.stop();\n\n		this._el = el;\n		this._inProgress = true;\n		this._newPos = newPos;\n\n		this.fire('start');\n\n		el.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +\n		        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';\n\n		L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n		L.DomUtil.setPosition(el, newPos);\n\n		// toggle reflow, Chrome flickers for some reason if you don't do this\n		L.Util.falseFn(el.offsetWidth);\n\n		// there's no native way to track value updates of transitioned properties, so we imitate this\n		this._stepTimer = setInterval(L.bind(this._onStep, this), 50);\n	},\n\n	stop: function () {\n		if (!this._inProgress) { return; }\n\n		// if we just removed the transition property, the element would jump to its final position,\n		// so we need to make it stay at the current position\n\n		L.DomUtil.setPosition(this._el, this._getPos());\n		this._onTransitionEnd();\n		L.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation\n	},\n\n	_onStep: function () {\n		var stepPos = this._getPos();\n		if (!stepPos) {\n			this._onTransitionEnd();\n			return;\n		}\n		// jshint camelcase: false\n		// make L.DomUtil.getPosition return intermediate position value during animation\n		this._el._leaflet_pos = stepPos;\n\n		this.fire('step');\n	},\n\n	// you can't easily get intermediate values of properties animated with CSS3 Transitions,\n	// we need to parse computed style (in case of transform it returns matrix string)\n\n	_transformRe: /([-+]?(?:\\d*\\.)?\\d+)\\D*, ([-+]?(?:\\d*\\.)?\\d+)\\D*\\)/,\n\n	_getPos: function () {\n		var left, top, matches,\n		    el = this._el,\n		    style = window.getComputedStyle(el);\n\n		if (L.Browser.any3d) {\n			matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);\n			if (!matches) { return; }\n			left = parseFloat(matches[1]);\n			top  = parseFloat(matches[2]);\n		} else {\n			left = parseFloat(style.left);\n			top  = parseFloat(style.top);\n		}\n\n		return new L.Point(left, top, true);\n	},\n\n	_onTransitionEnd: function () {\n		L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\n		if (!this._inProgress) { return; }\n		this._inProgress = false;\n\n		this._el.style[L.DomUtil.TRANSITION] = '';\n\n		// jshint camelcase: false\n		// make sure L.DomUtil.getPosition returns the final position value after animation\n		this._el._leaflet_pos = this._newPos;\n\n		clearInterval(this._stepTimer);\n\n		this.fire('step').fire('end');\n	}\n\n});\n\n\n/*\n * Extends L.Map to handle panning animations.\n */\n\nL.Map.include({\n\n	setView: function (center, zoom, options) {\n\n		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);\n		options = options || {};\n\n		if (this._panAnim) {\n			this._panAnim.stop();\n		}\n\n		if (this._loaded && !options.reset && options !== true) {\n\n			if (options.animate !== undefined) {\n				options.zoom = L.extend({animate: options.animate}, options.zoom);\n				options.pan = L.extend({animate: options.animate}, options.pan);\n			}\n\n			// try animating pan or zoom\n			var animated = (this._zoom !== zoom) ?\n				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\n				this._tryAnimatedPan(center, options.pan);\n\n			if (animated) {\n				// prevent resize handler call, the view will refresh after animation anyway\n				clearTimeout(this._sizeTimer);\n				return this;\n			}\n		}\n\n		// animation didn't start, just reset the map view\n		this._resetView(center, zoom);\n\n		return this;\n	},\n\n	panBy: function (offset, options) {\n		offset = L.point(offset).round();\n		options = options || {};\n\n		if (!offset.x && !offset.y) {\n			return this;\n		}\n\n		if (!this._panAnim) {\n			this._panAnim = new L.PosAnimation();\n\n			this._panAnim.on({\n				'step': this._onPanTransitionStep,\n				'end': this._onPanTransitionEnd\n			}, this);\n		}\n\n		// don't fire movestart if animating inertia\n		if (!options.noMoveStart) {\n			this.fire('movestart');\n		}\n\n		// animate pan unless animate: false specified\n		if (options.animate !== false) {\n			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\n\n			var newPos = this._getMapPanePos().subtract(offset);\n			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n		} else {\n			this._rawPanBy(offset);\n			this.fire('move').fire('moveend');\n		}\n\n		return this;\n	},\n\n	_onPanTransitionStep: function () {\n		this.fire('move');\n	},\n\n	_onPanTransitionEnd: function () {\n		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\n		this.fire('moveend');\n	},\n\n	_tryAnimatedPan: function (center, options) {\n		// difference between the new and current centers in pixels\n		var offset = this._getCenterOffset(center)._floor();\n\n		// don't animate too far unless animate: true specified in options\n		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\n\n		this.panBy(offset, options);\n\n		return true;\n	}\n});\n\n\n/*\n * L.PosAnimation fallback implementation that powers Leaflet pan animations\n * in browsers that don't support CSS3 Transitions.\n */\n\nL.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({\n\n	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n		this.stop();\n\n		this._el = el;\n		this._inProgress = true;\n		this._duration = duration || 0.25;\n		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\n		this._startPos = L.DomUtil.getPosition(el);\n		this._offset = newPos.subtract(this._startPos);\n		this._startTime = +new Date();\n\n		this.fire('start');\n\n		this._animate();\n	},\n\n	stop: function () {\n		if (!this._inProgress) { return; }\n\n		this._step();\n		this._complete();\n	},\n\n	_animate: function () {\n		// animation loop\n		this._animId = L.Util.requestAnimFrame(this._animate, this);\n		this._step();\n	},\n\n	_step: function () {\n		var elapsed = (+new Date()) - this._startTime,\n		    duration = this._duration * 1000;\n\n		if (elapsed < duration) {\n			this._runFrame(this._easeOut(elapsed / duration));\n		} else {\n			this._runFrame(1);\n			this._complete();\n		}\n	},\n\n	_runFrame: function (progress) {\n		var pos = this._startPos.add(this._offset.multiplyBy(progress));\n		L.DomUtil.setPosition(this._el, pos);\n\n		this.fire('step');\n	},\n\n	_complete: function () {\n		L.Util.cancelAnimFrame(this._animId);\n\n		this._inProgress = false;\n		this.fire('end');\n	},\n\n	_easeOut: function (t) {\n		return 1 - Math.pow(1 - t, this._easeOutPower);\n	}\n});\n\n\n/*\n * Extends L.Map to handle zoom animations.\n */\n\nL.Map.mergeOptions({\n	zoomAnimation: true,\n	zoomAnimationThreshold: 4\n});\n\nif (L.DomUtil.TRANSITION) {\n\n	L.Map.addInitHook(function () {\n		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n		this._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&\n				L.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;\n\n		// zoom transitions run with the same duration for all layers, so if one of transitionend events\n		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n		if (this._zoomAnimated) {\n			L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n		}\n	});\n}\n\nL.Map.include(!L.DomUtil.TRANSITION ? {} : {\n\n	_catchTransitionEnd: function (e) {\n		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n			this._onZoomTransitionEnd();\n		}\n	},\n\n	_nothingToAnimate: function () {\n		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n	},\n\n	_tryAnimatedZoom: function (center, zoom, options) {\n\n		if (this._animatingZoom) { return true; }\n\n		options = options || {};\n\n		// don't animate if disabled, not supported or zoom difference is too large\n		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\n		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\n\n		// offset is the pixel coords of the zoom origin relative to the current center\n		var scale = this.getZoomScale(zoom),\n		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),\n			origin = this._getCenterLayerPoint()._add(offset);\n\n		// don't animate if the zoom origin isn't within one screen from the current center, unless forced\n		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }\n\n		this\n		    .fire('movestart')\n		    .fire('zoomstart');\n\n		this._animateZoom(center, zoom, origin, scale, null, true);\n\n		return true;\n	},\n\n	_animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {\n\n		if (!forTouchZoom) {\n			this._animatingZoom = true;\n		}\n\n		// put transform transition on all layers with leaflet-zoom-animated class\n		L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\n\n		// remember what center/zoom to set after animation\n		this._animateToCenter = center;\n		this._animateToZoom = zoom;\n\n		// disable any dragging during animation\n		if (L.Draggable) {\n			L.Draggable._disabled = true;\n		}\n\n		L.Util.requestAnimFrame(function () {\n			this.fire('zoomanim', {\n				center: center,\n				zoom: zoom,\n				origin: origin,\n				scale: scale,\n				delta: delta,\n				backwards: backwards\n			});\n		}, this);\n	},\n\n	_onZoomTransitionEnd: function () {\n\n		this._animatingZoom = false;\n\n		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\n\n		this._resetView(this._animateToCenter, this._animateToZoom, true, true);\n\n		if (L.Draggable) {\n			L.Draggable._disabled = false;\n		}\n	}\n});\n\n\n/*\n	Zoom animation logic for L.TileLayer.\n*/\n\nL.TileLayer.include({\n	_animateZoom: function (e) {\n		if (!this._animating) {\n			this._animating = true;\n			this._prepareBgBuffer();\n		}\n\n		var bg = this._bgBuffer,\n		    transform = L.DomUtil.TRANSFORM,\n		    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],\n		    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);\n\n		bg.style[transform] = e.backwards ?\n				scaleStr + ' ' + initialTransform :\n				initialTransform + ' ' + scaleStr;\n	},\n\n	_endZoomAnim: function () {\n		var front = this._tileContainer,\n		    bg = this._bgBuffer;\n\n		front.style.visibility = '';\n		front.parentNode.appendChild(front); // Bring to fore\n\n		// force reflow\n		L.Util.falseFn(bg.offsetWidth);\n\n		this._animating = false;\n	},\n\n	_clearBgBuffer: function () {\n		var map = this._map;\n\n		if (map && !map._animatingZoom && !map.touchZoom._zooming) {\n			this._bgBuffer.innerHTML = '';\n			this._bgBuffer.style[L.DomUtil.TRANSFORM] = '';\n		}\n	},\n\n	_prepareBgBuffer: function () {\n\n		var front = this._tileContainer,\n		    bg = this._bgBuffer;\n\n		// if foreground layer doesn't have many tiles but bg layer does,\n		// keep the existing bg layer and just zoom it some more\n\n		var bgLoaded = this._getLoadedTilesPercentage(bg),\n		    frontLoaded = this._getLoadedTilesPercentage(front);\n\n		if (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {\n\n			front.style.visibility = 'hidden';\n			this._stopLoadingImages(front);\n			return;\n		}\n\n		// prepare the buffer to become the front tile pane\n		bg.style.visibility = 'hidden';\n		bg.style[L.DomUtil.TRANSFORM] = '';\n\n		// switch out the current layer to be the new bg layer (and vice-versa)\n		this._tileContainer = bg;\n		bg = this._bgBuffer = front;\n\n		this._stopLoadingImages(bg);\n\n		//prevent bg buffer from clearing right after zoom\n		clearTimeout(this._clearBgBufferTimer);\n	},\n\n	_getLoadedTilesPercentage: function (container) {\n		var tiles = container.getElementsByTagName('img'),\n		    i, len, count = 0;\n\n		for (i = 0, len = tiles.length; i < len; i++) {\n			if (tiles[i].complete) {\n				count++;\n			}\n		}\n		return count / len;\n	},\n\n	// stops loading all tiles in the background layer\n	_stopLoadingImages: function (container) {\n		var tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),\n		    i, len, tile;\n\n		for (i = 0, len = tiles.length; i < len; i++) {\n			tile = tiles[i];\n\n			if (!tile.complete) {\n				tile.onload = L.Util.falseFn;\n				tile.onerror = L.Util.falseFn;\n				tile.src = L.Util.emptyImageUrl;\n\n				tile.parentNode.removeChild(tile);\n			}\n		}\n	}\n});\n\n\n/*\r\n * Provides L.Map with convenient shortcuts for using browser geolocation features.\r\n */\r\n\r\nL.Map.include({\r\n	_defaultLocateOptions: {\r\n		watch: false,\r\n		setView: false,\r\n		maxZoom: Infinity,\r\n		timeout: 10000,\r\n		maximumAge: 0,\r\n		enableHighAccuracy: false\r\n	},\r\n\r\n	locate: function (/*Object*/ options) {\r\n\r\n		options = this._locateOptions = L.extend(this._defaultLocateOptions, options);\r\n\r\n		if (!navigator.geolocation) {\r\n			this._handleGeolocationError({\r\n				code: 0,\r\n				message: 'Geolocation not supported.'\r\n			});\r\n			return this;\r\n		}\r\n\r\n		var onResponse = L.bind(this._handleGeolocationResponse, this),\r\n			onError = L.bind(this._handleGeolocationError, this);\r\n\r\n		if (options.watch) {\r\n			this._locationWatchId =\r\n			        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n		} else {\r\n			navigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n		}\r\n		return this;\r\n	},\r\n\r\n	stopLocate: function () {\r\n		if (navigator.geolocation) {\r\n			navigator.geolocation.clearWatch(this._locationWatchId);\r\n		}\r\n		if (this._locateOptions) {\r\n			this._locateOptions.setView = false;\r\n		}\r\n		return this;\r\n	},\r\n\r\n	_handleGeolocationError: function (error) {\r\n		var c = error.code,\r\n		    message = error.message ||\r\n		            (c === 1 ? 'permission denied' :\r\n		            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\r\n		if (this._locateOptions.setView && !this._loaded) {\r\n			this.fitWorld();\r\n		}\r\n\r\n		this.fire('locationerror', {\r\n			code: c,\r\n			message: 'Geolocation error: ' + message + '.'\r\n		});\r\n	},\r\n\r\n	_handleGeolocationResponse: function (pos) {\r\n		var lat = pos.coords.latitude,\r\n		    lng = pos.coords.longitude,\r\n		    latlng = new L.LatLng(lat, lng),\r\n\r\n		    latAccuracy = 180 * pos.coords.accuracy / 40075017,\r\n		    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),\r\n\r\n		    bounds = L.latLngBounds(\r\n		            [lat - latAccuracy, lng - lngAccuracy],\r\n		            [lat + latAccuracy, lng + lngAccuracy]),\r\n\r\n		    options = this._locateOptions;\r\n\r\n		if (options.setView) {\r\n			var zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);\r\n			this.setView(latlng, zoom);\r\n		}\r\n\r\n		var data = {\r\n			latlng: latlng,\r\n			bounds: bounds,\r\n			timestamp: pos.timestamp\r\n		};\r\n\r\n		for (var i in pos.coords) {\r\n			if (typeof pos.coords[i] === 'number') {\r\n				data[i] = pos.coords[i];\r\n			}\r\n		}\r\n\r\n		this.fire('locationfound', data);\r\n	}\r\n});\r\n\n\n}(window, document));//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5qcz82MTQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGLGdDQUFnQztBQUNoQzs7QUFFQTs7QUFFQTs7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsVUFBVSxRQUFROztBQUVsQjs7QUFFQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNB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RUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUEsNEJBQTRCO0FBQzVCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFNBQVM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsbUJBQW1CLFFBQVE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFD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QTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLDhDQUE4QztBQUM5QztBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIsdUJBQXVCO0FBQ25ELEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsZ0NBQWdDLFFBQVE7O0FBRXhDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsUUFBUTs7QUFFM0Isd0dBQXdHLFFBQVE7O0FBRWhIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxlQUFlLGNBQWM7O0FBRTdCO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxhQUFhO0FBQzdDLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxhQUFhO0FBQ2hELEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSx5REFBeUQsUUFBUTs7QUFFakU7QUFDQSxFQUFFOztBQUVGO0FBQ0Esd0NBQXdDLFFBQVE7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGVBQWU7QUFDbkM7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLENBQUM7O0FBRUQsa0RBQWtEO0FBQ2xEO0FBQ0EsdUJBQXVCLFFBQVE7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRCw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLDZCQUE2QixRQUFROztBQUVyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSwrQ0FBK0MsUUFBUTs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsZUFBZTtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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Q0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsUUFBUTs7QUFFN0I7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7O0FBRUEsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLFFBQVE7O0FBRXBDLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEOztBQUVBLGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1EQUFtRCxRQUFROztBQUUzRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxTQUFTOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsb0NBQW9DO0FBQ3BDO0FBQ0Es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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0Esc0JBQXNCLFFBQVE7O0FBRTlCO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsdUJBQXVCLFFBQVE7O0FBRS9CO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsUUFBUTs7QUFFdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0dBQW9HLFFBQVE7O0FBRTVHLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQSxvRkFBb0YsUUFBUTs7QUFFNUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBLCtEQUErRCxRQUFROztBQUV2RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLFFBQVE7O0FBRWxDO0FBQ0E7QUFDQSxpRUFBaUUsUUFBUTtBQUN6RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsbUJBQW1CLFFBQVE7O0FBRTNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQSw2REFBNkQsY0FBYzs7QUFFM0U7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpREFBaUQsUUFBUTs7QUFFekQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0Esc0JBQXNCLFFBQVE7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0RBQWtELFFBQVE7O0FBRTFEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUEsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGNBQWMsUUFBUTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0EsY0FBYyxRQUFROztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxtQkFBbUIsUUFBUTs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsYUFBYSxRQUFROztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLDBCQUEwQixRQUFROztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFF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QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsU0FBUztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxDQUFDIiwiZmlsZSI6IjEwNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gTGVhZmxldCwgYSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIG1vYmlsZS1mcmllbmRseSBpbnRlcmFjdGl2ZSBtYXBzLiBodHRwOi8vbGVhZmxldGpzLmNvbVxuIChjKSAyMDEwLTIwMTMsIFZsYWRpbWlyIEFnYWZvbmtpblxuIChjKSAyMDEwLTIwMTEsIENsb3VkTWFkZVxuKi9cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XHJcbnZhciBvbGRMID0gd2luZG93LkwsXHJcbiAgICBMID0ge307XHJcblxyXG5MLnZlcnNpb24gPSAnMC43LjInO1xyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgZm9yIE5vZGUgbW9kdWxlIHBhdHRlcm4gbG9hZGVycywgaW5jbHVkaW5nIEJyb3dzZXJpZnlcclxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IEw7XHJcblxyXG4vLyBkZWZpbmUgTGVhZmxldCBhcyBhbiBBTUQgbW9kdWxlXHJcbn0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcblx0ZGVmaW5lKEwpO1xyXG59XHJcblxyXG4vLyBkZWZpbmUgTGVhZmxldCBhcyBhIGdsb2JhbCBMIHZhcmlhYmxlLCBzYXZpbmcgdGhlIG9yaWdpbmFsIEwgdG8gcmVzdG9yZSBsYXRlciBpZiBuZWVkZWRcclxuXHJcbkwubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcclxuXHR3aW5kb3cuTCA9IG9sZEw7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG53aW5kb3cuTCA9IEw7XHJcblxuXG4vKlxyXG4gKiBMLlV0aWwgY29udGFpbnMgdmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIHRocm91Z2hvdXQgTGVhZmxldCBjb2RlLlxyXG4gKi9cclxuXHJcbkwuVXRpbCA9IHtcclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChkZXN0KSB7IC8vIChPYmplY3RbLCBPYmplY3QsIC4uLl0pIC0+XHJcblx0XHR2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcblx0XHQgICAgaSwgaiwgbGVuLCBzcmM7XHJcblxyXG5cdFx0Zm9yIChqID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xyXG5cdFx0XHRzcmMgPSBzb3VyY2VzW2pdIHx8IHt9O1xyXG5cdFx0XHRmb3IgKGkgaW4gc3JjKSB7XHJcblx0XHRcdFx0aWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG5cdFx0XHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBkZXN0O1xyXG5cdH0sXHJcblxyXG5cdGJpbmQ6IGZ1bmN0aW9uIChmbiwgb2JqKSB7IC8vIChGdW5jdGlvbiwgT2JqZWN0KSAtPiBGdW5jdGlvblxyXG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiBudWxsO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncyB8fCBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRzdGFtcDogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXN0SWQgPSAwLFxyXG5cdFx0ICAgIGtleSA9ICdfbGVhZmxldF9pZCc7XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0XHRvYmpba2V5XSA9IG9ialtrZXldIHx8ICsrbGFzdElkO1xyXG5cdFx0XHRyZXR1cm4gb2JqW2tleV07XHJcblx0XHR9O1xyXG5cdH0oKSksXHJcblxyXG5cdGludm9rZUVhY2g6IGZ1bmN0aW9uIChvYmosIG1ldGhvZCwgY29udGV4dCkge1xyXG5cdFx0dmFyIGksIGFyZ3M7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xyXG5cclxuXHRcdFx0Zm9yIChpIGluIG9iaikge1xyXG5cdFx0XHRcdG1ldGhvZC5hcHBseShjb250ZXh0LCBbaSwgb2JqW2ldXS5jb25jYXQoYXJncykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRsaW1pdEV4ZWNCeUludGVydmFsOiBmdW5jdGlvbiAoZm4sIHRpbWUsIGNvbnRleHQpIHtcclxuXHRcdHZhciBsb2NrLCBleGVjT25VbmxvY2s7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHdyYXBwZXJGbigpIHtcclxuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG5cdFx0XHRpZiAobG9jaykge1xyXG5cdFx0XHRcdGV4ZWNPblVubG9jayA9IHRydWU7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsb2NrID0gdHJ1ZTtcclxuXHJcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdGxvY2sgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0aWYgKGV4ZWNPblVubG9jaykge1xyXG5cdFx0XHRcdFx0d3JhcHBlckZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG5cdFx0XHRcdFx0ZXhlY09uVW5sb2NrID0gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCB0aW1lKTtcclxuXHJcblx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRmYWxzZUZuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Zm9ybWF0TnVtOiBmdW5jdGlvbiAobnVtLCBkaWdpdHMpIHtcclxuXHRcdHZhciBwb3cgPSBNYXRoLnBvdygxMCwgZGlnaXRzIHx8IDUpO1xyXG5cdFx0cmV0dXJuIE1hdGgucm91bmQobnVtICogcG93KSAvIHBvdztcclxuXHR9LFxyXG5cclxuXHR0cmltOiBmdW5jdGlvbiAoc3RyKSB7XHJcblx0XHRyZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxuXHR9LFxyXG5cclxuXHRzcGxpdFdvcmRzOiBmdW5jdGlvbiAoc3RyKSB7XHJcblx0XHRyZXR1cm4gTC5VdGlsLnRyaW0oc3RyKS5zcGxpdCgvXFxzKy8pO1xyXG5cdH0sXHJcblxyXG5cdHNldE9wdGlvbnM6IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMpIHtcclxuXHRcdG9iai5vcHRpb25zID0gTC5leHRlbmQoe30sIG9iai5vcHRpb25zLCBvcHRpb25zKTtcclxuXHRcdHJldHVybiBvYmoub3B0aW9ucztcclxuXHR9LFxyXG5cclxuXHRnZXRQYXJhbVN0cmluZzogZnVuY3Rpb24gKG9iaiwgZXhpc3RpbmdVcmwsIHVwcGVyY2FzZSkge1xyXG5cdFx0dmFyIHBhcmFtcyA9IFtdO1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuXHRcdFx0cGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHVwcGVyY2FzZSA/IGkudG9VcHBlckNhc2UoKSA6IGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcblx0fSxcclxuXHR0ZW1wbGF0ZTogZnVuY3Rpb24gKHN0ciwgZGF0YSkge1xyXG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9cXHsgKihbXFx3X10rKSAqXFx9L2csIGZ1bmN0aW9uIChzdHIsIGtleSkge1xyXG5cdFx0XHR2YXIgdmFsdWUgPSBkYXRhW2tleV07XHJcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB2YWx1ZSBwcm92aWRlZCBmb3IgdmFyaWFibGUgJyArIHN0cik7XHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZShkYXRhKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdmFsdWU7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG5cdH0sXHJcblxyXG5cdGVtcHR5SW1hZ2VVcmw6ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9J1xyXG59O1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcblx0Ly8gaW5zcGlyZWQgYnkgaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcblx0ZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG5cdFx0dmFyIGksIGZuLFxyXG5cdFx0ICAgIHByZWZpeGVzID0gWyd3ZWJraXQnLCAnbW96JywgJ28nLCAnbXMnXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoICYmICFmbjsgaSsrKSB7XHJcblx0XHRcdGZuID0gd2luZG93W3ByZWZpeGVzW2ldICsgbmFtZV07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZuO1xyXG5cdH1cclxuXHJcblx0dmFyIGxhc3RUaW1lID0gMDtcclxuXHJcblx0ZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcblx0XHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG5cdFx0ICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lIC0gbGFzdFRpbWUpKTtcclxuXHJcblx0XHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG5cdFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxuXHR9XHJcblxyXG5cdHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcblx0ICAgICAgICBnZXRQcmVmaXhlZCgnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgdGltZW91dERlZmVyO1xyXG5cclxuXHR2YXIgY2FuY2VsRm4gPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcclxuXHQgICAgICAgIGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcblx0ICAgICAgICBnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHxcclxuXHQgICAgICAgIGZ1bmN0aW9uIChpZCkgeyB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTsgfTtcclxuXHJcblxyXG5cdEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lID0gZnVuY3Rpb24gKGZuLCBjb250ZXh0LCBpbW1lZGlhdGUsIGVsZW1lbnQpIHtcclxuXHRcdGZuID0gTC5iaW5kKGZuLCBjb250ZXh0KTtcclxuXHJcblx0XHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcblx0XHRcdGZuKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBmbiwgZWxlbWVudCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0aWYgKGlkKSB7XHJcblx0XHRcdGNhbmNlbEZuLmNhbGwod2luZG93LCBpZCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcbn0oKSk7XHJcblxyXG4vLyBzaG9ydGN1dHMgZm9yIG1vc3QgdXNlZCB1dGlsaXR5IGZ1bmN0aW9uc1xyXG5MLmV4dGVuZCA9IEwuVXRpbC5leHRlbmQ7XHJcbkwuYmluZCA9IEwuVXRpbC5iaW5kO1xyXG5MLnN0YW1wID0gTC5VdGlsLnN0YW1wO1xyXG5MLnNldE9wdGlvbnMgPSBMLlV0aWwuc2V0T3B0aW9ucztcclxuXG5cbi8qXHJcbiAqIEwuQ2xhc3MgcG93ZXJzIHRoZSBPT1AgZmFjaWxpdGllcyBvZiB0aGUgbGlicmFyeS5cclxuICogVGhhbmtzIHRvIEpvaG4gUmVzaWcgYW5kIERlYW4gRWR3YXJkcyBmb3IgaW5zcGlyYXRpb24hXHJcbiAqL1xyXG5cclxuTC5DbGFzcyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuTC5DbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0Ly8gZXh0ZW5kZWQgY2xhc3Mgd2l0aCB0aGUgbmV3IHByb3RvdHlwZVxyXG5cdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG5cdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG5cdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG5cdFx0aWYgKHRoaXMuX2luaXRIb29rcykge1xyXG5cdFx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyBpbnN0YW50aWF0ZSBjbGFzcyB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3JcclxuXHR2YXIgRiA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdEYucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG5cdHZhciBwcm90byA9IG5ldyBGKCk7XHJcblx0cHJvdG8uY29uc3RydWN0b3IgPSBOZXdDbGFzcztcclxuXHJcblx0TmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG5cdC8vaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcblx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcblx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAncHJvdG90eXBlJykge1xyXG5cdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuXHRpZiAocHJvcHMuc3RhdGljcykge1xyXG5cdFx0TC5leHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLnN0YXRpY3M7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggaW5jbHVkZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcblx0XHRMLlV0aWwuZXh0ZW5kLmFwcGx5KG51bGwsIFtwcm90b10uY29uY2F0KHByb3BzLmluY2x1ZGVzKSk7XHJcblx0XHRkZWxldGUgcHJvcHMuaW5jbHVkZXM7XHJcblx0fVxyXG5cclxuXHQvLyBtZXJnZSBvcHRpb25zXHJcblx0aWYgKHByb3BzLm9wdGlvbnMgJiYgcHJvdG8ub3B0aW9ucykge1xyXG5cdFx0cHJvcHMub3B0aW9ucyA9IEwuZXh0ZW5kKHt9LCBwcm90by5vcHRpb25zLCBwcm9wcy5vcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdC8vIG1peCBnaXZlbiBwcm9wZXJ0aWVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdEwuZXh0ZW5kKHByb3RvLCBwcm9wcyk7XHJcblxyXG5cdHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcblx0dmFyIHBhcmVudCA9IHRoaXM7XHJcblx0Ly8ganNoaW50IGNhbWVsY2FzZTogZmFsc2VcclxuXHROZXdDbGFzcy5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xyXG5cclxuXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG5cdHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRIb29rc0NhbGxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAocGFyZW50LnByb3RvdHlwZS5jYWxsSW5pdEhvb2tzKSB7XHJcblx0XHRcdHBhcmVudC5wcm90b3R5cGUuY2FsbEluaXRIb29rcy5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRIb29rc0NhbGxlZCA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3RvLl9pbml0SG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiBOZXdDbGFzcztcclxufTtcclxuXHJcblxyXG4vLyBtZXRob2QgZm9yIGFkZGluZyBwcm9wZXJ0aWVzIHRvIHByb3RvdHlwZVxyXG5MLkNsYXNzLmluY2x1ZGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHRMLmV4dGVuZCh0aGlzLnByb3RvdHlwZSwgcHJvcHMpO1xyXG59O1xyXG5cclxuLy8gbWVyZ2UgbmV3IGRlZmF1bHQgb3B0aW9ucyB0byB0aGUgQ2xhc3NcclxuTC5DbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdEwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLy8gYWRkIGEgY29uc3RydWN0b3IgaG9va1xyXG5MLkNsYXNzLmFkZEluaXRIb29rID0gZnVuY3Rpb24gKGZuKSB7IC8vIChGdW5jdGlvbikgfHwgKFN0cmluZywgYXJncy4uLilcclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG5cdHZhciBpbml0ID0gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8gZm4gOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzW2ZuXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHR9O1xyXG5cclxuXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzID0gdGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyB8fCBbXTtcclxuXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzLnB1c2goaW5pdCk7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLk1peGluLkV2ZW50cyBpcyB1c2VkIHRvIGFkZCBjdXN0b20gZXZlbnRzIGZ1bmN0aW9uYWxpdHkgdG8gTGVhZmxldCBjbGFzc2VzLlxyXG4gKi9cclxuXHJcbnZhciBldmVudHNLZXkgPSAnX2xlYWZsZXRfZXZlbnRzJztcclxuXHJcbkwuTWl4aW4gPSB7fTtcclxuXHJcbkwuTWl4aW4uRXZlbnRzID0ge1xyXG5cclxuXHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7IC8vIChTdHJpbmcsIEZ1bmN0aW9uWywgT2JqZWN0XSkgb3IgKE9iamVjdFssIE9iamVjdF0pXHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAoTC5VdGlsLmludm9rZUVhY2godHlwZXMsIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciwgdGhpcywgZm4sIGNvbnRleHQpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGV2ZW50cyA9IHRoaXNbZXZlbnRzS2V5XSA9IHRoaXNbZXZlbnRzS2V5XSB8fCB7fSxcclxuXHRcdCAgICBjb250ZXh0SWQgPSBjb250ZXh0ICYmIGNvbnRleHQgIT09IHRoaXMgJiYgTC5zdGFtcChjb250ZXh0KSxcclxuXHRcdCAgICBpLCBsZW4sIGV2ZW50LCB0eXBlLCBpbmRleEtleSwgaW5kZXhMZW5LZXksIHR5cGVJbmRleDtcclxuXHJcblx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHR0eXBlcyA9IEwuVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRldmVudCA9IHtcclxuXHRcdFx0XHRhY3Rpb246IGZuLFxyXG5cdFx0XHRcdGNvbnRleHQ6IGNvbnRleHQgfHwgdGhpc1xyXG5cdFx0XHR9O1xyXG5cdFx0XHR0eXBlID0gdHlwZXNbaV07XHJcblxyXG5cdFx0XHRpZiAoY29udGV4dElkKSB7XHJcblx0XHRcdFx0Ly8gc3RvcmUgbGlzdGVuZXJzIG9mIGEgcGFydGljdWxhciBjb250ZXh0IGluIGEgc2VwYXJhdGUgaGFzaCAoaWYgaXQgaGFzIGFuIGlkKVxyXG5cdFx0XHRcdC8vIGdpdmVzIGEgbWFqb3IgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiByZW1vdmluZyB0aG91c2FuZHMgb2YgbWFwIGxheWVyc1xyXG5cclxuXHRcdFx0XHRpbmRleEtleSA9IHR5cGUgKyAnX2lkeCc7XHJcblx0XHRcdFx0aW5kZXhMZW5LZXkgPSBpbmRleEtleSArICdfbGVuJztcclxuXHJcblx0XHRcdFx0dHlwZUluZGV4ID0gZXZlbnRzW2luZGV4S2V5XSA9IGV2ZW50c1tpbmRleEtleV0gfHwge307XHJcblxyXG5cdFx0XHRcdGlmICghdHlwZUluZGV4W2NvbnRleHRJZF0pIHtcclxuXHRcdFx0XHRcdHR5cGVJbmRleFtjb250ZXh0SWRdID0gW107XHJcblxyXG5cdFx0XHRcdFx0Ly8ga2VlcCB0cmFjayBvZiB0aGUgbnVtYmVyIG9mIGtleXMgaW4gdGhlIGluZGV4IHRvIHF1aWNrbHkgY2hlY2sgaWYgaXQncyBlbXB0eVxyXG5cdFx0XHRcdFx0ZXZlbnRzW2luZGV4TGVuS2V5XSA9IChldmVudHNbaW5kZXhMZW5LZXldIHx8IDApICsgMTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHR5cGVJbmRleFtjb250ZXh0SWRdLnB1c2goZXZlbnQpO1xyXG5cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZXZlbnRzW3R5cGVdID0gZXZlbnRzW3R5cGVdIHx8IFtdO1xyXG5cdFx0XHRcdGV2ZW50c1t0eXBlXS5wdXNoKGV2ZW50KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGhhc0V2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAodHlwZSkgeyAvLyAoU3RyaW5nKSAtPiBCb29sZWFuXHJcblx0XHR2YXIgZXZlbnRzID0gdGhpc1tldmVudHNLZXldO1xyXG5cdFx0cmV0dXJuICEhZXZlbnRzICYmICgodHlwZSBpbiBldmVudHMgJiYgZXZlbnRzW3R5cGVdLmxlbmd0aCA+IDApIHx8XHJcblx0XHQgICAgICAgICAgICAgICAgICAgICh0eXBlICsgJ19pZHgnIGluIGV2ZW50cyAmJiBldmVudHNbdHlwZSArICdfaWR4X2xlbiddID4gMCkpO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHsgLy8gKFtTdHJpbmcsIEZ1bmN0aW9uLCBPYmplY3RdKSBvciAoT2JqZWN0WywgT2JqZWN0XSlcclxuXHJcblx0XHRpZiAoIXRoaXNbZXZlbnRzS2V5XSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXR5cGVzKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoTC5VdGlsLmludm9rZUVhY2godHlwZXMsIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciwgdGhpcywgZm4sIGNvbnRleHQpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGV2ZW50cyA9IHRoaXNbZXZlbnRzS2V5XSxcclxuXHRcdCAgICBjb250ZXh0SWQgPSBjb250ZXh0ICYmIGNvbnRleHQgIT09IHRoaXMgJiYgTC5zdGFtcChjb250ZXh0KSxcclxuXHRcdCAgICBpLCBsZW4sIHR5cGUsIGxpc3RlbmVycywgaiwgaW5kZXhLZXksIGluZGV4TGVuS2V5LCB0eXBlSW5kZXgsIHJlbW92ZWQ7XHJcblxyXG5cdFx0dHlwZXMgPSBMLlV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dHlwZSA9IHR5cGVzW2ldO1xyXG5cdFx0XHRpbmRleEtleSA9IHR5cGUgKyAnX2lkeCc7XHJcblx0XHRcdGluZGV4TGVuS2V5ID0gaW5kZXhLZXkgKyAnX2xlbic7XHJcblxyXG5cdFx0XHR0eXBlSW5kZXggPSBldmVudHNbaW5kZXhLZXldO1xyXG5cclxuXHRcdFx0aWYgKCFmbikge1xyXG5cdFx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgZm9yIGEgdHlwZSBpZiBmdW5jdGlvbiBpc24ndCBzcGVjaWZpZWRcclxuXHRcdFx0XHRkZWxldGUgZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbaW5kZXhLZXldO1xyXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbaW5kZXhMZW5LZXldO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsaXN0ZW5lcnMgPSBjb250ZXh0SWQgJiYgdHlwZUluZGV4ID8gdHlwZUluZGV4W2NvbnRleHRJZF0gOiBldmVudHNbdHlwZV07XHJcblxyXG5cdFx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHRcdFx0XHRcdGZvciAoaiA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG5cdFx0XHRcdFx0XHRpZiAoKGxpc3RlbmVyc1tqXS5hY3Rpb24gPT09IGZuKSAmJiAoIWNvbnRleHQgfHwgKGxpc3RlbmVyc1tqXS5jb250ZXh0ID09PSBjb250ZXh0KSkpIHtcclxuXHRcdFx0XHRcdFx0XHRyZW1vdmVkID0gbGlzdGVuZXJzLnNwbGljZShqLCAxKTtcclxuXHRcdFx0XHRcdFx0XHQvLyBzZXQgdGhlIG9sZCBhY3Rpb24gdG8gYSBuby1vcCwgYmVjYXVzZSBpdCBpcyBwb3NzaWJsZVxyXG5cdFx0XHRcdFx0XHRcdC8vIHRoYXQgdGhlIGxpc3RlbmVyIGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXIgYXMgcGFydCBvZiBhIGRpc3BhdGNoXHJcblx0XHRcdFx0XHRcdFx0cmVtb3ZlZFswXS5hY3Rpb24gPSBMLlV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChjb250ZXh0ICYmIHR5cGVJbmRleCAmJiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkpIHtcclxuXHRcdFx0XHRcdFx0ZGVsZXRlIHR5cGVJbmRleFtjb250ZXh0SWRdO1xyXG5cdFx0XHRcdFx0XHRldmVudHNbaW5kZXhMZW5LZXldLS07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Y2xlYXJBbGxFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0ZGVsZXRlIHRoaXNbZXZlbnRzS2V5XTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGZpcmVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHsgLy8gKFN0cmluZ1ssIE9iamVjdF0pXHJcblx0XHRpZiAoIXRoaXMuaGFzRXZlbnRMaXN0ZW5lcnModHlwZSkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGV2ZW50ID0gTC5VdGlsLmV4dGVuZCh7fSwgZGF0YSwgeyB0eXBlOiB0eXBlLCB0YXJnZXQ6IHRoaXMgfSk7XHJcblxyXG5cdFx0dmFyIGV2ZW50cyA9IHRoaXNbZXZlbnRzS2V5XSxcclxuXHRcdCAgICBsaXN0ZW5lcnMsIGksIGxlbiwgdHlwZUluZGV4LCBjb250ZXh0SWQ7XHJcblxyXG5cdFx0aWYgKGV2ZW50c1t0eXBlXSkge1xyXG5cdFx0XHQvLyBtYWtlIHN1cmUgYWRkaW5nL3JlbW92aW5nIGxpc3RlbmVycyBpbnNpZGUgb3RoZXIgbGlzdGVuZXJzIHdvbid0IGNhdXNlIGluZmluaXRlIGxvb3BcclxuXHRcdFx0bGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdLnNsaWNlKCk7XHJcblxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRsaXN0ZW5lcnNbaV0uYWN0aW9uLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGV2ZW50KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZpcmUgZXZlbnQgZm9yIHRoZSBjb250ZXh0LWluZGV4ZWQgbGlzdGVuZXJzIGFzIHdlbGxcclxuXHRcdHR5cGVJbmRleCA9IGV2ZW50c1t0eXBlICsgJ19pZHgnXTtcclxuXHJcblx0XHRmb3IgKGNvbnRleHRJZCBpbiB0eXBlSW5kZXgpIHtcclxuXHRcdFx0bGlzdGVuZXJzID0gdHlwZUluZGV4W2NvbnRleHRJZF0uc2xpY2UoKTtcclxuXHJcblx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdGxpc3RlbmVyc1tpXS5hY3Rpb24uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgZXZlbnQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGFkZE9uZVRpbWVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKEwuVXRpbC5pbnZva2VFYWNoKHR5cGVzLCB0aGlzLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyLCB0aGlzLCBmbiwgY29udGV4dCkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IEwuYmluZChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdFx0ICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzXHJcblx0XHQgICAgLmFkZEV2ZW50TGlzdGVuZXIodHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0ICAgIC5hZGRFdmVudExpc3RlbmVyKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHR9XHJcbn07XHJcblxyXG5MLk1peGluLkV2ZW50cy5vbiA9IEwuTWl4aW4uRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXI7XHJcbkwuTWl4aW4uRXZlbnRzLm9mZiA9IEwuTWl4aW4uRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXI7XHJcbkwuTWl4aW4uRXZlbnRzLm9uY2UgPSBMLk1peGluLkV2ZW50cy5hZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcjtcclxuTC5NaXhpbi5FdmVudHMuZmlyZSA9IEwuTWl4aW4uRXZlbnRzLmZpcmVFdmVudDtcclxuXG5cbi8qXHJcbiAqIEwuQnJvd3NlciBoYW5kbGVzIGRpZmZlcmVudCBicm93c2VyIGFuZCBmZWF0dXJlIGRldGVjdGlvbnMgZm9yIGludGVybmFsIExlYWZsZXQgdXNlLlxyXG4gKi9cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3csXHJcblx0XHRpZWx0OSA9IGllICYmICFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLFxyXG5cclxuXHQgICAgLy8gdGVycmlibGUgYnJvd3NlciBkZXRlY3Rpb24gdG8gd29yayBhcm91bmQgU2FmYXJpIC8gaU9TIC8gQW5kcm9pZCBicm93c2VyIGJ1Z3NcclxuXHQgICAgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXHJcblx0ICAgIHdlYmtpdCA9IHVhLmluZGV4T2YoJ3dlYmtpdCcpICE9PSAtMSxcclxuXHQgICAgY2hyb21lID0gdWEuaW5kZXhPZignY2hyb21lJykgIT09IC0xLFxyXG5cdCAgICBwaGFudG9tanMgPSB1YS5pbmRleE9mKCdwaGFudG9tJykgIT09IC0xLFxyXG5cdCAgICBhbmRyb2lkID0gdWEuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSxcclxuXHQgICAgYW5kcm9pZDIzID0gdWEuc2VhcmNoKCdhbmRyb2lkIFsyM10nKSAhPT0gLTEsXHJcblx0XHRnZWNrbyA9IHVhLmluZGV4T2YoJ2dlY2tvJykgIT09IC0xLFxyXG5cclxuXHQgICAgbW9iaWxlID0gdHlwZW9mIG9yaWVudGF0aW9uICE9PSB1bmRlZmluZWQgKyAnJyxcclxuXHQgICAgbXNQb2ludGVyID0gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgJiZcclxuXHQgICAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyAmJiAhd2luZG93LlBvaW50ZXJFdmVudCxcclxuXHRcdHBvaW50ZXIgPSAod2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkICYmIHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMpIHx8XHJcblx0XHRcdFx0ICBtc1BvaW50ZXIsXHJcblx0ICAgIHJldGluYSA9ICgnZGV2aWNlUGl4ZWxSYXRpbycgaW4gd2luZG93ICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMSkgfHxcclxuXHQgICAgICAgICAgICAgKCdtYXRjaE1lZGlhJyBpbiB3aW5kb3cgJiYgd2luZG93Lm1hdGNoTWVkaWEoJyhtaW4tcmVzb2x1dGlvbjoxNDRkcGkpJykgJiZcclxuXHQgICAgICAgICAgICAgIHdpbmRvdy5tYXRjaE1lZGlhKCcobWluLXJlc29sdXRpb246MTQ0ZHBpKScpLm1hdGNoZXMpLFxyXG5cclxuXHQgICAgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxyXG5cdCAgICBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBkb2Muc3R5bGUpLFxyXG5cdCAgICB3ZWJraXQzZCA9ICgnV2ViS2l0Q1NTTWF0cml4JyBpbiB3aW5kb3cpICYmICgnbTExJyBpbiBuZXcgd2luZG93LldlYktpdENTU01hdHJpeCgpKSAmJiAhYW5kcm9pZDIzLFxyXG5cdCAgICBnZWNrbzNkID0gJ01velBlcnNwZWN0aXZlJyBpbiBkb2Muc3R5bGUsXHJcblx0ICAgIG9wZXJhM2QgPSAnT1RyYW5zaXRpb24nIGluIGRvYy5zdHlsZSxcclxuXHQgICAgYW55M2QgPSAhd2luZG93LkxfRElTQUJMRV8zRCAmJiAoaWUzZCB8fCB3ZWJraXQzZCB8fCBnZWNrbzNkIHx8IG9wZXJhM2QpICYmICFwaGFudG9tanM7XHJcblxyXG5cclxuXHQvLyBQaGFudG9tSlMgaGFzICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgYnV0IGRvZXNuJ3QgYWN0dWFsbHkgc3VwcG9ydCB0b3VjaC5cclxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L3B1bGwvMTQzNCNpc3N1ZWNvbW1lbnQtMTM4NDMxNTFcclxuXHJcblx0dmFyIHRvdWNoID0gIXdpbmRvdy5MX05PX1RPVUNIICYmICFwaGFudG9tanMgJiYgKGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgc3RhcnROYW1lID0gJ29udG91Y2hzdGFydCc7XHJcblxyXG5cdFx0Ly8gSUUxMCsgKFdlIHNpbXVsYXRlIHRoZXNlIGludG8gdG91Y2gqIGV2ZW50cyBpbiBMLkRvbUV2ZW50IGFuZCBMLkRvbUV2ZW50LlBvaW50ZXIpIG9yIFdlYktpdCwgZXRjLlxyXG5cdFx0aWYgKHBvaW50ZXIgfHwgKHN0YXJ0TmFtZSBpbiBkb2MpKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpcmVmb3gvR2Vja29cclxuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcclxuXHRcdCAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoIWRpdi5zZXRBdHRyaWJ1dGUpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0ZGl2LnNldEF0dHJpYnV0ZShzdGFydE5hbWUsICdyZXR1cm47Jyk7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBkaXZbc3RhcnROYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRzdXBwb3J0ZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRpdi5yZW1vdmVBdHRyaWJ1dGUoc3RhcnROYW1lKTtcclxuXHRcdGRpdiA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHN1cHBvcnRlZDtcclxuXHR9KCkpO1xyXG5cclxuXHJcblx0TC5Ccm93c2VyID0ge1xyXG5cdFx0aWU6IGllLFxyXG5cdFx0aWVsdDk6IGllbHQ5LFxyXG5cdFx0d2Via2l0OiB3ZWJraXQsXHJcblx0XHRnZWNrbzogZ2Vja28gJiYgIXdlYmtpdCAmJiAhd2luZG93Lm9wZXJhICYmICFpZSxcclxuXHJcblx0XHRhbmRyb2lkOiBhbmRyb2lkLFxyXG5cdFx0YW5kcm9pZDIzOiBhbmRyb2lkMjMsXHJcblxyXG5cdFx0Y2hyb21lOiBjaHJvbWUsXHJcblxyXG5cdFx0aWUzZDogaWUzZCxcclxuXHRcdHdlYmtpdDNkOiB3ZWJraXQzZCxcclxuXHRcdGdlY2tvM2Q6IGdlY2tvM2QsXHJcblx0XHRvcGVyYTNkOiBvcGVyYTNkLFxyXG5cdFx0YW55M2Q6IGFueTNkLFxyXG5cclxuXHRcdG1vYmlsZTogbW9iaWxlLFxyXG5cdFx0bW9iaWxlV2Via2l0OiBtb2JpbGUgJiYgd2Via2l0LFxyXG5cdFx0bW9iaWxlV2Via2l0M2Q6IG1vYmlsZSAmJiB3ZWJraXQzZCxcclxuXHRcdG1vYmlsZU9wZXJhOiBtb2JpbGUgJiYgd2luZG93Lm9wZXJhLFxyXG5cclxuXHRcdHRvdWNoOiB0b3VjaCxcclxuXHRcdG1zUG9pbnRlcjogbXNQb2ludGVyLFxyXG5cdFx0cG9pbnRlcjogcG9pbnRlcixcclxuXHJcblx0XHRyZXRpbmE6IHJldGluYVxyXG5cdH07XHJcblxyXG59KCkpO1xyXG5cblxuLypcclxuICogTC5Qb2ludCByZXByZXNlbnRzIGEgcG9pbnQgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzLlxyXG4gKi9cclxuXHJcbkwuUG9pbnQgPSBmdW5jdGlvbiAoLypOdW1iZXIqLyB4LCAvKk51bWJlciovIHksIC8qQm9vbGVhbiovIHJvdW5kKSB7XHJcblx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG5cdHRoaXMueSA9IChyb3VuZCA/IE1hdGgucm91bmQoeSkgOiB5KTtcclxufTtcclxuXHJcbkwuUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBub24tZGVzdHJ1Y3RpdmUsIHJldHVybnMgYSBuZXcgcG9pbnRcclxuXHRhZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKEwucG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcblx0X2FkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR0aGlzLnggKz0gcG9pbnQueDtcclxuXHRcdHRoaXMueSArPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QoTC5wb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR0aGlzLnggLT0gcG9pbnQueDtcclxuXHRcdHRoaXMueSAtPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X2RpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggLz0gbnVtO1xyXG5cdFx0dGhpcy55IC89IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54ICo9IG51bTtcclxuXHRcdHRoaXMueSAqPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpO1xyXG5cdH0sXHJcblxyXG5cdF9mbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMueCxcclxuXHRcdCAgICB5ID0gcG9pbnQueSAtIHRoaXMueTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludC54ID09PSB0aGlzLnggJiZcclxuXHRcdCAgICAgICBwb2ludC55ID09PSB0aGlzLnk7XHJcblx0fSxcclxuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSBMLnBvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMocG9pbnQueCkgPD0gTWF0aC5hYnModGhpcy54KSAmJlxyXG5cdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAnUG9pbnQoJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG5cdFx0ICAgICAgICBMLlV0aWwuZm9ybWF0TnVtKHRoaXMueSkgKyAnKSc7XHJcblx0fVxyXG59O1xyXG5cclxuTC5wb2ludCA9IGZ1bmN0aW9uICh4LCB5LCByb3VuZCkge1xyXG5cdGlmICh4IGluc3RhbmNlb2YgTC5Qb2ludCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmIChMLlV0aWwuaXNBcnJheSh4KSkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHhbMF0sIHhbMV0pO1xyXG5cdH1cclxuXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGwpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEwuUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59O1xyXG5cblxuLypcclxuICogTC5Cb3VuZHMgcmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgb24gdGhlIHNjcmVlbiBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICovXHJcblxyXG5MLkJvdW5kcyA9IGZ1bmN0aW9uIChhLCBiKSB7IC8vKFBvaW50LCBQb2ludCkgb3IgUG9pbnRbXVxyXG5cdGlmICghYSkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIHBvaW50cyA9IGIgPyBbYSwgYl0gOiBhO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChwb2ludHNbaV0pO1xyXG5cdH1cclxufTtcclxuXHJcbkwuQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHQvLyBleHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cdGV4dGVuZDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHBvaW50ID0gTC5wb2ludChwb2ludCk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm1pbiAmJiAhdGhpcy5tYXgpIHtcclxuXHRcdFx0dGhpcy5taW4gPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0XHR0aGlzLm1heCA9IHBvaW50LmNsb25lKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm1pbi54ID0gTWF0aC5taW4ocG9pbnQueCwgdGhpcy5taW4ueCk7XHJcblx0XHRcdHRoaXMubWF4LnggPSBNYXRoLm1heChwb2ludC54LCB0aGlzLm1heC54KTtcclxuXHRcdFx0dGhpcy5taW4ueSA9IE1hdGgubWluKHBvaW50LnksIHRoaXMubWluLnkpO1xyXG5cdFx0XHR0aGlzLm1heC55ID0gTWF0aC5tYXgocG9pbnQueSwgdGhpcy5tYXgueSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uIChyb3VuZCkgeyAvLyAoQm9vbGVhbikgLT4gUG9pbnRcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi55ICsgdGhpcy5tYXgueSkgLyAyLCByb3VuZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0Qm90dG9tTGVmdDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFRvcFJpZ2h0OiBmdW5jdGlvbiAoKSB7IC8vIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcblx0fSxcclxuXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuXHR9LFxyXG5cclxuXHRjb250YWluczogZnVuY3Rpb24gKG9iaikgeyAvLyAoQm91bmRzKSBvciAoUG9pbnQpIC0+IEJvb2xlYW5cclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTC5Qb2ludCkge1xyXG5cdFx0XHRvYmogPSBMLnBvaW50KG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSBMLmJvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMLkJvdW5kcykge1xyXG5cdFx0XHRtaW4gPSBvYmoubWluO1xyXG5cdFx0XHRtYXggPSBvYmoubWF4O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSBMLmJvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG5cdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLm1pbiAmJiB0aGlzLm1heCk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5ib3VuZHMgPSBmdW5jdGlvbiAoYSwgYikgeyAvLyAoQm91bmRzKSBvciAoUG9pbnQsIFBvaW50KSBvciAoUG9pbnRbXSlcclxuXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEwuQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLkJvdW5kcyhhLCBiKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIEwuVHJhbnNmb3JtYXRpb24gaXMgYW4gdXRpbGl0eSBjbGFzcyB0byBwZXJmb3JtIHNpbXBsZSBwb2ludCB0cmFuc2Zvcm1hdGlvbnMgdGhyb3VnaCBhIDJkLW1hdHJpeC5cclxuICovXHJcblxyXG5MLlRyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuXHR0aGlzLl9hID0gYTtcclxuXHR0aGlzLl9iID0gYjtcclxuXHR0aGlzLl9jID0gYztcclxuXHR0aGlzLl9kID0gZDtcclxufTtcclxuXHJcbkwuVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkgeyAvLyAoUG9pbnQsIE51bWJlcikgLT4gUG9pbnRcclxuXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm0ocG9pbnQuY2xvbmUoKSwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGRlc3RydWN0aXZlIHRyYW5zZm9ybSAoZmFzdGVyKVxyXG5cdF90cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuXHRcdHBvaW50LnggPSBzY2FsZSAqICh0aGlzLl9hICogcG9pbnQueCArIHRoaXMuX2IpO1xyXG5cdFx0cG9pbnQueSA9IHNjYWxlICogKHRoaXMuX2MgKiBwb2ludC55ICsgdGhpcy5fZCk7XHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblx0fSxcclxuXHJcblx0dW50cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcblx0fVxyXG59O1xyXG5cblxuLypcclxuICogTC5Eb21VdGlsIGNvbnRhaW5zIHZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBET00uXHJcbiAqL1xyXG5cclxuTC5Eb21VdGlsID0ge1xyXG5cdGdldDogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0U3R5bGU6IGZ1bmN0aW9uIChlbCwgc3R5bGUpIHtcclxuXHJcblx0XHR2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV07XHJcblxyXG5cdFx0aWYgKCF2YWx1ZSAmJiBlbC5jdXJyZW50U3R5bGUpIHtcclxuXHRcdFx0dmFsdWUgPSBlbC5jdXJyZW50U3R5bGVbc3R5bGVdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgoIXZhbHVlIHx8IHZhbHVlID09PSAnYXV0bycpICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XHJcblx0XHRcdHZhciBjc3MgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuXHRcdFx0dmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWUgPT09ICdhdXRvJyA/IG51bGwgOiB2YWx1ZTtcclxuXHR9LFxyXG5cclxuXHRnZXRWaWV3cG9ydE9mZnNldDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuXHJcblx0XHR2YXIgdG9wID0gMCxcclxuXHRcdCAgICBsZWZ0ID0gMCxcclxuXHRcdCAgICBlbCA9IGVsZW1lbnQsXHJcblx0XHQgICAgZG9jQm9keSA9IGRvY3VtZW50LmJvZHksXHJcblx0XHQgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXHJcblx0XHQgICAgcG9zO1xyXG5cclxuXHRcdGRvIHtcclxuXHRcdFx0dG9wICArPSBlbC5vZmZzZXRUb3AgIHx8IDA7XHJcblx0XHRcdGxlZnQgKz0gZWwub2Zmc2V0TGVmdCB8fCAwO1xyXG5cclxuXHRcdFx0Ly9hZGQgYm9yZGVyc1xyXG5cdFx0XHR0b3AgKz0gcGFyc2VJbnQoTC5Eb21VdGlsLmdldFN0eWxlKGVsLCAnYm9yZGVyVG9wV2lkdGgnKSwgMTApIHx8IDA7XHJcblx0XHRcdGxlZnQgKz0gcGFyc2VJbnQoTC5Eb21VdGlsLmdldFN0eWxlKGVsLCAnYm9yZGVyTGVmdFdpZHRoJyksIDEwKSB8fCAwO1xyXG5cclxuXHRcdFx0cG9zID0gTC5Eb21VdGlsLmdldFN0eWxlKGVsLCAncG9zaXRpb24nKTtcclxuXHJcblx0XHRcdGlmIChlbC5vZmZzZXRQYXJlbnQgPT09IGRvY0JvZHkgJiYgcG9zID09PSAnYWJzb2x1dGUnKSB7IGJyZWFrOyB9XHJcblxyXG5cdFx0XHRpZiAocG9zID09PSAnZml4ZWQnKSB7XHJcblx0XHRcdFx0dG9wICArPSBkb2NCb2R5LnNjcm9sbFRvcCAgfHwgZG9jRWwuc2Nyb2xsVG9wICB8fCAwO1xyXG5cdFx0XHRcdGxlZnQgKz0gZG9jQm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsLnNjcm9sbExlZnQgfHwgMDtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHBvcyA9PT0gJ3JlbGF0aXZlJyAmJiAhZWwub2Zmc2V0TGVmdCkge1xyXG5cdFx0XHRcdHZhciB3aWR0aCA9IEwuRG9tVXRpbC5nZXRTdHlsZShlbCwgJ3dpZHRoJyksXHJcblx0XHRcdFx0ICAgIG1heFdpZHRoID0gTC5Eb21VdGlsLmdldFN0eWxlKGVsLCAnbWF4LXdpZHRoJyksXHJcblx0XHRcdFx0ICAgIHIgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcblx0XHRcdFx0aWYgKHdpZHRoICE9PSAnbm9uZScgfHwgbWF4V2lkdGggIT09ICdub25lJykge1xyXG5cdFx0XHRcdFx0bGVmdCArPSByLmxlZnQgKyBlbC5jbGllbnRMZWZ0O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly9jYWxjdWxhdGUgZnVsbCB5IG9mZnNldCBzaW5jZSB3ZSdyZSBicmVha2luZyBvdXQgb2YgdGhlIGxvb3BcclxuXHRcdFx0XHR0b3AgKz0gci50b3AgKyAoZG9jQm9keS5zY3JvbGxUb3AgIHx8IGRvY0VsLnNjcm9sbFRvcCAgfHwgMCk7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRlbCA9IGVsLm9mZnNldFBhcmVudDtcclxuXHJcblx0XHR9IHdoaWxlIChlbCk7XHJcblxyXG5cdFx0ZWwgPSBlbGVtZW50O1xyXG5cclxuXHRcdGRvIHtcclxuXHRcdFx0aWYgKGVsID09PSBkb2NCb2R5KSB7IGJyZWFrOyB9XHJcblxyXG5cdFx0XHR0b3AgIC09IGVsLnNjcm9sbFRvcCAgfHwgMDtcclxuXHRcdFx0bGVmdCAtPSBlbC5zY3JvbGxMZWZ0IHx8IDA7XHJcblxyXG5cdFx0XHRlbCA9IGVsLnBhcmVudE5vZGU7XHJcblx0XHR9IHdoaWxlIChlbCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KGxlZnQsIHRvcCk7XHJcblx0fSxcclxuXHJcblx0ZG9jdW1lbnRJc0x0cjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCFMLkRvbVV0aWwuX2RvY0lzTHRyQ2FjaGVkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5fZG9jSXNMdHJDYWNoZWQgPSB0cnVlO1xyXG5cdFx0XHRMLkRvbVV0aWwuX2RvY0lzTHRyID0gTC5Eb21VdGlsLmdldFN0eWxlKGRvY3VtZW50LmJvZHksICdkaXJlY3Rpb24nKSA9PT0gJ2x0cic7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gTC5Eb21VdGlsLl9kb2NJc0x0cjtcclxuXHR9LFxyXG5cclxuXHRjcmVhdGU6IGZ1bmN0aW9uICh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xyXG5cclxuXHRcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcblx0XHRlbC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XHJcblxyXG5cdFx0aWYgKGNvbnRhaW5lcikge1xyXG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBlbDtcclxuXHR9LFxyXG5cclxuXHRoYXNDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuXHRcdH1cclxuXHRcdHZhciBjbGFzc05hbWUgPSBMLkRvbVV0aWwuX2dldENsYXNzKGVsKTtcclxuXHRcdHJldHVybiBjbGFzc05hbWUubGVuZ3RoID4gMCAmJiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgbmFtZSArICcoXFxcXHN8JCknKS50ZXN0KGNsYXNzTmFtZSk7XHJcblx0fSxcclxuXHJcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHZhciBjbGFzc2VzID0gTC5VdGlsLnNwbGl0V29yZHMobmFtZSk7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICghTC5Eb21VdGlsLmhhc0NsYXNzKGVsLCBuYW1lKSkge1xyXG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gTC5Eb21VdGlsLl9nZXRDbGFzcyhlbCk7XHJcblx0XHRcdEwuRG9tVXRpbC5fc2V0Q2xhc3MoZWwsIChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuYW1lKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5fc2V0Q2xhc3MoZWwsIEwuVXRpbC50cmltKCgnICcgKyBMLkRvbVV0aWwuX2dldENsYXNzKGVsKSArICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3NldENsYXNzOiBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcclxuXHRcdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGVsLmNsYXNzTmFtZSA9IG5hbWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XHJcblx0XHRcdGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZ2V0Q2xhc3M6IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0cmV0dXJuIGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcclxuXHR9LFxyXG5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7XHJcblxyXG5cdFx0aWYgKCdvcGFjaXR5JyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0XHRlbC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XHJcblxyXG5cdFx0fSBlbHNlIGlmICgnZmlsdGVyJyBpbiBlbC5zdHlsZSkge1xyXG5cclxuXHRcdFx0dmFyIGZpbHRlciA9IGZhbHNlLFxyXG5cdFx0XHQgICAgZmlsdGVyTmFtZSA9ICdEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYSc7XHJcblxyXG5cdFx0XHQvLyBmaWx0ZXJzIGNvbGxlY3Rpb24gdGhyb3dzIGFuIGVycm9yIGlmIHdlIHRyeSB0byByZXRyaWV2ZSBhIGZpbHRlciB0aGF0IGRvZXNuJ3QgZXhpc3RcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRmaWx0ZXIgPSBlbC5maWx0ZXJzLml0ZW0oZmlsdGVyTmFtZSk7XHJcblx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHQvLyBkb24ndCBzZXQgb3BhY2l0eSB0byAxIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBzZXQgYW4gb3BhY2l0eSxcclxuXHRcdFx0XHQvLyBpdCBpc24ndCBuZWVkZWQgYW5kIGJyZWFrcyB0cmFuc3BhcmVudCBwbmdzLlxyXG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gMSkgeyByZXR1cm47IH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwKTtcclxuXHJcblx0XHRcdGlmIChmaWx0ZXIpIHtcclxuXHRcdFx0XHRmaWx0ZXIuRW5hYmxlZCA9ICh2YWx1ZSAhPT0gMTAwKTtcclxuXHRcdFx0XHRmaWx0ZXIuT3BhY2l0eSA9IHZhbHVlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGVsLnN0eWxlLmZpbHRlciArPSAnIHByb2dpZDonICsgZmlsdGVyTmFtZSArICcob3BhY2l0eT0nICsgdmFsdWUgKyAnKSc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR0ZXN0UHJvcDogZnVuY3Rpb24gKHByb3BzKSB7XHJcblxyXG5cdFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKHByb3BzW2ldIGluIHN0eWxlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHByb3BzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Z2V0VHJhbnNsYXRlU3RyaW5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIG9uIFdlYktpdCBicm93c2VycyAoQ2hyb21lL1NhZmFyaS9pT1MgU2FmYXJpL0FuZHJvaWQpIHVzaW5nIHRyYW5zbGF0ZTNkIGluc3RlYWQgb2YgdHJhbnNsYXRlXHJcblx0XHQvLyBtYWtlcyBhbmltYXRpb24gc21vb3RoZXIgYXMgaXQgZW5zdXJlcyBIVyBhY2NlbCBpcyB1c2VkLiBGaXJlZm94IDEzIGRvZXNuJ3QgY2FyZVxyXG5cdFx0Ly8gKHNhbWUgc3BlZWQgZWl0aGVyIHdheSksIE9wZXJhIDEyIGRvZXNuJ3Qgc3VwcG9ydCB0cmFuc2xhdGUzZFxyXG5cclxuXHRcdHZhciBpczNkID0gTC5Ccm93c2VyLndlYmtpdDNkLFxyXG5cdFx0ICAgIG9wZW4gPSAndHJhbnNsYXRlJyArIChpczNkID8gJzNkJyA6ICcnKSArICcoJyxcclxuXHRcdCAgICBjbG9zZSA9IChpczNkID8gJywwJyA6ICcnKSArICcpJztcclxuXHJcblx0XHRyZXR1cm4gb3BlbiArIHBvaW50LnggKyAncHgsJyArIHBvaW50LnkgKyAncHgnICsgY2xvc2U7XHJcblx0fSxcclxuXHJcblx0Z2V0U2NhbGVTdHJpbmc6IGZ1bmN0aW9uIChzY2FsZSwgb3JpZ2luKSB7XHJcblxyXG5cdFx0dmFyIHByZVRyYW5zbGF0ZVN0ciA9IEwuRG9tVXRpbC5nZXRUcmFuc2xhdGVTdHJpbmcob3JpZ2luLmFkZChvcmlnaW4ubXVsdGlwbHlCeSgtMSAqIHNjYWxlKSkpLFxyXG5cdFx0ICAgIHNjYWxlU3RyID0gJyBzY2FsZSgnICsgc2NhbGUgKyAnKSAnO1xyXG5cclxuXHRcdHJldHVybiBwcmVUcmFuc2xhdGVTdHIgKyBzY2FsZVN0cjtcclxuXHR9LFxyXG5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKGVsLCBwb2ludCwgZGlzYWJsZTNEKSB7IC8vIChIVE1MRWxlbWVudCwgUG9pbnRbLCBCb29sZWFuXSlcclxuXHJcblx0XHQvLyBqc2hpbnQgY2FtZWxjYXNlOiBmYWxzZVxyXG5cdFx0ZWwuX2xlYWZsZXRfcG9zID0gcG9pbnQ7XHJcblxyXG5cdFx0aWYgKCFkaXNhYmxlM0QgJiYgTC5Ccm93c2VyLmFueTNkKSB7XHJcblx0XHRcdGVsLnN0eWxlW0wuRG9tVXRpbC5UUkFOU0ZPUk1dID0gIEwuRG9tVXRpbC5nZXRUcmFuc2xhdGVTdHJpbmcocG9pbnQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZWwuc3R5bGUubGVmdCA9IHBvaW50LnggKyAncHgnO1xyXG5cdFx0XHRlbC5zdHlsZS50b3AgPSBwb2ludC55ICsgJ3B4JztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHQvLyB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZm9yIGVsZW1lbnRzIHByZXZpb3VzbHkgcG9zaXRpb25lZCB1c2luZyBzZXRQb3NpdGlvbixcclxuXHRcdC8vIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSB0aGUgcG9zaXRpb24gZm9yIHBlcmZvcm1hbmNlXHJcblxyXG5cdFx0Ly8ganNoaW50IGNhbWVsY2FzZTogZmFsc2VcclxuXHRcdHJldHVybiBlbC5fbGVhZmxldF9wb3M7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbi8vIHByZWZpeCBzdHlsZSBwcm9wZXJ0eSBuYW1lc1xyXG5cclxuTC5Eb21VdGlsLlRSQU5TRk9STSA9IEwuRG9tVXRpbC50ZXN0UHJvcChcclxuICAgICAgICBbJ3RyYW5zZm9ybScsICdXZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXSk7XHJcblxyXG4vLyB3ZWJraXRUcmFuc2l0aW9uIGNvbWVzIGZpcnN0IGJlY2F1c2Ugc29tZSBicm93c2VyIHZlcnNpb25zIHRoYXQgZHJvcCB2ZW5kb3IgcHJlZml4IGRvbid0IGRvXHJcbi8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG5cclxuTC5Eb21VdGlsLlRSQU5TSVRJT04gPSBMLkRvbVV0aWwudGVzdFByb3AoXHJcbiAgICAgICAgWyd3ZWJraXRUcmFuc2l0aW9uJywgJ3RyYW5zaXRpb24nLCAnT1RyYW5zaXRpb24nLCAnTW96VHJhbnNpdGlvbicsICdtc1RyYW5zaXRpb24nXSk7XHJcblxyXG5MLkRvbVV0aWwuVFJBTlNJVElPTl9FTkQgPVxyXG4gICAgICAgIEwuRG9tVXRpbC5UUkFOU0lUSU9OID09PSAnd2Via2l0VHJhbnNpdGlvbicgfHwgTC5Eb21VdGlsLlRSQU5TSVRJT04gPT09ICdPVHJhbnNpdGlvbicgP1xyXG4gICAgICAgIEwuRG9tVXRpbC5UUkFOU0lUSU9OICsgJ0VuZCcgOiAndHJhbnNpdGlvbmVuZCc7XHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudCkge1xyXG4gICAgICAgIEwuZXh0ZW5kKEwuRG9tVXRpbCwge1xyXG4gICAgICAgICAgICBkaXNhYmxlVGV4dFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgTC5Eb21FdmVudC5vbih3aW5kb3csICdzZWxlY3RzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZW5hYmxlVGV4dFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgTC5Eb21FdmVudC5vZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gTC5Eb21VdGlsLnRlc3RQcm9wKFxyXG4gICAgICAgICAgICBbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcbiAgICAgICAgTC5leHRlbmQoTC5Eb21VdGlsLCB7XHJcbiAgICAgICAgICAgIGRpc2FibGVUZXh0U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VzZXJTZWxlY3QgPSBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBlbmFibGVUZXh0U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSB0aGlzLl91c2VyU2VsZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl91c2VyU2VsZWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cdEwuZXh0ZW5kKEwuRG9tVXRpbCwge1xyXG5cdFx0ZGlzYWJsZUltYWdlRHJhZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKHdpbmRvdywgJ2RyYWdzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRlbmFibGVJbWFnZURyYWc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0XHR9XHJcblx0fSk7XHJcbn0pKCk7XHJcblxuXG4vKlxyXG4gKiBMLkxhdExuZyByZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSBjb29yZGluYXRlcy5cclxuICovXHJcblxyXG5MLkxhdExuZyA9IGZ1bmN0aW9uIChsYXQsIGxuZywgYWx0KSB7IC8vIChOdW1iZXIsIE51bWJlciwgTnVtYmVyKVxyXG5cdGxhdCA9IHBhcnNlRmxvYXQobGF0KTtcclxuXHRsbmcgPSBwYXJzZUZsb2F0KGxuZyk7XHJcblxyXG5cdGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMYXRMbmcgb2JqZWN0OiAoJyArIGxhdCArICcsICcgKyBsbmcgKyAnKScpO1xyXG5cdH1cclxuXHJcblx0dGhpcy5sYXQgPSBsYXQ7XHJcblx0dGhpcy5sbmcgPSBsbmc7XHJcblxyXG5cdGlmIChhbHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy5hbHQgPSBwYXJzZUZsb2F0KGFsdCk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5leHRlbmQoTC5MYXRMbmcsIHtcclxuXHRERUdfVE9fUkFEOiBNYXRoLlBJIC8gMTgwLFxyXG5cdFJBRF9UT19ERUc6IDE4MCAvIE1hdGguUEksXHJcblx0TUFYX01BUkdJTjogMS4wRS05IC8vIG1heCBtYXJnaW4gb2YgZXJyb3IgZm9yIHRoZSBcImVxdWFsc1wiIGNoZWNrXHJcbn0pO1xyXG5cclxuTC5MYXRMbmcucHJvdG90eXBlID0ge1xyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaikgeyAvLyAoTGF0TG5nKSAtPiBCb29sZWFuXHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSBMLmxhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSBMLkxhdExuZy5NQVhfTUFSR0lOO1xyXG5cdH0sXHJcblxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7IC8vIChOdW1iZXIpIC0+IFN0cmluZ1xyXG5cdFx0cmV0dXJuICdMYXRMbmcoJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgTC5VdGlsLmZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuXHR9LFxyXG5cclxuXHQvLyBIYXZlcnNpbmUgZGlzdGFuY2UgZm9ybXVsYSwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcclxuXHQvLyBUT0RPIG1vdmUgdG8gcHJvamVjdGlvbiBjb2RlLCBMYXRMbmcgc2hvdWxkbid0IGtub3cgYWJvdXQgRWFydGhcclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAob3RoZXIpIHsgLy8gKExhdExuZykgLT4gTnVtYmVyXHJcblx0XHRvdGhlciA9IEwubGF0TG5nKG90aGVyKTtcclxuXHJcblx0XHR2YXIgUiA9IDYzNzgxMzcsIC8vIGVhcnRoIHJhZGl1cyBpbiBtZXRlcnNcclxuXHRcdCAgICBkMnIgPSBMLkxhdExuZy5ERUdfVE9fUkFELFxyXG5cdFx0ICAgIGRMYXQgPSAob3RoZXIubGF0IC0gdGhpcy5sYXQpICogZDJyLFxyXG5cdFx0ICAgIGRMb24gPSAob3RoZXIubG5nIC0gdGhpcy5sbmcpICogZDJyLFxyXG5cdFx0ICAgIGxhdDEgPSB0aGlzLmxhdCAqIGQycixcclxuXHRcdCAgICBsYXQyID0gb3RoZXIubGF0ICogZDJyLFxyXG5cdFx0ICAgIHNpbjEgPSBNYXRoLnNpbihkTGF0IC8gMiksXHJcblx0XHQgICAgc2luMiA9IE1hdGguc2luKGRMb24gLyAyKTtcclxuXHJcblx0XHR2YXIgYSA9IHNpbjEgKiBzaW4xICsgc2luMiAqIHNpbjIgKiBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpO1xyXG5cclxuXHRcdHJldHVybiBSICogMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcclxuXHR9LFxyXG5cclxuXHR3cmFwOiBmdW5jdGlvbiAoYSwgYikgeyAvLyAoTnVtYmVyLCBOdW1iZXIpIC0+IExhdExuZ1xyXG5cdFx0dmFyIGxuZyA9IHRoaXMubG5nO1xyXG5cclxuXHRcdGEgPSBhIHx8IC0xODA7XHJcblx0XHRiID0gYiB8fCAgMTgwO1xyXG5cclxuXHRcdGxuZyA9IChsbmcgKyBiKSAlIChiIC0gYSkgKyAobG5nIDwgYSB8fCBsbmcgPT09IGIgPyBiIDogYSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyh0aGlzLmxhdCwgbG5nKTtcclxuXHR9XHJcbn07XHJcblxyXG5MLmxhdExuZyA9IGZ1bmN0aW9uIChhLCBiKSB7IC8vIChMYXRMbmcpIG9yIChbTnVtYmVyLCBOdW1iZXJdKSBvciAoTnVtYmVyLCBOdW1iZXIpXHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChMLlV0aWwuaXNBcnJheShhKSkge1xyXG5cdFx0aWYgKHR5cGVvZiBhWzBdID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgYVswXSA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcoYS5sYXQsICdsbmcnIGluIGEgPyBhLmxuZyA6IGEubG9uKTtcclxuXHR9XHJcblx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5MYXRMbmcoYSwgYik7XHJcbn07XHJcblxyXG5cblxuLypcclxuICogTC5MYXRMbmdCb3VuZHMgcmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgb24gdGhlIG1hcCBpbiBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcbiAqL1xyXG5cclxuTC5MYXRMbmdCb3VuZHMgPSBmdW5jdGlvbiAoc291dGhXZXN0LCBub3J0aEVhc3QpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcblx0aWYgKCFzb3V0aFdlc3QpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBsYXRsbmdzID0gbm9ydGhFYXN0ID8gW3NvdXRoV2VzdCwgbm9ydGhFYXN0XSA6IHNvdXRoV2VzdDtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKGxhdGxuZ3NbaV0pO1xyXG5cdH1cclxufTtcclxuXHJcbkwuTGF0TG5nQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHQvLyBleHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludCBvciBib3VuZHNcclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZykgb3IgKExhdExuZ0JvdW5kcylcclxuXHRcdGlmICghb2JqKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGxhdExuZyA9IEwubGF0TG5nKG9iaik7XHJcblx0XHRpZiAobGF0TG5nICE9PSBudWxsKSB7XHJcblx0XHRcdG9iaiA9IGxhdExuZztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IEwubGF0TG5nQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nKSB7XHJcblx0XHRcdGlmICghdGhpcy5fc291dGhXZXN0ICYmICF0aGlzLl9ub3J0aEVhc3QpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3V0aFdlc3QgPSBuZXcgTC5MYXRMbmcob2JqLmxhdCwgb2JqLmxuZyk7XHJcblx0XHRcdFx0dGhpcy5fbm9ydGhFYXN0ID0gbmV3IEwuTGF0TG5nKG9iai5sYXQsIG9iai5sbmcpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXRoV2VzdC5sYXQgPSBNYXRoLm1pbihvYmoubGF0LCB0aGlzLl9zb3V0aFdlc3QubGF0KTtcclxuXHRcdFx0XHR0aGlzLl9zb3V0aFdlc3QubG5nID0gTWF0aC5taW4ob2JqLmxuZywgdGhpcy5fc291dGhXZXN0LmxuZyk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX25vcnRoRWFzdC5sYXQgPSBNYXRoLm1heChvYmoubGF0LCB0aGlzLl9ub3J0aEVhc3QubGF0KTtcclxuXHRcdFx0XHR0aGlzLl9ub3J0aEVhc3QubG5nID0gTWF0aC5tYXgob2JqLmxuZywgdGhpcy5fbm9ydGhFYXN0LmxuZyk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTC5MYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5leHRlbmQob2JqLl9zb3V0aFdlc3QpO1xyXG5cdFx0XHR0aGlzLmV4dGVuZChvYmouX25vcnRoRWFzdCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBleHRlbmQgdGhlIGJvdW5kcyBieSBhIHBlcmNlbnRhZ2VcclxuXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykgeyAvLyAoTnVtYmVyKSAtPiBMYXRMbmdCb3VuZHNcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcblx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgbmV3IEwuTGF0TG5nKHN3LmxhdCAtIGhlaWdodEJ1ZmZlciwgc3cubG5nIC0gd2lkdGhCdWZmZXIpLFxyXG5cdFx0ICAgICAgICBuZXcgTC5MYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkgeyAvLyAtPiBMYXRMbmdcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcoXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XHJcblx0fSxcclxuXHJcblx0Z2V0U291dGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG5cdH0sXHJcblxyXG5cdGdldE5vcnRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdDtcclxuXHR9LFxyXG5cclxuXHRnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcodGhpcy5nZXROb3J0aCgpLCB0aGlzLmdldFdlc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0U291dGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubG5nO1xyXG5cdH0sXHJcblxyXG5cdGdldFNvdXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxhdDtcclxuXHR9LFxyXG5cclxuXHRnZXRFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHRnZXROb3J0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZ0JvdW5kcykgb3IgKExhdExuZykgLT4gQm9vbGVhblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nKSB7XHJcblx0XHRcdG9iaiA9IEwubGF0TG5nKG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSBMLmxhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTC5MYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLmdldFNvdXRoV2VzdCgpO1xyXG5cdFx0XHRuZTIgPSBvYmouZ2V0Tm9ydGhFYXN0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdzIgPSBuZTIgPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChzdzIubGF0ID49IHN3LmxhdCkgJiYgKG5lMi5sYXQgPD0gbmUubGF0KSAmJlxyXG5cdFx0ICAgICAgIChzdzIubG5nID49IHN3LmxuZykgJiYgKG5lMi5sbmcgPD0gbmUubG5nKTtcclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChMYXRMbmdCb3VuZHMpXHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRJbnRlcnNlY3RzID0gKG5lMi5sYXQgPj0gc3cubGF0KSAmJiAoc3cyLmxhdCA8PSBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ0ludGVyc2VjdHMgPSAobmUyLmxuZyA+PSBzdy5sbmcpICYmIChzdzIubG5nIDw9IG5lLmxuZyk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdEludGVyc2VjdHMgJiYgbG5nSW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHR0b0JCb3hTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbdGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0Tm9ydGgoKV0uam9pbignLCcpO1xyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoTGF0TG5nQm91bmRzKVxyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCkpICYmXHJcblx0XHQgICAgICAgdGhpcy5fbm9ydGhFYXN0LmVxdWFscyhib3VuZHMuZ2V0Tm9ydGhFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLl9zb3V0aFdlc3QgJiYgdGhpcy5fbm9ydGhFYXN0KTtcclxuXHR9XHJcbn07XHJcblxyXG4vL1RPRE8gSW50ZXJuYXRpb25hbCBkYXRlIGxpbmU/XHJcblxyXG5MLmxhdExuZ0JvdW5kcyA9IGZ1bmN0aW9uIChhLCBiKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcsIExhdExuZylcclxuXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEwuTGF0TG5nQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhhLCBiKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIEwuUHJvamVjdGlvbiBjb250YWlucyB2YXJpb3VzIGdlb2dyYXBoaWNhbCBwcm9qZWN0aW9ucyB1c2VkIGJ5IENSUyBjbGFzc2VzLlxyXG4gKi9cclxuXHJcbkwuUHJvamVjdGlvbiA9IHt9O1xyXG5cblxuLypcclxuICogU3BoZXJpY2FsIE1lcmNhdG9yIGlzIHRoZSBtb3N0IHBvcHVsYXIgbWFwIHByb2plY3Rpb24sIHVzZWQgYnkgRVBTRzozODU3IENSUyB1c2VkIGJ5IGRlZmF1bHQuXHJcbiAqL1xyXG5cclxuTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yID0ge1xyXG5cdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykgeyAvLyAoTGF0TG5nKSAtPiBQb2ludFxyXG5cdFx0dmFyIGQgPSBMLkxhdExuZy5ERUdfVE9fUkFELFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHggPSBsYXRsbmcubG5nICogZCxcclxuXHRcdCAgICB5ID0gbGF0ICogZDtcclxuXHJcblx0XHR5ID0gTWF0aC5sb2coTWF0aC50YW4oKE1hdGguUEkgLyA0KSArICh5IC8gMikpKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoeCwgeSk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50LCBCb29sZWFuKSAtPiBMYXRMbmdcclxuXHRcdHZhciBkID0gTC5MYXRMbmcuUkFEX1RPX0RFRyxcclxuXHRcdCAgICBsbmcgPSBwb2ludC54ICogZCxcclxuXHRcdCAgICBsYXQgPSAoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55KSkgLSAoTWF0aC5QSSAvIDIpKSAqIGQ7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhsYXQsIGxuZyk7XHJcblx0fVxyXG59O1xyXG5cblxuLypcclxuICogU2ltcGxlIGVxdWlyZWN0YW5ndWxhciAoUGxhdGUgQ2FycmVlKSBwcm9qZWN0aW9uLCB1c2VkIGJ5IENSUyBsaWtlIEVQU0c6NDMyNiBhbmQgU2ltcGxlLlxyXG4gKi9cclxuXHJcbkwuUHJvamVjdGlvbi5Mb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KGxhdGxuZy5sbmcsIGxhdGxuZy5sYXQpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHBvaW50LnksIHBvaW50LngpO1xyXG5cdH1cclxufTtcclxuXG5cbi8qXHJcbiAqIEwuQ1JTIGlzIGEgYmFzZSBvYmplY3QgZm9yIGFsbCBkZWZpbmVkIENSUyAoQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtcykgaW4gTGVhZmxldC5cclxuICovXHJcblxyXG5MLkNSUyA9IHtcclxuXHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7IC8vIChMYXRMbmcsIE51bWJlcikgLT4gUG9pbnRcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHsgLy8gKFBvaW50LCBOdW1iZXJbLCBCb29sZWFuXSkgLT4gTGF0TG5nXHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHVudHJhbnNmb3JtZWRQb2ludCA9IHRoaXMudHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocG9pbnQsIHNjYWxlKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdCh1bnRyYW5zZm9ybWVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIDI1NiAqIE1hdGgucG93KDIsIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgcyA9IHRoaXMuc2NhbGUoem9vbSk7XHJcblx0XHRyZXR1cm4gTC5wb2ludChzLCBzKTtcclxuXHR9XHJcbn07XHJcblxuXG4vKlxuICogQSBzaW1wbGUgQ1JTIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGZsYXQgbm9uLUVhcnRoIG1hcHMgbGlrZSBwYW5vcmFtYXMgb3IgZ2FtZSBtYXBzLlxuICovXG5cbkwuQ1JTLlNpbXBsZSA9IEwuZXh0ZW5kKHt9LCBMLkNSUywge1xuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uTG9uTGF0LFxuXHR0cmFuc2Zvcm1hdGlvbjogbmV3IEwuVHJhbnNmb3JtYXRpb24oMSwgMCwgLTEsIDApLFxuXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcblx0fVxufSk7XG5cblxuLypcclxuICogTC5DUlMuRVBTRzM4NTcgKFNwaGVyaWNhbCBNZXJjYXRvcikgaXMgdGhlIG1vc3QgY29tbW9uIENSUyBmb3Igd2ViIG1hcHBpbmdcclxuICogYW5kIGlzIHVzZWQgYnkgTGVhZmxldCBieSBkZWZhdWx0LlxyXG4gKi9cclxuXHJcbkwuQ1JTLkVQU0czODU3ID0gTC5leHRlbmQoe30sIEwuQ1JTLCB7XHJcblx0Y29kZTogJ0VQU0c6Mzg1NycsXHJcblxyXG5cdHByb2plY3Rpb246IEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcixcclxuXHR0cmFuc2Zvcm1hdGlvbjogbmV3IEwuVHJhbnNmb3JtYXRpb24oMC41IC8gTWF0aC5QSSwgMC41LCAtMC41IC8gTWF0aC5QSSwgMC41KSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykgeyAvLyAoTGF0TG5nKSAtPiBQb2ludFxyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKSxcclxuXHRcdCAgICBlYXJ0aFJhZGl1cyA9IDYzNzgxMzc7XHJcblx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQubXVsdGlwbHlCeShlYXJ0aFJhZGl1cyk7XHJcblx0fVxyXG59KTtcclxuXHJcbkwuQ1JTLkVQU0c5MDA5MTMgPSBMLmV4dGVuZCh7fSwgTC5DUlMuRVBTRzM4NTcsIHtcclxuXHRjb2RlOiAnRVBTRzo5MDA5MTMnXHJcbn0pO1xyXG5cblxuLypcclxuICogTC5DUlMuRVBTRzQzMjYgaXMgYSBDUlMgcG9wdWxhciBhbW9uZyBhZHZhbmNlZCBHSVMgc3BlY2lhbGlzdHMuXHJcbiAqL1xyXG5cclxuTC5DUlMuRVBTRzQzMjYgPSBMLmV4dGVuZCh7fSwgTC5DUlMsIHtcclxuXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuXHJcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLkxvbkxhdCxcclxuXHR0cmFuc2Zvcm1hdGlvbjogbmV3IEwuVHJhbnNmb3JtYXRpb24oMSAvIDM2MCwgMC41LCAtMSAvIDM2MCwgMC41KVxyXG59KTtcclxuXG5cbi8qXHJcbiAqIEwuTWFwIGlzIHRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkgLSBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1hcC5cclxuICovXHJcblxyXG5MLk1hcCA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0aW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRjcnM6IEwuQ1JTLkVQU0czODU3LFxyXG5cclxuXHRcdC8qXHJcblx0XHRjZW50ZXI6IExhdExuZyxcclxuXHRcdHpvb206IE51bWJlcixcclxuXHRcdGxheWVyczogQXJyYXksXHJcblx0XHQqL1xyXG5cclxuXHRcdGZhZGVBbmltYXRpb246IEwuRG9tVXRpbC5UUkFOU0lUSU9OICYmICFMLkJyb3dzZXIuYW5kcm9pZDIzLFxyXG5cdFx0dHJhY2tSZXNpemU6IHRydWUsXHJcblx0XHRtYXJrZXJab29tQW5pbWF0aW9uOiBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJiBMLkJyb3dzZXIuYW55M2RcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxyXG5cdFx0b3B0aW9ucyA9IEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblxyXG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcihpZCk7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblxyXG5cdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG5cdFx0dGhpcy5fb25SZXNpemUgPSBMLmJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnNldFZpZXcoTC5sYXRMbmcob3B0aW9ucy5jZW50ZXIpLCBvcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl96b29tQm91bmRMYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3RpbGVMYXllcnNOdW0gPSAwO1xyXG5cclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuXHRcdHRoaXMuX2FkZExheWVycyhvcHRpb25zLmxheWVycyk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHB1YmxpYyBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuXHQvLyByZXBsYWNlZCBieSBhbmltYXRpb24tcG93ZXJlZCBpbXBsZW1lbnRhdGlvbiBpbiBNYXAuUGFuQW5pbWF0aW9uLmpzXHJcblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbTtcclxuXHRcdHRoaXMuX3Jlc2V0VmlldyhMLmxhdExuZyhjZW50ZXIpLCB0aGlzLl9saW1pdFpvb20oem9vbSkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdHpvb21JbjogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyAoZGVsdGEgfHwgMSksIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdHpvb21PdXQ6IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gKGRlbHRhIHx8IDEpLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRzZXRab29tQXJvdW5kOiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIGNvbnRhaW5lclBvaW50ID0gbGF0bG5nIGluc3RhbmNlb2YgTC5Qb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdGZpdEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IEwucG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSBMLnBvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cclxuXHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSksXHJcblx0XHQgICAgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcblx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG5cdFx0em9vbSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhab29tID8gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCB6b29tKSA6IHpvb207XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0cGFuVG86IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHsgLy8gKExhdExuZylcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLl96b29tLCB7cGFuOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHsgLy8gKFBvaW50KVxyXG5cdFx0Ly8gcmVwbGFjZWQgd2l0aCBhbmltYXRlZCBwYW5CeSBpbiBNYXAuUGFuQW5pbWF0aW9uLmpzXHJcblx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cclxuXHRcdHRoaXMuX3Jhd1BhbkJ5KEwucG9pbnQob2Zmc2V0KSk7XHJcblxyXG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0c2V0TWF4Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBib3VuZHM7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm9uKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0XHRuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKGNlbnRlci5lcXVhbHMobmV3Q2VudGVyKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnBhblRvKG5ld0NlbnRlciwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0Ly8gVE9ETyBtZXRob2QgaXMgdG9vIGJpZywgcmVmYWN0b3JcclxuXHJcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHQvLyBUT0RPIGdldE1heFpvb20sIGdldE1pblpvb20gaW4gSUxheWVyIChpbnN0ZWFkIG9mIG9wdGlvbnMpXHJcblx0XHRpZiAobGF5ZXIub3B0aW9ucyAmJiAoIWlzTmFOKGxheWVyLm9wdGlvbnMubWF4Wm9vbSkgfHwgIWlzTmFOKGxheWVyLm9wdGlvbnMubWluWm9vbSkpKSB7XHJcblx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF0gPSBsYXllcjtcclxuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE8gbG9va3MgdWdseSwgcmVmYWN0b3IhISFcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBMLlRpbGVMYXllciAmJiAobGF5ZXIgaW5zdGFuY2VvZiBMLlRpbGVMYXllcikpIHtcclxuXHRcdFx0dGhpcy5fdGlsZUxheWVyc051bSsrO1xyXG5cdFx0XHR0aGlzLl90aWxlTGF5ZXJzVG9Mb2FkKys7XHJcblx0XHRcdGxheWVyLm9uKCdsb2FkJywgdGhpcy5fb25UaWxlTGF5ZXJMb2FkLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyQWRkKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdGxheWVyLm9uUmVtb3ZlKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE8gbG9va3MgdWdseSwgcmVmYWN0b3JcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBMLlRpbGVMYXllciAmJiAobGF5ZXIgaW5zdGFuY2VvZiBMLlRpbGVMYXllcikpIHtcclxuXHRcdFx0dGhpcy5fdGlsZUxheWVyc051bS0tO1xyXG5cdFx0XHR0aGlzLl90aWxlTGF5ZXJzVG9Mb2FkLS07XHJcblx0XHRcdGxheWVyLm9mZignbG9hZCcsIHRoaXMuX29uVGlsZUxheWVyTG9hZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCFsYXllcikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRyZXR1cm4gKEwuc3RhbXAobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XHJcblx0fSxcclxuXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0aW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBMLmV4dGVuZCh7XHJcblx0XHRcdGFuaW1hdGU6IGZhbHNlLFxyXG5cdFx0XHRwYW46IHRydWVcclxuXHRcdH0sIG9wdGlvbnMgPT09IHRydWUgPyB7YW5pbWF0ZTogdHJ1ZX0gOiBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgb2xkU2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5faW5pdGlhbENlbnRlciA9IG51bGw7XHJcblxyXG5cdFx0dmFyIG5ld1NpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBvbGRDZW50ZXIgPSBvbGRTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gbmV3U2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG9sZENlbnRlci5zdWJ0cmFjdChuZXdDZW50ZXIpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAmJiBvcHRpb25zLnBhbikge1xyXG5cdFx0XHR0aGlzLnBhbkJ5KG9mZnNldCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5kZWJvdW5jZU1vdmVlbmQpIHtcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHR0aGlzLl9zaXplVGltZXIgPSBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdtb3ZlZW5kJyksIDIwMCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdyZXNpemUnLCB7XHJcblx0XHRcdG9sZFNpemU6IG9sZFNpemUsXHJcblx0XHRcdG5ld1NpemU6IG5ld1NpemVcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE8gaGFuZGxlci5hZGRUb1xyXG5cdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd1bmxvYWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKCdvZmYnKTtcclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyB0aHJvd3MgZXJyb3IgaW4gSUU2LThcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldDtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NsZWFyUGFuZXMoKTtcclxuXHRcdGlmICh0aGlzLl9jbGVhckNvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5fY2xlYXJDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY2xlYXJIYW5kbGVycygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwdWJsaWMgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcclxuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7IC8vIChCb29sZWFuKSAtPiBMYXRMbmdcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdGlhbENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5faW5pdGlhbENlbnRlcjtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl96b29tO1xyXG5cdH0sXHJcblxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBzdyA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRCb3R0b21MZWZ0KCkpLFxyXG5cdFx0ICAgIG5lID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldFRvcFJpZ2h0KCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoc3csIG5lKTtcclxuXHR9LFxyXG5cclxuXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdCh0aGlzLl9sYXllcnNNaW5ab29tID09PSB1bmRlZmluZWQgPyAwIDogdGhpcy5fbGF5ZXJzTWluWm9vbSkgOlxyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHR9LFxyXG5cclxuXHRnZXRNYXhab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRzWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKSB7IC8vIChMYXRMbmdCb3VuZHNbLCBCb29sZWFuLCBQb2ludF0pIC0+IE51bWJlclxyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0TWluWm9vbSgpIC0gKGluc2lkZSA/IDEgOiAwKSxcclxuXHRcdCAgICBtYXhab29tID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cclxuXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdCAgICBzZSA9IGJvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgem9vbU5vdEZvdW5kID0gdHJ1ZSxcclxuXHRcdCAgICBib3VuZHNTaXplO1xyXG5cclxuXHRcdHBhZGRpbmcgPSBMLnBvaW50KHBhZGRpbmcgfHwgWzAsIDBdKTtcclxuXHJcblx0XHRkbyB7XHJcblx0XHRcdHpvb20rKztcclxuXHRcdFx0Ym91bmRzU2l6ZSA9IHRoaXMucHJvamVjdChzZSwgem9vbSkuc3VidHJhY3QodGhpcy5wcm9qZWN0KG53LCB6b29tKSkuYWRkKHBhZGRpbmcpO1xyXG5cdFx0XHR6b29tTm90Rm91bmQgPSAhaW5zaWRlID8gc2l6ZS5jb250YWlucyhib3VuZHNTaXplKSA6IGJvdW5kc1NpemUueCA8IHNpemUueCB8fCBib3VuZHNTaXplLnkgPCBzaXplLnk7XHJcblxyXG5cdFx0fSB3aGlsZSAoem9vbU5vdEZvdW5kICYmIHpvb20gPD0gbWF4Wm9vbSk7XHJcblxyXG5cdFx0aWYgKHpvb21Ob3RGb3VuZCAmJiBpbnNpZGUpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGluc2lkZSA/IHpvb20gOiB6b29tIC0gMTtcclxuXHR9LFxyXG5cclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX3NpemUgfHwgdGhpcy5fc2l6ZUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBMLlBvaW50KFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0KTtcclxuXHJcblx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5jbG9uZSgpO1xyXG5cdH0sXHJcblxyXG5cdGdldFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KCk7XHJcblx0XHRyZXR1cm4gbmV3IEwuQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFBpeGVsT3JpZ2luOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcy5faW5pdGlhbFRvcExlZnRQb2ludDtcclxuXHR9LFxyXG5cclxuXHRnZXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG5cdH0sXHJcblxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gVE9ETyByZXBsYWNlIHdpdGggdW5pdmVyc2FsIGltcGxlbWVudGF0aW9uIGFmdGVyIHJlZmFjdG9yaW5nIHByb2plY3Rpb25zXHJcblxyXG5cdGdldFpvb21TY2FsZTogZnVuY3Rpb24gKHRvWm9vbSkge1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUodGhpcy5fem9vbSk7XHJcblx0fSxcclxuXHJcblx0Z2V0U2NhbGVab29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuXHRcdHJldHVybiB0aGlzLl96b29tICsgKE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gY29udmVyc2lvbiBtZXRob2RzXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHsgLy8gKExhdExuZ1ssIE51bWJlcl0pIC0+IFBvaW50XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KEwubGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7IC8vIChQb2ludFssIE51bWJlcl0pIC0+IExhdExuZ1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMucG9pbnRUb0xhdExuZyhMLnBvaW50KHBvaW50KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gTC5wb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdGxhdExuZ1RvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0KEwubGF0TG5nKGxhdGxuZykpLl9yb3VuZCgpO1xyXG5cdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIEwucG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gTC5wb2ludChwb2ludCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoTC5wb2ludChwb2ludCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KEwubGF0TG5nKGxhdGxuZykpKTtcclxuXHR9LFxyXG5cclxuXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHRtb3VzZUV2ZW50VG9MYXRMbmc6IGZ1bmN0aW9uIChlKSB7IC8vIChNb3VzZUV2ZW50KVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIG1hcCBpbml0aWFsaXphdGlvbiBtZXRob2RzXHJcblxyXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuZ2V0KGlkKTtcclxuXHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG5cdFx0fSBlbHNlIGlmIChjb250YWluZXIuX2xlYWZsZXQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29udGFpbmVyLl9sZWFmbGV0ID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICtcclxuXHRcdFx0KEwuQnJvd3Nlci50b3VjaCA/ICcgbGVhZmxldC10b3VjaCcgOiAnJykgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLnJldGluYSA/ICcgbGVhZmxldC1yZXRpbmEnIDogJycpICtcclxuXHRcdFx0KEwuQnJvd3Nlci5pZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgK1xyXG5cdFx0XHQodGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gPyAnIGxlYWZsZXQtZmFkZS1hbmltJyA6ICcnKSk7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gTC5Eb21VdGlsLmdldFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJyk7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XHJcblx0XHRcdGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdFBhbmVzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2luaXRDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBhbmVzID0gdGhpcy5fcGFuZXMgPSB7fTtcclxuXHJcblx0XHR0aGlzLl9tYXBQYW5lID0gcGFuZXMubWFwUGFuZSA9IHRoaXMuX2NyZWF0ZVBhbmUoJ2xlYWZsZXQtbWFwLXBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdHRoaXMuX3RpbGVQYW5lID0gcGFuZXMudGlsZVBhbmUgPSB0aGlzLl9jcmVhdGVQYW5lKCdsZWFmbGV0LXRpbGUtcGFuZScsIHRoaXMuX21hcFBhbmUpO1xyXG5cdFx0cGFuZXMub2JqZWN0c1BhbmUgPSB0aGlzLl9jcmVhdGVQYW5lKCdsZWFmbGV0LW9iamVjdHMtcGFuZScsIHRoaXMuX21hcFBhbmUpO1xyXG5cdFx0cGFuZXMuc2hhZG93UGFuZSA9IHRoaXMuX2NyZWF0ZVBhbmUoJ2xlYWZsZXQtc2hhZG93LXBhbmUnKTtcclxuXHRcdHBhbmVzLm92ZXJsYXlQYW5lID0gdGhpcy5fY3JlYXRlUGFuZSgnbGVhZmxldC1vdmVybGF5LXBhbmUnKTtcclxuXHRcdHBhbmVzLm1hcmtlclBhbmUgPSB0aGlzLl9jcmVhdGVQYW5lKCdsZWFmbGV0LW1hcmtlci1wYW5lJyk7XHJcblx0XHRwYW5lcy5wb3B1cFBhbmUgPSB0aGlzLl9jcmVhdGVQYW5lKCdsZWFmbGV0LXBvcHVwLXBhbmUnKTtcclxuXHJcblx0XHR2YXIgem9vbUhpZGUgPSAnIGxlYWZsZXQtem9vbS1oaWRlJztcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCB6b29tSGlkZSk7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5zaGFkb3dQYW5lLCB6b29tSGlkZSk7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5wb3B1cFBhbmUsIHpvb21IaWRlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlUGFuZTogZnVuY3Rpb24gKGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblx0XHRyZXR1cm4gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fcGFuZXMub2JqZWN0c1BhbmUpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhclBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fbWFwUGFuZSk7XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyczogZnVuY3Rpb24gKGxheWVycykge1xyXG5cdFx0bGF5ZXJzID0gbGF5ZXJzID8gKEwuVXRpbC5pc0FycmF5KGxheWVycykgPyBsYXllcnMgOiBbbGF5ZXJzXSkgOiBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBwcmVzZXJ2ZU1hcE9mZnNldCwgYWZ0ZXJab29tQW5pbSkge1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9ICh0aGlzLl96b29tICE9PSB6b29tKTtcclxuXHJcblx0XHRpZiAoIWFmdGVyWm9vbUFuaW0pIHtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHJcblx0XHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnem9vbXN0YXJ0Jyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdHRoaXMuX2luaXRpYWxDZW50ZXIgPSBjZW50ZXI7XHJcblxyXG5cdFx0dGhpcy5faW5pdGlhbFRvcExlZnRQb2ludCA9IHRoaXMuX2dldE5ld1RvcExlZnRQb2ludChjZW50ZXIpO1xyXG5cclxuXHRcdGlmICghcHJlc2VydmVNYXBPZmZzZXQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBMLlBvaW50KDAsIDApKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX2luaXRpYWxUb3BMZWZ0UG9pbnQuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3RpbGVMYXllcnNUb0xvYWQgPSB0aGlzLl90aWxlTGF5ZXJzTnVtO1xyXG5cclxuXHRcdHZhciBsb2FkaW5nID0gIXRoaXMuX2xvYWRlZDtcclxuXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnLCB7aGFyZDogIXByZXNlcnZlTWFwT2Zmc2V0fSk7XHJcblxyXG5cdFx0aWYgKGxvYWRpbmcpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XHJcblx0XHRcdHRoaXMuZWFjaExheWVyKHRoaXMuX2xheWVyQWRkLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQgfHwgYWZ0ZXJab29tQW5pbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21lbmQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnLCB7aGFyZDogIXByZXNlcnZlTWFwT2Zmc2V0fSk7XHJcblx0fSxcclxuXHJcblx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tU3BhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpIC0gdGhpcy5nZXRNaW5ab29tKCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpvb21MZXZlbHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpLFxyXG5cdFx0XHRtaW5ab29tID0gSW5maW5pdHksXHJcblx0XHRcdG1heFpvb20gPSAtSW5maW5pdHksXHJcblx0XHRcdG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fem9vbUJvdW5kTGF5ZXJzKSB7XHJcblx0XHRcdHZhciBsYXllciA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXTtcclxuXHRcdFx0aWYgKCFpc05hTihsYXllci5vcHRpb25zLm1pblpvb20pKSB7XHJcblx0XHRcdFx0bWluWm9vbSA9IE1hdGgubWluKG1pblpvb20sIGxheWVyLm9wdGlvbnMubWluWm9vbSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFpc05hTihsYXllci5vcHRpb25zLm1heFpvb20pKSB7XHJcblx0XHRcdFx0bWF4Wm9vbSA9IE1hdGgubWF4KG1heFpvb20sIGxheWVyLm9wdGlvbnMubWF4Wm9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaSA9PT0gdW5kZWZpbmVkKSB7IC8vIHdlIGhhdmUgbm8gdGlsZWxheWVyc1xyXG5cdFx0XHR0aGlzLl9sYXllcnNNYXhab29tID0gdGhpcy5fbGF5ZXJzTWluWm9vbSA9IHVuZGVmaW5lZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tO1xyXG5cdFx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3Bhbkluc2lkZU1heEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5wYW5JbnNpZGVCb3VuZHModGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrSWZMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gbWFwIGV2ZW50c1xyXG5cclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKG9uT2ZmKSB7XHJcblx0XHRpZiAoIUwuRG9tRXZlbnQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0b25PZmYgPSBvbk9mZiB8fCAnb24nO1xyXG5cclxuXHRcdEwuRG9tRXZlbnRbb25PZmZdKHRoaXMuX2NvbnRhaW5lciwgJ2NsaWNrJywgdGhpcy5fb25Nb3VzZUNsaWNrLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgZXZlbnRzID0gWydkYmxjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZWVudGVyJyxcclxuXHRcdCAgICAgICAgICAgICAgJ21vdXNlbGVhdmUnLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J10sXHJcblx0XHQgICAgaSwgbGVuO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRMLkRvbUV2ZW50W29uT2ZmXSh0aGlzLl9jb250YWluZXIsIGV2ZW50c1tpXSwgdGhpcy5fZmlyZU1vdXNlRXZlbnQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcclxuXHRcdFx0TC5Eb21FdmVudFtvbk9mZl0od2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuXHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShcclxuXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcywgZmFsc2UsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X29uTW91c2VDbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8ICghZS5fc2ltdWxhdGVkICYmXHJcblx0XHQgICAgICAgICgodGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLm1vdmVkKCkpIHx8XHJcblx0XHQgICAgICAgICAodGhpcy5ib3hab29tICAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSkpKSB8fFxyXG5cdFx0ICAgICAgICAgICAgTC5Eb21FdmVudC5fc2tpcHBlZChlKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ByZWNsaWNrJyk7XHJcblx0XHR0aGlzLl9maXJlTW91c2VFdmVudChlKTtcclxuXHR9LFxyXG5cclxuXHRfZmlyZU1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBMLkRvbUV2ZW50Ll9za2lwcGVkKGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciB0eXBlID0gZS50eXBlO1xyXG5cclxuXHRcdHR5cGUgPSAodHlwZSA9PT0gJ21vdXNlZW50ZXInID8gJ21vdXNlb3ZlcicgOiAodHlwZSA9PT0gJ21vdXNlbGVhdmUnID8gJ21vdXNlb3V0JyA6IHR5cGUpKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuaGFzRXZlbnRMaXN0ZW5lcnModHlwZSkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdjb250ZXh0bWVudScpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY29udGFpbmVyUG9pbnQgPSB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpLFxyXG5cdFx0ICAgIGxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGNvbnRhaW5lclBvaW50KSxcclxuXHRcdCAgICBsYXRsbmcgPSB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuXHJcblx0XHR0aGlzLmZpcmUodHlwZSwge1xyXG5cdFx0XHRsYXRsbmc6IGxhdGxuZyxcclxuXHRcdFx0bGF5ZXJQb2ludDogbGF5ZXJQb2ludCxcclxuXHRcdFx0Y29udGFpbmVyUG9pbnQ6IGNvbnRhaW5lclBvaW50LFxyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfb25UaWxlTGF5ZXJMb2FkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl90aWxlTGF5ZXJzVG9Mb2FkLS07XHJcblx0XHRpZiAodGhpcy5fdGlsZUxheWVyc051bSAmJiAhdGhpcy5fdGlsZUxheWVyc1RvTG9hZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVsYXllcnNsb2FkJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NsZWFySGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0d2hlblJlYWR5OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHRoaXMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5vbignbG9hZCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9sYXllckFkZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRsYXllci5vbkFkZCh0aGlzKTtcclxuXHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcclxuXHJcblx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSk7XHJcblx0fSxcclxuXHJcblx0X21vdmVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0cmV0dXJuIHBvcyAmJiAhcG9zLmVxdWFscyhbMCwgMF0pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFBpeGVsT3JpZ2luKCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TmV3VG9wTGVmdFBvaW50OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XHJcblx0XHQvLyBUT0RPIHJvdW5kIG9uIGRpc3BsYXksIG5vdCBjYWxjdWxhdGlvbiB0byBpbmNyZWFzZSBwcmVjaXNpb24/XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSkuX3N1YnRyYWN0KHZpZXdIYWxmKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCBuZXdab29tLCBuZXdDZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3VG9wTGVmdFBvaW50KG5ld0NlbnRlciwgbmV3Wm9vbSkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgbmV3Wm9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdF9nZXRDZW50ZXJMYXllclBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIG9mZnNldCBvZiB0aGUgc3BlY2lmaWVkIHBsYWNlIHRvIHRoZSBjdXJyZW50IGNlbnRlciBpbiBwaXhlbHNcclxuXHRfZ2V0Q2VudGVyT2Zmc2V0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBjZW50ZXI7IH1cclxuXHJcblx0XHR2YXIgY2VudGVyUG9pbnQgPSB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHZpZXdCb3VuZHMgPSBuZXcgTC5Cb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRCb3VuZHNPZmZzZXQodmlld0JvdW5kcywgYm91bmRzLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QoY2VudGVyUG9pbnQuYWRkKG9mZnNldCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQsIGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIG9mZnNldDsgfVxyXG5cclxuXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIG5ld0JvdW5kcyA9IG5ldyBMLkJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiBvZmZzZXQuYWRkKHRoaXMuX2dldEJvdW5kc09mZnNldChuZXdCb3VuZHMsIGJvdW5kcykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG5cdF9nZXRCb3VuZHNPZmZzZXQ6IGZ1bmN0aW9uIChweEJvdW5kcywgbWF4Qm91bmRzLCB6b29tKSB7XHJcblx0XHR2YXIgbndPZmZzZXQgPSB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldE5vcnRoV2VzdCgpLCB6b29tKS5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG5cdFx0ICAgIHNlT2Zmc2V0ID0gdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXRTb3V0aEVhc3QoKSwgem9vbSkuc3VidHJhY3QocHhCb3VuZHMubWF4KSxcclxuXHJcblx0XHQgICAgZHggPSB0aGlzLl9yZWJvdW5kKG53T2Zmc2V0LngsIC1zZU9mZnNldC54KSxcclxuXHRcdCAgICBkeSA9IHRoaXMuX3JlYm91bmQobndPZmZzZXQueSwgLXNlT2Zmc2V0LnkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChkeCwgZHkpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWJvdW5kOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuXHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID9cclxuXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcblx0XHRcdE1hdGgubWF4KDAsIE1hdGguY2VpbChsZWZ0KSkgLSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHJpZ2h0KSk7XHJcblx0fSxcclxuXHJcblx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5tYXAgPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuTWFwKGlkLCBvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIE1lcmNhdG9yIHByb2plY3Rpb24gdGhhdCB0YWtlcyBpbnRvIGFjY291bnQgdGhhdCB0aGUgRWFydGggaXMgbm90IGEgcGVyZmVjdCBzcGhlcmUuXHJcbiAqIExlc3MgcG9wdWxhciB0aGFuIHNwaGVyaWNhbCBtZXJjYXRvcjsgdXNlZCBieSBwcm9qZWN0aW9ucyBsaWtlIEVQU0c6MzM5NS5cclxuICovXHJcblxyXG5MLlByb2plY3Rpb24uTWVyY2F0b3IgPSB7XHJcblx0TUFYX0xBVElUVURFOiA4NS4wODQwNTkxNTU2LFxyXG5cclxuXHRSX01JTk9SOiA2MzU2NzUyLjMxNDI0NTE3OSxcclxuXHRSX01BSk9SOiA2Mzc4MTM3LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7IC8vIChMYXRMbmcpIC0+IFBvaW50XHJcblx0XHR2YXIgZCA9IEwuTGF0TG5nLkRFR19UT19SQUQsXHJcblx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXHJcblx0XHQgICAgbGF0ID0gTWF0aC5tYXgoTWF0aC5taW4obWF4LCBsYXRsbmcubGF0KSwgLW1heCksXHJcblx0XHQgICAgciA9IHRoaXMuUl9NQUpPUixcclxuXHRcdCAgICByMiA9IHRoaXMuUl9NSU5PUixcclxuXHRcdCAgICB4ID0gbGF0bG5nLmxuZyAqIGQgKiByLFxyXG5cdFx0ICAgIHkgPSBsYXQgKiBkLFxyXG5cdFx0ICAgIHRtcCA9IHIyIC8gcixcclxuXHRcdCAgICBlY2NlbnQgPSBNYXRoLnNxcnQoMS4wIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICBjb24gPSBlY2NlbnQgKiBNYXRoLnNpbih5KTtcclxuXHJcblx0XHRjb24gPSBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGVjY2VudCAqIDAuNSk7XHJcblxyXG5cdFx0dmFyIHRzID0gTWF0aC50YW4oMC41ICogKChNYXRoLlBJICogMC41KSAtIHkpKSAvIGNvbjtcclxuXHRcdHkgPSAtciAqIE1hdGgubG9nKHRzKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoeCwgeSk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50LCBCb29sZWFuKSAtPiBMYXRMbmdcclxuXHRcdHZhciBkID0gTC5MYXRMbmcuUkFEX1RPX0RFRyxcclxuXHRcdCAgICByID0gdGhpcy5SX01BSk9SLFxyXG5cdFx0ICAgIHIyID0gdGhpcy5SX01JTk9SLFxyXG5cdFx0ICAgIGxuZyA9IHBvaW50LnggKiBkIC8gcixcclxuXHRcdCAgICB0bXAgPSByMiAvIHIsXHJcblx0XHQgICAgZWNjZW50ID0gTWF0aC5zcXJ0KDEgLSAodG1wICogdG1wKSksXHJcblx0XHQgICAgdHMgPSBNYXRoLmV4cCgtIHBvaW50LnkgLyByKSxcclxuXHRcdCAgICBwaGkgPSAoTWF0aC5QSSAvIDIpIC0gMiAqIE1hdGguYXRhbih0cyksXHJcblx0XHQgICAgbnVtSXRlciA9IDE1LFxyXG5cdFx0ICAgIHRvbCA9IDFlLTcsXHJcblx0XHQgICAgaSA9IG51bUl0ZXIsXHJcblx0XHQgICAgZHBoaSA9IDAuMSxcclxuXHRcdCAgICBjb247XHJcblxyXG5cdFx0d2hpbGUgKChNYXRoLmFicyhkcGhpKSA+IHRvbCkgJiYgKC0taSA+IDApKSB7XHJcblx0XHRcdGNvbiA9IGVjY2VudCAqIE1hdGguc2luKHBoaSk7XHJcblx0XHRcdGRwaGkgPSAoTWF0aC5QSSAvIDIpIC0gMiAqIE1hdGguYXRhbih0cyAqXHJcblx0XHRcdCAgICAgICAgICAgIE1hdGgucG93KCgxLjAgLSBjb24pIC8gKDEuMCArIGNvbiksIDAuNSAqIGVjY2VudCkpIC0gcGhpO1xyXG5cdFx0XHRwaGkgKz0gZHBoaTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHBoaSAqIGQsIGxuZyk7XHJcblx0fVxyXG59O1xyXG5cblxuXHJcbkwuQ1JTLkVQU0czMzk1ID0gTC5leHRlbmQoe30sIEwuQ1JTLCB7XHJcblx0Y29kZTogJ0VQU0c6MzM5NScsXHJcblxyXG5cdHByb2plY3Rpb246IEwuUHJvamVjdGlvbi5NZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbSA9IEwuUHJvamVjdGlvbi5NZXJjYXRvcixcclxuXHRcdCAgICByID0gbS5SX01BSk9SLFxyXG5cdFx0ICAgIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiByKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcblxuXG4vKlxyXG4gKiBMLlRpbGVMYXllciBpcyB1c2VkIGZvciBzdGFuZGFyZCB4eXotbnVtYmVyZWQgdGlsZSBsYXllcnMuXHJcbiAqL1xyXG5cclxuTC5UaWxlTGF5ZXIgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0aW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRtaW5ab29tOiAwLFxyXG5cdFx0bWF4Wm9vbTogMTgsXHJcblx0XHR0aWxlU2l6ZTogMjU2LFxyXG5cdFx0c3ViZG9tYWluczogJ2FiYycsXHJcblx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cdFx0YXR0cmlidXRpb246ICcnLFxyXG5cdFx0em9vbU9mZnNldDogMCxcclxuXHRcdG9wYWNpdHk6IDEsXHJcblx0XHQvKlxyXG5cdFx0bWF4TmF0aXZlWm9vbTogbnVsbCxcclxuXHRcdHpJbmRleDogbnVsbCxcclxuXHRcdHRtczogZmFsc2UsXHJcblx0XHRjb250aW51b3VzV29ybGQ6IGZhbHNlLFxyXG5cdFx0bm9XcmFwOiBmYWxzZSxcclxuXHRcdHpvb21SZXZlcnNlOiBmYWxzZSxcclxuXHRcdGRldGVjdFJldGluYTogZmFsc2UsXHJcblx0XHRyZXVzZVRpbGVzOiBmYWxzZSxcclxuXHRcdGJvdW5kczogZmFsc2UsXHJcblx0XHQqL1xyXG5cdFx0dW5sb2FkSW52aXNpYmxlVGlsZXM6IEwuQnJvd3Nlci5tb2JpbGUsXHJcblx0XHR1cGRhdGVXaGVuSWRsZTogTC5Ccm93c2VyLm1vYmlsZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHRcdG9wdGlvbnMgPSBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gZGV0ZWN0aW5nIHJldGluYSBkaXNwbGF5cywgYWRqdXN0aW5nIHRpbGVTaXplIGFuZCB6b29tIGxldmVsc1xyXG5cdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEwuQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cdFx0XHRvcHRpb25zLnpvb21PZmZzZXQrKztcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLm1pblpvb20gPiAwKSB7XHJcblx0XHRcdFx0b3B0aW9ucy5taW5ab29tLS07XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb20tLTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5ib3VuZHMpIHtcclxuXHRcdFx0b3B0aW9ucy5ib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhvcHRpb25zLmJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdHZhciBzdWJkb21haW5zID0gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnM7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBzdWJkb21haW5zID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMuc3ViZG9tYWlucyA9IHN1YmRvbWFpbnMuc3BsaXQoJycpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblx0XHR0aGlzLl9hbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuXHRcdC8vIGNyZWF0ZSBhIGNvbnRhaW5lciBkaXYgZm9yIHRpbGVzXHJcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XHJcblxyXG5cdFx0Ly8gc2V0IHVwIGV2ZW50c1xyXG5cdFx0bWFwLm9uKHtcclxuXHRcdFx0J3ZpZXdyZXNldCc6IHRoaXMuX3Jlc2V0LFxyXG5cdFx0XHQnbW92ZWVuZCc6IHRoaXMuX3VwZGF0ZVxyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vbih7XHJcblx0XHRcdFx0J3pvb21hbmltJzogdGhpcy5fYW5pbWF0ZVpvb20sXHJcblx0XHRcdFx0J3pvb21lbmQnOiB0aGlzLl9lbmRab29tQW5pbVxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSkge1xyXG5cdFx0XHR0aGlzLl9saW1pdGVkVXBkYXRlID0gTC5VdGlsLmxpbWl0RXhlY0J5SW50ZXJ2YWwodGhpcy5fdXBkYXRlLCAxNTAsIHRoaXMpO1xyXG5cdFx0XHRtYXAub24oJ21vdmUnLCB0aGlzLl9saW1pdGVkVXBkYXRlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdG1hcC5vZmYoe1xyXG5cdFx0XHQndmlld3Jlc2V0JzogdGhpcy5fcmVzZXQsXHJcblx0XHRcdCdtb3ZlZW5kJzogdGhpcy5fdXBkYXRlXHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5fYW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9mZih7XHJcblx0XHRcdFx0J3pvb21hbmltJzogdGhpcy5fYW5pbWF0ZVpvb20sXHJcblx0XHRcdFx0J3pvb21lbmQnOiB0aGlzLl9lbmRab29tQW5pbVxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSkge1xyXG5cdFx0XHRtYXAub2ZmKCdtb3ZlJywgdGhpcy5fbGltaXRlZFVwZGF0ZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gbnVsbDtcclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZSA9IHRoaXMuX21hcC5fcGFuZXMudGlsZVBhbmU7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHRwYW5lLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgocGFuZSwgTWF0aC5tYXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZSA9IHRoaXMuX21hcC5fcGFuZXMudGlsZVBhbmU7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHRwYW5lLmluc2VydEJlZm9yZSh0aGlzLl9jb250YWluZXIsIHBhbmUuZmlyc3RDaGlsZCk7XHJcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgocGFuZSwgTWF0aC5taW4pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xyXG5cdH0sXHJcblxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHpJbmRleDtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCwgbm9SZWRyYXcpIHtcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0KHtoYXJkOiB0cnVlfSk7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChwYW5lLCBjb21wYXJlKSB7XHJcblxyXG5cdFx0dmFyIGxheWVycyA9IHBhbmUuY2hpbGRyZW4sXHJcblx0XHQgICAgZWRnZVpJbmRleCA9IC1jb21wYXJlKEluZmluaXR5LCAtSW5maW5pdHkpLCAvLyAtSW5maW5pdHkgZm9yIG1heCwgSW5maW5pdHkgZm9yIG1pblxyXG5cdFx0ICAgIHpJbmRleCwgaSwgbGVuO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cclxuXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdFx0ekluZGV4ID0gcGFyc2VJbnQobGF5ZXJzW2ldLnN0eWxlLnpJbmRleCwgMTApO1xyXG5cclxuXHRcdFx0XHRpZiAoIWlzTmFOKHpJbmRleCkpIHtcclxuXHRcdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsIHpJbmRleCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHRoaXMuX2NvbnRhaW5lci5zdHlsZS56SW5kZXggPVxyXG5cdFx0ICAgICAgICAoaXNGaW5pdGUoZWRnZVpJbmRleCkgPyBlZGdlWkluZGV4IDogMCkgKyBjb21wYXJlKDEsIC0xKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGksXHJcblx0XHQgICAgdGlsZXMgPSB0aGlzLl90aWxlcztcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcblx0XHRcdGZvciAoaSBpbiB0aWxlcykge1xyXG5cdFx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRpbGVzW2ldLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgdGlsZVBhbmUgPSB0aGlzLl9tYXAuX3BhbmVzLnRpbGVQYW5lO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWxheWVyJyk7XHJcblxyXG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9hbmltYXRlZCkge1xyXG5cdFx0XHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC10aWxlLWNvbnRhaW5lcic7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2JnQnVmZmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0XHRcdHRoaXMuX3RpbGVDb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuX3RpbGVDb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRpbGVQYW5lLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHt0aWxlOiB0aGlzLl90aWxlc1trZXldfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdGlsZXMgPSB7fTtcclxuXHRcdHRoaXMuX3RpbGVzVG9Mb2FkID0gMDtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnJldXNlVGlsZXMpIHtcclxuXHRcdFx0dGhpcy5fdW51c2VkVGlsZXMgPSBbXTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl90aWxlQ29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRlZCAmJiBlICYmIGUuaGFyZCkge1xyXG5cdFx0XHR0aGlzLl9jbGVhckJnQnVmZmVyKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSArIHRoaXMub3B0aW9ucy56b29tT2Zmc2V0LFxyXG5cdFx0ICAgIHpvb21OID0gdGhpcy5vcHRpb25zLm1heE5hdGl2ZVpvb20sXHJcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XHJcblxyXG5cdFx0aWYgKHpvb21OICYmIHpvb20gPiB6b29tTikge1xyXG5cdFx0XHR0aWxlU2l6ZSA9IE1hdGgucm91bmQobWFwLmdldFpvb21TY2FsZSh6b29tKSAvIG1hcC5nZXRab29tU2NhbGUoem9vbU4pICogdGlsZVNpemUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aWxlU2l6ZTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBib3VuZHMgPSBtYXAuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcclxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX2dldFRpbGVTaXplKCk7XHJcblxyXG5cdFx0aWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fCB6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0aWxlQm91bmRzID0gTC5ib3VuZHMoXHJcblx0XHQgICAgICAgIGJvdW5kcy5taW4uZGl2aWRlQnkodGlsZVNpemUpLl9mbG9vcigpLFxyXG5cdFx0ICAgICAgICBib3VuZHMubWF4LmRpdmlkZUJ5KHRpbGVTaXplKS5fZmxvb3IoKSk7XHJcblxyXG5cdFx0dGhpcy5fYWRkVGlsZXNGcm9tQ2VudGVyT3V0KHRpbGVCb3VuZHMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMudW5sb2FkSW52aXNpYmxlVGlsZXMgfHwgdGhpcy5vcHRpb25zLnJldXNlVGlsZXMpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlT3RoZXJUaWxlcyh0aWxlQm91bmRzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYWRkVGlsZXNGcm9tQ2VudGVyT3V0OiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR2YXIgcXVldWUgPSBbXSxcclxuXHRcdCAgICBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCk7XHJcblxyXG5cdFx0dmFyIGosIGksIHBvaW50O1xyXG5cclxuXHRcdGZvciAoaiA9IGJvdW5kcy5taW4ueTsgaiA8PSBib3VuZHMubWF4Lnk7IGorKykge1xyXG5cdFx0XHRmb3IgKGkgPSBib3VuZHMubWluLng7IGkgPD0gYm91bmRzLm1heC54OyBpKyspIHtcclxuXHRcdFx0XHRwb2ludCA9IG5ldyBMLlBvaW50KGksIGopO1xyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5fdGlsZVNob3VsZEJlTG9hZGVkKHBvaW50KSkge1xyXG5cdFx0XHRcdFx0cXVldWUucHVzaChwb2ludCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRpbGVzVG9Mb2FkID0gcXVldWUubGVuZ3RoO1xyXG5cclxuXHRcdGlmICh0aWxlc1RvTG9hZCA9PT0gMCkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxyXG5cdFx0cXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG5cdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKGNlbnRlcikgLSBiLmRpc3RhbmNlVG8oY2VudGVyKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuXHJcblx0XHQvLyBpZiBpdHMgdGhlIGZpcnN0IGJhdGNoIG9mIHRpbGVzIHRvIGxvYWRcclxuXHRcdGlmICghdGhpcy5fdGlsZXNUb0xvYWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdGlsZXNUb0xvYWQgKz0gdGlsZXNUb0xvYWQ7XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRpbGVzVG9Mb2FkOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgZnJhZ21lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3RpbGVDb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlU2hvdWxkQmVMb2FkZWQ6IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHRcdGlmICgodGlsZVBvaW50LnggKyAnOicgKyB0aWxlUG9pbnQueSkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBhbHJlYWR5IGxvYWRlZFxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmICghb3B0aW9ucy5jb250aW51b3VzV29ybGQpIHtcclxuXHRcdFx0dmFyIGxpbWl0ID0gdGhpcy5fZ2V0V3JhcFRpbGVOdW0oKTtcclxuXHJcblx0XHRcdC8vIGRvbid0IGxvYWQgaWYgZXhjZWVkcyB3b3JsZCBib3VuZHNcclxuXHRcdFx0aWYgKChvcHRpb25zLm5vV3JhcCAmJiAodGlsZVBvaW50LnggPCAwIHx8IHRpbGVQb2ludC54ID49IGxpbWl0LngpKSB8fFxyXG5cdFx0XHRcdHRpbGVQb2ludC55IDwgMCB8fCB0aWxlUG9pbnQueSA+PSBsaW1pdC55KSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmJvdW5kcykge1xyXG5cdFx0XHR2YXIgdGlsZVNpemUgPSBvcHRpb25zLnRpbGVTaXplLFxyXG5cdFx0XHQgICAgbndQb2ludCA9IHRpbGVQb2ludC5tdWx0aXBseUJ5KHRpbGVTaXplKSxcclxuXHRcdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZChbdGlsZVNpemUsIHRpbGVTaXplXSksXHJcblx0XHRcdCAgICBudyA9IHRoaXMuX21hcC51bnByb2plY3QobndQb2ludCksXHJcblx0XHRcdCAgICBzZSA9IHRoaXMuX21hcC51bnByb2plY3Qoc2VQb2ludCk7XHJcblxyXG5cdFx0XHQvLyBUT0RPIHRlbXBvcmFyeSBoYWNrLCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTYxOFxyXG5cdFx0XHRpZiAoIW9wdGlvbnMuY29udGludW91c1dvcmxkICYmICFvcHRpb25zLm5vV3JhcCkge1xyXG5cdFx0XHRcdG53ID0gbncud3JhcCgpO1xyXG5cdFx0XHRcdHNlID0gc2Uud3JhcCgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIW9wdGlvbnMuYm91bmRzLmludGVyc2VjdHMoW253LCBzZV0pKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVPdGhlclRpbGVzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR2YXIga0FyciwgeCwgeSwga2V5O1xyXG5cclxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XHJcblx0XHRcdGtBcnIgPSBrZXkuc3BsaXQoJzonKTtcclxuXHRcdFx0eCA9IHBhcnNlSW50KGtBcnJbMF0sIDEwKTtcclxuXHRcdFx0eSA9IHBhcnNlSW50KGtBcnJbMV0sIDEwKTtcclxuXHJcblx0XHRcdC8vIHJlbW92ZSB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kc1xyXG5cdFx0XHRpZiAoeCA8IGJvdW5kcy5taW4ueCB8fCB4ID4gYm91bmRzLm1heC54IHx8IHkgPCBib3VuZHMubWluLnkgfHwgeSA+IGJvdW5kcy5tYXgueSkge1xyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XHJcblx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XHJcblxyXG5cdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge3RpbGU6IHRpbGUsIHVybDogdGlsZS5zcmN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnJldXNlVGlsZXMpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRpbGUsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XHJcblx0XHRcdHRoaXMuX3VudXNlZFRpbGVzLnB1c2godGlsZSk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0aWxlLnBhcmVudE5vZGUgPT09IHRoaXMuX3RpbGVDb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5fdGlsZUNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aWxlKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0Nsb3VkTWFkZS9MZWFmbGV0L2lzc3Vlcy8xMzdcclxuXHRcdGlmICghTC5Ccm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0dGlsZS5vbmxvYWQgPSBudWxsO1xyXG5cdFx0XHR0aWxlLnNyYyA9IEwuVXRpbC5lbXB0eUltYWdlVXJsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRUaWxlOiBmdW5jdGlvbiAodGlsZVBvaW50LCBjb250YWluZXIpIHtcclxuXHRcdHZhciB0aWxlUG9zID0gdGhpcy5fZ2V0VGlsZVBvcyh0aWxlUG9pbnQpO1xyXG5cclxuXHRcdC8vIGdldCB1bnVzZWQgdGlsZSAtIG9yIGNyZWF0ZSBhIG5ldyB0aWxlXHJcblx0XHR2YXIgdGlsZSA9IHRoaXMuX2dldFRpbGUoKTtcclxuXHJcblx0XHQvKlxyXG5cdFx0Q2hyb21lIDIwIGxheW91dHMgbXVjaCBmYXN0ZXIgd2l0aCB0b3AvbGVmdCAodmVyaWZ5IHdpdGggdGltZWxpbmUsIGZyYW1lcylcclxuXHRcdEFuZHJvaWQgNCBicm93c2VyIGhhcyBkaXNwbGF5IGlzc3VlcyB3aXRoIHRvcC9sZWZ0IGFuZCByZXF1aXJlcyB0cmFuc2Zvcm0gaW5zdGVhZFxyXG5cdFx0KG90aGVyIGJyb3dzZXJzIGRvbid0IGN1cnJlbnRseSBjYXJlKSAtIHNlZSBkZWJ1Zy9oYWNrcy9qaXR0ZXIuaHRtbCBmb3IgYW4gZXhhbXBsZVxyXG5cdFx0Ki9cclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zLCBMLkJyb3dzZXIuY2hyb21lKTtcclxuXHJcblx0XHR0aGlzLl90aWxlc1t0aWxlUG9pbnQueCArICc6JyArIHRpbGVQb2ludC55XSA9IHRpbGU7XHJcblxyXG5cdFx0dGhpcy5fbG9hZFRpbGUodGlsZSwgdGlsZVBvaW50KTtcclxuXHJcblx0XHRpZiAodGlsZS5wYXJlbnROb2RlICE9PSB0aGlzLl90aWxlQ29udGFpbmVyKSB7XHJcblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbUZvclVybDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdHpvb20gPSBvcHRpb25zLm1heFpvb20gLSB6b29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHpvb20gKz0gb3B0aW9ucy56b29tT2Zmc2V0O1xyXG5cclxuXHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heE5hdGl2ZVpvb20pIDogem9vbTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VGlsZVBvczogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cdFx0dmFyIG9yaWdpbiA9IHRoaXMuX21hcC5nZXRQaXhlbE9yaWdpbigpLFxyXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5fZ2V0VGlsZVNpemUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGlsZVBvaW50Lm11bHRpcGx5QnkodGlsZVNpemUpLnN1YnRyYWN0KG9yaWdpbik7XHJcblx0fSxcclxuXHJcblx0Ly8gaW1hZ2Utc3BlY2lmaWMgY29kZSAob3ZlcnJpZGUgdG8gaW1wbGVtZW50IGUuZy4gQ2FudmFzIG9yIFNWRyB0aWxlIGxheWVyKVxyXG5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHRyZXR1cm4gTC5VdGlsLnRlbXBsYXRlKHRoaXMuX3VybCwgTC5leHRlbmQoe1xyXG5cdFx0XHRzOiB0aGlzLl9nZXRTdWJkb21haW4odGlsZVBvaW50KSxcclxuXHRcdFx0ejogdGlsZVBvaW50LnosXHJcblx0XHRcdHg6IHRpbGVQb2ludC54LFxyXG5cdFx0XHR5OiB0aWxlUG9pbnQueVxyXG5cdFx0fSwgdGhpcy5vcHRpb25zKSk7XHJcblx0fSxcclxuXHJcblx0X2dldFdyYXBUaWxlTnVtOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzLFxyXG5cdFx0ICAgIHNpemUgPSBjcnMuZ2V0U2l6ZSh0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcclxuXHRcdHJldHVybiBzaXplLmRpdmlkZUJ5KHRoaXMuX2dldFRpbGVTaXplKCkpLl9mbG9vcigpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGp1c3RUaWxlUG9pbnQ6IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHJcblx0XHR2YXIgbGltaXQgPSB0aGlzLl9nZXRXcmFwVGlsZU51bSgpO1xyXG5cclxuXHRcdC8vIHdyYXAgdGlsZSBjb29yZGluYXRlc1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuY29udGludW91c1dvcmxkICYmICF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XHJcblx0XHRcdHRpbGVQb2ludC54ID0gKCh0aWxlUG9pbnQueCAlIGxpbWl0LngpICsgbGltaXQueCkgJSBsaW1pdC54O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcblx0XHRcdHRpbGVQb2ludC55ID0gbGltaXQueSAtIHRpbGVQb2ludC55IC0gMTtcclxuXHRcdH1cclxuXHJcblx0XHR0aWxlUG9pbnQueiA9IHRoaXMuX2dldFpvb21Gb3JVcmwoKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0U3ViZG9tYWluOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcblx0fSxcclxuXHJcblx0X2dldFRpbGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmV1c2VUaWxlcyAmJiB0aGlzLl91bnVzZWRUaWxlcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHZhciB0aWxlID0gdGhpcy5fdW51c2VkVGlsZXMucG9wKCk7XHJcblx0XHRcdHRoaXMuX3Jlc2V0VGlsZSh0aWxlKTtcclxuXHRcdFx0cmV0dXJuIHRpbGU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlVGlsZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIE92ZXJyaWRlIGlmIGRhdGEgc3RvcmVkIG9uIGEgdGlsZSBuZWVkcyB0byBiZSBjbGVhbmVkIHVwIGJlZm9yZSByZXVzZVxyXG5cdF9yZXNldFRpbGU6IGZ1bmN0aW9uICgvKnRpbGUqLykge30sXHJcblxyXG5cdF9jcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2ltZycsICdsZWFmbGV0LXRpbGUnKTtcclxuXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlLnN0eWxlLmhlaWdodCA9IHRoaXMuX2dldFRpbGVTaXplKCkgKyAncHgnO1xyXG5cdFx0dGlsZS5nYWxsZXJ5aW1nID0gJ25vJztcclxuXHJcblx0XHR0aWxlLm9uc2VsZWN0c3RhcnQgPSB0aWxlLm9ubW91c2Vtb3ZlID0gTC5VdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5pZWx0OSAmJiB0aGlzLm9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHRcdH1cclxuXHRcdC8vIHdpdGhvdXQgdGhpcyBoYWNrLCB0aWxlcyBkaXNhcHBlYXIgYWZ0ZXIgem9vbSBvbiBDaHJvbWUgZm9yIEFuZHJvaWRcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzIwNzhcclxuXHRcdGlmIChMLkJyb3dzZXIubW9iaWxlV2Via2l0M2QpIHtcclxuXHRcdFx0dGlsZS5zdHlsZS5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aWxlO1xyXG5cdH0sXHJcblxyXG5cdF9sb2FkVGlsZTogZnVuY3Rpb24gKHRpbGUsIHRpbGVQb2ludCkge1xyXG5cdFx0dGlsZS5fbGF5ZXIgID0gdGhpcztcclxuXHRcdHRpbGUub25sb2FkICA9IHRoaXMuX3RpbGVPbkxvYWQ7XHJcblx0XHR0aWxlLm9uZXJyb3IgPSB0aGlzLl90aWxlT25FcnJvcjtcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RUaWxlUG9pbnQodGlsZVBvaW50KTtcclxuXHRcdHRpbGUuc3JjICAgICA9IHRoaXMuZ2V0VGlsZVVybCh0aWxlUG9pbnQpO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcclxuXHRcdFx0dGlsZTogdGlsZSxcclxuXHRcdFx0dXJsOiB0aWxlLnNyY1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3RpbGVzVG9Mb2FkLS07XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGVkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90aWxlQ29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl90aWxlc1RvTG9hZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9hbmltYXRlZCkge1xyXG5cdFx0XHRcdC8vIGNsZWFyIHNjYWxlZCB0aWxlcyBhZnRlciBhbGwgbmV3IHRpbGVzIGFyZSBsb2FkZWQgKGZvciBwZXJmb3JtYW5jZSlcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fY2xlYXJCZ0J1ZmZlclRpbWVyKTtcclxuXHRcdFx0XHR0aGlzLl9jbGVhckJnQnVmZmVyVGltZXIgPSBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9jbGVhckJnQnVmZmVyLCB0aGlzKSwgNTAwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcjtcclxuXHJcblx0XHQvL09ubHkgaWYgd2UgYXJlIGxvYWRpbmcgYW4gYWN0dWFsIGltYWdlXHJcblx0XHRpZiAodGhpcy5zcmMgIT09IEwuVXRpbC5lbXB0eUltYWdlVXJsKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLCAnbGVhZmxldC10aWxlLWxvYWRlZCcpO1xyXG5cclxuXHRcdFx0bGF5ZXIuZmlyZSgndGlsZWxvYWQnLCB7XHJcblx0XHRcdFx0dGlsZTogdGhpcyxcclxuXHRcdFx0XHR1cmw6IHRoaXMuc3JjXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLl90aWxlTG9hZGVkKCk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkVycm9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcjtcclxuXHJcblx0XHRsYXllci5maXJlKCd0aWxlZXJyb3InLCB7XHJcblx0XHRcdHRpbGU6IHRoaXMsXHJcblx0XHRcdHVybDogdGhpcy5zcmNcclxuXHRcdH0pO1xyXG5cclxuXHRcdHZhciBuZXdVcmwgPSBsYXllci5vcHRpb25zLmVycm9yVGlsZVVybDtcclxuXHRcdGlmIChuZXdVcmwpIHtcclxuXHRcdFx0dGhpcy5zcmMgPSBuZXdVcmw7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuX3RpbGVMb2FkZWQoKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC50aWxlTGF5ZXIgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLlRpbGVMYXllcih1cmwsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcclxuICogTC5UaWxlTGF5ZXIuV01TIGlzIHVzZWQgZm9yIHB1dHRpbmcgV01TIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuXHJcbiAqL1xyXG5cclxuTC5UaWxlTGF5ZXIuV01TID0gTC5UaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG5cdFx0c2VydmljZTogJ1dNUycsXHJcblx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHRcdHZlcnNpb246ICcxLjEuMScsXHJcblx0XHRsYXllcnM6ICcnLFxyXG5cdFx0c3R5bGVzOiAnJyxcclxuXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cdFx0dHJhbnNwYXJlbnQ6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBPYmplY3QpXHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdHZhciB3bXNQYXJhbXMgPSBMLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKSxcclxuXHRcdCAgICB0aWxlU2l6ZSA9IG9wdGlvbnMudGlsZVNpemUgfHwgdGhpcy5vcHRpb25zLnRpbGVTaXplO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmRldGVjdFJldGluYSAmJiBMLkJyb3dzZXIucmV0aW5hKSB7XHJcblx0XHRcdHdtc1BhcmFtcy53aWR0aCA9IHdtc1BhcmFtcy5oZWlnaHQgPSB0aWxlU2l6ZSAqIDI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR3bXNQYXJhbXMud2lkdGggPSB3bXNQYXJhbXMuaGVpZ2h0ID0gdGlsZVNpemU7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdC8vIGFsbCBrZXlzIHRoYXQgYXJlIG5vdCBUaWxlTGF5ZXIgb3B0aW9ucyBnbyB0byBXTVMgcGFyYW1zXHJcblx0XHRcdGlmICghdGhpcy5vcHRpb25zLmhhc093blByb3BlcnR5KGkpICYmIGkgIT09ICdjcnMnKSB7XHJcblx0XHRcdFx0d21zUGFyYW1zW2ldID0gb3B0aW9uc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMud21zUGFyYW1zID0gd21zUGFyYW1zO1xyXG5cclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cclxuXHRcdHRoaXMuX2NycyA9IHRoaXMub3B0aW9ucy5jcnMgfHwgbWFwLm9wdGlvbnMuY3JzO1xyXG5cclxuXHRcdHRoaXMuX3dtc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHRoaXMud21zUGFyYW1zLnZlcnNpb24pO1xyXG5cclxuXHRcdHZhciBwcm9qZWN0aW9uS2V5ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xyXG5cdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcblx0XHRMLlRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFN0cmluZ1xyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlsZVNpemUsXHJcblxyXG5cdFx0ICAgIG53UG9pbnQgPSB0aWxlUG9pbnQubXVsdGlwbHlCeSh0aWxlU2l6ZSksXHJcblx0XHQgICAgc2VQb2ludCA9IG53UG9pbnQuYWRkKFt0aWxlU2l6ZSwgdGlsZVNpemVdKSxcclxuXHJcblx0XHQgICAgbncgPSB0aGlzLl9jcnMucHJvamVjdChtYXAudW5wcm9qZWN0KG53UG9pbnQsIHRpbGVQb2ludC56KSksXHJcblx0XHQgICAgc2UgPSB0aGlzLl9jcnMucHJvamVjdChtYXAudW5wcm9qZWN0KHNlUG9pbnQsIHRpbGVQb2ludC56KSksXHJcblx0XHQgICAgYmJveCA9IHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zICYmIHRoaXMuX2NycyA9PT0gTC5DUlMuRVBTRzQzMjYgP1xyXG5cdFx0ICAgICAgICBbc2UueSwgbncueCwgbncueSwgc2UueF0uam9pbignLCcpIDpcclxuXHRcdCAgICAgICAgW253LngsIHNlLnksIHNlLngsIG53LnldLmpvaW4oJywnKSxcclxuXHJcblx0XHQgICAgdXJsID0gTC5VdGlsLnRlbXBsYXRlKHRoaXMuX3VybCwge3M6IHRoaXMuX2dldFN1YmRvbWFpbih0aWxlUG9pbnQpfSk7XHJcblxyXG5cdFx0cmV0dXJuIHVybCArIEwuVXRpbC5nZXRQYXJhbVN0cmluZyh0aGlzLndtc1BhcmFtcywgdXJsLCB0cnVlKSArICcmQkJPWD0nICsgYmJveDtcclxuXHR9LFxyXG5cclxuXHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChwYXJhbXMsIG5vUmVkcmF3KSB7XHJcblxyXG5cdFx0TC5leHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLnRpbGVMYXllci53bXMgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLlRpbGVMYXllci5XTVModXJsLCBvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIEwuVGlsZUxheWVyLkNhbnZhcyBpcyBhIGNsYXNzIHRoYXQgeW91IGNhbiB1c2UgYXMgYSBiYXNlIGZvciBjcmVhdGluZ1xyXG4gKiBkeW5hbWljYWxseSBkcmF3biBDYW52YXMtYmFzZWQgdGlsZSBsYXllcnMuXHJcbiAqL1xyXG5cclxuTC5UaWxlTGF5ZXIuQ2FudmFzID0gTC5UaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHRvcHRpb25zOiB7XHJcblx0XHRhc3luYzogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9yZXNldCh7aGFyZDogdHJ1ZX0pO1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3RpbGVzKSB7XHJcblx0XHRcdHRoaXMuX3JlZHJhd1RpbGUodGhpcy5fdGlsZXNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3JlZHJhd1RpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XHJcblx0XHR0aGlzLmRyYXdUaWxlKHRpbGUsIHRpbGUuX3RpbGVQb2ludCwgdGhpcy5fbWFwLl96b29tKTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XHJcblx0XHR0aWxlLndpZHRoID0gdGlsZS5oZWlnaHQgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XHJcblx0XHR0aWxlLm9uc2VsZWN0c3RhcnQgPSB0aWxlLm9ubW91c2Vtb3ZlID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRyZXR1cm4gdGlsZTtcclxuXHR9LFxyXG5cclxuXHRfbG9hZFRpbGU6IGZ1bmN0aW9uICh0aWxlLCB0aWxlUG9pbnQpIHtcclxuXHRcdHRpbGUuX2xheWVyID0gdGhpcztcclxuXHRcdHRpbGUuX3RpbGVQb2ludCA9IHRpbGVQb2ludDtcclxuXHJcblx0XHR0aGlzLl9yZWRyYXdUaWxlKHRpbGUpO1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmFzeW5jKSB7XHJcblx0XHRcdHRoaXMudGlsZURyYXduKHRpbGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGRyYXdUaWxlOiBmdW5jdGlvbiAoLyp0aWxlLCB0aWxlUG9pbnQqLykge1xyXG5cdFx0Ly8gb3ZlcnJpZGUgd2l0aCByZW5kZXJpbmcgY29kZVxyXG5cdH0sXHJcblxyXG5cdHRpbGVEcmF3bjogZnVuY3Rpb24gKHRpbGUpIHtcclxuXHRcdHRoaXMuX3RpbGVPbkxvYWQuY2FsbCh0aWxlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbkwudGlsZUxheWVyLmNhbnZhcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLlRpbGVMYXllci5DYW52YXMob3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLkltYWdlT3ZlcmxheSBpcyB1c2VkIHRvIG92ZXJsYXkgaW1hZ2VzIG92ZXIgdGhlIG1hcCAodG8gc3BlY2lmaWMgZ2VvZ3JhcGhpY2FsIGJvdW5kcykuXHJcbiAqL1xyXG5cclxuTC5JbWFnZU92ZXJsYXkgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0aW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRvcGFjaXR5OiAxXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIExhdExuZ0JvdW5kcywgT2JqZWN0KVxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cdFx0dGhpcy5fYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1hcC5fcGFuZXMub3ZlcmxheVBhbmUuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cclxuXHRcdG1hcC5vbigndmlld3Jlc2V0JywgdGhpcy5fcmVzZXQsIHRoaXMpO1xyXG5cclxuXHRcdGlmIChtYXAub3B0aW9ucy56b29tQW5pbWF0aW9uICYmIEwuQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRtYXAub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5nZXRQYW5lcygpLm92ZXJsYXlQYW5lLnJlbW92ZUNoaWxkKHRoaXMuX2ltYWdlKTtcclxuXHJcblx0XHRtYXAub2ZmKCd2aWV3cmVzZXQnLCB0aGlzLl9yZXNldCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKG1hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPIHJlbW92ZSBicmluZ1RvRnJvbnQvYnJpbmdUb0JhY2sgZHVwbGljYXRpb24gZnJvbSBUaWxlTGF5ZXIvUGF0aFxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5fcGFuZXMub3ZlcmxheVBhbmUuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lID0gdGhpcy5fbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHRwYW5lLmluc2VydEJlZm9yZSh0aGlzLl9pbWFnZSwgcGFuZS5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCkge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cdFx0dGhpcy5faW1hZ2Uuc3JjID0gdGhpcy5fdXJsO1xyXG5cdH0sXHJcblxyXG5cdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2ltYWdlID0gTC5Eb21VdGlsLmNyZWF0ZSgnaW1nJywgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBMLkJyb3dzZXIuYW55M2QpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5faW1hZ2UsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHJcblx0XHQvL1RPRE8gY3JlYXRlSW1hZ2UgdXRpbCBtZXRob2QgdG8gcmVtb3ZlIGR1cGxpY2F0aW9uXHJcblx0XHRMLmV4dGVuZCh0aGlzLl9pbWFnZSwge1xyXG5cdFx0XHRnYWxsZXJ5aW1nOiAnbm8nLFxyXG5cdFx0XHRvbnNlbGVjdHN0YXJ0OiBMLlV0aWwuZmFsc2VGbixcclxuXHRcdFx0b25tb3VzZW1vdmU6IEwuVXRpbC5mYWxzZUZuLFxyXG5cdFx0XHRvbmxvYWQ6IEwuYmluZCh0aGlzLl9vbkltYWdlTG9hZCwgdGhpcyksXHJcblx0XHRcdHNyYzogdGhpcy5fdXJsXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGltYWdlID0gdGhpcy5faW1hZ2UsXHJcblx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcblx0XHQgICAgbncgPSB0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXHJcblx0XHQgICAgc2UgPSB0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIHRvcExlZnQgPSBtYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludChudywgZS56b29tLCBlLmNlbnRlciksXHJcblx0XHQgICAgc2l6ZSA9IG1hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHNlLCBlLnpvb20sIGUuY2VudGVyKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHQgICAgb3JpZ2luID0gdG9wTGVmdC5fYWRkKHNpemUuX211bHRpcGx5QnkoKDEgLyAyKSAqICgxIC0gMSAvIHNjYWxlKSkpO1xyXG5cclxuXHRcdGltYWdlLnN0eWxlW0wuRG9tVXRpbC5UUkFOU0ZPUk1dID1cclxuXHRcdCAgICAgICAgTC5Eb21VdGlsLmdldFRyYW5zbGF0ZVN0cmluZyhvcmlnaW4pICsgJyBzY2FsZSgnICsgc2NhbGUgKyAnKSAnO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGltYWdlICAgPSB0aGlzLl9pbWFnZSxcclxuXHRcdCAgICB0b3BMZWZ0ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXRTb3V0aEVhc3QoKSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihpbWFnZSwgdG9wTGVmdCk7XHJcblxyXG5cdFx0aW1hZ2Uuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0fSxcclxuXHJcblx0X29uSW1hZ2VMb2FkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5faW1hZ2UsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5pbWFnZU92ZXJsYXkgPSBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIEwuSWNvbiBpcyBhbiBpbWFnZS1iYXNlZCBpY29uIGNsYXNzIHRoYXQgeW91IGNhbiB1c2Ugd2l0aCBMLk1hcmtlciBmb3IgY3VzdG9tIG1hcmtlcnMuXHJcbiAqL1xyXG5cclxuTC5JY29uID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8qXHJcblx0XHRpY29uVXJsOiAoU3RyaW5nKSAocmVxdWlyZWQpXHJcblx0XHRpY29uUmV0aW5hVXJsOiAoU3RyaW5nKSAob3B0aW9uYWwsIHVzZWQgZm9yIHJldGluYSBkZXZpY2VzIGlmIGRldGVjdGVkKVxyXG5cdFx0aWNvblNpemU6IChQb2ludCkgKGNhbiBiZSBzZXQgdGhyb3VnaCBDU1MpXHJcblx0XHRpY29uQW5jaG9yOiAoUG9pbnQpIChjZW50ZXJlZCBieSBkZWZhdWx0LCBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMpXHJcblx0XHRwb3B1cEFuY2hvcjogKFBvaW50KSAoaWYgbm90IHNwZWNpZmllZCwgcG9wdXAgb3BlbnMgaW4gdGhlIGFuY2hvciBwb2ludClcclxuXHRcdHNoYWRvd1VybDogKFN0cmluZykgKG5vIHNoYWRvdyBieSBkZWZhdWx0KVxyXG5cdFx0c2hhZG93UmV0aW5hVXJsOiAoU3RyaW5nKSAob3B0aW9uYWwsIHVzZWQgZm9yIHJldGluYSBkZXZpY2VzIGlmIGRldGVjdGVkKVxyXG5cdFx0c2hhZG93U2l6ZTogKFBvaW50KVxyXG5cdFx0c2hhZG93QW5jaG9yOiAoUG9pbnQpXHJcblx0XHQqL1xyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdpY29uJywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ3NoYWRvdycsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJY29uOiBmdW5jdGlvbiAobmFtZSwgb2xkSWNvbikge1xyXG5cdFx0dmFyIHNyYyA9IHRoaXMuX2dldEljb25VcmwobmFtZSk7XHJcblxyXG5cdFx0aWYgKCFzcmMpIHtcclxuXHRcdFx0aWYgKG5hbWUgPT09ICdpY29uJykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW1nO1xyXG5cdFx0aWYgKCFvbGRJY29uIHx8IG9sZEljb24udGFnTmFtZSAhPT0gJ0lNRycpIHtcclxuXHRcdFx0aW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpbWcgPSB0aGlzLl9jcmVhdGVJbWcoc3JjLCBvbGRJY29uKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoaW1nLCBuYW1lKTtcclxuXHJcblx0XHRyZXR1cm4gaW1nO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRJY29uU3R5bGVzOiBmdW5jdGlvbiAoaW1nLCBuYW1lKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBzaXplID0gTC5wb2ludChvcHRpb25zW25hbWUgKyAnU2l6ZSddKSxcclxuXHRcdCAgICBhbmNob3I7XHJcblxyXG5cdFx0aWYgKG5hbWUgPT09ICdzaGFkb3cnKSB7XHJcblx0XHRcdGFuY2hvciA9IEwucG9pbnQob3B0aW9ucy5zaGFkb3dBbmNob3IgfHwgb3B0aW9ucy5pY29uQW5jaG9yKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGFuY2hvciA9IEwucG9pbnQob3B0aW9ucy5pY29uQW5jaG9yKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWFuY2hvciAmJiBzaXplKSB7XHJcblx0XHRcdGFuY2hvciA9IHNpemUuZGl2aWRlQnkoMiwgdHJ1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIG9wdGlvbnMuY2xhc3NOYW1lO1xyXG5cclxuXHRcdGlmIChhbmNob3IpIHtcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpbkxlZnQgPSAoLWFuY2hvci54KSArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5Ub3AgID0gKC1hbmNob3IueSkgKyAncHgnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzaXplKSB7XHJcblx0XHRcdGltZy5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSW1nOiBmdW5jdGlvbiAoc3JjLCBlbCkge1xyXG5cdFx0ZWwgPSBlbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHRcdGVsLnNyYyA9IHNyYztcclxuXHRcdHJldHVybiBlbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdGlmIChMLkJyb3dzZXIucmV0aW5hICYmIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNbbmFtZSArICdSZXRpbmFVcmwnXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnNbbmFtZSArICdVcmwnXTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5pY29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuSWNvbihvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXG4gKiBMLkljb24uRGVmYXVsdCBpcyB0aGUgYmx1ZSBtYXJrZXIgaWNvbiB1c2VkIGJ5IGRlZmF1bHQgaW4gTGVhZmxldC5cbiAqL1xuXG5MLkljb24uRGVmYXVsdCA9IEwuSWNvbi5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRpY29uU2l6ZTogWzI1LCA0MV0sXG5cdFx0aWNvbkFuY2hvcjogWzEyLCA0MV0sXG5cdFx0cG9wdXBBbmNob3I6IFsxLCAtMzRdLFxuXG5cdFx0c2hhZG93U2l6ZTogWzQxLCA0MV1cblx0fSxcblxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHR2YXIga2V5ID0gbmFtZSArICdVcmwnO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9uc1trZXldKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zW2tleV07XG5cdFx0fVxuXG5cdFx0aWYgKEwuQnJvd3Nlci5yZXRpbmEgJiYgbmFtZSA9PT0gJ2ljb24nKSB7XG5cdFx0XHRuYW1lICs9ICctMngnO1xuXHRcdH1cblxuXHRcdHZhciBwYXRoID0gTC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoO1xuXG5cdFx0aWYgKCFwYXRoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkblxcJ3QgYXV0b2RldGVjdCBMLkljb24uRGVmYXVsdC5pbWFnZVBhdGgsIHNldCBpdCBtYW51YWxseS4nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0aCArICcvbWFya2VyLScgKyBuYW1lICsgJy5wbmcnO1xuXHR9XG59KTtcblxuTC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JyksXG5cdCAgICBsZWFmbGV0UmUgPSAvW1xcL15dbGVhZmxldFtcXC1cXC5fXT8oW1xcd1xcLVxcLl9dKilcXC5qc1xcPz8vO1xuXG5cdHZhciBpLCBsZW4sIHNyYywgbWF0Y2hlcywgcGF0aDtcblxuXHRmb3IgKGkgPSAwLCBsZW4gPSBzY3JpcHRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0c3JjID0gc2NyaXB0c1tpXS5zcmM7XG5cdFx0bWF0Y2hlcyA9IHNyYy5tYXRjaChsZWFmbGV0UmUpO1xuXG5cdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdHBhdGggPSBzcmMuc3BsaXQobGVhZmxldFJlKVswXTtcblx0XHRcdHJldHVybiAocGF0aCA/IHBhdGggKyAnLycgOiAnJykgKyAnaW1hZ2VzJztcblx0XHR9XG5cdH1cbn0oKSk7XG5cblxuLypcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC5cclxuICovXHJcblxyXG5MLk1hcmtlciA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0aW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRpY29uOiBuZXcgTC5JY29uLkRlZmF1bHQoKSxcclxuXHRcdHRpdGxlOiAnJyxcclxuXHRcdGFsdDogJycsXHJcblx0XHRjbGlja2FibGU6IHRydWUsXHJcblx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cdFx0a2V5Ym9hcmQ6IHRydWUsXHJcblx0XHR6SW5kZXhPZmZzZXQ6IDAsXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cdFx0cmlzZU9uSG92ZXI6IGZhbHNlLFxyXG5cdFx0cmlzZU9mZnNldDogMjUwXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdG1hcC5vbigndmlld3Jlc2V0JywgdGhpcy51cGRhdGUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0dGhpcy5maXJlKCdhZGQnKTtcclxuXHJcblx0XHRpZiAobWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBtYXAub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAodGhpcy5kcmFnZ2luZykge1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3JlbW92ZScpO1xyXG5cclxuXHRcdG1hcC5vZmYoe1xyXG5cdFx0XHQndmlld3Jlc2V0JzogdGhpcy51cGRhdGUsXHJcblx0XHRcdCd6b29tYW5pbSc6IHRoaXMuX2FuaW1hdGVab29tXHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywgeyBsYXRsbmc6IHRoaXMuX2xhdGxuZyB9KTtcclxuXHR9LFxyXG5cclxuXHRzZXRaSW5kZXhPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQgPSBvZmZzZXQ7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldEljb246IGZ1bmN0aW9uIChpY29uKSB7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLmljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5iaW5kUG9wdXAodGhpcy5fcG9wdXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG5cdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBhbmltYXRpb24gPSAobWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBtYXAub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSxcclxuXHRcdCAgICBjbGFzc1RvQWRkID0gYW5pbWF0aW9uID8gJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcgOiAnbGVhZmxldC16b29tLWhpZGUnO1xyXG5cclxuXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcblx0XHRcdGFkZEljb24gPSBmYWxzZTtcclxuXHJcblx0XHQvLyBpZiB3ZSdyZSBub3QgcmV1c2luZyB0aGUgaWNvbiwgcmVtb3ZlIHRoZSBvbGQgb25lIGFuZCBpbml0IG5ldyBvbmVcclxuXHRcdGlmIChpY29uICE9PSB0aGlzLl9pY29uKSB7XHJcblx0XHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGFkZEljb24gPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMudGl0bGUpIHtcclxuXHRcdFx0XHRpY29uLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0aWYgKG9wdGlvbnMuYWx0KSB7XHJcblx0XHRcdFx0aWNvbi5hbHQgPSBvcHRpb25zLmFsdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhpY29uLCBjbGFzc1RvQWRkKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5rZXlib2FyZCkge1xyXG5cdFx0XHRpY29uLnRhYkluZGV4ID0gJzAnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBpY29uO1xyXG5cclxuXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0XHQub24oaWNvbiwgJ21vdXNlb3ZlcicsIHRoaXMuX2JyaW5nVG9Gcm9udCwgdGhpcylcclxuXHRcdFx0XHQub24oaWNvbiwgJ21vdXNlb3V0JywgdGhpcy5fcmVzZXRaSW5kZXgsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdTaGFkb3cgPSBvcHRpb25zLmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdyksXHJcblx0XHRcdGFkZFNoYWRvdyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cgIT09IHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHRcdFx0YWRkU2hhZG93ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobmV3U2hhZG93KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhuZXdTaGFkb3csIGNsYXNzVG9BZGQpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbmV3U2hhZG93O1xyXG5cclxuXHJcblx0XHRpZiAob3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHZhciBwYW5lcyA9IHRoaXMuX21hcC5fcGFuZXM7XHJcblxyXG5cdFx0aWYgKGFkZEljb24pIHtcclxuXHRcdFx0cGFuZXMubWFya2VyUGFuZS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICYmIGFkZFNoYWRvdykge1xyXG5cdFx0XHRwYW5lcy5zaGFkb3dQYW5lLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0TC5Eb21FdmVudFxyXG5cdFx0XHQgICAgLm9mZih0aGlzLl9pY29uLCAnbW91c2VvdmVyJywgdGhpcy5fYnJpbmdUb0Zyb250KVxyXG5cdFx0XHQgICAgLm9mZih0aGlzLl9pY29uLCAnbW91c2VvdXQnLCB0aGlzLl9yZXNldFpJbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLl9wYW5lcy5tYXJrZXJQYW5lLnJlbW92ZUNoaWxkKHRoaXMuX2ljb24pO1xyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fbWFwLl9wYW5lcy5zaGFkb3dQYW5lLnJlbW92ZUNoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRQb3M6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5jbGlja2FibGUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gVE9ETyByZWZhY3RvciBpbnRvIHNvbWV0aGluZyBzaGFyZWQgd2l0aCBNYXAvUGF0aC9ldGMuIHRvIERSWSBpdCB1cFxyXG5cclxuXHRcdHZhciBpY29uID0gdGhpcy5faWNvbixcclxuXHRcdCAgICBldmVudHMgPSBbJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnY29udGV4dG1lbnUnXTtcclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XHJcblx0XHRMLkRvbUV2ZW50Lm9uKGljb24sICdjbGljaycsIHRoaXMuX29uTW91c2VDbGljaywgdGhpcyk7XHJcblx0XHRMLkRvbUV2ZW50Lm9uKGljb24sICdrZXlwcmVzcycsIHRoaXMuX29uS2V5UHJlc3MsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub24oaWNvbiwgZXZlbnRzW2ldLCB0aGlzLl9maXJlTW91c2VFdmVudCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEwuSGFuZGxlci5NYXJrZXJEcmFnKSB7XHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTC5IYW5kbGVyLk1hcmtlckRyYWcodGhpcyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmRyYWdnYWJsZSkge1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25Nb3VzZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHdhc0RyYWdnZWQgPSB0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcubW92ZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5oYXNFdmVudExpc3RlbmVycyhlLnR5cGUpIHx8IHdhc0RyYWdnZWQpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHdhc0RyYWdnZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKCghdGhpcy5kcmFnZ2luZyB8fCAhdGhpcy5kcmFnZ2luZy5fZW5hYmxlZCkgJiYgdGhpcy5fbWFwLmRyYWdnaW5nICYmIHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZlZCgpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuZmlyZShlLnR5cGUsIHtcclxuXHRcdFx0b3JpZ2luYWxFdmVudDogZSxcclxuXHRcdFx0bGF0bG5nOiB0aGlzLl9sYXRsbmdcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9vbktleVByZXNzOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdjbGljaycsIHtcclxuXHRcdFx0XHRvcmlnaW5hbEV2ZW50OiBlLFxyXG5cdFx0XHRcdGxhdGxuZzogdGhpcy5fbGF0bG5nXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maXJlTW91c2VFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHJcblx0XHR0aGlzLmZpcmUoZS50eXBlLCB7XHJcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGUsXHJcblx0XHRcdGxhdGxuZzogdGhpcy5fbGF0bG5nXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBUT0RPIHByb3BlciBjdXN0b20gZXZlbnQgcHJvcGFnYXRpb25cclxuXHRcdC8vIHRoaXMgbGluZSB3aWxsIGFsd2F5cyBiZSBjYWxsZWQgaWYgbWFya2VyIGlzIGluIGEgRmVhdHVyZUdyb3VwXHJcblx0XHRpZiAoZS50eXBlID09PSAnY29udGV4dG1lbnUnICYmIHRoaXMuaGFzRXZlbnRMaXN0ZW5lcnMoZS50eXBlKSkge1xyXG5cdFx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGUudHlwZSAhPT0gJ21vdXNlZG93bicpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5faWNvbiwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9zaGFkb3csIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgodGhpcy5vcHRpb25zLnJpc2VPZmZzZXQpO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldFpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KDApO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLm1hcmtlciA9IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxuICogTC5EaXZJY29uIGlzIGEgbGlnaHR3ZWlnaHQgSFRNTC1iYXNlZCBpY29uIGNsYXNzIChhcyBvcHBvc2VkIHRvIHRoZSBpbWFnZS1iYXNlZCBMLkljb24pXG4gKiB0byB1c2Ugd2l0aCBMLk1hcmtlci5cbiAqL1xuXG5MLkRpdkljb24gPSBMLkljb24uZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdGljb25TaXplOiBbMTIsIDEyXSwgLy8gYWxzbyBjYW4gYmUgc2V0IHRocm91Z2ggQ1NTXG5cdFx0Lypcblx0XHRpY29uQW5jaG9yOiAoUG9pbnQpXG5cdFx0cG9wdXBBbmNob3I6IChQb2ludClcblx0XHRodG1sOiAoU3RyaW5nKVxuXHRcdGJnUG9zOiAoUG9pbnQpXG5cdFx0Ki9cblx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uJyxcblx0XHRodG1sOiBmYWxzZVxuXHR9LFxuXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XG5cdFx0dmFyIGRpdiA9IChvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0RJVicpID8gb2xkSWNvbiA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdGlvbnMuaHRtbCAhPT0gZmFsc2UpIHtcblx0XHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpdi5pbm5lckhUTUwgPSAnJztcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5iZ1Bvcykge1xuXHRcdFx0ZGl2LnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9XG5cdFx0XHQgICAgICAgICgtb3B0aW9ucy5iZ1Bvcy54KSArICdweCAnICsgKC1vcHRpb25zLmJnUG9zLnkpICsgJ3B4Jztcblx0XHR9XG5cblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGRpdiwgJ2ljb24nKTtcblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuTC5kaXZJY29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLkRpdkljb24ob3B0aW9ucyk7XG59O1xuXG5cbi8qXHJcbiAqIEwuUG9wdXAgaXMgdXNlZCBmb3IgZGlzcGxheWluZyBwb3B1cHMgb24gdGhlIG1hcC5cclxuICovXHJcblxyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbn0pO1xyXG5cclxuTC5Qb3B1cCA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHRpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdG1pbldpZHRoOiA1MCxcclxuXHRcdG1heFdpZHRoOiAzMDAsXHJcblx0XHQvLyBtYXhIZWlnaHQ6IG51bGwsXHJcblx0XHRhdXRvUGFuOiB0cnVlLFxyXG5cdFx0Y2xvc2VCdXR0b246IHRydWUsXHJcblx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNSwgNV0sXHJcblx0XHQvLyBhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IG51bGwsXHJcblx0XHQvLyBhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBudWxsLFxyXG5cdFx0a2VlcEluVmlldzogZmFsc2UsXHJcblx0XHRjbGFzc05hbWU6ICcnLFxyXG5cdFx0em9vbUFuaW1hdGlvbjogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblx0XHR0aGlzLl9hbmltYXRlZCA9IEwuQnJvd3Nlci5hbnkzZCAmJiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbjtcclxuXHRcdHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhbmltRmFkZSA9IG1hcC5vcHRpb25zLmZhZGVBbmltYXRpb247XHJcblxyXG5cdFx0aWYgKGFuaW1GYWRlKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHR9XHJcblx0XHRtYXAuX3BhbmVzLnBvcHVwUGFuZS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdG1hcC5vbih0aGlzLl9nZXRFdmVudHMoKSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRpZiAoYW5pbUZhZGUpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAxKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmZpcmUoJ29wZW4nKTtcclxuXHJcblx0XHRtYXAuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9wZW5Qb3B1cCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAuX3BhbmVzLnBvcHVwUGFuZS5yZW1vdmVDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdEwuVXRpbC5mYWxzZUZuKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aCk7IC8vIGZvcmNlIHJlZmxvd1xyXG5cclxuXHRcdG1hcC5vZmYodGhpcy5fZ2V0RXZlbnRzKCksIHRoaXMpO1xyXG5cclxuXHRcdGlmIChtYXAub3B0aW9ucy5mYWRlQW5pbWF0aW9uKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ2Nsb3NlJyk7XHJcblxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcclxuXHR9LFxyXG5cclxuXHRzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0dGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZUxheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cclxuXHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fdXBkYXRlUG9zaXRpb25cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGVkKSB7XHJcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX3pvb21BbmltYXRpb247XHJcblx0XHR9XHJcblx0XHRpZiAoJ2Nsb3NlT25DbGljaycgaW4gdGhpcy5vcHRpb25zID8gdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA6IHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSB7XHJcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5jbG9zZVBvcHVwKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtcG9wdXAnLFxyXG5cdFx0XHRjb250YWluZXJDbGFzcyA9IHByZWZpeCArICcgJyArIHRoaXMub3B0aW9ucy5jbGFzc05hbWUgKyAnIGxlYWZsZXQtem9vbS0nICtcclxuXHRcdFx0ICAgICAgICAodGhpcy5fYW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKSxcclxuXHRcdFx0Y29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY29udGFpbmVyQ2xhc3MpLFxyXG5cdFx0XHRjbG9zZUJ1dHRvbjtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XHJcblx0XHRcdGNsb3NlQnV0dG9uID0gdGhpcy5fY2xvc2VCdXR0b24gPVxyXG5cdFx0XHQgICAgICAgIEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJyYjMjE1Oyc7XHJcblx0XHRcdEwuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY2xvc2VCdXR0b24pO1xyXG5cclxuXHRcdFx0TC5Eb21FdmVudC5vbihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgdGhpcy5fb25DbG9zZUJ1dHRvbkNsaWNrLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPVxyXG5cdFx0ICAgICAgICBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQtd3JhcHBlcicsIGNvbnRhaW5lcik7XHJcblx0XHRMLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHdyYXBwZXIpO1xyXG5cclxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50Jywgd3JhcHBlcik7XHJcblxyXG5cdFx0TC5Eb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24odGhpcy5fY29udGVudE5vZGUpO1xyXG5cdFx0TC5Eb21FdmVudC5vbih3cmFwcGVyLCAnY29udGV4dG1lbnUnLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblxyXG5cdFx0dGhpcy5fdGlwQ29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAtY29udGFpbmVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX3RpcCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwJywgdGhpcy5fdGlwQ29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlQ29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250ZW50KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICh0eXBlb2YgdGhpcy5fY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0dGhpcy5fY29udGVudE5vZGUuaW5uZXJIVE1MID0gdGhpcy5fY29udGVudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHdoaWxlICh0aGlzLl9jb250ZW50Tm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuXHRcdFx0XHR0aGlzLl9jb250ZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jb250ZW50Tm9kZS5maXJzdENoaWxkKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9jb250ZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLl9jb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHRoaXMuZmlyZSgnY29udGVudHVwZGF0ZScpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250ZW50Tm9kZSxcclxuXHRcdCAgICBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICcnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHRcdHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMub3B0aW9ucy5tYXhXaWR0aCk7XHJcblx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gKHdpZHRoICsgMSkgKyAncHgnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICcnO1xyXG5cclxuXHRcdHN0eWxlLmhlaWdodCA9ICcnO1xyXG5cclxuXHRcdHZhciBoZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG5cdFx0ICAgIG1heEhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQsXHJcblx0XHQgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJztcclxuXHJcblx0XHRpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xyXG5cdFx0XHRzdHlsZS5oZWlnaHQgPSBtYXhIZWlnaHQgKyAncHgnO1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdCAgICBhbmltYXRlZCA9IHRoaXMuX2FuaW1hdGVkLFxyXG5cdFx0ICAgIG9mZnNldCA9IEwucG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCk7XHJcblxyXG5cdFx0aWYgKGFuaW1hdGVkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyQm90dG9tID0gLW9mZnNldC55IC0gKGFuaW1hdGVkID8gMCA6IHBvcy55KTtcclxuXHRcdHRoaXMuX2NvbnRhaW5lckxlZnQgPSAtTWF0aC5yb3VuZCh0aGlzLl9jb250YWluZXJXaWR0aCAvIDIpICsgb2Zmc2V0LnggKyAoYW5pbWF0ZWQgPyAwIDogcG9zLngpO1xyXG5cclxuXHRcdC8vIGJvdHRvbSBwb3NpdGlvbiB0aGUgcG9wdXAgaW4gY2FzZSB0aGUgaGVpZ2h0IG9mIHRoZSBwb3B1cCBjaGFuZ2VzIChpbWFnZXMgbG9hZGluZyBldGMpXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuYm90dG9tID0gdGhpcy5fY29udGFpbmVyQm90dG9tICsgJ3B4JztcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5sZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCArICdweCc7XHJcblx0fSxcclxuXHJcblx0X3pvb21BbmltYXRpb246IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKTtcclxuXHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmF1dG9QYW4pIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG5cdFx0ICAgIGNvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyV2lkdGgsXHJcblxyXG5cdFx0ICAgIGxheWVyUG9zID0gbmV3IEwuUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGVkKSB7XHJcblx0XHRcdGxheWVyUG9zLl9hZGQoTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjb250YWluZXJQb3MgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQobGF5ZXJQb3MpLFxyXG5cdFx0ICAgIHBhZGRpbmcgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ1RMID0gTC5wb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IEwucG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgc2l6ZSA9IG1hcC5nZXRTaXplKCksXHJcblx0XHQgICAgZHggPSAwLFxyXG5cdFx0ICAgIGR5ID0gMDtcclxuXHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCArIHBhZGRpbmdCUi54ID4gc2l6ZS54KSB7IC8vIHJpZ2h0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCAtIHNpemUueCArIHBhZGRpbmdCUi54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54IC0gZHggLSBwYWRkaW5nVEwueCA8IDApIHsgLy8gbGVmdFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54IC0gcGFkZGluZ1RMLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgKyBwYWRkaW5nQlIueSA+IHNpemUueSkgeyAvLyBib3R0b21cclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55IC0gZHkgLSBwYWRkaW5nVEwueSA8IDApIHsgLy8gdG9wXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgLSBwYWRkaW5nVEwueTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZHggfHwgZHkpIHtcclxuXHRcdFx0bWFwXHJcblx0XHRcdCAgICAuZmlyZSgnYXV0b3BhbnN0YXJ0JylcclxuXHRcdFx0ICAgIC5wYW5CeShbZHgsIGR5XSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uQ2xvc2VCdXR0b25DbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX2Nsb3NlKCk7XHJcblx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XHJcblx0fVxyXG59KTtcclxuXHJcbkwucG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0cmV0dXJuIG5ldyBMLlBvcHVwKG9wdGlvbnMsIHNvdXJjZSk7XHJcbn07XHJcblxyXG5cclxuTC5NYXAuaW5jbHVkZSh7XHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAocG9wdXAsIGxhdGxuZywgb3B0aW9ucykgeyAvLyAoUG9wdXApIG9yIChTdHJpbmcgfHwgSFRNTEVsZW1lbnQsIExhdExuZ1ssIE9iamVjdF0pXHJcblx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHJcblx0XHRpZiAoIShwb3B1cCBpbnN0YW5jZW9mIEwuUG9wdXApKSB7XHJcblx0XHRcdHZhciBjb250ZW50ID0gcG9wdXA7XHJcblxyXG5cdFx0XHRwb3B1cCA9IG5ldyBMLlBvcHVwKG9wdGlvbnMpXHJcblx0XHRcdCAgICAuc2V0TGF0TG5nKGxhdGxuZylcclxuXHRcdFx0ICAgIC5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0cG9wdXAuX2lzT3BlbiA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5fcG9wdXAgPSBwb3B1cDtcclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKHBvcHVwKTtcclxuXHR9LFxyXG5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAocG9wdXApIHtcclxuXHRcdGlmICghcG9wdXAgfHwgcG9wdXAgPT09IHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHBvcHVwID0gdGhpcy5fcG9wdXA7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdH1cclxuXHRcdGlmIChwb3B1cCkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUxheWVyKHBvcHVwKTtcclxuXHRcdFx0cG9wdXAuX2lzT3BlbiA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXG5cbi8qXHJcbiAqIFBvcHVwIGV4dGVuc2lvbiB0byBMLk1hcmtlciwgYWRkaW5nIHBvcHVwLXJlbGF0ZWQgbWV0aG9kcy5cclxuICovXHJcblxyXG5MLk1hcmtlci5pbmNsdWRlKHtcclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkpIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKHRoaXMuX2xhdGxuZyk7XHJcblx0XHRcdHRoaXMuX21hcC5vcGVuUG9wdXAodGhpcy5fcG9wdXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5fY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHRvZ2dsZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0aWYgKHRoaXMuX3BvcHVwLl9pc09wZW4pIHtcclxuXHRcdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLm9wZW5Qb3B1cCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRiaW5kUG9wdXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XHJcblx0XHR2YXIgYW5jaG9yID0gTC5wb2ludCh0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yIHx8IFswLCAwXSk7XHJcblxyXG5cdFx0YW5jaG9yID0gYW5jaG9yLmFkZChMLlBvcHVwLnByb3RvdHlwZS5vcHRpb25zLm9mZnNldCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vZmZzZXQpIHtcclxuXHRcdFx0YW5jaG9yID0gYW5jaG9yLmFkZChvcHRpb25zLm9mZnNldCk7XHJcblx0XHR9XHJcblxyXG5cdFx0b3B0aW9ucyA9IEwuZXh0ZW5kKHtvZmZzZXQ6IGFuY2hvcn0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5vbignY2xpY2snLCB0aGlzLnRvZ2dsZVBvcHVwLCB0aGlzKVxyXG5cdFx0XHQgICAgLm9uKCdyZW1vdmUnLCB0aGlzLmNsb3NlUG9wdXAsIHRoaXMpXHJcblx0XHRcdCAgICAub24oJ21vdmUnLCB0aGlzLl9tb3ZlUG9wdXAsIHRoaXMpO1xyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgTC5Qb3B1cCkge1xyXG5cdFx0XHRMLnNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gY29udGVudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbmV3IEwuUG9wdXAob3B0aW9ucywgdGhpcylcclxuXHRcdFx0XHQuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRQb3B1cENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHVuYmluZFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAub2ZmKCdjbGljaycsIHRoaXMudG9nZ2xlUG9wdXAsIHRoaXMpXHJcblx0XHRcdCAgICAub2ZmKCdyZW1vdmUnLCB0aGlzLmNsb3NlUG9wdXAsIHRoaXMpXHJcblx0XHRcdCAgICAub2ZmKCdtb3ZlJywgdGhpcy5fbW92ZVBvcHVwLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BvcHVwO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xyXG5cdH1cclxufSk7XHJcblxuXG4vKlxyXG4gKiBMLkxheWVyR3JvdXAgaXMgYSBjbGFzcyB0byBjb21iaW5lIHNldmVyYWwgbGF5ZXJzIGludG8gb25lIHNvIHRoYXRcclxuICogeW91IGNhbiBtYW5pcHVsYXRlIHRoZSBncm91cCAoZS5nLiBhZGQvcmVtb3ZlIGl0KSBhcyBvbmUgbGF5ZXIuXHJcbiAqL1xyXG5cclxuTC5MYXllckdyb3VwID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdHZhciBpLCBsZW47XHJcblxyXG5cdFx0aWYgKGxheWVycykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gbGF5ZXIgaW4gdGhpcy5fbGF5ZXJzID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbGF5ZXJzW2lkXSkge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2lkXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCFsYXllcikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRyZXR1cm4gKGxheWVyIGluIHRoaXMuX2xheWVycyB8fCB0aGlzLmdldExheWVySWQobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XHJcblx0fSxcclxuXHJcblx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKHRoaXMucmVtb3ZlTGF5ZXIsIHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0aW52b2tlOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG5cdFx0ICAgIGksIGxheWVyO1xyXG5cclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaV07XHJcblxyXG5cdFx0XHRpZiAobGF5ZXJbbWV0aG9kTmFtZV0pIHtcclxuXHRcdFx0XHRsYXllclttZXRob2ROYW1lXS5hcHBseShsYXllciwgYXJncyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLmFkZExheWVyLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcihtYXAucmVtb3ZlTGF5ZXIsIG1hcCk7XHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHR9LFxyXG5cclxuXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllcnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllcnMucHVzaCh0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGxheWVycztcclxuXHR9LFxyXG5cclxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0WkluZGV4JywgekluZGV4KTtcclxuXHR9LFxyXG5cclxuXHRnZXRMYXllcklkOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHJldHVybiBMLnN0YW1wKGxheWVyKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5sYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycykge1xyXG5cdHJldHVybiBuZXcgTC5MYXllckdyb3VwKGxheWVycyk7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLkZlYXR1cmVHcm91cCBleHRlbmRzIEwuTGF5ZXJHcm91cCBieSBpbnRyb2R1Y2luZyBtb3VzZSBldmVudHMgYW5kIGFkZGl0aW9uYWwgbWV0aG9kc1xyXG4gKiBzaGFyZWQgYmV0d2VlbiBhIGdyb3VwIG9mIGludGVyYWN0aXZlIGxheWVycyAobGlrZSB2ZWN0b3JzIG9yIG1hcmtlcnMpLlxyXG4gKi9cclxuXHJcbkwuRmVhdHVyZUdyb3VwID0gTC5MYXllckdyb3VwLmV4dGVuZCh7XHJcblx0aW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxyXG5cclxuXHRzdGF0aWNzOiB7XHJcblx0XHRFVkVOVFM6ICdjbGljayBkYmxjbGljayBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2Vtb3ZlIGNvbnRleHRtZW51IHBvcHVwb3BlbiBwb3B1cGNsb3NlJ1xyXG5cdH0sXHJcblxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoJ29uJyBpbiBsYXllcikge1xyXG5cdFx0XHRsYXllci5vbihMLkZlYXR1cmVHcm91cC5FVkVOVFMsIHRoaXMuX3Byb3BhZ2F0ZUV2ZW50LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRMLkxheWVyR3JvdXAucHJvdG90eXBlLmFkZExheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cENvbnRlbnQgJiYgbGF5ZXIuYmluZFBvcHVwKSB7XHJcblx0XHRcdGxheWVyLmJpbmRQb3B1cCh0aGlzLl9wb3B1cENvbnRlbnQsIHRoaXMuX3BvcHVwT3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLm9mZihMLkZlYXR1cmVHcm91cC5FVkVOVFMsIHRoaXMuX3Byb3BhZ2F0ZUV2ZW50LCB0aGlzKTtcclxuXHJcblx0XHRMLkxheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cENvbnRlbnQpIHtcclxuXHRcdFx0dGhpcy5pbnZva2UoJ3VuYmluZFBvcHVwJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG5cdFx0dGhpcy5fcG9wdXBDb250ZW50ID0gY29udGVudDtcclxuXHRcdHRoaXMuX3BvcHVwT3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JpbmRQb3B1cCcsIGNvbnRlbnQsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0Ly8gb3BlbiBwb3B1cCBvbiB0aGUgZmlyc3QgbGF5ZXJcclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLm9wZW5Qb3B1cChsYXRsbmcpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0U3R5bGUnLCBzdHlsZSk7XHJcblx0fSxcclxuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9Gcm9udCcpO1xyXG5cdH0sXHJcblxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9CYWNrJyk7XHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGJvdW5kcy5leHRlbmQobGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlciA/IGxheWVyLmdldExhdExuZygpIDogbGF5ZXIuZ2V0Qm91bmRzKCkpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9LFxyXG5cclxuXHRfcHJvcGFnYXRlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRlID0gTC5leHRlbmQoe1xyXG5cdFx0XHRsYXllcjogZS50YXJnZXQsXHJcblx0XHRcdHRhcmdldDogdGhpc1xyXG5cdFx0fSwgZSk7XHJcblx0XHR0aGlzLmZpcmUoZS50eXBlLCBlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5mZWF0dXJlR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0cmV0dXJuIG5ldyBMLkZlYXR1cmVHcm91cChsYXllcnMpO1xyXG59O1xyXG5cblxuLypcclxuICogTC5QYXRoIGlzIGEgYmFzZSBjbGFzcyBmb3IgcmVuZGVyaW5nIHZlY3RvciBwYXRocyBvbiBhIG1hcC4gSW5oZXJpdGVkIGJ5IFBvbHlsaW5lLCBDaXJjbGUsIGV0Yy5cclxuICovXHJcblxyXG5MLlBhdGggPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0aW5jbHVkZXM6IFtMLk1peGluLkV2ZW50c10sXHJcblxyXG5cdHN0YXRpY3M6IHtcclxuXHRcdC8vIGhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXdcclxuXHRcdC8vIChyZWxhdGl2ZSB0byBpdHMgc2l6ZSwgZS5nLiAwLjUgaXMgaGFsZiB0aGUgc2NyZWVuIGluIGVhY2ggZGlyZWN0aW9uKVxyXG5cdFx0Ly8gc2V0IGl0IHNvIHRoYXQgU1ZHIGVsZW1lbnQgZG9lc24ndCBleGNlZWQgMTI4MHB4ICh2ZWN0b3JzIGZsaWNrZXIgb24gZHJhZ2VuZCBpZiBpdCBpcylcclxuXHRcdENMSVBfUEFERElORzogKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIG1heCA9IEwuQnJvd3Nlci5tb2JpbGUgPyAxMjgwIDogMjAwMCxcclxuXHRcdFx0ICAgIHRhcmdldCA9IChtYXggLyBNYXRoLm1heCh3aW5kb3cub3V0ZXJXaWR0aCwgd2luZG93Lm91dGVySGVpZ2h0KSAtIDEpIC8gMjtcclxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDAuNSwgdGFyZ2V0KSk7XHJcblx0XHR9KSgpXHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0c3Ryb2tlOiB0cnVlLFxyXG5cdFx0Y29sb3I6ICcjMDAzM2ZmJyxcclxuXHRcdGRhc2hBcnJheTogbnVsbCxcclxuXHRcdGxpbmVDYXA6IG51bGwsXHJcblx0XHRsaW5lSm9pbjogbnVsbCxcclxuXHRcdHdlaWdodDogNSxcclxuXHRcdG9wYWNpdHk6IDAuNSxcclxuXHJcblx0XHRmaWxsOiBmYWxzZSxcclxuXHRcdGZpbGxDb2xvcjogbnVsbCwgLy9zYW1lIGFzIGNvbG9yIGJ5IGRlZmF1bHRcclxuXHRcdGZpbGxPcGFjaXR5OiAwLjIsXHJcblxyXG5cdFx0Y2xpY2thYmxlOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2luaXRFbGVtZW50cygpO1xyXG5cdFx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5wcm9qZWN0TGF0bG5ncygpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5fbWFwLl9wYXRoUm9vdC5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnYWRkJyk7XHJcblxyXG5cdFx0bWFwLm9uKHtcclxuXHRcdFx0J3ZpZXdyZXNldCc6IHRoaXMucHJvamVjdExhdGxuZ3MsXHJcblx0XHRcdCdtb3ZlZW5kJzogdGhpcy5fdXBkYXRlUGF0aFxyXG5cdFx0fSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAuX3BhdGhSb290LnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0Ly8gTmVlZCB0byBmaXJlIHJlbW92ZSBldmVudCBiZWZvcmUgd2Ugc2V0IF9tYXAgdG8gbnVsbCBhcyB0aGUgZXZlbnQgaG9va3MgbWlnaHQgbmVlZCB0aGUgb2JqZWN0XHJcblx0XHR0aGlzLmZpcmUoJ3JlbW92ZScpO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnZtbCkge1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xyXG5cdFx0XHR0aGlzLl9zdHJva2UgPSBudWxsO1xyXG5cdFx0XHR0aGlzLl9maWxsID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRtYXAub2ZmKHtcclxuXHRcdFx0J3ZpZXdyZXNldCc6IHRoaXMucHJvamVjdExhdGxuZ3MsXHJcblx0XHRcdCdtb3ZlZW5kJzogdGhpcy5fdXBkYXRlUGF0aFxyXG5cdFx0fSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0cHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIGRvIGFsbCBwcm9qZWN0aW9uIHN0dWZmIGhlcmVcclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlU3R5bGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5wcm9qZWN0TGF0bG5ncygpO1xyXG5cdFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5NYXAuaW5jbHVkZSh7XHJcblx0X3VwZGF0ZVBhdGhWaWV3cG9ydDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHAgPSBMLlBhdGguQ0xJUF9QQURESU5HLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBwYW5lUG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpLFxyXG5cdFx0ICAgIG1pbiA9IHBhbmVQb3MubXVsdGlwbHlCeSgtMSkuX3N1YnRyYWN0KHNpemUubXVsdGlwbHlCeShwKS5fcm91bmQoKSksXHJcblx0XHQgICAgbWF4ID0gbWluLmFkZChzaXplLm11bHRpcGx5QnkoMSArIHAgKiAyKS5fcm91bmQoKSk7XHJcblxyXG5cdFx0dGhpcy5fcGF0aFZpZXdwb3J0ID0gbmV3IEwuQm91bmRzKG1pbiwgbWF4KTtcclxuXHR9XHJcbn0pO1xyXG5cblxuLypcclxuICogRXh0ZW5kcyBMLlBhdGggd2l0aCBTVkctc3BlY2lmaWMgcmVuZGVyaW5nIGNvZGUuXHJcbiAqL1xyXG5cclxuTC5QYXRoLlNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcblxyXG5MLkJyb3dzZXIuc3ZnID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhMLlBhdGguU1ZHX05TLCAnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XHJcblxyXG5MLlBhdGggPSBMLlBhdGguZXh0ZW5kKHtcclxuXHRzdGF0aWNzOiB7XHJcblx0XHRTVkc6IEwuQnJvd3Nlci5zdmdcclxuXHR9LFxyXG5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciByb290ID0gdGhpcy5fbWFwLl9wYXRoUm9vdCxcclxuXHRcdCAgICBwYXRoID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuXHRcdGlmIChwYXRoICYmIHJvb3QubGFzdENoaWxkICE9PSBwYXRoKSB7XHJcblx0XHRcdHJvb3QuYXBwZW5kQ2hpbGQocGF0aCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJvb3QgPSB0aGlzLl9tYXAuX3BhdGhSb290LFxyXG5cdFx0ICAgIHBhdGggPSB0aGlzLl9jb250YWluZXIsXHJcblx0XHQgICAgZmlyc3QgPSByb290LmZpcnN0Q2hpbGQ7XHJcblxyXG5cdFx0aWYgKHBhdGggJiYgZmlyc3QgIT09IHBhdGgpIHtcclxuXHRcdFx0cm9vdC5pbnNlcnRCZWZvcmUocGF0aCwgZmlyc3QpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0UGF0aFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gZm9ybSBwYXRoIHN0cmluZyBoZXJlXHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKEwuUGF0aC5TVkdfTlMsIG5hbWUpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0RWxlbWVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX21hcC5faW5pdFBhdGhSb290KCk7XHJcblx0XHR0aGlzLl9pbml0UGF0aCgpO1xyXG5cdFx0dGhpcy5faW5pdFN0eWxlKCk7XHJcblx0fSxcclxuXHJcblx0X2luaXRQYXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIgPSB0aGlzLl9jcmVhdGVFbGVtZW50KCdnJyk7XHJcblxyXG5cdFx0dGhpcy5fcGF0aCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQoJ3BhdGgnKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fcGF0aCwgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3BhdGgpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0U3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc3Ryb2tlKSB7XHJcblx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCAncm91bmQnKTtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgJ3JvdW5kJyk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmZpbGwpIHtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsICdldmVub2RkJyk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnBvaW50ZXJFdmVudHMpIHtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgdGhpcy5vcHRpb25zLnBvaW50ZXJFdmVudHMpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuY2xpY2thYmxlICYmICF0aGlzLm9wdGlvbnMucG9pbnRlckV2ZW50cykge1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc3Ryb2tlKSB7XHJcblx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCB0aGlzLm9wdGlvbnMuY29sb3IpO1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCB0aGlzLm9wdGlvbnMud2VpZ2h0KTtcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5kYXNoQXJyYXkpIHtcclxuXHRcdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIHRoaXMub3B0aW9ucy5kYXNoQXJyYXkpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuX3BhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5saW5lQ2FwKSB7XHJcblx0XHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgdGhpcy5vcHRpb25zLmxpbmVDYXApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMubGluZUpvaW4pIHtcclxuXHRcdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgdGhpcy5vcHRpb25zLmxpbmVKb2luKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmZpbGwpIHtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCB0aGlzLm9wdGlvbnMuZmlsbENvbG9yIHx8IHRoaXMub3B0aW9ucy5jb2xvcik7XHJcblx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCB0aGlzLm9wdGlvbnMuZmlsbE9wYWNpdHkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc3RyID0gdGhpcy5nZXRQYXRoU3RyaW5nKCk7XHJcblx0XHRpZiAoIXN0cikge1xyXG5cdFx0XHQvLyBmaXggd2Via2l0IGVtcHR5IHN0cmluZyBwYXJzaW5nIGJ1Z1xyXG5cdFx0XHRzdHIgPSAnTTAgMCc7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHN0cik7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETyByZW1vdmUgZHVwbGljYXRpb24gd2l0aCBMLk1hcFxyXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsaWNrYWJsZSkge1xyXG5cdFx0XHRpZiAoTC5Ccm93c2VyLnN2ZyB8fCAhTC5Ccm93c2VyLnZtbCkge1xyXG5cdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9wYXRoLCAnbGVhZmxldC1jbGlja2FibGUnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0TC5Eb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICdjbGljaycsIHRoaXMuX29uTW91c2VDbGljaywgdGhpcyk7XHJcblxyXG5cdFx0XHR2YXIgZXZlbnRzID0gWydkYmxjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2VvdmVyJyxcclxuXHRcdFx0ICAgICAgICAgICAgICAnbW91c2VvdXQnLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J107XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0TC5Eb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsIGV2ZW50c1tpXSwgdGhpcy5fZmlyZU1vdXNlRXZlbnQsIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uTW91c2VDbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICh0aGlzLl9tYXAuZHJhZ2dpbmcgJiYgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmVkKCkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fZmlyZU1vdXNlRXZlbnQoZSk7XHJcblx0fSxcclxuXHJcblx0X2ZpcmVNb3VzZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLmhhc0V2ZW50TGlzdGVuZXJzKGUudHlwZSkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBjb250YWluZXJQb2ludCA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKSxcclxuXHRcdCAgICBsYXllclBvaW50ID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGNvbnRhaW5lclBvaW50KSxcclxuXHRcdCAgICBsYXRsbmcgPSBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cclxuXHRcdHRoaXMuZmlyZShlLnR5cGUsIHtcclxuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcblx0XHRcdGxheWVyUG9pbnQ6IGxheWVyUG9pbnQsXHJcblx0XHRcdGNvbnRhaW5lclBvaW50OiBjb250YWluZXJQb2ludCxcclxuXHRcdFx0b3JpZ2luYWxFdmVudDogZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ2NvbnRleHRtZW51Jykge1xyXG5cdFx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGUudHlwZSAhPT0gJ21vdXNlbW92ZScpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbkwuTWFwLmluY2x1ZGUoe1xyXG5cdF9pbml0UGF0aFJvb3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fcGF0aFJvb3QpIHtcclxuXHRcdFx0dGhpcy5fcGF0aFJvb3QgPSBMLlBhdGgucHJvdG90eXBlLl9jcmVhdGVFbGVtZW50KCdzdmcnKTtcclxuXHRcdFx0dGhpcy5fcGFuZXMub3ZlcmxheVBhbmUuYXBwZW5kQ2hpbGQodGhpcy5fcGF0aFJvb3QpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uICYmIEwuQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9wYXRoUm9vdCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cclxuXHRcdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRcdCd6b29tYW5pbSc6IHRoaXMuX2FuaW1hdGVQYXRoWm9vbSxcclxuXHRcdFx0XHRcdCd6b29tZW5kJzogdGhpcy5fZW5kUGF0aFpvb21cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fcGF0aFJvb3QsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm9uKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlU3ZnVmlld3BvcnQpO1xyXG5cdFx0XHR0aGlzLl91cGRhdGVTdmdWaWV3cG9ydCgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlUGF0aFpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZShlLnpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChlLmNlbnRlcikuX211bHRpcGx5QnkoLXNjYWxlKS5fYWRkKHRoaXMuX3BhdGhWaWV3cG9ydC5taW4pO1xyXG5cclxuXHRcdHRoaXMuX3BhdGhSb290LnN0eWxlW0wuRG9tVXRpbC5UUkFOU0ZPUk1dID1cclxuXHRcdCAgICAgICAgTC5Eb21VdGlsLmdldFRyYW5zbGF0ZVN0cmluZyhvZmZzZXQpICsgJyBzY2FsZSgnICsgc2NhbGUgKyAnKSAnO1xyXG5cclxuXHRcdHRoaXMuX3BhdGhab29taW5nID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfZW5kUGF0aFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3BhdGhab29taW5nID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVN2Z1ZpZXdwb3J0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BhdGhab29taW5nKSB7XHJcblx0XHRcdC8vIERvIG5vdCB1cGRhdGUgU1ZHcyB3aGlsZSBhIHpvb20gYW5pbWF0aW9uIGlzIGdvaW5nIG9uIG90aGVyd2lzZSB0aGUgYW5pbWF0aW9uIHdpbGwgYnJlYWsuXHJcblx0XHRcdC8vIFdoZW4gdGhlIHpvb20gYW5pbWF0aW9uIGVuZHMgd2Ugd2lsbCBiZSB1cGRhdGVkIGFnYWluIGFueXdheVxyXG5cdFx0XHQvLyBUaGlzIGZpeGVzIHRoZSBjYXNlIHdoZXJlIHlvdSBkbyBhIG1vbWVudHVtIG1vdmUgYW5kIHpvb20gd2hpbGUgdGhlIG1vdmUgaXMgc3RpbGwgb25nb2luZy5cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZVBhdGhWaWV3cG9ydCgpO1xyXG5cclxuXHRcdHZhciB2cCA9IHRoaXMuX3BhdGhWaWV3cG9ydCxcclxuXHRcdCAgICBtaW4gPSB2cC5taW4sXHJcblx0XHQgICAgbWF4ID0gdnAubWF4LFxyXG5cdFx0ICAgIHdpZHRoID0gbWF4LnggLSBtaW4ueCxcclxuXHRcdCAgICBoZWlnaHQgPSBtYXgueSAtIG1pbi55LFxyXG5cdFx0ICAgIHJvb3QgPSB0aGlzLl9wYXRoUm9vdCxcclxuXHRcdCAgICBwYW5lID0gdGhpcy5fcGFuZXMub3ZlcmxheVBhbmU7XHJcblxyXG5cdFx0Ly8gSGFjayB0byBtYWtlIGZsaWNrZXIgb24gZHJhZyBlbmQgb24gbW9iaWxlIHdlYmtpdCBsZXNzIGlycml0YXRpbmdcclxuXHRcdGlmIChMLkJyb3dzZXIubW9iaWxlV2Via2l0KSB7XHJcblx0XHRcdHBhbmUucmVtb3ZlQ2hpbGQocm9vdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHJvb3QsIG1pbik7XHJcblx0XHRyb290LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3aWR0aCk7XHJcblx0XHRyb290LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcclxuXHRcdHJvb3Quc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgW21pbi54LCBtaW4ueSwgd2lkdGgsIGhlaWdodF0uam9pbignICcpKTtcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLm1vYmlsZVdlYmtpdCkge1xyXG5cdFx0XHRwYW5lLmFwcGVuZENoaWxkKHJvb3QpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxuXG4vKlxyXG4gKiBQb3B1cCBleHRlbnNpb24gdG8gTC5QYXRoIChwb2x5bGluZXMsIHBvbHlnb25zLCBjaXJjbGVzKSwgYWRkaW5nIHBvcHVwLXJlbGF0ZWQgbWV0aG9kcy5cclxuICovXHJcblxyXG5MLlBhdGguaW5jbHVkZSh7XHJcblxyXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIEwuUG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBjb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCBvcHRpb25zKSB7XHJcblx0XHRcdFx0dGhpcy5fcG9wdXAgPSBuZXcgTC5Qb3B1cChvcHRpb25zLCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5vbignY2xpY2snLCB0aGlzLl9vcGVuUG9wdXAsIHRoaXMpXHJcblx0XHRcdCAgICAub24oJ3JlbW92ZScsIHRoaXMuY2xvc2VQb3B1cCwgdGhpcyk7XHJcblxyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHVuYmluZFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAub2ZmKCdjbGljaycsIHRoaXMuX29wZW5Qb3B1cClcclxuXHRcdFx0ICAgIC5vZmYoJ3JlbW92ZScsIHRoaXMuY2xvc2VQb3B1cCk7XHJcblxyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHQvLyBvcGVuIHRoZSBwb3B1cCBmcm9tIG9uZSBvZiB0aGUgcGF0aCdzIHBvaW50cyBpZiBub3Qgc3BlY2lmaWVkXHJcblx0XHRcdGxhdGxuZyA9IGxhdGxuZyB8fCB0aGlzLl9sYXRsbmcgfHxcclxuXHRcdFx0ICAgICAgICAgdGhpcy5fbGF0bG5nc1tNYXRoLmZsb29yKHRoaXMuX2xhdGxuZ3MubGVuZ3RoIC8gMildO1xyXG5cclxuXHRcdFx0dGhpcy5fb3BlblBvcHVwKHtsYXRsbmc6IGxhdGxuZ30pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5fY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xyXG5cdFx0dGhpcy5fbWFwLm9wZW5Qb3B1cCh0aGlzLl9wb3B1cCk7XHJcblx0fVxyXG59KTtcclxuXG5cbi8qXHJcbiAqIFZlY3RvciByZW5kZXJpbmcgZm9yIElFNi04IHRocm91Z2ggVk1MLlxyXG4gKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxyXG4gKi9cclxuXHJcbkwuQnJvd3Nlci52bWwgPSAhTC5Ccm93c2VyLnN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRkaXYuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcclxuXHJcblx0XHR2YXIgc2hhcGUgPSBkaXYuZmlyc3RDaGlsZDtcclxuXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcclxuXHJcblx0XHRyZXR1cm4gc2hhcGUgJiYgKHR5cGVvZiBzaGFwZS5hZGogPT09ICdvYmplY3QnKTtcclxuXHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufSgpKTtcclxuXHJcbkwuUGF0aCA9IEwuQnJvd3Nlci5zdmcgfHwgIUwuQnJvd3Nlci52bWwgPyBMLlBhdGggOiBMLlBhdGguZXh0ZW5kKHtcclxuXHRzdGF0aWNzOiB7XHJcblx0XHRWTUw6IHRydWUsXHJcblx0XHRDTElQX1BBRERJTkc6IDAuMDJcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlRWxlbWVudDogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKCdsdm1sJywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XHJcblx0XHRcdH07XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxyXG5cdFx0XHRcdCAgICAgICAgJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH0oKSksXHJcblxyXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQoJ3NoYXBlJyk7XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdm1sLXNoYXBlJyArXHJcblx0XHRcdCh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lID8gJyAnICsgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSA6ICcnKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGlja2FibGUpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29udGFpbmVyLmNvb3Jkc2l6ZSA9ICcxIDEnO1xyXG5cclxuXHRcdHRoaXMuX3BhdGggPSB0aGlzLl9jcmVhdGVFbGVtZW50KCdwYXRoJyk7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcGF0aCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwLl9wYXRoUm9vdC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0U3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc3Ryb2tlID0gdGhpcy5fc3Ryb2tlLFxyXG5cdFx0ICAgIGZpbGwgPSB0aGlzLl9maWxsLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuXHRcdGNvbnRhaW5lci5zdHJva2VkID0gb3B0aW9ucy5zdHJva2U7XHJcblx0XHRjb250YWluZXIuZmlsbGVkID0gb3B0aW9ucy5maWxsO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xyXG5cdFx0XHRpZiAoIXN0cm9rZSkge1xyXG5cdFx0XHRcdHN0cm9rZSA9IHRoaXMuX3N0cm9rZSA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQoJ3N0cm9rZScpO1xyXG5cdFx0XHRcdHN0cm9rZS5lbmRjYXAgPSAncm91bmQnO1xyXG5cdFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHJva2UpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0cm9rZS53ZWlnaHQgPSBvcHRpb25zLndlaWdodCArICdweCc7XHJcblx0XHRcdHN0cm9rZS5jb2xvciA9IG9wdGlvbnMuY29sb3I7XHJcblx0XHRcdHN0cm9rZS5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XHJcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IEwuVXRpbC5pc0FycmF5KG9wdGlvbnMuZGFzaEFycmF5KSA/XHJcblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LmpvaW4oJyAnKSA6XHJcblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LnJlcGxhY2UoLyggKiwgKikvZywgJyAnKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gJyc7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG9wdGlvbnMubGluZUNhcCkge1xyXG5cdFx0XHRcdHN0cm9rZS5lbmRjYXAgPSBvcHRpb25zLmxpbmVDYXAucmVwbGFjZSgnYnV0dCcsICdmbGF0Jyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG9wdGlvbnMubGluZUpvaW4pIHtcclxuXHRcdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoc3Ryb2tlKSB7XHJcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdHJva2UpO1xyXG5cdFx0XHR0aGlzLl9zdHJva2UgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcclxuXHRcdFx0aWYgKCFmaWxsKSB7XHJcblx0XHRcdFx0ZmlsbCA9IHRoaXMuX2ZpbGwgPSB0aGlzLl9jcmVhdGVFbGVtZW50KCdmaWxsJyk7XHJcblx0XHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGwpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZpbGwuY29sb3IgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xyXG5cdFx0XHRmaWxsLm9wYWNpdHkgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xyXG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XHJcblx0XHRcdHRoaXMuX2ZpbGwgPSBudWxsO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9jb250YWluZXIuc3R5bGU7XHJcblxyXG5cdFx0c3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHRcdHRoaXMuX3BhdGgudiA9IHRoaXMuZ2V0UGF0aFN0cmluZygpICsgJyAnOyAvLyB0aGUgc3BhY2UgZml4ZXMgSUUgZW1wdHkgcGF0aCBzdHJpbmcgYnVnXHJcblx0XHRzdHlsZS5kaXNwbGF5ID0gJyc7XHJcblx0fVxyXG59KTtcclxuXHJcbkwuTWFwLmluY2x1ZGUoTC5Ccm93c2VyLnN2ZyB8fCAhTC5Ccm93c2VyLnZtbCA/IHt9IDoge1xyXG5cdF9pbml0UGF0aFJvb3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wYXRoUm9vdCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgcm9vdCA9IHRoaXMuX3BhdGhSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRyb290LmNsYXNzTmFtZSA9ICdsZWFmbGV0LXZtbC1jb250YWluZXInO1xyXG5cdFx0dGhpcy5fcGFuZXMub3ZlcmxheVBhbmUuYXBwZW5kQ2hpbGQocm9vdCk7XHJcblxyXG5cdFx0dGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZVBhdGhWaWV3cG9ydCk7XHJcblx0XHR0aGlzLl91cGRhdGVQYXRoVmlld3BvcnQoKTtcclxuXHR9XHJcbn0pO1xyXG5cblxuLypcclxuICogVmVjdG9yIHJlbmRlcmluZyBmb3IgYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBjYW52YXMuXHJcbiAqL1xyXG5cclxuTC5Ccm93c2VyLmNhbnZhcyA9IChmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dDtcclxufSgpKTtcclxuXHJcbkwuUGF0aCA9IChMLlBhdGguU1ZHICYmICF3aW5kb3cuTF9QUkVGRVJfQ0FOVkFTKSB8fCAhTC5Ccm93c2VyLmNhbnZhcyA/IEwuUGF0aCA6IEwuUGF0aC5leHRlbmQoe1xyXG5cdHN0YXRpY3M6IHtcclxuXHRcdC8vQ0xJUF9QQURESU5HOiAwLjAyLCAvLyBub3Qgc3VyZSBpZiB0aGVyZSdzIGEgbmVlZCB0byBzZXQgaXQgdG8gYSBzbWFsbCB2YWx1ZVxyXG5cdFx0Q0FOVkFTOiB0cnVlLFxyXG5cdFx0U1ZHOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLnByb2plY3RMYXRsbmdzKCk7XHJcblx0XHRcdHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBzdHlsZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVTdHlsZSgpO1xyXG5cdFx0XHR0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwXHJcblx0XHQgICAgLm9mZigndmlld3Jlc2V0JywgdGhpcy5wcm9qZWN0TGF0bG5ncywgdGhpcylcclxuXHRcdCAgICAub2ZmKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlUGF0aCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGlja2FibGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLm9mZignY2xpY2snLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5fbWFwLm9mZignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcclxuXHRcdFxyXG5cdFx0dGhpcy5maXJlKCdyZW1vdmUnKTtcclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3JlcXVlc3RVcGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIUwuUGF0aC5fdXBkYXRlUmVxdWVzdCkge1xyXG5cdFx0XHRMLlBhdGguX3VwZGF0ZVJlcXVlc3QgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9maXJlTWFwTW92ZUVuZCwgdGhpcy5fbWFwKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZmlyZU1hcE1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuUGF0aC5fdXBkYXRlUmVxdWVzdCA9IG51bGw7XHJcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEVsZW1lbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9tYXAuX2luaXRQYXRoUm9vdCgpO1xyXG5cdFx0dGhpcy5fY3R4ID0gdGhpcy5fbWFwLl9jYW52YXNDdHg7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcclxuXHRcdFx0dGhpcy5fY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMud2VpZ2h0O1xyXG5cdFx0XHR0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmNvbG9yO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xyXG5cdFx0XHR0aGlzLl9jdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZHJhd1BhdGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpLCBqLCBsZW4sIGxlbjIsIHBvaW50LCBkcmF3TWV0aG9kO1xyXG5cclxuXHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gdGhpcy5fcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XHJcblx0XHRcdFx0cG9pbnQgPSB0aGlzLl9wYXJ0c1tpXVtqXTtcclxuXHRcdFx0XHRkcmF3TWV0aG9kID0gKGogPT09IDAgPyAnbW92ZScgOiAnbGluZScpICsgJ1RvJztcclxuXHJcblx0XHRcdFx0dGhpcy5fY3R4W2RyYXdNZXRob2RdKHBvaW50LngsIHBvaW50LnkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIFRPRE8gcmVmYWN0b3IgdWdseSBoYWNrXHJcblx0XHRcdGlmICh0aGlzIGluc3RhbmNlb2YgTC5Qb2x5Z29uKSB7XHJcblx0XHRcdFx0dGhpcy5fY3R4LmNsb3NlUGF0aCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NoZWNrSWZFbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICF0aGlzLl9wYXJ0cy5sZW5ndGg7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9jaGVja0lmRW1wdHkoKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgY3R4ID0gdGhpcy5fY3R4LFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0dGhpcy5fZHJhd1BhdGgoKTtcclxuXHRcdGN0eC5zYXZlKCk7XHJcblx0XHR0aGlzLl91cGRhdGVTdHlsZSgpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcclxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcclxuXHRcdFx0Y3R4LmZpbGwoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcclxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5vcGFjaXR5O1xyXG5cdFx0XHRjdHguc3Ryb2tlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHJcblx0XHQvLyBUT0RPIG9wdGltaXphdGlvbjogMSBmaWxsL3N0cm9rZSBmb3IgYWxsIGZlYXR1cmVzIHdpdGggZXF1YWwgc3R5bGUgaW5zdGVhZCBvZiAxIGZvciBlYWNoIGZlYXR1cmVcclxuXHR9LFxyXG5cclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGlja2FibGUpIHtcclxuXHRcdFx0Ly8gVE9ETyBkYmxjbGlja1xyXG5cdFx0XHR0aGlzLl9tYXAub24oJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5zUG9pbnQoZS5sYXllclBvaW50KSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2NsaWNrJywgZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIFRPRE8gZG9uJ3QgZG8gb24gZWFjaCBtb3ZlXHJcblx0XHRpZiAodGhpcy5fY29udGFpbnNQb2ludChlLmxheWVyUG9pbnQpKSB7XHJcblx0XHRcdHRoaXMuX2N0eC5jYW52YXMuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xyXG5cdFx0XHR0aGlzLl9tb3VzZUluc2lkZSA9IHRydWU7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW91c2VvdmVyJywgZSk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0aGlzLl9tb3VzZUluc2lkZSkge1xyXG5cdFx0XHR0aGlzLl9jdHguY2FudmFzLnN0eWxlLmN1cnNvciA9ICcnO1xyXG5cdFx0XHR0aGlzLl9tb3VzZUluc2lkZSA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdXNlb3V0JywgZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbkwuTWFwLmluY2x1ZGUoKEwuUGF0aC5TVkcgJiYgIXdpbmRvdy5MX1BSRUZFUl9DQU5WQVMpIHx8ICFMLkJyb3dzZXIuY2FudmFzID8ge30gOiB7XHJcblx0X2luaXRQYXRoUm9vdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJvb3QgPSB0aGlzLl9wYXRoUm9vdCxcclxuXHRcdCAgICBjdHg7XHJcblxyXG5cdFx0aWYgKCFyb290KSB7XHJcblx0XHRcdHJvb3QgPSB0aGlzLl9wYXRoUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG5cdFx0XHRyb290LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHRcdFx0Y3R4ID0gdGhpcy5fY2FudmFzQ3R4ID0gcm9vdC5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuXHRcdFx0Y3R4LmxpbmVDYXAgPSAncm91bmQnO1xyXG5cdFx0XHRjdHgubGluZUpvaW4gPSAncm91bmQnO1xyXG5cclxuXHRcdFx0dGhpcy5fcGFuZXMub3ZlcmxheVBhbmUuYXBwZW5kQ2hpbGQocm9vdCk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0XHR0aGlzLl9wYXRoUm9vdC5jbGFzc05hbWUgPSAnbGVhZmxldC16b29tLWFuaW1hdGVkJztcclxuXHRcdFx0XHR0aGlzLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVQYXRoWm9vbSk7XHJcblx0XHRcdFx0dGhpcy5vbignem9vbWVuZCcsIHRoaXMuX2VuZFBhdGhab29tKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLm9uKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlQ2FudmFzVmlld3BvcnQpO1xyXG5cdFx0XHR0aGlzLl91cGRhdGVDYW52YXNWaWV3cG9ydCgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVDYW52YXNWaWV3cG9ydDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gZG9uJ3QgcmVkcmF3IHdoaWxlIHpvb21pbmcuIFNlZSBfdXBkYXRlU3ZnVmlld3BvcnQgZm9yIG1vcmUgZGV0YWlsc1xyXG5cdFx0aWYgKHRoaXMuX3BhdGhab29taW5nKSB7IHJldHVybjsgfVxyXG5cdFx0dGhpcy5fdXBkYXRlUGF0aFZpZXdwb3J0KCk7XHJcblxyXG5cdFx0dmFyIHZwID0gdGhpcy5fcGF0aFZpZXdwb3J0LFxyXG5cdFx0ICAgIG1pbiA9IHZwLm1pbixcclxuXHRcdCAgICBzaXplID0gdnAubWF4LnN1YnRyYWN0KG1pbiksXHJcblx0XHQgICAgcm9vdCA9IHRoaXMuX3BhdGhSb290O1xyXG5cclxuXHRcdC8vVE9ETyBjaGVjayBpZiB0aGlzIHdvcmtzIHByb3Blcmx5IG9uIG1vYmlsZSB3ZWJraXRcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihyb290LCBtaW4pO1xyXG5cdFx0cm9vdC53aWR0aCA9IHNpemUueDtcclxuXHRcdHJvb3QuaGVpZ2h0ID0gc2l6ZS55O1xyXG5cdFx0cm9vdC5nZXRDb250ZXh0KCcyZCcpLnRyYW5zbGF0ZSgtbWluLngsIC1taW4ueSk7XHJcblx0fVxyXG59KTtcclxuXG5cbi8qXHJcbiAqIEwuTGluZVV0aWwgY29udGFpbnMgZGlmZmVyZW50IHV0aWxpdHkgZnVuY3Rpb25zIGZvciBsaW5lIHNlZ21lbnRzXHJcbiAqIGFuZCBwb2x5bGluZXMgKGNsaXBwaW5nLCBzaW1wbGlmaWNhdGlvbiwgZGlzdGFuY2VzLCBldGMuKVxyXG4gKi9cclxuXHJcbi8qanNoaW50IGJpdHdpc2U6ZmFsc2UgKi8gLy8gYWxsb3cgYml0d2lzZSBvcGVyYXRpb25zIGZvciB0aGlzIGZpbGVcclxuXHJcbkwuTGluZVV0aWwgPSB7XHJcblxyXG5cdC8vIFNpbXBsaWZ5IHBvbHlsaW5lIHdpdGggdmVydGV4IHJlZHVjdGlvbiBhbmQgRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLlxyXG5cdC8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG5cdHNpbXBsaWZ5OiBmdW5jdGlvbiAoLypQb2ludFtdKi8gcG9pbnRzLCAvKk51bWJlciovIHRvbGVyYW5jZSkge1xyXG5cdFx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcblx0XHQvLyBzdGFnZSAxOiB2ZXJ0ZXggcmVkdWN0aW9uXHJcblx0XHRwb2ludHMgPSB0aGlzLl9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdFx0Ly8gc3RhZ2UgMjogRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uXHJcblx0XHRwb2ludHMgPSB0aGlzLl9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludHM7XHJcblx0fSxcclxuXHJcblx0Ly8gZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgc2VnbWVudCBiZXR3ZWVuIHR3byBwb2ludHNcclxuXHRwb2ludFRvU2VnbWVudERpc3RhbmNlOiAgZnVuY3Rpb24gKC8qUG9pbnQqLyBwLCAvKlBvaW50Ki8gcDEsIC8qUG9pbnQqLyBwMikge1xyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHRydWUpKTtcclxuXHR9LFxyXG5cclxuXHRjbG9zZXN0UG9pbnRPblNlZ21lbnQ6IGZ1bmN0aW9uICgvKlBvaW50Ki8gcCwgLypQb2ludCovIHAxLCAvKlBvaW50Ki8gcDIpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobVxyXG5cdF9zaW1wbGlmeURQOiBmdW5jdGlvbiAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuXHRcdHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG5cdFx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcblx0XHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG5cdFx0bWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuXHRcdHRoaXMuX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIDAsIGxlbiAtIDEpO1xyXG5cclxuXHRcdHZhciBpLFxyXG5cdFx0ICAgIG5ld1BvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG5cdFx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3UG9pbnRzO1xyXG5cdH0sXHJcblxyXG5cdF9zaW1wbGlmeURQU3RlcDogZnVuY3Rpb24gKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG5cdFx0dmFyIG1heFNxRGlzdCA9IDAsXHJcblx0XHQgICAgaW5kZXgsIGksIHNxRGlzdDtcclxuXHJcblx0XHRmb3IgKGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdCAtIDE7IGkrKykge1xyXG5cdFx0XHRzcURpc3QgPSB0aGlzLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XHJcblx0XHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRcdG1heFNxRGlzdCA9IHNxRGlzdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRtYXJrZXJzW2luZGV4XSA9IDE7XHJcblxyXG5cdFx0XHR0aGlzLl9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG5cdFx0XHR0aGlzLl9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gcmVkdWNlIHBvaW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG8gZWFjaCBvdGhlciB0byBhIHNpbmdsZSBwb2ludFxyXG5cdF9yZWR1Y2VQb2ludHM6IGZ1bmN0aW9uIChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblx0XHR2YXIgcmVkdWNlZFBvaW50cyA9IFtwb2ludHNbMF1dO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLl9zcURpc3QocG9pbnRzW2ldLCBwb2ludHNbcHJldl0pID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0XHRwcmV2ID0gaTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHByZXYgPCBsZW4gLSAxKSB7XHJcblx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbbGVuIC0gMV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlZHVjZWRQb2ludHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQ29oZW4tU3V0aGVybGFuZCBsaW5lIGNsaXBwaW5nIGFsZ29yaXRobS5cclxuXHQvLyBVc2VkIHRvIGF2b2lkIHJlbmRlcmluZyBwYXJ0cyBvZiBhIHBvbHlsaW5lIHRoYXQgYXJlIG5vdCBjdXJyZW50bHkgdmlzaWJsZS5cclxuXHJcblx0Y2xpcFNlZ21lbnQ6IGZ1bmN0aW9uIChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlKSB7XHJcblx0XHR2YXIgY29kZUEgPSB1c2VMYXN0Q29kZSA/IHRoaXMuX2xhc3RDb2RlIDogdGhpcy5fZ2V0Qml0Q29kZShhLCBib3VuZHMpLFxyXG5cdFx0ICAgIGNvZGVCID0gdGhpcy5fZ2V0Qml0Q29kZShiLCBib3VuZHMpLFxyXG5cclxuXHRcdCAgICBjb2RlT3V0LCBwLCBuZXdDb2RlO1xyXG5cclxuXHRcdC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG5cdFx0dGhpcy5fbGFzdENvZGUgPSBjb2RlQjtcclxuXHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHQvLyBpZiBhLGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCBhY2NlcHQpXHJcblx0XHRcdGlmICghKGNvZGVBIHwgY29kZUIpKSB7XHJcblx0XHRcdFx0cmV0dXJuIFthLCBiXTtcclxuXHRcdFx0Ly8gaWYgYSxiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIHJlamVjdClcclxuXHRcdFx0fSBlbHNlIGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHQvLyBvdGhlciBjYXNlc1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvZGVPdXQgPSBjb2RlQSB8fCBjb2RlQjtcclxuXHRcdFx0XHRwID0gdGhpcy5fZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlT3V0LCBib3VuZHMpO1xyXG5cdFx0XHRcdG5ld0NvZGUgPSB0aGlzLl9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblxyXG5cdFx0XHRcdGlmIChjb2RlT3V0ID09PSBjb2RlQSkge1xyXG5cdFx0XHRcdFx0YSA9IHA7XHJcblx0XHRcdFx0XHRjb2RlQSA9IG5ld0NvZGU7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGIgPSBwO1xyXG5cdFx0XHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9nZXRFZGdlSW50ZXJzZWN0aW9uOiBmdW5jdGlvbiAoYSwgYiwgY29kZSwgYm91bmRzKSB7XHJcblx0XHR2YXIgZHggPSBiLnggLSBhLngsXHJcblx0XHQgICAgZHkgPSBiLnkgLSBhLnksXHJcblx0XHQgICAgbWluID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXggPSBib3VuZHMubWF4O1xyXG5cclxuXHRcdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvaW50KGEueCArIGR4ICogKG1heC55IC0gYS55KSAvIGR5LCBtYXgueSk7XHJcblx0XHR9IGVsc2UgaWYgKGNvZGUgJiA0KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHksIG1pbi55KTtcclxuXHRcdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvaW50KG1heC54LCBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeCk7XHJcblx0XHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvaW50KG1pbi54LCBhLnkgKyBkeSAqIChtaW4ueCAtIGEueCkgLyBkeCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2dldEJpdENvZGU6IGZ1bmN0aW9uICgvKlBvaW50Ki8gcCwgYm91bmRzKSB7XHJcblx0XHR2YXIgY29kZSA9IDA7XHJcblxyXG5cdFx0aWYgKHAueCA8IGJvdW5kcy5taW4ueCkgeyAvLyBsZWZ0XHJcblx0XHRcdGNvZGUgfD0gMTtcclxuXHRcdH0gZWxzZSBpZiAocC54ID4gYm91bmRzLm1heC54KSB7IC8vIHJpZ2h0XHJcblx0XHRcdGNvZGUgfD0gMjtcclxuXHRcdH1cclxuXHRcdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGNvZGUgfD0gNDtcclxuXHRcdH0gZWxzZSBpZiAocC55ID4gYm91bmRzLm1heC55KSB7IC8vIHRvcFxyXG5cdFx0XHRjb2RlIHw9IDg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvZGU7XHJcblx0fSxcclxuXHJcblx0Ly8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcblx0X3NxRGlzdDogZnVuY3Rpb24gKHAxLCBwMikge1xyXG5cdFx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcblx0XHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuXHRfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQ6IGZ1bmN0aW9uIChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG5cdFx0dmFyIHggPSBwMS54LFxyXG5cdFx0ICAgIHkgPSBwMS55LFxyXG5cdFx0ICAgIGR4ID0gcDIueCAtIHgsXHJcblx0XHQgICAgZHkgPSBwMi55IC0geSxcclxuXHRcdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuXHRcdCAgICB0O1xyXG5cclxuXHRcdGlmIChkb3QgPiAwKSB7XHJcblx0XHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG5cdFx0XHRpZiAodCA+IDEpIHtcclxuXHRcdFx0XHR4ID0gcDIueDtcclxuXHRcdFx0XHR5ID0gcDIueTtcclxuXHRcdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG5cdFx0XHRcdHggKz0gZHggKiB0O1xyXG5cdFx0XHRcdHkgKz0gZHkgKiB0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0ZHggPSBwLnggLSB4O1xyXG5cdFx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuXHRcdHJldHVybiBzcURpc3QgPyBkeCAqIGR4ICsgZHkgKiBkeSA6IG5ldyBMLlBvaW50KHgsIHkpO1xyXG5cdH1cclxufTtcclxuXG5cbi8qXHJcbiAqIEwuUG9seWxpbmUgaXMgdXNlZCB0byBkaXNwbGF5IHBvbHlsaW5lcyBvbiBhIG1hcC5cclxuICovXHJcblxyXG5MLlBvbHlsaW5lID0gTC5QYXRoLmV4dGVuZCh7XHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcclxuXHRcdEwuUGF0aC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKTtcclxuXHR9LFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBob3cgbXVjaCB0byBzaW1wbGlmeSB0aGUgcG9seWxpbmUgb24gZWFjaCB6b29tIGxldmVsXHJcblx0XHQvLyBtb3JlID0gYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBzbW9vdGhlciBsb29rLCBsZXNzID0gbW9yZSBhY2N1cmF0ZVxyXG5cdFx0c21vb3RoRmFjdG9yOiAxLjAsXHJcblx0XHRub0NsaXA6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0cHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX29yaWdpbmFsUG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2xhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fb3JpZ2luYWxQb2ludHNbaV0gPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZ3NbaV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldFBhdGhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGgsIHN0ciA9ICcnOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0c3RyICs9IHRoaXMuX2dldFBhdGhQYXJ0U3RyKHRoaXMuX3BhcnRzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzdHI7XHJcblx0fSxcclxuXHJcblx0Z2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZ3M7XHJcblx0fSxcclxuXHJcblx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcclxuXHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKTtcclxuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xyXG5cdH0sXHJcblxyXG5cdGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5ncy5wdXNoKEwubGF0TG5nKGxhdGxuZykpO1xyXG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XHJcblx0fSxcclxuXHJcblx0c3BsaWNlTGF0TG5nczogZnVuY3Rpb24gKCkgeyAvLyAoTnVtYmVyIGluZGV4LCBOdW1iZXIgaG93TWFueSlcclxuXHRcdHZhciByZW1vdmVkID0gW10uc3BsaWNlLmFwcGx5KHRoaXMuX2xhdGxuZ3MsIGFyZ3VtZW50cyk7XHJcblx0XHR0aGlzLl9jb252ZXJ0TGF0TG5ncyh0aGlzLl9sYXRsbmdzLCB0cnVlKTtcclxuXHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHRyZXR1cm4gcmVtb3ZlZDtcclxuXHR9LFxyXG5cclxuXHRjbG9zZXN0TGF5ZXJQb2ludDogZnVuY3Rpb24gKHApIHtcclxuXHRcdHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5LCBwYXJ0cyA9IHRoaXMuX3BhcnRzLCBwMSwgcDIsIG1pblBvaW50ID0gbnVsbDtcclxuXHJcblx0XHRmb3IgKHZhciBqID0gMCwgakxlbiA9IHBhcnRzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xyXG5cdFx0XHR2YXIgcG9pbnRzID0gcGFydHNbal07XHJcblx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XHJcblx0XHRcdFx0cDIgPSBwb2ludHNbaV07XHJcblx0XHRcdFx0dmFyIHNxRGlzdCA9IEwuTGluZVV0aWwuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSk7XHJcblx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XHJcblx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IHNxRGlzdDtcclxuXHRcdFx0XHRcdG1pblBvaW50ID0gTC5MaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChtaW5Qb2ludCkge1xyXG5cdFx0XHRtaW5Qb2ludC5kaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbWluUG9pbnQ7XHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKHRoaXMuZ2V0TGF0TG5ncygpKTtcclxuXHR9LFxyXG5cclxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzLCBvdmVyd3JpdGUpIHtcclxuXHRcdHZhciBpLCBsZW4sIHRhcmdldCA9IG92ZXJ3cml0ZSA/IGxhdGxuZ3MgOiBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmIChMLlV0aWwuaXNBcnJheShsYXRsbmdzW2ldKSAmJiB0eXBlb2YgbGF0bG5nc1tpXVswXSAhPT0gJ251bWJlcicpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dGFyZ2V0W2ldID0gTC5sYXRMbmcobGF0bG5nc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdH0sXHJcblxyXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLlBhdGgucHJvdG90eXBlLl9pbml0RXZlbnRzLmNhbGwodGhpcyk7XHJcblx0fSxcclxuXHJcblx0X2dldFBhdGhQYXJ0U3RyOiBmdW5jdGlvbiAocG9pbnRzKSB7XHJcblx0XHR2YXIgcm91bmQgPSBMLlBhdGguVk1MO1xyXG5cclxuXHRcdGZvciAodmFyIGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aCwgc3RyID0gJycsIHA7IGogPCBsZW4yOyBqKyspIHtcclxuXHRcdFx0cCA9IHBvaW50c1tqXTtcclxuXHRcdFx0aWYgKHJvdW5kKSB7XHJcblx0XHRcdFx0cC5fcm91bmQoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHIgKz0gKGogPyAnTCcgOiAnTScpICsgcC54ICsgJyAnICsgcC55O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0cjtcclxuXHR9LFxyXG5cclxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvaW50cyA9IHRoaXMuX29yaWdpbmFsUG9pbnRzLFxyXG5cdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcblx0XHQgICAgaSwgaywgc2VnbWVudDtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xyXG5cdFx0XHR0aGlzLl9wYXJ0cyA9IFtwb2ludHNdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcclxuXHJcblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcclxuXHRcdCAgICB2cCA9IHRoaXMuX21hcC5fcGF0aFZpZXdwb3J0LFxyXG5cdFx0ICAgIGx1ID0gTC5MaW5lVXRpbDtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBrID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xyXG5cdFx0XHRzZWdtZW50ID0gbHUuY2xpcFNlZ21lbnQocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdLCB2cCwgaSk7XHJcblx0XHRcdGlmICghc2VnbWVudCkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwYXJ0c1trXSA9IHBhcnRzW2tdIHx8IFtdO1xyXG5cdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMF0pO1xyXG5cclxuXHRcdFx0Ly8gaWYgc2VnbWVudCBnb2VzIG91dCBvZiBzY3JlZW4sIG9yIGl0J3MgdGhlIGxhc3Qgb25lLCBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmUgcGFydFxyXG5cdFx0XHRpZiAoKHNlZ21lbnRbMV0gIT09IHBvaW50c1tpICsgMV0pIHx8IChpID09PSBsZW4gLSAyKSkge1xyXG5cdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFsxXSk7XHJcblx0XHRcdFx0aysrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gc2ltcGxpZnkgZWFjaCBjbGlwcGVkIHBhcnQgb2YgdGhlIHBvbHlsaW5lXHJcblx0X3NpbXBsaWZ5UG9pbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcclxuXHRcdCAgICBsdSA9IEwuTGluZVV0aWw7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHBhcnRzW2ldID0gbHUuc2ltcGxpZnkocGFydHNbaV0sIHRoaXMub3B0aW9ucy5zbW9vdGhGYWN0b3IpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9jbGlwUG9pbnRzKCk7XHJcblx0XHR0aGlzLl9zaW1wbGlmeVBvaW50cygpO1xyXG5cclxuXHRcdEwuUGF0aC5wcm90b3R5cGUuX3VwZGF0ZVBhdGguY2FsbCh0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5wb2x5bGluZSA9IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLlBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcclxuICogTC5Qb2x5VXRpbCBjb250YWlucyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbnMgKGNsaXBwaW5nLCBldGMuKS5cclxuICovXHJcblxyXG4vKmpzaGludCBiaXR3aXNlOmZhbHNlICovIC8vIGFsbG93IGJpdHdpc2Ugb3BlcmF0aW9ucyBoZXJlXHJcblxyXG5MLlBvbHlVdGlsID0ge307XHJcblxyXG4vKlxyXG4gKiBTdXRoZXJsYW5kLUhvZGdlbWFuIHBvbHlnb24gY2xpcHBpbmcgYWxnb3JpdGhtLlxyXG4gKiBVc2VkIHRvIGF2b2lkIHJlbmRlcmluZyBwYXJ0cyBvZiBhIHBvbHlnb24gdGhhdCBhcmUgbm90IGN1cnJlbnRseSB2aXNpYmxlLlxyXG4gKi9cclxuTC5Qb2x5VXRpbC5jbGlwUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMsIGJvdW5kcykge1xyXG5cdHZhciBjbGlwcGVkUG9pbnRzLFxyXG5cdCAgICBlZGdlcyA9IFsxLCA0LCAyLCA4XSxcclxuXHQgICAgaSwgaiwgayxcclxuXHQgICAgYSwgYixcclxuXHQgICAgbGVuLCBlZGdlLCBwLFxyXG5cdCAgICBsdSA9IEwuTGluZVV0aWw7XHJcblxyXG5cdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0cG9pbnRzW2ldLl9jb2RlID0gbHUuX2dldEJpdENvZGUocG9pbnRzW2ldLCBib3VuZHMpO1xyXG5cdH1cclxuXHJcblx0Ly8gZm9yIGVhY2ggZWRnZSAobGVmdCwgYm90dG9tLCByaWdodCwgdG9wKVxyXG5cdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcclxuXHRcdGVkZ2UgPSBlZGdlc1trXTtcclxuXHRcdGNsaXBwZWRQb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG5cdFx0XHRhID0gcG9pbnRzW2ldO1xyXG5cdFx0XHRiID0gcG9pbnRzW2pdO1xyXG5cclxuXHRcdFx0Ly8gaWYgYSBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93XHJcblx0XHRcdGlmICghKGEuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdC8vIGlmIGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZ29lcyBvdXQgb2Ygc2NyZWVuKVxyXG5cdFx0XHRcdGlmIChiLl9jb2RlICYgZWRnZSkge1xyXG5cdFx0XHRcdFx0cCA9IGx1Ll9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcyk7XHJcblx0XHRcdFx0XHRwLl9jb2RlID0gbHUuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKGEpO1xyXG5cclxuXHRcdFx0Ly8gZWxzZSBpZiBiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZW50ZXJzIHRoZSBzY3JlZW4pXHJcblx0XHRcdH0gZWxzZSBpZiAoIShiLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHRwID0gbHUuX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzKTtcclxuXHRcdFx0XHRwLl9jb2RlID0gbHUuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59O1xyXG5cblxuLypcclxuICogTC5Qb2x5Z29uIGlzIHVzZWQgdG8gZGlzcGxheSBwb2x5Z29ucyBvbiBhIG1hcC5cclxuICovXHJcblxyXG5MLlBvbHlnb24gPSBMLlBvbHlsaW5lLmV4dGVuZCh7XHJcblx0b3B0aW9uczoge1xyXG5cdFx0ZmlsbDogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XHJcblx0XHRMLlBvbHlsaW5lLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbGF0bG5ncywgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9pbml0V2l0aEhvbGVzKGxhdGxuZ3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0V2l0aEhvbGVzOiBmdW5jdGlvbiAobGF0bG5ncykge1xyXG5cdFx0dmFyIGksIGxlbiwgaG9sZTtcclxuXHRcdGlmIChsYXRsbmdzICYmIEwuVXRpbC5pc0FycmF5KGxhdGxuZ3NbMF0pICYmICh0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ251bWJlcicpKSB7XHJcblx0XHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzWzBdKTtcclxuXHRcdFx0dGhpcy5faG9sZXMgPSBsYXRsbmdzLnNsaWNlKDEpO1xyXG5cclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5faG9sZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRob2xlID0gdGhpcy5faG9sZXNbaV0gPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyh0aGlzLl9ob2xlc1tpXSk7XHJcblx0XHRcdFx0aWYgKGhvbGVbMF0uZXF1YWxzKGhvbGVbaG9sZS5sZW5ndGggLSAxXSkpIHtcclxuXHRcdFx0XHRcdGhvbGUucG9wKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZmlsdGVyIG91dCBsYXN0IHBvaW50IGlmIGl0cyBlcXVhbCB0byB0aGUgZmlyc3Qgb25lXHJcblx0XHRsYXRsbmdzID0gdGhpcy5fbGF0bG5ncztcclxuXHJcblx0XHRpZiAobGF0bG5ncy5sZW5ndGggPj0gMiAmJiBsYXRsbmdzWzBdLmVxdWFscyhsYXRsbmdzW2xhdGxuZ3MubGVuZ3RoIC0gMV0pKSB7XHJcblx0XHRcdGxhdGxuZ3MucG9wKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuUG9seWxpbmUucHJvdG90eXBlLnByb2plY3RMYXRsbmdzLmNhbGwodGhpcyk7XHJcblxyXG5cdFx0Ly8gcHJvamVjdCBwb2x5Z29uIGhvbGVzIHBvaW50c1xyXG5cdFx0Ly8gVE9ETyBtb3ZlIHRoaXMgbG9naWMgdG8gUG9seWxpbmUgdG8gZ2V0IHJpZCBvZiBkdXBsaWNhdGlvblxyXG5cdFx0dGhpcy5faG9sZVBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGlmICghdGhpcy5faG9sZXMpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGksIGosIGxlbiwgbGVuMjtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9ob2xlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9ob2xlUG9pbnRzW2ldID0gW107XHJcblxyXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gdGhpcy5faG9sZXNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XHJcblx0XHRcdFx0dGhpcy5faG9sZVBvaW50c1tpXVtqXSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5faG9sZXNbaV1bal0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcclxuXHRcdGlmIChsYXRsbmdzICYmIEwuVXRpbC5pc0FycmF5KGxhdGxuZ3NbMF0pICYmICh0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ251bWJlcicpKSB7XHJcblx0XHRcdHRoaXMuX2luaXRXaXRoSG9sZXMobGF0bG5ncyk7XHJcblx0XHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIEwuUG9seWxpbmUucHJvdG90eXBlLnNldExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvaW50cyA9IHRoaXMuX29yaWdpbmFsUG9pbnRzLFxyXG5cdFx0ICAgIG5ld1BhcnRzID0gW107XHJcblxyXG5cdFx0dGhpcy5fcGFydHMgPSBbcG9pbnRzXS5jb25jYXQodGhpcy5faG9sZVBvaW50cyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHZhciBjbGlwcGVkID0gTC5Qb2x5VXRpbC5jbGlwUG9seWdvbih0aGlzLl9wYXJ0c1tpXSwgdGhpcy5fbWFwLl9wYXRoVmlld3BvcnQpO1xyXG5cdFx0XHRpZiAoY2xpcHBlZC5sZW5ndGgpIHtcclxuXHRcdFx0XHRuZXdQYXJ0cy5wdXNoKGNsaXBwZWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcGFydHMgPSBuZXdQYXJ0cztcclxuXHR9LFxyXG5cclxuXHRfZ2V0UGF0aFBhcnRTdHI6IGZ1bmN0aW9uIChwb2ludHMpIHtcclxuXHRcdHZhciBzdHIgPSBMLlBvbHlsaW5lLnByb3RvdHlwZS5fZ2V0UGF0aFBhcnRTdHIuY2FsbCh0aGlzLCBwb2ludHMpO1xyXG5cdFx0cmV0dXJuIHN0ciArIChMLkJyb3dzZXIuc3ZnID8gJ3onIDogJ3gnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5wb2x5Z29uID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcclxufTtcclxuXG5cbi8qXHJcbiAqIENvbnRhaW5zIEwuTXVsdGlQb2x5bGluZSBhbmQgTC5NdWx0aVBvbHlnb24gbGF5ZXJzLlxyXG4gKi9cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0ZnVuY3Rpb24gY3JlYXRlTXVsdGkoS2xhc3MpIHtcclxuXHJcblx0XHRyZXR1cm4gTC5GZWF0dXJlR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XHJcblx0XHRcdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblx0XHRcdFx0dGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0XHRcdFx0dGhpcy5zZXRMYXRMbmdzKGxhdGxuZ3MpO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcclxuXHRcdFx0XHR2YXIgaSA9IDAsXHJcblx0XHRcdFx0ICAgIGxlbiA9IGxhdGxuZ3MubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0XHRcdGlmIChpIDwgbGVuKSB7XHJcblx0XHRcdFx0XHRcdGxheWVyLnNldExhdExuZ3MobGF0bG5nc1tpKytdKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIobGF5ZXIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdFx0XHR3aGlsZSAoaSA8IGxlbikge1xyXG5cdFx0XHRcdFx0dGhpcy5hZGRMYXllcihuZXcgS2xhc3MobGF0bG5nc1tpKytdLCB0aGlzLl9vcHRpb25zKSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRcdFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0XHRcdGxhdGxuZ3MucHVzaChsYXllci5nZXRMYXRMbmdzKCkpO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbGF0bG5ncztcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRMLk11bHRpUG9seWxpbmUgPSBjcmVhdGVNdWx0aShMLlBvbHlsaW5lKTtcclxuXHRMLk11bHRpUG9seWdvbiA9IGNyZWF0ZU11bHRpKEwuUG9seWdvbik7XHJcblxyXG5cdEwubXVsdGlQb2x5bGluZSA9IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTXVsdGlQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcclxuXHR9O1xyXG5cclxuXHRMLm11bHRpUG9seWdvbiA9IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTXVsdGlQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cdH07XHJcbn0oKSk7XHJcblxuXG4vKlxyXG4gKiBMLlJlY3RhbmdsZSBleHRlbmRzIFBvbHlnb24gYW5kIGNyZWF0ZXMgYSByZWN0YW5nbGUgd2hlbiBwYXNzZWQgYSBMYXRMbmdCb3VuZHMgb2JqZWN0LlxyXG4gKi9cclxuXHJcbkwuUmVjdGFuZ2xlID0gTC5Qb2x5Z29uLmV4dGVuZCh7XHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0TC5Qb2x5Z29uLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcyksIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xyXG5cdFx0dGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcclxuXHR9LFxyXG5cclxuXHRfYm91bmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XHJcblx0XHRsYXRMbmdCb3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhsYXRMbmdCb3VuZHMpO1xyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksXHJcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpXHJcblx0XHRdO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLnJlY3RhbmdsZSA9IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuUmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLkNpcmNsZSBpcyBhIGNpcmNsZSBvdmVybGF5ICh3aXRoIGEgY2VydGFpbiByYWRpdXMgaW4gbWV0ZXJzKS5cclxuICovXHJcblxyXG5MLkNpcmNsZSA9IEwuUGF0aC5leHRlbmQoe1xyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIHJhZGl1cywgb3B0aW9ucykge1xyXG5cdFx0TC5QYXRoLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHRcdHRoaXMuX21SYWRpdXMgPSByYWRpdXM7XHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0ZmlsbDogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xyXG5cdH0sXHJcblxyXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xyXG5cdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcclxuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xyXG5cdH0sXHJcblxyXG5cdHByb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbG5nUmFkaXVzID0gdGhpcy5fZ2V0TG5nUmFkaXVzKCksXHJcblx0XHQgICAgbGF0bG5nID0gdGhpcy5fbGF0bG5nLFxyXG5cdFx0ICAgIHBvaW50TGVmdCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoW2xhdGxuZy5sYXQsIGxhdGxuZy5sbmcgLSBsbmdSYWRpdXNdKTtcclxuXHJcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKTtcclxuXHRcdHRoaXMuX3JhZGl1cyA9IE1hdGgubWF4KHRoaXMuX3BvaW50LnggLSBwb2ludExlZnQueCwgMSk7XHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbG5nUmFkaXVzID0gdGhpcy5fZ2V0TG5nUmFkaXVzKCksXHJcblx0XHQgICAgbGF0UmFkaXVzID0gKHRoaXMuX21SYWRpdXMgLyA0MDA3NTAxNykgKiAzNjAsXHJcblx0XHQgICAgbGF0bG5nID0gdGhpcy5fbGF0bG5nO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIFtsYXRsbmcubGF0IC0gbGF0UmFkaXVzLCBsYXRsbmcubG5nIC0gbG5nUmFkaXVzXSxcclxuXHRcdCAgICAgICAgW2xhdGxuZy5sYXQgKyBsYXRSYWRpdXMsIGxhdGxuZy5sbmcgKyBsbmdSYWRpdXNdKTtcclxuXHR9LFxyXG5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Z2V0UGF0aFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHAgPSB0aGlzLl9wb2ludCxcclxuXHRcdCAgICByID0gdGhpcy5fcmFkaXVzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jaGVja0lmRW1wdHkoKSkge1xyXG5cdFx0XHRyZXR1cm4gJyc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5zdmcpIHtcclxuXHRcdFx0cmV0dXJuICdNJyArIHAueCArICcsJyArIChwLnkgLSByKSArXHJcblx0XHRcdCAgICAgICAnQScgKyByICsgJywnICsgciArICcsMCwxLDEsJyArXHJcblx0XHRcdCAgICAgICAocC54IC0gMC4xKSArICcsJyArIChwLnkgLSByKSArICcgeic7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwLl9yb3VuZCgpO1xyXG5cdFx0XHRyID0gTWF0aC5yb3VuZChyKTtcclxuXHRcdFx0cmV0dXJuICdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgciArICcsJyArIHIgKyAnIDAsJyArICg2NTUzNSAqIDM2MCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbVJhZGl1cztcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPIEVhcnRoIGhhcmRjb2RlZCwgbW92ZSBpbnRvIHByb2plY3Rpb24gY29kZSFcclxuXHJcblx0X2dldExhdFJhZGl1czogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tUmFkaXVzIC8gNDAwNzUwMTcpICogMzYwO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRMbmdSYWRpdXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9nZXRMYXRSYWRpdXMoKSAvIE1hdGguY29zKEwuTGF0TG5nLkRFR19UT19SQUQgKiB0aGlzLl9sYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHR2YXIgdnAgPSB0aGlzLl9tYXAuX3BhdGhWaWV3cG9ydCxcclxuXHRcdCAgICByID0gdGhpcy5fcmFkaXVzLFxyXG5cdFx0ICAgIHAgPSB0aGlzLl9wb2ludDtcclxuXHJcblx0XHRyZXR1cm4gcC54IC0gciA+IHZwLm1heC54IHx8IHAueSAtIHIgPiB2cC5tYXgueSB8fFxyXG5cdFx0ICAgICAgIHAueCArIHIgPCB2cC5taW4ueCB8fCBwLnkgKyByIDwgdnAubWluLnk7XHJcblx0fVxyXG59KTtcclxuXHJcbkwuY2lyY2xlID0gZnVuY3Rpb24gKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNpcmNsZShsYXRsbmcsIHJhZGl1cywgb3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBMLkNpcmNsZU1hcmtlciBpcyBhIGNpcmNsZSBvdmVybGF5IHdpdGggYSBwZXJtYW5lbnQgcGl4ZWwgcmFkaXVzLlxyXG4gKi9cclxuXHJcbkwuQ2lyY2xlTWFya2VyID0gTC5DaXJjbGUuZXh0ZW5kKHtcclxuXHRvcHRpb25zOiB7XHJcblx0XHRyYWRpdXM6IDEwLFxyXG5cdFx0d2VpZ2h0OiAyXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0TC5DaXJjbGUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBsYXRsbmcsIG51bGwsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVN0eWxlIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5DaXJjbGUucHJvdG90eXBlLl91cGRhdGVTdHlsZS5jYWxsKHRoaXMpO1xyXG5cdFx0dGhpcy5zZXRSYWRpdXModGhpcy5vcHRpb25zLnJhZGl1cyk7XHJcblx0fSxcclxuXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRMLkNpcmNsZS5wcm90b3R5cGUuc2V0TGF0TG5nLmNhbGwodGhpcywgbGF0bG5nKTtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5faXNPcGVuKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhsYXRsbmcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xyXG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLmNpcmNsZU1hcmtlciA9IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxyXG4gKiBFeHRlbmRzIEwuUG9seWxpbmUgdG8gYmUgYWJsZSB0byBtYW51YWxseSBkZXRlY3QgY2xpY2tzIG9uIENhbnZhcy1yZW5kZXJlZCBwb2x5bGluZXMuXHJcbiAqL1xyXG5cclxuTC5Qb2x5bGluZS5pbmNsdWRlKCFMLlBhdGguQ0FOVkFTID8ge30gOiB7XHJcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwLCBjbG9zZWQpIHtcclxuXHRcdHZhciBpLCBqLCBrLCBsZW4sIGxlbjIsIGRpc3QsIHBhcnQsXHJcblx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQgLyAyO1xyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIudG91Y2gpIHtcclxuXHRcdFx0dyArPSAxMDsgLy8gcG9seWxpbmUgY2xpY2sgdG9sZXJhbmNlIG9uIHRvdWNoIGRldmljZXNcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XHJcblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xyXG5cdFx0XHRcdGlmICghY2xvc2VkICYmIChqID09PSAwKSkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRkaXN0ID0gTC5MaW5lVXRpbC5wb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHBhcnRba10sIHBhcnRbal0pO1xyXG5cclxuXHRcdFx0XHRpZiAoZGlzdCA8PSB3KSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn0pO1xyXG5cblxuLypcclxuICogRXh0ZW5kcyBMLlBvbHlnb24gdG8gYmUgYWJsZSB0byBtYW51YWxseSBkZXRlY3QgY2xpY2tzIG9uIENhbnZhcy1yZW5kZXJlZCBwb2x5Z29ucy5cclxuICovXHJcblxyXG5MLlBvbHlnb24uaW5jbHVkZSghTC5QYXRoLkNBTlZBUyA/IHt9IDoge1xyXG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xyXG5cdFx0dmFyIGluc2lkZSA9IGZhbHNlLFxyXG5cdFx0ICAgIHBhcnQsIHAxLCBwMixcclxuXHRcdCAgICBpLCBqLCBrLFxyXG5cdFx0ICAgIGxlbiwgbGVuMjtcclxuXHJcblx0XHQvLyBUT0RPIG9wdGltaXphdGlvbjogY2hlY2sgaWYgd2l0aGluIGJvdW5kcyBmaXJzdFxyXG5cclxuXHRcdGlmIChMLlBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsIHAsIHRydWUpKSB7XHJcblx0XHRcdC8vIGNsaWNrIG9uIHBvbHlnb24gYm9yZGVyXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJheSBjYXN0aW5nIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGlmIHBvaW50IGlzIGluIHBvbHlnb25cclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XHJcblxyXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcclxuXHRcdFx0XHRwMSA9IHBhcnRbal07XHJcblx0XHRcdFx0cDIgPSBwYXJ0W2tdO1xyXG5cclxuXHRcdFx0XHRpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJlxyXG5cdFx0XHRcdFx0XHQocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xyXG5cdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW5zaWRlO1xyXG5cdH1cclxufSk7XHJcblxuXG4vKlxyXG4gKiBFeHRlbmRzIEwuQ2lyY2xlIHdpdGggQ2FudmFzLXNwZWNpZmljIGNvZGUuXHJcbiAqL1xyXG5cclxuTC5DaXJjbGUuaW5jbHVkZSghTC5QYXRoLkNBTlZBUyA/IHt9IDoge1xyXG5cdF9kcmF3UGF0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHAgPSB0aGlzLl9wb2ludDtcclxuXHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcclxuXHRcdHRoaXMuX2N0eC5hcmMocC54LCBwLnksIHRoaXMuX3JhZGl1cywgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcclxuXHR9LFxyXG5cclxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcclxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLl9wb2ludCxcclxuXHRcdCAgICB3MiA9IHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDA7XHJcblxyXG5cdFx0cmV0dXJuIChwLmRpc3RhbmNlVG8oY2VudGVyKSA8PSB0aGlzLl9yYWRpdXMgKyB3Mik7XHJcblx0fVxyXG59KTtcclxuXG5cbi8qXG4gKiBDaXJjbGVNYXJrZXIgY2FudmFzIHNwZWNpZmljIGRyYXdpbmcgcGFydHMuXG4gKi9cblxuTC5DaXJjbGVNYXJrZXIuaW5jbHVkZSghTC5QYXRoLkNBTlZBUyA/IHt9IDoge1xuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uICgpIHtcblx0XHRMLlBhdGgucHJvdG90eXBlLl91cGRhdGVTdHlsZS5jYWxsKHRoaXMpO1xuXHR9XG59KTtcblxuXG4vKlxyXG4gKiBMLkdlb0pTT04gdHVybnMgYW55IEdlb0pTT04gZGF0YSBpbnRvIGEgTGVhZmxldCBsYXllci5cclxuICovXHJcblxyXG5MLkdlb0pTT04gPSBMLkZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdGlmIChnZW9qc29uKSB7XHJcblx0XHRcdHRoaXMuYWRkRGF0YShnZW9qc29uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhZGREYXRhOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG5cdFx0dmFyIGZlYXR1cmVzID0gTC5VdGlsLmlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG5cdFx0aWYgKGZlYXR1cmVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Ly8gT25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcblx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG5cdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlc1tpXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIoZ2VvanNvbikpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGxheWVyID0gTC5HZW9KU09OLmdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zLnBvaW50VG9MYXllciwgb3B0aW9ucy5jb29yZHNUb0xhdExuZywgb3B0aW9ucyk7XHJcblx0XHRsYXllci5mZWF0dXJlID0gTC5HZW9KU09OLmFzRmVhdHVyZShnZW9qc29uKTtcclxuXHJcblx0XHRsYXllci5kZWZhdWx0T3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XHJcblx0XHR0aGlzLnJlc2V0U3R5bGUobGF5ZXIpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm9uRWFjaEZlYXR1cmUpIHtcclxuXHRcdFx0b3B0aW9ucy5vbkVhY2hGZWF0dXJlKGdlb2pzb24sIGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihsYXllcik7XHJcblx0fSxcclxuXHJcblx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgc3R5bGUgPSB0aGlzLm9wdGlvbnMuc3R5bGU7XHJcblx0XHRpZiAoc3R5bGUpIHtcclxuXHRcdFx0Ly8gcmVzZXQgYW55IGN1c3RvbSBzdHlsZXNcclxuXHRcdFx0TC5VdGlsLmV4dGVuZChsYXllci5vcHRpb25zLCBsYXllci5kZWZhdWx0T3B0aW9ucyk7XHJcblxyXG5cdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiAobGF5ZXIsIHN0eWxlKSB7XHJcblx0XHRpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLmV4dGVuZChMLkdlb0pTT04sIHtcclxuXHRnZW9tZXRyeVRvTGF5ZXI6IGZ1bmN0aW9uIChnZW9qc29uLCBwb2ludFRvTGF5ZXIsIGNvb3Jkc1RvTGF0TG5nLCB2ZWN0b3JPcHRpb25zKSB7XHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uLFxyXG5cdFx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzLFxyXG5cdFx0ICAgIGxheWVycyA9IFtdLFxyXG5cdFx0ICAgIGxhdGxuZywgbGF0bG5ncywgaSwgbGVuO1xyXG5cclxuXHRcdGNvb3Jkc1RvTGF0TG5nID0gY29vcmRzVG9MYXRMbmcgfHwgdGhpcy5jb29yZHNUb0xhdExuZztcclxuXHJcblx0XHRzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcclxuXHRcdGNhc2UgJ1BvaW50JzpcclxuXHRcdFx0bGF0bG5nID0gY29vcmRzVG9MYXRMbmcoY29vcmRzKTtcclxuXHRcdFx0cmV0dXJuIHBvaW50VG9MYXllciA/IHBvaW50VG9MYXllcihnZW9qc29uLCBsYXRsbmcpIDogbmV3IEwuTWFya2VyKGxhdGxuZyk7XHJcblxyXG5cdFx0Y2FzZSAnTXVsdGlQb2ludCc6XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGxhdGxuZyA9IGNvb3Jkc1RvTGF0TG5nKGNvb3Jkc1tpXSk7XHJcblx0XHRcdFx0bGF5ZXJzLnB1c2gocG9pbnRUb0xheWVyID8gcG9pbnRUb0xheWVyKGdlb2pzb24sIGxhdGxuZykgOiBuZXcgTC5NYXJrZXIobGF0bG5nKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG5ldyBMLkZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRcdGNhc2UgJ0xpbmVTdHJpbmcnOlxyXG5cdFx0XHRsYXRsbmdzID0gdGhpcy5jb29yZHNUb0xhdExuZ3MoY29vcmRzLCAwLCBjb29yZHNUb0xhdExuZyk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2x5bGluZShsYXRsbmdzLCB2ZWN0b3JPcHRpb25zKTtcclxuXHJcblx0XHRjYXNlICdQb2x5Z29uJzpcclxuXHRcdFx0aWYgKGNvb3Jkcy5sZW5ndGggPT09IDIgJiYgIWNvb3Jkc1sxXS5sZW5ndGgpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0bGF0bG5ncyA9IHRoaXMuY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgMSwgY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9seWdvbihsYXRsbmdzLCB2ZWN0b3JPcHRpb25zKTtcclxuXHJcblx0XHRjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxyXG5cdFx0XHRsYXRsbmdzID0gdGhpcy5jb29yZHNUb0xhdExuZ3MoY29vcmRzLCAxLCBjb29yZHNUb0xhdExuZyk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5NdWx0aVBvbHlsaW5lKGxhdGxuZ3MsIHZlY3Rvck9wdGlvbnMpO1xyXG5cclxuXHRcdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRcdGxhdGxuZ3MgPSB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIDIsIGNvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLk11bHRpUG9seWdvbihsYXRsbmdzLCB2ZWN0b3JPcHRpb25zKTtcclxuXHJcblx0XHRjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblxyXG5cdFx0XHRcdGxheWVycy5wdXNoKHRoaXMuZ2VvbWV0cnlUb0xheWVyKHtcclxuXHRcdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeS5nZW9tZXRyaWVzW2ldLFxyXG5cdFx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRcdFx0cHJvcGVydGllczogZ2VvanNvbi5wcm9wZXJ0aWVzXHJcblx0XHRcdFx0fSwgcG9pbnRUb0xheWVyLCBjb29yZHNUb0xhdExuZywgdmVjdG9yT3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBuZXcgTC5GZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Y29vcmRzVG9MYXRMbmc6IGZ1bmN0aW9uIChjb29yZHMpIHsgLy8gKEFycmF5WywgQm9vbGVhbl0pIC0+IExhdExuZ1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhjb29yZHNbMV0sIGNvb3Jkc1swXSwgY29vcmRzWzJdKTtcclxuXHR9LFxyXG5cclxuXHRjb29yZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChjb29yZHMsIGxldmVsc0RlZXAsIGNvb3Jkc1RvTGF0TG5nKSB7IC8vIChBcnJheVssIE51bWJlciwgRnVuY3Rpb25dKSAtPiBBcnJheVxyXG5cdFx0dmFyIGxhdGxuZywgaSwgbGVuLFxyXG5cdFx0ICAgIGxhdGxuZ3MgPSBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/XHJcblx0XHRcdCAgICAgICAgdGhpcy5jb29yZHNUb0xhdExuZ3MoY29vcmRzW2ldLCBsZXZlbHNEZWVwIC0gMSwgY29vcmRzVG9MYXRMbmcpIDpcclxuXHRcdFx0ICAgICAgICAoY29vcmRzVG9MYXRMbmcgfHwgdGhpcy5jb29yZHNUb0xhdExuZykoY29vcmRzW2ldKTtcclxuXHJcblx0XHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsYXRsbmdzO1xyXG5cdH0sXHJcblxyXG5cdGxhdExuZ1RvQ29vcmRzOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW2xhdGxuZy5sbmcsIGxhdGxuZy5sYXRdO1xyXG5cclxuXHRcdGlmIChsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Y29vcmRzLnB1c2gobGF0bG5nLmFsdCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY29vcmRzO1xyXG5cdH0sXHJcblxyXG5cdGxhdExuZ3NUb0Nvb3JkczogZnVuY3Rpb24gKGxhdExuZ3MpIHtcclxuXHRcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0TG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRjb29yZHMucHVzaChMLkdlb0pTT04ubGF0TG5nVG9Db29yZHMobGF0TG5nc1tpXSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb29yZHM7XHJcblx0fSxcclxuXHJcblx0Z2V0RmVhdHVyZTogZnVuY3Rpb24gKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG5cdFx0cmV0dXJuIGxheWVyLmZlYXR1cmUgPyBMLmV4dGVuZCh7fSwgbGF5ZXIuZmVhdHVyZSwge2dlb21ldHJ5OiBuZXdHZW9tZXRyeX0pIDogTC5HZW9KU09OLmFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcblx0fSxcclxuXHJcblx0YXNGZWF0dXJlOiBmdW5jdGlvbiAoZ2VvSlNPTikge1xyXG5cdFx0aWYgKGdlb0pTT04udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XHJcblx0XHRcdHJldHVybiBnZW9KU09OO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdFx0cHJvcGVydGllczoge30sXHJcblx0XHRcdGdlb21ldHJ5OiBnZW9KU09OXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG52YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gTC5HZW9KU09OLmdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogTC5HZW9KU09OLmxhdExuZ1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5nKCkpXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG5MLk1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuTC5DaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbkwuQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuTC5Qb2x5bGluZS5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdMaW5lU3RyaW5nJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IEwuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHModGhpcy5nZXRMYXRMbmdzKCkpXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5Qb2x5Z29uLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtMLkdlb0pTT04ubGF0TG5nc1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5ncygpKV0sXHJcblx0XHQgICAgaSwgbGVuLCBob2xlO1xyXG5cclxuXHRcdGNvb3Jkc1swXS5wdXNoKGNvb3Jkc1swXVswXSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2hvbGVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0aG9sZSA9IEwuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHModGhpcy5faG9sZXNbaV0pO1xyXG5cdFx0XHRcdGhvbGUucHVzaChob2xlWzBdKTtcclxuXHRcdFx0XHRjb29yZHMucHVzaChob2xlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2x5Z29uJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0ZnVuY3Rpb24gbXVsdGlUb0dlb0pTT04odHlwZSkge1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdFx0Y29vcmRzLnB1c2gobGF5ZXIudG9HZW9KU09OKCkuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHRcdH0pO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdEwuTXVsdGlQb2x5bGluZS5pbmNsdWRlKHt0b0dlb0pTT046IG11bHRpVG9HZW9KU09OKCdNdWx0aUxpbmVTdHJpbmcnKX0pO1xyXG5cdEwuTXVsdGlQb2x5Z29uLmluY2x1ZGUoe3RvR2VvSlNPTjogbXVsdGlUb0dlb0pTT04oJ011bHRpUG9seWdvbicpfSk7XHJcblxyXG5cdEwuTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuXHRcdHRvR2VvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeSxcclxuXHRcdFx0XHRqc29ucyA9IFtdLFxyXG5cdFx0XHRcdGpzb247XHJcblxyXG5cdFx0XHRpZiAoZ2VvbWV0cnkgJiYgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcblx0XHRcdFx0cmV0dXJuIG11bHRpVG9HZW9KU09OKCdNdWx0aVBvaW50JykuY2FsbCh0aGlzKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gZ2VvbWV0cnkgJiYgZ2VvbWV0cnkudHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbic7XHJcblxyXG5cdFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0XHRpZiAobGF5ZXIudG9HZW9KU09OKSB7XHJcblx0XHRcdFx0XHRqc29uID0gbGF5ZXIudG9HZW9KU09OKCk7XHJcblx0XHRcdFx0XHRqc29ucy5wdXNoKGlzR2VvbWV0cnlDb2xsZWN0aW9uID8ganNvbi5nZW9tZXRyeSA6IEwuR2VvSlNPTi5hc0ZlYXR1cmUoanNvbikpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0XHRyZXR1cm4gTC5HZW9KU09OLmdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcblx0XHRcdFx0XHR0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcblx0XHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fSk7XHJcbn0oKSk7XHJcblxyXG5MLmdlb0pzb24gPSBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5HZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcclxuICogTC5Eb21FdmVudCBjb250YWlucyBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBET00gZXZlbnRzLlxyXG4gKi9cclxuXHJcbkwuRG9tRXZlbnQgPSB7XHJcblx0LyogaW5zcGlyZWQgYnkgSm9obiBSZXNpZywgRGVhbiBFZHdhcmRzIGFuZCBZVUkgYWRkRXZlbnQgaW1wbGVtZW50YXRpb25zICovXHJcblx0YWRkTGlzdGVuZXI6IGZ1bmN0aW9uIChvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7IC8vIChIVE1MRWxlbWVudCwgU3RyaW5nLCBGdW5jdGlvblssIE9iamVjdF0pXHJcblxyXG5cdFx0dmFyIGlkID0gTC5zdGFtcChmbiksXHJcblx0XHQgICAga2V5ID0gJ19sZWFmbGV0XycgKyB0eXBlICsgaWQsXHJcblx0XHQgICAgaGFuZGxlciwgb3JpZ2luYWxIYW5kbGVyLCBuZXdUeXBlO1xyXG5cclxuXHRcdGlmIChvYmpba2V5XSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRyZXR1cm4gZm4uY2FsbChjb250ZXh0IHx8IG9iaiwgZSB8fCBMLkRvbUV2ZW50Ll9nZXRFdmVudCgpKTtcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XHJcblx0XHR9XHJcblx0XHRpZiAoTC5Ccm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiB0aGlzLmFkZERvdWJsZVRhcExpc3RlbmVyKSB7XHJcblx0XHRcdHRoaXMuYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyLCBpZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICgodHlwZSA9PT0gJ21vdXNlZW50ZXInKSB8fCAodHlwZSA9PT0gJ21vdXNlbGVhdmUnKSkge1xyXG5cclxuXHRcdFx0XHRvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cdFx0XHRcdG5ld1R5cGUgPSAodHlwZSA9PT0gJ21vdXNlZW50ZXInID8gJ21vdXNlb3ZlcicgOiAnbW91c2VvdXQnKTtcclxuXHJcblx0XHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0XHRpZiAoIUwuRG9tRXZlbnQuX2NoZWNrTW91c2Uob2JqLCBlKSkgeyByZXR1cm47IH1cclxuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEhhbmRsZXIoZSk7XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIobmV3VHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnY2xpY2snICYmIEwuQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdFx0b3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHRcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdHJldHVybiBMLkRvbUV2ZW50Ll9maWx0ZXJDbGljayhlLCBvcmlnaW5hbEhhbmRsZXIpO1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCdhdHRhY2hFdmVudCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0b2JqW2tleV0gPSBoYW5kbGVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBmbikgeyAgLy8gKEhUTUxFbGVtZW50LCBTdHJpbmcsIEZ1bmN0aW9uKVxyXG5cclxuXHRcdHZhciBpZCA9IEwuc3RhbXAoZm4pLFxyXG5cdFx0ICAgIGtleSA9ICdfbGVhZmxldF8nICsgdHlwZSArIGlkLFxyXG5cdFx0ICAgIGhhbmRsZXIgPSBvYmpba2V5XTtcclxuXHJcblx0XHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaWQpO1xyXG5cdFx0fSBlbHNlIGlmIChMLkJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmIHRoaXMucmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICgodHlwZSA9PT0gJ21vdXNlZW50ZXInKSB8fCAodHlwZSA9PT0gJ21vdXNlbGVhdmUnKSkge1xyXG5cdFx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCh0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6ICdtb3VzZW91dCcpLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKCdkZXRhY2hFdmVudCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0b2JqW2tleV0gPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKGUpIHtcclxuXHJcblx0XHRpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcclxuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdEwuRG9tRXZlbnQuX3NraXBwZWQoZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHZhciBzdG9wID0gTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb247XHJcblxyXG5cdFx0cmV0dXJuIEwuRG9tRXZlbnRcclxuXHRcdFx0Lm9uKGVsLCAnbW91c2V3aGVlbCcsIHN0b3ApXHJcblx0XHRcdC5vbihlbCwgJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCBzdG9wKTtcclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbjogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR2YXIgc3RvcCA9IEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBMLkRyYWdnYWJsZS5TVEFSVC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKGVsLCBMLkRyYWdnYWJsZS5TVEFSVFtpXSwgc3RvcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEwuRG9tRXZlbnRcclxuXHRcdFx0Lm9uKGVsLCAnY2xpY2snLCBMLkRvbUV2ZW50Ll9mYWtlU3RvcClcclxuXHRcdFx0Lm9uKGVsLCAnZGJsY2xpY2snLCBzdG9wKTtcclxuXHR9LFxyXG5cclxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKGUpIHtcclxuXHJcblx0XHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzdG9wOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIEwuRG9tRXZlbnRcclxuXHRcdFx0LnByZXZlbnREZWZhdWx0KGUpXHJcblx0XHRcdC5zdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0fSxcclxuXHJcblx0Z2V0TW91c2VQb3NpdGlvbjogZnVuY3Rpb24gKGUsIGNvbnRhaW5lcikge1xyXG5cdFx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoXHJcblx0XHRcdGUuY2xpZW50WCAtIHJlY3QubGVmdCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG5cdFx0XHRlLmNsaWVudFkgLSByZWN0LnRvcCAtIGNvbnRhaW5lci5jbGllbnRUb3ApO1xyXG5cdH0sXHJcblxyXG5cdGdldFdoZWVsRGVsdGE6IGZ1bmN0aW9uIChlKSB7XHJcblxyXG5cdFx0dmFyIGRlbHRhID0gMDtcclxuXHJcblx0XHRpZiAoZS53aGVlbERlbHRhKSB7XHJcblx0XHRcdGRlbHRhID0gZS53aGVlbERlbHRhIC8gMTIwO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGUuZGV0YWlsKSB7XHJcblx0XHRcdGRlbHRhID0gLWUuZGV0YWlsIC8gMztcclxuXHRcdH1cclxuXHRcdHJldHVybiBkZWx0YTtcclxuXHR9LFxyXG5cclxuXHRfc2tpcEV2ZW50czoge30sXHJcblxyXG5cdF9mYWtlU3RvcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIGZha2VzIHN0b3BQcm9wYWdhdGlvbiBieSBzZXR0aW5nIGEgc3BlY2lhbCBldmVudCBmbGFnLCBjaGVja2VkL3Jlc2V0IHdpdGggTC5Eb21FdmVudC5fc2tpcHBlZChlKVxyXG5cdFx0TC5Eb21FdmVudC5fc2tpcEV2ZW50c1tlLnR5cGVdID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfc2tpcHBlZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBza2lwcGVkID0gdGhpcy5fc2tpcEV2ZW50c1tlLnR5cGVdO1xyXG5cdFx0Ly8gcmVzZXQgd2hlbiBjaGVja2luZywgYXMgaXQncyBvbmx5IHVzZWQgaW4gbWFwIGNvbnRhaW5lciBhbmQgcHJvcGFnYXRlcyBvdXRzaWRlIG9mIHRoZSBtYXBcclxuXHRcdHRoaXMuX3NraXBFdmVudHNbZS50eXBlXSA9IGZhbHNlO1xyXG5cdFx0cmV0dXJuIHNraXBwZWQ7XHJcblx0fSxcclxuXHJcblx0Ly8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcblx0X2NoZWNrTW91c2U6IGZ1bmN0aW9uIChlbCwgZSkge1xyXG5cclxuXHRcdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuXHRcdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuXHRcdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcblx0fSxcclxuXHJcblx0X2dldEV2ZW50OiBmdW5jdGlvbiAoKSB7IC8vIGV2aWwgbWFnaWMgZm9yIElFXHJcblx0XHQvKmpzaGludCBub2FyZzpmYWxzZSAqL1xyXG5cdFx0dmFyIGUgPSB3aW5kb3cuZXZlbnQ7XHJcblx0XHRpZiAoIWUpIHtcclxuXHRcdFx0dmFyIGNhbGxlciA9IGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyO1xyXG5cdFx0XHR3aGlsZSAoY2FsbGVyKSB7XHJcblx0XHRcdFx0ZSA9IGNhbGxlclsnYXJndW1lbnRzJ11bMF07XHJcblx0XHRcdFx0aWYgKGUgJiYgd2luZG93LkV2ZW50ID09PSBlLmNvbnN0cnVjdG9yKSB7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2FsbGVyID0gY2FsbGVyLmNhbGxlcjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGU7XHJcblx0fSxcclxuXHJcblx0Ly8gdGhpcyBpcyBhIGhvcnJpYmxlIHdvcmthcm91bmQgZm9yIGEgYnVnIGluIEFuZHJvaWQgd2hlcmUgYSBzaW5nbGUgdG91Y2ggdHJpZ2dlcnMgdHdvIGNsaWNrIGV2ZW50c1xyXG5cdF9maWx0ZXJDbGljazogZnVuY3Rpb24gKGUsIGhhbmRsZXIpIHtcclxuXHRcdHZhciB0aW1lU3RhbXAgPSAoZS50aW1lU3RhbXAgfHwgZS5vcmlnaW5hbEV2ZW50LnRpbWVTdGFtcCksXHJcblx0XHRcdGVsYXBzZWQgPSBMLkRvbUV2ZW50Ll9sYXN0Q2xpY2sgJiYgKHRpbWVTdGFtcCAtIEwuRG9tRXZlbnQuX2xhc3RDbGljayk7XHJcblxyXG5cdFx0Ly8gYXJlIHRoZXkgY2xvc2VyIHRvZ2V0aGVyIHRoYW4gNTAwbXMgeWV0IG1vcmUgdGhhbiAxMDBtcz9cclxuXHRcdC8vIEFuZHJvaWQgdHlwaWNhbGx5IHRyaWdnZXJzIHRoZW0gfjMwMG1zIGFwYXJ0IHdoaWxlIG11bHRpcGxlIGxpc3RlbmVyc1xyXG5cdFx0Ly8gb24gdGhlIHNhbWUgZXZlbnQgc2hvdWxkIGJlIHRyaWdnZXJlZCBmYXIgZmFzdGVyO1xyXG5cdFx0Ly8gb3IgY2hlY2sgaWYgY2xpY2sgaXMgc2ltdWxhdGVkIG9uIHRoZSBlbGVtZW50LCBhbmQgaWYgaXQgaXMsIHJlamVjdCBhbnkgbm9uLXNpbXVsYXRlZCBldmVudHNcclxuXHJcblx0XHRpZiAoKGVsYXBzZWQgJiYgZWxhcHNlZCA+IDEwMCAmJiBlbGFwc2VkIDwgNTAwKSB8fCAoZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrICYmICFlLl9zaW11bGF0ZWQpKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0TC5Eb21FdmVudC5fbGFzdENsaWNrID0gdGltZVN0YW1wO1xyXG5cclxuXHRcdHJldHVybiBoYW5kbGVyKGUpO1xyXG5cdH1cclxufTtcclxuXHJcbkwuRG9tRXZlbnQub24gPSBMLkRvbUV2ZW50LmFkZExpc3RlbmVyO1xyXG5MLkRvbUV2ZW50Lm9mZiA9IEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXI7XHJcblxuXG4vKlxyXG4gKiBMLkRyYWdnYWJsZSBhbGxvd3MgeW91IHRvIGFkZCBkcmFnZ2luZyBjYXBhYmlsaXRpZXMgdG8gYW55IGVsZW1lbnQuIFN1cHBvcnRzIG1vYmlsZSBkZXZpY2VzIHRvby5cclxuICovXHJcblxyXG5MLkRyYWdnYWJsZSA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHRpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXHJcblxyXG5cdHN0YXRpY3M6IHtcclxuXHRcdFNUQVJUOiBMLkJyb3dzZXIudG91Y2ggPyBbJ3RvdWNoc3RhcnQnLCAnbW91c2Vkb3duJ10gOiBbJ21vdXNlZG93biddLFxyXG5cdFx0RU5EOiB7XHJcblx0XHRcdG1vdXNlZG93bjogJ21vdXNldXAnLFxyXG5cdFx0XHR0b3VjaHN0YXJ0OiAndG91Y2hlbmQnLFxyXG5cdFx0XHRwb2ludGVyZG93bjogJ3RvdWNoZW5kJyxcclxuXHRcdFx0TVNQb2ludGVyRG93bjogJ3RvdWNoZW5kJ1xyXG5cdFx0fSxcclxuXHRcdE1PVkU6IHtcclxuXHRcdFx0bW91c2Vkb3duOiAnbW91c2Vtb3ZlJyxcclxuXHRcdFx0dG91Y2hzdGFydDogJ3RvdWNobW92ZScsXHJcblx0XHRcdHBvaW50ZXJkb3duOiAndG91Y2htb3ZlJyxcclxuXHRcdFx0TVNQb2ludGVyRG93bjogJ3RvdWNobW92ZSdcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZWxlbWVudCwgZHJhZ1N0YXJ0VGFyZ2V0KSB7XHJcblx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcclxuXHRcdHRoaXMuX2RyYWdTdGFydFRhcmdldCA9IGRyYWdTdGFydFRhcmdldCB8fCBlbGVtZW50O1xyXG5cdH0sXHJcblxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IEwuRHJhZ2dhYmxlLlNUQVJULmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBMLkRyYWdnYWJsZS5TVEFSVFtpXSwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IEwuRHJhZ2dhYmxlLlNUQVJULmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgTC5EcmFnZ2FibGUuU1RBUlRbaV0sIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkgJiYgIWUudG91Y2hlcykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZSk7XHJcblxyXG5cdFx0aWYgKEwuRHJhZ2dhYmxlLl9kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0TC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21vdmluZykgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xyXG5cclxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gdGhpcy5fbmV3UG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnRcclxuXHRcdCAgICAub24oZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLk1PVkVbZS50eXBlXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKVxyXG5cdFx0ICAgIC5vbihkb2N1bWVudCwgTC5EcmFnZ2FibGUuRU5EW2UudHlwZV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxyXG5cdFx0ICAgIG5ld1BvaW50ID0gbmV3IEwuUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSksXHJcblx0XHQgICAgb2Zmc2V0ID0gbmV3UG9pbnQuc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCk7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAoTC5Ccm93c2VyLnRvdWNoICYmIE1hdGguYWJzKG9mZnNldC54KSArIE1hdGguYWJzKG9mZnNldC55KSA8IDMpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHRoaXMuX3N0YXJ0UG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQpLnN1YnRyYWN0KG9mZnNldCk7XHJcblxyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcblx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fYW5pbVJlcXVlc3QgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVQb3NpdGlvbiwgdGhpcywgdHJ1ZSwgdGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0KTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuZmlyZSgncHJlZHJhZycpO1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuX25ld1Bvcyk7XHJcblx0XHR0aGlzLmZpcmUoJ2RyYWcnKTtcclxuXHR9LFxyXG5cclxuXHRfb25VcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gTC5EcmFnZ2FibGUuTU9WRSkge1xyXG5cdFx0XHRMLkRvbUV2ZW50XHJcblx0XHRcdCAgICAub2ZmKGRvY3VtZW50LCBMLkRyYWdnYWJsZS5NT1ZFW2ldLCB0aGlzLl9vbk1vdmUpXHJcblx0XHRcdCAgICAub2ZmKGRvY3VtZW50LCBMLkRyYWdnYWJsZS5FTkRbaV0sIHRoaXMuX29uVXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcclxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21vdmVkICYmIHRoaXMuX21vdmluZykge1xyXG5cdFx0XHQvLyBlbnN1cmUgZHJhZyBpcyBub3QgZmlyZWQgYWZ0ZXIgZHJhZ2VuZFxyXG5cdFx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ2VuZCcsIHtcclxuXHRcdFx0XHRkaXN0YW5jZTogdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmluZyA9IGZhbHNlO1xyXG5cdH1cclxufSk7XHJcblxuXG4vKlxuXHRMLkhhbmRsZXIgaXMgYSBiYXNlIGNsYXNzIGZvciBoYW5kbGVyIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IHRvIGluamVjdFxuXHRpbnRlcmFjdGlvbiBmZWF0dXJlcyBsaWtlIGRyYWdnaW5nIHRvIGNsYXNzZXMgbGlrZSBNYXAgYW5kIE1hcmtlci5cbiovXG5cbkwuSGFuZGxlciA9IEwuQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuYWRkSG9va3MoKTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXHRcdHRoaXMucmVtb3ZlSG9va3MoKTtcblx0fSxcblxuXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZW5hYmxlZDtcblx0fVxufSk7XG5cblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0ZHJhZ2dpbmc6IHRydWUsXG5cblx0aW5lcnRpYTogIUwuQnJvd3Nlci5hbmRyb2lkMjMsXG5cdGluZXJ0aWFEZWNlbGVyYXRpb246IDM0MDAsIC8vIHB4L3NeMlxuXHRpbmVydGlhTWF4U3BlZWQ6IEluZmluaXR5LCAvLyBweC9zXG5cdGluZXJ0aWFUaHJlc2hvbGQ6IEwuQnJvd3Nlci50b3VjaCA/IDMyIDogMTgsIC8vIG1zXG5cdGVhc2VMaW5lYXJpdHk6IDAuMjUsXG5cblx0Ly8gVE9ETyByZWZhY3RvciwgbW92ZSB0byBDUlNcblx0d29ybGRDb3B5SnVtcDogZmFsc2Vcbn0pO1xuXG5MLk1hcC5EcmFnID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShtYXAuX21hcFBhbmUsIG1hcC5fY29udGFpbmVyKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdFx0J2RyYWdzdGFydCc6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0XHQnZHJhZyc6IHRoaXMuX29uRHJhZyxcblx0XHRcdFx0J2RyYWdlbmQnOiB0aGlzLl9vbkRyYWdFbmRcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWcsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3ZpZXdyZXNldCcsIHRoaXMuX29uVmlld1Jlc2V0LCB0aGlzKTtcblxuXHRcdFx0XHRtYXAud2hlblJlYWR5KHRoaXMuX29uVmlld1Jlc2V0LCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKG1hcC5fcGFuQW5pbSkge1xuXHRcdFx0bWFwLl9wYW5BbmltLnN0b3AoKTtcblx0XHR9XG5cblx0XHRtYXBcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHRcdHRoaXMuX3RpbWVzID0gW107XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cblx0XHRcdGlmICh0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiAyMDApIHtcblx0XHRcdFx0dGhpcy5fcG9zaXRpb25zLnNoaWZ0KCk7XG5cdFx0XHRcdHRoaXMuX3RpbWVzLnNoaWZ0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWFwXG5cdFx0ICAgIC5maXJlKCdtb3ZlJylcblx0XHQgICAgLmZpcmUoJ2RyYWcnKTtcblx0fSxcblxuXHRfb25WaWV3UmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUT0RPIGZpeCBoYXJkY29kZWQgRWFydGggdmFsdWVzXG5cdFx0dmFyIHB4Q2VudGVyID0gdGhpcy5fbWFwLmdldFNpemUoKS5fZGl2aWRlQnkoMiksXG5cdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XG5cblx0XHR0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQgPSBweFdvcmxkQ2VudGVyLnN1YnRyYWN0KHB4Q2VudGVyKS54O1xuXHRcdHRoaXMuX3dvcmxkV2lkdGggPSB0aGlzLl9tYXAucHJvamVjdChbMCwgMTgwXSkueDtcblx0fSxcblxuXHRfb25QcmVEcmFnOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0byBiZSBhYmxlIHRvIGFkanVzdCBtYXAgcGFuZSBwb3NpdGlvbiBhZnRlciB6b29tXG5cdFx0dmFyIHdvcmxkV2lkdGggPSB0aGlzLl93b3JsZFdpZHRoLFxuXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcblx0XHQgICAgZHggPSB0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQsXG5cdFx0ICAgIHggPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LFxuXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYMiA9ICh4ICsgaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCAtIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYID0gTWF0aC5hYnMobmV3WDEgKyBkeCkgPCBNYXRoLmFicyhuZXdYMiArIGR4KSA/IG5ld1gxIDogbmV3WDI7XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54ID0gbmV3WDtcblx0fSxcblxuXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9wdGlvbnMgPSBtYXAub3B0aW9ucyxcblx0XHQgICAgZGVsYXkgPSArbmV3IERhdGUoKSAtIHRoaXMuX2xhc3RUaW1lLFxuXG5cdFx0ICAgIG5vSW5lcnRpYSA9ICFvcHRpb25zLmluZXJ0aWEgfHwgZGVsYXkgPiBvcHRpb25zLmluZXJ0aWFUaHJlc2hvbGQgfHwgIXRoaXMuX3Bvc2l0aW9uc1swXTtcblxuXHRcdG1hcC5maXJlKCdkcmFnZW5kJywgZSk7XG5cblx0XHRpZiAobm9JbmVydGlhKSB7XG5cdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxcblx0XHRcdCAgICBkdXJhdGlvbiA9ICh0aGlzLl9sYXN0VGltZSArIGRlbGF5IC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcblx0XHRcdCAgICBlYXNlID0gb3B0aW9ucy5lYXNlTGluZWFyaXR5LFxuXG5cdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuXHRcdFx0ICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkID0gTWF0aC5taW4ob3B0aW9ucy5pbmVydGlhTWF4U3BlZWQsIHNwZWVkKSxcblx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuXHRcdFx0ICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuXHRcdFx0ICAgIG9mZnNldCA9IGxpbWl0ZWRTcGVlZFZlY3Rvci5tdWx0aXBseUJ5KC1kZWNlbGVyYXRpb25EdXJhdGlvbiAvIDIpLnJvdW5kKCk7XG5cblx0XHRcdGlmICghb2Zmc2V0LnggfHwgIW9mZnNldC55KSB7XG5cdFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHRcdEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0LCB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogZGVjZWxlcmF0aW9uRHVyYXRpb24sXG5cdFx0XHRcdFx0XHRlYXNlTGluZWFyaXR5OiBlYXNlLFxuXHRcdFx0XHRcdFx0bm9Nb3ZlU3RhcnQ6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZHJhZ2dpbmcnLCBMLk1hcC5EcmFnKTtcblxuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxuTC5NYXAuRG91YmxlQ2xpY2tab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSArIChlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyAtMSA6IDEpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmRvdWJsZUNsaWNrWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZChlLmNvbnRhaW5lclBvaW50LCB6b29tKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkb3VibGVDbGlja1pvb20nLCBMLk1hcC5Eb3VibGVDbGlja1pvb20pO1xuXG5cbi8qXG4gKiBMLkhhbmRsZXIuU2Nyb2xsV2hlZWxab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gZW5hYmxlIG1vdXNlIHNjcm9sbCB3aGVlbCB6b29tIG9uIHRoZSBtYXAuXG4gKi9cblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0c2Nyb2xsV2hlZWxab29tOiB0cnVlXG59KTtcblxuTC5NYXAuU2Nyb2xsV2hlZWxab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwpO1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xuXHR9LFxuXG5cdF9vbldoZWVsU2Nyb2xsOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBkZWx0YSA9IEwuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YShlKTtcblxuXHRcdHRoaXMuX2RlbHRhICs9IGRlbHRhO1xuXHRcdHRoaXMuX2xhc3RNb3VzZVBvcyA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdGlmICghdGhpcy5fc3RhcnRUaW1lKSB7XG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblx0XHR9XG5cblx0XHR2YXIgbGVmdCA9IE1hdGgubWF4KDQwIC0gKCtuZXcgRGF0ZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSwgMCk7XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuXHRcdHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChMLmJpbmQodGhpcy5fcGVyZm9ybVpvb20sIHRoaXMpLCBsZWZ0KTtcblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZSk7XG5cdH0sXG5cblx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgZGVsdGEgPSB0aGlzLl9kZWx0YSxcblx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHRkZWx0YSA9IGRlbHRhID4gMCA/IE1hdGguY2VpbChkZWx0YSkgOiBNYXRoLmZsb29yKGRlbHRhKTtcblx0XHRkZWx0YSA9IE1hdGgubWF4KE1hdGgubWluKGRlbHRhLCA0KSwgLTQpO1xuXHRcdGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArIGRlbHRhKSAtIHpvb207XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuXHRcdGlmICghZGVsdGEpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQodGhpcy5fbGFzdE1vdXNlUG9zLCB6b29tICsgZGVsdGEpO1xuXHRcdH1cblx0fVxufSk7XG5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3Njcm9sbFdoZWVsWm9vbScsIEwuTWFwLlNjcm9sbFdoZWVsWm9vbSk7XG5cblxuLypcclxuICogRXh0ZW5kcyB0aGUgZXZlbnQgaGFuZGxpbmcgY29kZSB3aXRoIGRvdWJsZSB0YXAgc3VwcG9ydCBmb3IgbW9iaWxlIGJyb3dzZXJzLlxyXG4gKi9cclxuXHJcbkwuZXh0ZW5kKEwuRG9tRXZlbnQsIHtcclxuXHJcblx0X3RvdWNoc3RhcnQ6IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgOiBMLkJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVyZG93bicgOiAndG91Y2hzdGFydCcsXHJcblx0X3RvdWNoZW5kOiBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyA6IEwuQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJ1cCcgOiAndG91Y2hlbmQnLFxyXG5cclxuXHQvLyBpbnNwaXJlZCBieSBaZXB0byB0b3VjaCBjb2RlIGJ5IFRob21hcyBGdWNoc1xyXG5cdGFkZERvdWJsZVRhcExpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCBoYW5kbGVyLCBpZCkge1xyXG5cdFx0dmFyIGxhc3QsXHJcblx0XHQgICAgZG91YmxlVGFwID0gZmFsc2UsXHJcblx0XHQgICAgZGVsYXkgPSAyNTAsXHJcblx0XHQgICAgdG91Y2gsXHJcblx0XHQgICAgcHJlID0gJ19sZWFmbGV0XycsXHJcblx0XHQgICAgdG91Y2hzdGFydCA9IHRoaXMuX3RvdWNoc3RhcnQsXHJcblx0XHQgICAgdG91Y2hlbmQgPSB0aGlzLl90b3VjaGVuZCxcclxuXHRcdCAgICB0cmFja2VkVG91Y2hlcyA9IFtdO1xyXG5cclxuXHRcdGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XHJcblx0XHRcdHZhciBjb3VudDtcclxuXHJcblx0XHRcdGlmIChMLkJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdHRyYWNrZWRUb3VjaGVzLnB1c2goZS5wb2ludGVySWQpO1xyXG5cdFx0XHRcdGNvdW50ID0gdHJhY2tlZFRvdWNoZXMubGVuZ3RoO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvdW50ID0gZS50b3VjaGVzLmxlbmd0aDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoY291bnQgPiAxKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSxcclxuXHRcdFx0XHRkZWx0YSA9IG5vdyAtIChsYXN0IHx8IG5vdyk7XHJcblxyXG5cdFx0XHR0b3VjaCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XHJcblx0XHRcdGRvdWJsZVRhcCA9IChkZWx0YSA+IDAgJiYgZGVsdGEgPD0gZGVsYXkpO1xyXG5cdFx0XHRsYXN0ID0gbm93O1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIG9uVG91Y2hFbmQoZSkge1xyXG5cdFx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0XHR2YXIgaWR4ID0gdHJhY2tlZFRvdWNoZXMuaW5kZXhPZihlLnBvaW50ZXJJZCk7XHJcblx0XHRcdFx0aWYgKGlkeCA9PT0gLTEpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dHJhY2tlZFRvdWNoZXMuc3BsaWNlKGlkeCwgMSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChkb3VibGVUYXApIHtcclxuXHRcdFx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0XHRcdC8vIHdvcmsgYXJvdW5kIC50eXBlIGJlaW5nIHJlYWRvbmx5IHdpdGggTVNQb2ludGVyKiBldmVudHNcclxuXHRcdFx0XHRcdHZhciBuZXdUb3VjaCA9IHsgfSxcclxuXHRcdFx0XHRcdFx0cHJvcDtcclxuXHJcblx0XHRcdFx0XHQvLyBqc2hpbnQgZm9yaW46ZmFsc2VcclxuXHRcdFx0XHRcdGZvciAodmFyIGkgaW4gdG91Y2gpIHtcclxuXHRcdFx0XHRcdFx0cHJvcCA9IHRvdWNoW2ldO1xyXG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdFx0XHRuZXdUb3VjaFtpXSA9IHByb3AuYmluZCh0b3VjaCk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0bmV3VG91Y2hbaV0gPSBwcm9wO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0b3VjaCA9IG5ld1RvdWNoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0b3VjaC50eXBlID0gJ2RibGNsaWNrJztcclxuXHRcdFx0XHRoYW5kbGVyKHRvdWNoKTtcclxuXHRcdFx0XHRsYXN0ID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0b2JqW3ByZSArIHRvdWNoc3RhcnQgKyBpZF0gPSBvblRvdWNoU3RhcnQ7XHJcblx0XHRvYmpbcHJlICsgdG91Y2hlbmQgKyBpZF0gPSBvblRvdWNoRW5kO1xyXG5cclxuXHRcdC8vIG9uIHBvaW50ZXIgd2UgbmVlZCB0byBsaXN0ZW4gb24gdGhlIGRvY3VtZW50LCBvdGhlcndpc2UgYSBkcmFnIHN0YXJ0aW5nIG9uIHRoZSBtYXAgYW5kIG1vdmluZyBvZmYgc2NyZWVuXHJcblx0XHQvLyB3aWxsIG5vdCBjb21lIHRocm91Z2ggdG8gdXMsIHNvIHdlIHdpbGwgbG9zZSB0cmFjayBvZiBob3cgbWFueSB0b3VjaGVzIGFyZSBvbmdvaW5nXHJcblx0XHR2YXIgZW5kRWxlbWVudCA9IEwuQnJvd3Nlci5wb2ludGVyID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogb2JqO1xyXG5cclxuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRvdWNoc3RhcnQsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xyXG5cdFx0ZW5kRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRvdWNoZW5kLCBvblRvdWNoRW5kLCBmYWxzZSk7XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdGVuZEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihMLkRvbUV2ZW50LlBPSU5URVJfQ0FOQ0VMLCBvblRvdWNoRW5kLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlRG91YmxlVGFwTGlzdGVuZXI6IGZ1bmN0aW9uIChvYmosIGlkKSB7XHJcblx0XHR2YXIgcHJlID0gJ19sZWFmbGV0Xyc7XHJcblxyXG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fdG91Y2hzdGFydCwgb2JqW3ByZSArIHRoaXMuX3RvdWNoc3RhcnQgKyBpZF0sIGZhbHNlKTtcclxuXHRcdChMLkJyb3dzZXIucG9pbnRlciA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IG9iaikucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuXHRcdCAgICAgICAgdGhpcy5fdG91Y2hlbmQsIG9ialtwcmUgKyB0aGlzLl90b3VjaGVuZCArIGlkXSwgZmFsc2UpO1xyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihMLkRvbUV2ZW50LlBPSU5URVJfQ0FOQ0VMLCBvYmpbcHJlICsgdGhpcy5fdG91Y2hlbmQgKyBpZF0sXHJcblx0XHRcdFx0ZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxuXG4vKlxuICogRXh0ZW5kcyBMLkRvbUV2ZW50IHRvIHByb3ZpZGUgdG91Y2ggc3VwcG9ydCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgYW5kIFdpbmRvd3MtYmFzZWQgZGV2aWNlcy5cbiAqL1xuXG5MLmV4dGVuZChMLkRvbUV2ZW50LCB7XG5cblx0Ly9zdGF0aWNcblx0UE9JTlRFUl9ET1dOOiBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nIDogJ3BvaW50ZXJkb3duJyxcblx0UE9JTlRFUl9NT1ZFOiBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlck1vdmUnIDogJ3BvaW50ZXJtb3ZlJyxcblx0UE9JTlRFUl9VUDogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgOiAncG9pbnRlcnVwJyxcblx0UE9JTlRFUl9DQU5DRUw6IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyQ2FuY2VsJyA6ICdwb2ludGVyY2FuY2VsJyxcblxuXHRfcG9pbnRlcnM6IFtdLFxuXHRfcG9pbnRlckRvY3VtZW50TGlzdGVuZXI6IGZhbHNlLFxuXG5cdC8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cblx0Ly8gQmFzZWQgb24gY2hhbmdlcyBieSB2ZXByb3phIGh0dHBzOi8vZ2l0aHViLmNvbS9DbG91ZE1hZGUvTGVhZmxldC9wdWxsLzEwMTlcblx0Ly9yZWYgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8gaHR0cHM6Ly93d3cudzMub3JnL0J1Z3MvUHVibGljL3Nob3dfYnVnLmNnaT9pZD0yMjg5MFxuXG5cdGFkZFBvaW50ZXJMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpIHtcblxuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdGNhc2UgJ3RvdWNoc3RhcnQnOlxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkUG9pbnRlckxpc3RlbmVyU3RhcnQob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XG5cdFx0Y2FzZSAndG91Y2hlbmQnOlxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkUG9pbnRlckxpc3RlbmVyRW5kKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpO1xuXHRcdGNhc2UgJ3RvdWNobW92ZSc6XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRQb2ludGVyTGlzdGVuZXJNb3ZlKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyAnVW5rbm93biB0b3VjaCBldmVudCB0eXBlJztcblx0XHR9XG5cdH0sXG5cblx0YWRkUG9pbnRlckxpc3RlbmVyU3RhcnQ6IGZ1bmN0aW9uIChvYmosIHR5cGUsIGhhbmRsZXIsIGlkKSB7XG5cdFx0dmFyIHByZSA9ICdfbGVhZmxldF8nLFxuXHRcdCAgICBwb2ludGVycyA9IHRoaXMuX3BvaW50ZXJzO1xuXG5cdFx0dmFyIGNiID0gZnVuY3Rpb24gKGUpIHtcblxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblxuXHRcdFx0dmFyIGFscmVhZHlJbkFycmF5ID0gZmFsc2U7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwb2ludGVyc1tpXS5wb2ludGVySWQgPT09IGUucG9pbnRlcklkKSB7XG5cdFx0XHRcdFx0YWxyZWFkeUluQXJyYXkgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWFscmVhZHlJbkFycmF5KSB7XG5cdFx0XHRcdHBvaW50ZXJzLnB1c2goZSk7XG5cdFx0XHR9XG5cblx0XHRcdGUudG91Y2hlcyA9IHBvaW50ZXJzLnNsaWNlKCk7XG5cdFx0XHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG5cdFx0XHRoYW5kbGVyKGUpO1xuXHRcdH07XG5cblx0XHRvYmpbcHJlICsgJ3RvdWNoc3RhcnQnICsgaWRdID0gY2I7XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0RPV04sIGNiLCBmYWxzZSk7XG5cblx0XHQvLyBuZWVkIHRvIGFsc28gbGlzdGVuIGZvciBlbmQgZXZlbnRzIHRvIGtlZXAgdGhlIF9wb2ludGVycyBsaXN0IGFjY3VyYXRlXG5cdFx0Ly8gdGhpcyBuZWVkcyB0byBiZSBvbiB0aGUgYm9keSBhbmQgbmV2ZXIgZ28gYXdheVxuXHRcdGlmICghdGhpcy5fcG9pbnRlckRvY3VtZW50TGlzdGVuZXIpIHtcblx0XHRcdHZhciBpbnRlcm5hbENiID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChwb2ludGVyc1tpXS5wb2ludGVySWQgPT09IGUucG9pbnRlcklkKSB7XG5cdFx0XHRcdFx0XHRwb2ludGVycy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHQvL1dlIGxpc3RlbiBvbiB0aGUgZG9jdW1lbnRFbGVtZW50IGFzIGFueSBkcmFncyB0aGF0IGVuZCBieSBtb3ZpbmcgdGhlIHRvdWNoIG9mZiB0aGUgc2NyZWVuIGdldCBmaXJlZCB0aGVyZVxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX1VQLCBpbnRlcm5hbENiLCBmYWxzZSk7XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfQ0FOQ0VMLCBpbnRlcm5hbENiLCBmYWxzZSk7XG5cblx0XHRcdHRoaXMuX3BvaW50ZXJEb2N1bWVudExpc3RlbmVyID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRhZGRQb2ludGVyTGlzdGVuZXJNb3ZlOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCkge1xuXHRcdHZhciBwcmUgPSAnX2xlYWZsZXRfJyxcblx0XHQgICAgdG91Y2hlcyA9IHRoaXMuX3BvaW50ZXJzO1xuXG5cdFx0ZnVuY3Rpb24gY2IoZSkge1xuXG5cdFx0XHQvLyBkb24ndCBmaXJlIHRvdWNoIG1vdmVzIHdoZW4gbW91c2UgaXNuJ3QgZG93blxuXHRcdFx0aWYgKChlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpICYmIGUuYnV0dG9ucyA9PT0gMCkgeyByZXR1cm47IH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh0b3VjaGVzW2ldLnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcblx0XHRcdFx0XHR0b3VjaGVzW2ldID0gZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRlLnRvdWNoZXMgPSB0b3VjaGVzLnNsaWNlKCk7XG5cdFx0XHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG5cdFx0XHRoYW5kbGVyKGUpO1xuXHRcdH1cblxuXHRcdG9ialtwcmUgKyAndG91Y2htb3ZlJyArIGlkXSA9IGNiO1xuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9NT1ZFLCBjYiwgZmFsc2UpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YWRkUG9pbnRlckxpc3RlbmVyRW5kOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCkge1xuXHRcdHZhciBwcmUgPSAnX2xlYWZsZXRfJyxcblx0XHQgICAgdG91Y2hlcyA9IHRoaXMuX3BvaW50ZXJzO1xuXG5cdFx0dmFyIGNiID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodG91Y2hlc1tpXS5wb2ludGVySWQgPT09IGUucG9pbnRlcklkKSB7XG5cdFx0XHRcdFx0dG91Y2hlcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZS50b3VjaGVzID0gdG91Y2hlcy5zbGljZSgpO1xuXHRcdFx0ZS5jaGFuZ2VkVG91Y2hlcyA9IFtlXTtcblxuXHRcdFx0aGFuZGxlcihlKTtcblx0XHR9O1xuXG5cdFx0b2JqW3ByZSArICd0b3VjaGVuZCcgKyBpZF0gPSBjYjtcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfVVAsIGNiLCBmYWxzZSk7XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0NBTkNFTCwgY2IsIGZhbHNlKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgaWQpIHtcblx0XHR2YXIgcHJlID0gJ19sZWFmbGV0XycsXG5cdFx0ICAgIGNiID0gb2JqW3ByZSArIHR5cGUgKyBpZF07XG5cblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRjYXNlICd0b3VjaHN0YXJ0Jzpcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9ET1dOLCBjYiwgZmFsc2UpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAndG91Y2htb3ZlJzpcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9NT1ZFLCBjYiwgZmFsc2UpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAndG91Y2hlbmQnOlxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX1VQLCBjYiwgZmFsc2UpO1xuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0NBTkNFTCwgY2IsIGZhbHNlKTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxuXG4vKlxuICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0dG91Y2hab29tOiBMLkJyb3dzZXIudG91Y2ggJiYgIUwuQnJvd3Nlci5hbmRyb2lkMjMsXG5cdGJvdW5jZUF0Wm9vbUxpbWl0czogdHJ1ZVxufSk7XG5cbkwuTWFwLlRvdWNoWm9vbSA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCBtYXAuX2FuaW1hdGluZ1pvb20gfHwgdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZS50b3VjaGVzWzFdKSxcblx0XHQgICAgdmlld0NlbnRlciA9IG1hcC5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpO1xuXG5cdFx0dGhpcy5fc3RhcnRDZW50ZXIgPSBwMS5hZGQocDIpLl9kaXZpZGVCeSgyKTtcblx0XHR0aGlzLl9zdGFydERpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcblxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5fem9vbWluZyA9IHRydWU7XG5cblx0XHR0aGlzLl9jZW50ZXJPZmZzZXQgPSB2aWV3Q2VudGVyLnN1YnRyYWN0KHRoaXMuX3N0YXJ0Q2VudGVyKTtcblxuXHRcdGlmIChtYXAuX3BhbkFuaW0pIHtcblx0XHRcdG1hcC5fcGFuQW5pbS5zdG9wKCk7XG5cdFx0fVxuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcylcblx0XHQgICAgLm9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8ICF0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlLnRvdWNoZXNbMV0pO1xuXG5cdFx0dGhpcy5fc2NhbGUgPSBwMS5kaXN0YW5jZVRvKHAyKSAvIHRoaXMuX3N0YXJ0RGlzdDtcblx0XHR0aGlzLl9kZWx0YSA9IHAxLl9hZGQocDIpLl9kaXZpZGVCeSgyKS5fc3VidHJhY3QodGhpcy5fc3RhcnRDZW50ZXIpO1xuXG5cdFx0aWYgKHRoaXMuX3NjYWxlID09PSAxKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMpIHtcblx0XHRcdGlmICgobWFwLmdldFpvb20oKSA9PT0gbWFwLmdldE1pblpvb20oKSAmJiB0aGlzLl9zY2FsZSA8IDEpIHx8XG5cdFx0XHQgICAgKG1hcC5nZXRab29tKCkgPT09IG1hcC5nZXRNYXhab29tKCkgJiYgdGhpcy5fc2NhbGUgPiAxKSkgeyByZXR1cm47IH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MobWFwLl9tYXBQYW5lLCAnbGVhZmxldC10b3VjaGluZycpO1xuXG5cdFx0XHRtYXBcblx0XHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHRcdCAgICAuZmlyZSgnem9vbXN0YXJ0Jyk7XG5cblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFxuXHRcdCAgICAgICAgdGhpcy5fdXBkYXRlT25Nb3ZlLCB0aGlzLCB0cnVlLCB0aGlzLl9tYXAuX2NvbnRhaW5lcik7XG5cblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF91cGRhdGVPbk1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvcmlnaW4gPSB0aGlzLl9nZXRTY2FsZU9yaWdpbigpLFxuXHRcdCAgICBjZW50ZXIgPSBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKG9yaWdpbiksXG5cdFx0ICAgIHpvb20gPSBtYXAuZ2V0U2NhbGVab29tKHRoaXMuX3NjYWxlKTtcblxuXHRcdG1hcC5fYW5pbWF0ZVpvb20oY2VudGVyLCB6b29tLCB0aGlzLl9zdGFydENlbnRlciwgdGhpcy5fc2NhbGUsIHRoaXMuX2RlbHRhLCBmYWxzZSwgdHJ1ZSk7XG5cdH0sXG5cblx0X29uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG5cdFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MobWFwLl9tYXBQYW5lLCAnbGVhZmxldC10b3VjaGluZycpO1xuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpXG5cdFx0ICAgIC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuXG5cdFx0dmFyIG9yaWdpbiA9IHRoaXMuX2dldFNjYWxlT3JpZ2luKCksXG5cdFx0ICAgIGNlbnRlciA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcob3JpZ2luKSxcblxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgZmxvYXRab29tRGVsdGEgPSBtYXAuZ2V0U2NhbGVab29tKHRoaXMuX3NjYWxlKSAtIG9sZFpvb20sXG5cdFx0ICAgIHJvdW5kWm9vbURlbHRhID0gKGZsb2F0Wm9vbURlbHRhID4gMCA/XG5cdFx0ICAgICAgICAgICAgTWF0aC5jZWlsKGZsb2F0Wm9vbURlbHRhKSA6IE1hdGguZmxvb3IoZmxvYXRab29tRGVsdGEpKSxcblxuXHRcdCAgICB6b29tID0gbWFwLl9saW1pdFpvb20ob2xkWm9vbSArIHJvdW5kWm9vbURlbHRhKSxcblx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKHpvb20pIC8gdGhpcy5fc2NhbGU7XG5cblx0XHRtYXAuX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgb3JpZ2luLCBzY2FsZSk7XG5cdH0sXG5cblx0X2dldFNjYWxlT3JpZ2luOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNlbnRlck9mZnNldCA9IHRoaXMuX2NlbnRlck9mZnNldC5zdWJ0cmFjdCh0aGlzLl9kZWx0YSkuZGl2aWRlQnkodGhpcy5fc2NhbGUpO1xuXHRcdHJldHVybiB0aGlzLl9zdGFydENlbnRlci5hZGQoY2VudGVyT2Zmc2V0KTtcblx0fVxufSk7XG5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoWm9vbScsIEwuTWFwLlRvdWNoWm9vbSk7XG5cblxuLypcbiAqIEwuTWFwLlRhcCBpcyB1c2VkIHRvIGVuYWJsZSBtb2JpbGUgaGFja3MgbGlrZSBxdWljayB0YXBzIGFuZCBsb25nIGhvbGQuXG4gKi9cblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0dGFwOiB0cnVlLFxuXHR0YXBUb2xlcmFuY2U6IDE1XG59KTtcblxuTC5NYXAuVGFwID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS50b3VjaGVzKSB7IHJldHVybjsgfVxuXG5cdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblxuXHRcdHRoaXMuX2ZpcmVDbGljayA9IHRydWU7XG5cblx0XHQvLyBkb24ndCBzaW11bGF0ZSBjbGljayBvciB0cmFjayBsb25ncHJlc3MgaWYgbW9yZSB0aGFuIDEgdG91Y2hcblx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF0sXG5cdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuXHRcdC8vIGlmIHRvdWNoaW5nIGEgbGluaywgaGlnaGxpZ2h0IGl0XG5cdFx0aWYgKGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0fVxuXG5cdFx0Ly8gc2ltdWxhdGUgbG9uZyBob2xkIGJ1dCBzZXR0aW5nIGEgdGltZW91dFxuXHRcdHRoaXMuX2hvbGRUaW1lb3V0ID0gc2V0VGltZW91dChMLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9maXJlQ2xpY2sgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fb25VcCgpO1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjb250ZXh0bWVudScsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKSwgMTAwMCk7XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0XHQub24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpXG5cdFx0XHQub24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVXAsIHRoaXMpO1xuXHR9LFxuXG5cdF9vblVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0XHQub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKVxuXHRcdFx0Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25VcCwgdGhpcyk7XG5cblx0XHRpZiAodGhpcy5fZmlyZUNsaWNrICYmIGUgJiYgZS5jaGFuZ2VkVG91Y2hlcykge1xuXG5cdFx0XHR2YXIgZmlyc3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLFxuXHRcdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0XHRpZiAoZWwgJiYgZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoZWwsICdsZWFmbGV0LWFjdGl2ZScpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzaW11bGF0ZSBjbGljayBpZiB0aGUgdG91Y2ggZGlkbid0IG1vdmUgdG9vIG11Y2hcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY2xpY2snLCBmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1RhcFZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKSA8PSB0aGlzLl9tYXAub3B0aW9ucy50YXBUb2xlcmFuY2U7XG5cdH0sXG5cblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF07XG5cdFx0dGhpcy5fbmV3UG9zID0gbmV3IEwuUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cdH0sXG5cblx0X3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG5cdFx0dmFyIHNpbXVsYXRlZEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTtcblx0XHRlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgPSB0cnVlO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQoXG5cdFx0ICAgICAgICB0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsXG5cdFx0ICAgICAgICBlLnNjcmVlblgsIGUuc2NyZWVuWSxcblx0XHQgICAgICAgIGUuY2xpZW50WCwgZS5jbGllbnRZLFxuXHRcdCAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG5cdH1cbn0pO1xuXG5pZiAoTC5Ccm93c2VyLnRvdWNoICYmICFMLkJyb3dzZXIucG9pbnRlcikge1xuXHRMLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXAnLCBMLk1hcC5UYXApO1xufVxuXG5cbi8qXG4gKiBMLkhhbmRsZXIuU2hpZnREcmFnWm9vbSBpcyB1c2VkIHRvIGFkZCBzaGlmdC1kcmFnIHpvb20gaW50ZXJhY3Rpb24gdG8gdGhlIG1hcFxuICAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdGJveFpvb206IHRydWVcbn0pO1xuXG5MLk1hcC5Cb3hab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbWFwLl9jb250YWluZXI7XG5cdFx0dGhpcy5fcGFuZSA9IG1hcC5fcGFuZXMub3ZlcmxheVBhbmU7XG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cblx0XHRpZiAoIWUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHR0aGlzLl9zdGFydExheWVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKTtcblxuXHRcdEwuRG9tRXZlbnRcblx0XHQgICAgLm9uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpXG5cdFx0ICAgIC5vbihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAsIHRoaXMpXG5cdFx0ICAgIC5vbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9ib3ggPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX3BhbmUpO1xuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2JveCwgdGhpcy5fc3RhcnRMYXllclBvaW50KTtcblxuXHRcdFx0Ly9UT0RPIHJlZmFjdG9yOiBtb3ZlIGN1cnNvciB0byBzdHlsZXNcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSAnY3Jvc3NoYWlyJztcblx0XHRcdHRoaXMuX21hcC5maXJlKCdib3h6b29tc3RhcnQnKTtcblx0XHR9XG5cblx0XHR2YXIgc3RhcnRQb2ludCA9IHRoaXMuX3N0YXJ0TGF5ZXJQb2ludCxcblx0XHQgICAgYm94ID0gdGhpcy5fYm94LFxuXG5cdFx0ICAgIGxheWVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSxcblx0XHQgICAgb2Zmc2V0ID0gbGF5ZXJQb2ludC5zdWJ0cmFjdChzdGFydFBvaW50KSxcblxuXHRcdCAgICBuZXdQb3MgPSBuZXcgTC5Qb2ludChcblx0XHQgICAgICAgIE1hdGgubWluKGxheWVyUG9pbnQueCwgc3RhcnRQb2ludC54KSxcblx0XHQgICAgICAgIE1hdGgubWluKGxheWVyUG9pbnQueSwgc3RhcnRQb2ludC55KSk7XG5cblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oYm94LCBuZXdQb3MpO1xuXG5cdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXG5cdFx0Ly8gVE9ETyByZWZhY3RvcjogcmVtb3ZlIGhhcmRjb2RlZCA0IHBpeGVsc1xuXHRcdGJveC5zdHlsZS53aWR0aCAgPSAoTWF0aC5tYXgoMCwgTWF0aC5hYnMob2Zmc2V0LngpIC0gNCkpICsgJ3B4Jztcblx0XHRib3guc3R5bGUuaGVpZ2h0ID0gKE1hdGgubWF4KDAsIE1hdGguYWJzKG9mZnNldC55KSAtIDQpKSArICdweCc7XG5cdH0sXG5cblx0X2ZpbmlzaDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tb3ZlZCkge1xuXHRcdFx0dGhpcy5fcGFuZS5yZW1vdmVDaGlsZCh0aGlzLl9ib3gpO1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9ICcnO1xuXHRcdH1cblxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0TC5Eb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpXG5cdFx0ICAgIC5vZmYoZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKVxuXHRcdCAgICAub2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93bik7XG5cdH0sXG5cblx0X29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcblxuXHRcdHRoaXMuX2ZpbmlzaCgpO1xuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgbGF5ZXJQb2ludCA9IG1hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpO1xuXG5cdFx0aWYgKHRoaXMuX3N0YXJ0TGF5ZXJQb2ludC5lcXVhbHMobGF5ZXJQb2ludCkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKFxuXHRcdCAgICAgICAgbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9zdGFydExheWVyUG9pbnQpLFxuXHRcdCAgICAgICAgbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KSk7XG5cblx0XHRtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG5cblx0XHRtYXAuZmlyZSgnYm94em9vbWVuZCcsIHtcblx0XHRcdGJveFpvb21Cb3VuZHM6IGJvdW5kc1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdHRoaXMuX2ZpbmlzaCgpO1xuXHRcdH1cblx0fVxufSk7XG5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2JveFpvb20nLCBMLk1hcC5Cb3hab29tKTtcblxuXG4vKlxuICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0a2V5Ym9hcmQ6IHRydWUsXG5cdGtleWJvYXJkUGFuT2Zmc2V0OiA4MCxcblx0a2V5Ym9hcmRab29tT2Zmc2V0OiAxXG59KTtcblxuTC5NYXAuS2V5Ym9hcmQgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblxuXHRrZXlDb2Rlczoge1xuXHRcdGxlZnQ6ICAgIFszN10sXG5cdFx0cmlnaHQ6ICAgWzM5XSxcblx0XHRkb3duOiAgICBbNDBdLFxuXHRcdHVwOiAgICAgIFszOF0sXG5cdFx0em9vbUluOiAgWzE4NywgMTA3LCA2MSwgMTcxXSxcblx0XHR6b29tT3V0OiBbMTg5LCAxMDksIDE3M11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXG5cdFx0dGhpcy5fc2V0UGFuT2Zmc2V0KG1hcC5vcHRpb25zLmtleWJvYXJkUGFuT2Zmc2V0KTtcblx0XHR0aGlzLl9zZXRab29tT2Zmc2V0KG1hcC5vcHRpb25zLmtleWJvYXJkWm9vbU9mZnNldCk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cblx0XHQvLyBtYWtlIHRoZSBjb250YWluZXIgZm9jdXNhYmxlIGJ5IHRhYmJpbmdcblx0XHRpZiAoY29udGFpbmVyLnRhYkluZGV4ID09PSAtMSkge1xuXHRcdFx0Y29udGFpbmVyLnRhYkluZGV4ID0gJzAnO1xuXHRcdH1cblxuXHRcdEwuRG9tRXZlbnRcblx0XHQgICAgLm9uKGNvbnRhaW5lciwgJ2ZvY3VzJywgdGhpcy5fb25Gb2N1cywgdGhpcylcblx0XHQgICAgLm9uKGNvbnRhaW5lciwgJ2JsdXInLCB0aGlzLl9vbkJsdXIsIHRoaXMpXG5cdFx0ICAgIC5vbihjb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXBcblx0XHQgICAgLm9uKCdmb2N1cycsIHRoaXMuX2FkZEhvb2tzLCB0aGlzKVxuXHRcdCAgICAub24oJ2JsdXInLCB0aGlzLl9yZW1vdmVIb29rcywgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW1vdmVIb29rcygpO1xuXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub2ZmKGNvbnRhaW5lciwgJ2ZvY3VzJywgdGhpcy5fb25Gb2N1cywgdGhpcylcblx0XHQgICAgLm9mZihjb250YWluZXIsICdibHVyJywgdGhpcy5fb25CbHVyLCB0aGlzKVxuXHRcdCAgICAub2ZmKGNvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcFxuXHRcdCAgICAub2ZmKCdmb2N1cycsIHRoaXMuX2FkZEhvb2tzLCB0aGlzKVxuXHRcdCAgICAub2ZmKCdibHVyJywgdGhpcy5fcmVtb3ZlSG9va3MsIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9mb2N1c2VkKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuXHRcdCAgICBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuXHRcdCAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsLnNjcm9sbExlZnQ7XG5cblx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xuXG5cdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG5cdH0sXG5cblx0X29uRm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnZm9jdXMnKTtcblx0fSxcblxuXHRfb25CbHVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdibHVyJyk7XG5cdH0sXG5cblx0X3NldFBhbk9mZnNldDogZnVuY3Rpb24gKHBhbikge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fcGFuS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMubGVmdFtpXV0gPSBbLTEgKiBwYW4sIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5yaWdodC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuZG93bi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5kb3duW2ldXSA9IFswLCBwYW5dO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy51cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy51cFtpXV0gPSBbMCwgLTEgKiBwYW5dO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbU9mZnNldDogZnVuY3Rpb24gKHpvb20pIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21JbltpXV0gPSB6b29tO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tT3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21PdXRbaV1dID0gLXpvb207XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGtleSA9IGUua2V5Q29kZSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKGtleSBpbiB0aGlzLl9wYW5LZXlzKSB7XG5cblx0XHRcdGlmIChtYXAuX3BhbkFuaW0gJiYgbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0XHRtYXAucGFuQnkodGhpcy5fcGFuS2V5c1trZXldKTtcblxuXHRcdFx0aWYgKG1hcC5vcHRpb25zLm1heEJvdW5kcykge1xuXHRcdFx0XHRtYXAucGFuSW5zaWRlQm91bmRzKG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xuXHRcdFx0bWFwLnNldFpvb20obWFwLmdldFpvb20oKSArIHRoaXMuX3pvb21LZXlzW2tleV0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XG5cdH1cbn0pO1xuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEwuTWFwLktleWJvYXJkKTtcblxuXG4vKlxuICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICovXG5cbkwuSGFuZGxlci5NYXJrZXJEcmFnID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKGljb24sIGljb24pO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZVxuXHRcdFx0Lm9uKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCwgdGhpcylcblx0XHRcdC5vbignZHJhZycsIHRoaXMuX29uRHJhZywgdGhpcylcblx0XHRcdC5vbignZHJhZ2VuZCcsIHRoaXMuX29uRHJhZ0VuZCwgdGhpcyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXJrZXIuX2ljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2RyYWdnYWJsZVxuXHRcdFx0Lm9mZignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQsIHRoaXMpXG5cdFx0XHQub2ZmKCdkcmFnJywgdGhpcy5fb25EcmFnLCB0aGlzKVxuXHRcdFx0Lm9mZignZHJhZ2VuZCcsIHRoaXMuX29uRHJhZ0VuZCwgdGhpcyk7XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpO1xuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXJrZXIuX2ljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXJrZXJcblx0XHQgICAgLmNsb3NlUG9wdXAoKVxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXHR9LFxuXG5cdF9vbkRyYWc6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBzaGFkb3cgPSBtYXJrZXIuX3NoYWRvdyxcblx0XHQgICAgaWNvblBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cblx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG5cdFx0aWYgKHNoYWRvdykge1xuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHNoYWRvdywgaWNvblBvcyk7XG5cdFx0fVxuXG5cdFx0bWFya2VyLl9sYXRsbmcgPSBsYXRsbmc7XG5cblx0XHRtYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmUnLCB7bGF0bG5nOiBsYXRsbmd9KVxuXHRcdCAgICAuZmlyZSgnZHJhZycpO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcblx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblx0fVxufSk7XG5cblxuLypcclxuICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5cclxuTC5Db250cm9sID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHR9LFxyXG5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG5cdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbCcpO1xyXG5cclxuXHRcdGlmIChwb3MuaW5kZXhPZignYm90dG9tJykgIT09IC0xKSB7XHJcblx0XHRcdGNvcm5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjb3JuZXIuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3JuZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVGcm9tOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpLFxyXG5cdFx0ICAgIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcclxuXHJcblx0XHRjb3JuZXIucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG5cdFx0aWYgKHRoaXMub25SZW1vdmUpIHtcclxuXHRcdFx0dGhpcy5vblJlbW92ZShtYXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yZWZvY3VzT25NYXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbkwuY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wob3B0aW9ucyk7XHJcbn07XHJcblxyXG5cclxuLy8gYWRkcyBjb250cm9sLXJlbGF0ZWQgbWV0aG9kcyB0byBMLk1hcFxyXG5cclxuTC5NYXAuaW5jbHVkZSh7XHJcblx0YWRkQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wuYWRkVG8odGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5yZW1vdmVGcm9tKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29ybmVycyA9IHRoaXMuX2NvbnRyb2xDb3JuZXJzID0ge30sXHJcblx0XHQgICAgbCA9ICdsZWFmbGV0LScsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9XHJcblx0XHQgICAgICAgICAgICBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRmdW5jdGlvbiBjcmVhdGVDb3JuZXIodlNpZGUsIGhTaWRlKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBsICsgdlNpZGUgKyAnICcgKyBsICsgaFNpZGU7XHJcblxyXG5cdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcclxuXHR9XHJcbn0pO1xyXG5cblxuLypcclxuICogTC5Db250cm9sLlpvb20gaXMgdXNlZCBmb3IgdGhlIGRlZmF1bHQgem9vbSBidXR0b25zIG9uIHRoZSBtYXAuXHJcbiAqL1xyXG5cclxuTC5Db250cm9sLlpvb20gPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ3RvcGxlZnQnLFxyXG5cdFx0em9vbUluVGV4dDogJysnLFxyXG5cdFx0em9vbUluVGl0bGU6ICdab29tIGluJyxcclxuXHRcdHpvb21PdXRUZXh0OiAnLScsXHJcblx0XHR6b29tT3V0VGl0bGU6ICdab29tIG91dCdcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dmFyIHpvb21OYW1lID0gJ2xlYWZsZXQtY29udHJvbC16b29tJyxcclxuXHRcdCAgICBjb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKTtcclxuXHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0dGhpcy5fem9vbUluQnV0dG9uICA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcclxuXHRcdCAgICAgICAgdGhpcy5vcHRpb25zLnpvb21JblRleHQsIHRoaXMub3B0aW9ucy56b29tSW5UaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLWluJywgIGNvbnRhaW5lciwgdGhpcy5fem9vbUluLCAgdGhpcyk7XHJcblx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFxyXG5cdFx0ICAgICAgICB0aGlzLm9wdGlvbnMuem9vbU91dFRleHQsIHRoaXMub3B0aW9ucy56b29tT3V0VGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1vdXQnLCBjb250YWluZXIsIHRoaXMuX3pvb21PdXQsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRtYXAub24oJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub2ZmKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X3pvb21JbjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX21hcC56b29tSW4oZS5zaGlmdEtleSA/IDMgOiAxKTtcclxuXHR9LFxyXG5cclxuXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX21hcC56b29tT3V0KGUuc2hpZnRLZXkgPyAzIDogMSk7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHZhciBsaW5rID0gTC5Eb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdGxpbmsuaW5uZXJIVE1MID0gaHRtbDtcclxuXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdGxpbmsudGl0bGUgPSB0aXRsZTtcclxuXHJcblx0XHR2YXIgc3RvcCA9IEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uO1xyXG5cclxuXHRcdEwuRG9tRXZlbnRcclxuXHRcdCAgICAub24obGluaywgJ2NsaWNrJywgc3RvcClcclxuXHRcdCAgICAub24obGluaywgJ21vdXNlZG93bicsIHN0b3ApXHJcblx0XHQgICAgLm9uKGxpbmssICdkYmxjbGljaycsIHN0b3ApXHJcblx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpXHJcblx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIGZuLCBjb250ZXh0KVxyXG5cdFx0ICAgIC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLl9yZWZvY3VzT25NYXAsIGNvbnRleHQpO1xyXG5cclxuXHRcdHJldHVybiBsaW5rO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdFx0Y2xhc3NOYW1lID0gJ2xlYWZsZXQtZGlzYWJsZWQnO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHJcblx0XHRpZiAobWFwLl96b29tID09PSBtYXAuZ2V0TWluWm9vbSgpKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG1hcC5fem9vbSA9PT0gbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdHpvb21Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTC5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuXHRcdHRoaXMuem9vbUNvbnRyb2wgPSBuZXcgTC5Db250cm9sLlpvb20oKTtcclxuXHRcdHRoaXMuYWRkQ29udHJvbCh0aGlzLnpvb21Db250cm9sKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5jb250cm9sLnpvb20gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Db250cm9sLlpvb20ob3B0aW9ucyk7XHJcbn07XHJcblxyXG5cblxuLypcclxuICogTC5Db250cm9sLkF0dHJpYnV0aW9uIGlzIHVzZWQgZm9yIGRpc3BsYXlpbmcgYXR0cmlidXRpb24gb24gdGhlIG1hcCAoYWRkZWQgYnkgZGVmYXVsdCkuXHJcbiAqL1xyXG5cclxuTC5Db250cm9sLkF0dHJpYnV0aW9uID0gTC5Db250cm9sLmV4dGVuZCh7XHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICdib3R0b21yaWdodCcsXHJcblx0XHRwcmVmaXg6ICc8YSBocmVmPVwiaHR0cDovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwc1wiPkxlYWZsZXQ8L2E+J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zID0ge307XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24nKTtcclxuXHRcdEwuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XHJcblx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0bWFwXHJcblx0XHQgICAgLm9uKCdsYXllcmFkZCcsIHRoaXMuX29uTGF5ZXJBZGQsIHRoaXMpXHJcblx0XHQgICAgLm9uKCdsYXllcnJlbW92ZScsIHRoaXMuX29uTGF5ZXJSZW1vdmUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcFxyXG5cdFx0ICAgIC5vZmYoJ2xheWVyYWRkJywgdGhpcy5fb25MYXllckFkZClcclxuXHRcdCAgICAub2ZmKCdsYXllcnJlbW92ZScsIHRoaXMuX29uTGF5ZXJSZW1vdmUpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRQcmVmaXg6IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5wcmVmaXggPSBwcmVmaXg7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSA9IDA7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fYXR0cmlidXRpb25zKSB7XHJcblx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcclxuXHRcdFx0XHRhdHRyaWJzLnB1c2goaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcHJlZml4QW5kQXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucHJlZml4KSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuXHRcdH1cclxuXHRcdGlmIChhdHRyaWJzLmxlbmd0aCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gcHJlZml4QW5kQXR0cmlicy5qb2luKCcgfCAnKTtcclxuXHR9LFxyXG5cclxuXHRfb25MYXllckFkZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChlLmxheWVyLmdldEF0dHJpYnV0aW9uKSB7XHJcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24oZS5sYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25MYXllclJlbW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChlLmxheWVyLmdldEF0dHJpYnV0aW9uKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRpb24oZS5sYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuTC5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRhdHRyaWJ1dGlvbkNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5MLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuXHRcdHRoaXMuYXR0cmlidXRpb25Db250cm9sID0gKG5ldyBMLkNvbnRyb2wuQXR0cmlidXRpb24oKSkuYWRkVG8odGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcbkwuY29udHJvbC5hdHRyaWJ1dGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wuQXR0cmlidXRpb24ob3B0aW9ucyk7XHJcbn07XHJcblxuXG4vKlxuICogTC5Db250cm9sLlNjYWxlIGlzIHVzZWQgZm9yIGRpc3BsYXlpbmcgbWV0cmljL2ltcGVyaWFsIHNjYWxlIG9uIHRoZSBtYXAuXG4gKi9cblxuTC5Db250cm9sLlNjYWxlID0gTC5Db250cm9sLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXHRcdG1heFdpZHRoOiAxMDAsXG5cdFx0bWV0cmljOiB0cnVlLFxuXHRcdGltcGVyaWFsOiB0cnVlLFxuXHRcdHVwZGF0ZVdoZW5JZGxlOiBmYWxzZVxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtc2NhbGUnLFxuXHRcdCAgICBjb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblxuXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHRcdG1hcC53aGVuUmVhZHkodGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuXHRcdHJldHVybiBjb250YWluZXI7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAub2ZmKHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0fSxcblxuXHRfYWRkU2NhbGVzOiBmdW5jdGlvbiAob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcblx0XHRpZiAob3B0aW9ucy5tZXRyaWMpIHtcblx0XHRcdHRoaXMuX21TY2FsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XG5cdFx0XHR0aGlzLl9pU2NhbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWxpbmUnLCBjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRCb3VuZHMoKSxcblx0XHQgICAgY2VudGVyTGF0ID0gYm91bmRzLmdldENlbnRlcigpLmxhdCxcblx0XHQgICAgaGFsZldvcmxkTWV0ZXJzID0gNjM3ODEzNyAqIE1hdGguUEkgKiBNYXRoLmNvcyhjZW50ZXJMYXQgKiBNYXRoLlBJIC8gMTgwKSxcblx0XHQgICAgZGlzdCA9IGhhbGZXb3JsZE1ldGVycyAqIChib3VuZHMuZ2V0Tm9ydGhFYXN0KCkubG5nIC0gYm91bmRzLmdldFNvdXRoV2VzdCgpLmxuZykgLyAxODAsXG5cblx0XHQgICAgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0ICAgIG1heE1ldGVycyA9IDA7XG5cblx0XHRpZiAoc2l6ZS54ID4gMCkge1xuXHRcdFx0bWF4TWV0ZXJzID0gZGlzdCAqIChvcHRpb25zLm1heFdpZHRoIC8gc2l6ZS54KTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZXMob3B0aW9ucywgbWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlU2NhbGVzOiBmdW5jdGlvbiAob3B0aW9ucywgbWF4TWV0ZXJzKSB7XG5cdFx0aWYgKG9wdGlvbnMubWV0cmljICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuaW1wZXJpYWwgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVJbXBlcmlhbChtYXhNZXRlcnMpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlTWV0cmljOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyk7XG5cblx0XHR0aGlzLl9tU2NhbGUuc3R5bGUud2lkdGggPSB0aGlzLl9nZXRTY2FsZVdpZHRoKG1ldGVycyAvIG1heE1ldGVycykgKyAncHgnO1xuXHRcdHRoaXMuX21TY2FsZS5pbm5lckhUTUwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXHR9LFxuXG5cdF91cGRhdGVJbXBlcmlhbDogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtYXhGZWV0ID0gbWF4TWV0ZXJzICogMy4yODA4Mzk5LFxuXHRcdCAgICBzY2FsZSA9IHRoaXMuX2lTY2FsZSxcblx0XHQgICAgbWF4TWlsZXMsIG1pbGVzLCBmZWV0O1xuXG5cdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG5cdFx0XHRtYXhNaWxlcyA9IG1heEZlZXQgLyA1MjgwO1xuXHRcdFx0bWlsZXMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNaWxlcyk7XG5cblx0XHRcdHNjYWxlLnN0eWxlLndpZHRoID0gdGhpcy5fZ2V0U2NhbGVXaWR0aChtaWxlcyAvIG1heE1pbGVzKSArICdweCc7XG5cdFx0XHRzY2FsZS5pbm5lckhUTUwgPSBtaWxlcyArICcgbWknO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZlZXQgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhGZWV0KTtcblxuXHRcdFx0c2NhbGUuc3R5bGUud2lkdGggPSB0aGlzLl9nZXRTY2FsZVdpZHRoKGZlZXQgLyBtYXhGZWV0KSArICdweCc7XG5cdFx0XHRzY2FsZS5pbm5lckhUTUwgPSBmZWV0ICsgJyBmdCc7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRTY2FsZVdpZHRoOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgLSAxMDtcblx0fSxcblxuXHRfZ2V0Um91bmROdW06IGZ1bmN0aW9uIChudW0pIHtcblx0XHR2YXIgcG93MTAgPSBNYXRoLnBvdygxMCwgKE1hdGguZmxvb3IobnVtKSArICcnKS5sZW5ndGggLSAxKSxcblx0XHQgICAgZCA9IG51bSAvIHBvdzEwO1xuXG5cdFx0ZCA9IGQgPj0gMTAgPyAxMCA6IGQgPj0gNSA/IDUgOiBkID49IDMgPyAzIDogZCA+PSAyID8gMiA6IDE7XG5cblx0XHRyZXR1cm4gcG93MTAgKiBkO1xuXHR9XG59KTtcblxuTC5jb250cm9sLnNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wuU2NhbGUob3B0aW9ucyk7XG59O1xuXG5cbi8qXHJcbiAqIEwuQ29udHJvbC5MYXllcnMgaXMgYSBjb250cm9sIHRvIGFsbG93IHVzZXJzIHRvIHN3aXRjaCBiZXR3ZWVuIGRpZmZlcmVudCBsYXllcnMgb24gdGhlIG1hcC5cclxuICovXHJcblxyXG5MLkNvbnRyb2wuTGF5ZXJzID0gTC5Db250cm9sLmV4dGVuZCh7XHJcblx0b3B0aW9uczoge1xyXG5cdFx0Y29sbGFwc2VkOiB0cnVlLFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCcsXHJcblx0XHRhdXRvWkluZGV4OiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl9sYXN0WkluZGV4ID0gMDtcclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIoYmFzZUxheWVyc1tpXSwgaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKG92ZXJsYXlzW2ldLCBpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0bWFwXHJcblx0XHQgICAgLm9uKCdsYXllcmFkZCcsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpXHJcblx0XHQgICAgLm9uKCdsYXllcnJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcFxyXG5cdFx0ICAgIC5vZmYoJ2xheWVyYWRkJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcylcclxuXHRcdCAgICAub2ZmKCdsYXllcnJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGFkZE92ZXJsYXk6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUsIHRydWUpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpO1xyXG5cclxuXHRcdC8vTWFrZXMgdGhpcyB3b3JrIG9uIElFMTAgVG91Y2ggZGV2aWNlcyBieSBzdG9wcGluZyBpdCBmcm9tIGZpcmluZyBhIG1vdXNlb3V0IGV2ZW50IHdoZW4gdGhlIHRvdWNoIGlzIHJlbGVhc2VkXHJcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKCFMLkJyb3dzZXIudG91Y2gpIHtcclxuXHRcdFx0TC5Eb21FdmVudFxyXG5cdFx0XHRcdC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpXHJcblx0XHRcdFx0LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vbihjb250YWluZXIsICdjbGljaycsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZm9ybSA9IHRoaXMuX2Zvcm0gPSBMLkRvbVV0aWwuY3JlYXRlKCdmb3JtJywgY2xhc3NOYW1lICsgJy1saXN0Jyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcclxuXHRcdFx0aWYgKCFMLkJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0XHQgICAgLm9uKGNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIHRoaXMuX2V4cGFuZCwgdGhpcylcclxuXHRcdFx0XHQgICAgLm9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5fY29sbGFwc2UsIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcblx0XHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG5cclxuXHRcdFx0aWYgKEwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQuc3RvcClcclxuXHRcdFx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIHRoaXMuX2V4cGFuZCwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0TC5Eb21FdmVudC5vbihsaW5rLCAnZm9jdXMnLCB0aGlzLl9leHBhbmQsIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vV29yayBhcm91bmQgZm9yIEZpcmVmb3ggYW5kcm9pZCBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDMzXHJcblx0XHRcdEwuRG9tRXZlbnQub24oZm9ybSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyksIDApO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLl9jb2xsYXBzZSwgdGhpcyk7XHJcblx0XHRcdC8vIFRPRE8ga2V5Ym9hcmQgYWNjZXNzaWJpbGl0eVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fZXhwYW5kKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYmFzZUxheWVyc0xpc3QgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBmb3JtKTtcclxuXHRcdHRoaXMuX3NlcGFyYXRvciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgZm9ybSk7XHJcblx0XHR0aGlzLl9vdmVybGF5c0xpc3QgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLW92ZXJsYXlzJywgZm9ybSk7XHJcblxyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZvcm0pO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lLCBvdmVybGF5KSB7XHJcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnNbaWRdID0ge1xyXG5cdFx0XHRsYXllcjogbGF5ZXIsXHJcblx0XHRcdG5hbWU6IG5hbWUsXHJcblx0XHRcdG92ZXJsYXk6IG92ZXJsYXlcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcblx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYmFzZUxheWVyc0xpc3QuaW5uZXJIVE1MID0gJyc7XHJcblx0XHR0aGlzLl9vdmVybGF5c0xpc3QuaW5uZXJIVE1MID0gJyc7XHJcblxyXG5cdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50ID0gZmFsc2UsXHJcblx0XHQgICAgb3ZlcmxheXNQcmVzZW50ID0gZmFsc2UsXHJcblx0XHQgICAgaSwgb2JqO1xyXG5cclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcblx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHR9LFxyXG5cclxuXHRfb25MYXllckNoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBvYmogPSB0aGlzLl9sYXllcnNbTC5zdGFtcChlLmxheWVyKV07XHJcblxyXG5cdFx0aWYgKCFvYmopIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0eXBlID0gb2JqLm92ZXJsYXkgP1xyXG5cdFx0XHQoZS50eXBlID09PSAnbGF5ZXJhZGQnID8gJ292ZXJsYXlhZGQnIDogJ292ZXJsYXlyZW1vdmUnKSA6XHJcblx0XHRcdChlLnR5cGUgPT09ICdsYXllcmFkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuXHRcdGlmICh0eXBlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwOi8vYml0Lmx5L1BxWUxCZSlcclxuXHRfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbiAobmFtZSwgY2hlY2tlZCkge1xyXG5cclxuXHRcdHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICsgbmFtZSArICdcIic7XHJcblx0XHRpZiAoY2hlY2tlZCkge1xyXG5cdFx0XHRyYWRpb0h0bWwgKz0gJyBjaGVja2VkPVwiY2hlY2tlZFwiJztcclxuXHRcdH1cclxuXHRcdHJhZGlvSHRtbCArPSAnLz4nO1xyXG5cclxuXHRcdHZhciByYWRpb0ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRyYWRpb0ZyYWdtZW50LmlubmVySFRNTCA9IHJhZGlvSHRtbDtcclxuXHJcblx0XHRyZXR1cm4gcmFkaW9GcmFnbWVudC5maXJzdENoaWxkO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRJdGVtOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpLFxyXG5cdFx0ICAgIGlucHV0LFxyXG5cdFx0ICAgIGNoZWNrZWQgPSB0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKTtcclxuXHJcblx0XHRpZiAob2JqLm92ZXJsYXkpIHtcclxuXHRcdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG5cdFx0XHRpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcclxuXHRcdFx0aW5wdXQuY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3InO1xyXG5cdFx0XHRpbnB1dC5kZWZhdWx0Q2hlY2tlZCA9IGNoZWNrZWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpbnB1dCA9IHRoaXMuX2NyZWF0ZVJhZGlvRWxlbWVudCgnbGVhZmxldC1iYXNlLWxheWVycycsIGNoZWNrZWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlucHV0LmxheWVySWQgPSBMLnN0YW1wKG9iai5sYXllcik7XHJcblxyXG5cdFx0TC5Eb21FdmVudC5vbihpbnB1dCwgJ2NsaWNrJywgdGhpcy5fb25JbnB1dENsaWNrLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHRcdG5hbWUuaW5uZXJIVE1MID0gJyAnICsgb2JqLm5hbWU7XHJcblxyXG5cdFx0bGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cdFx0bGFiZWwuYXBwZW5kQ2hpbGQobmFtZSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IG9iai5vdmVybGF5ID8gdGhpcy5fb3ZlcmxheXNMaXN0IDogdGhpcy5fYmFzZUxheWVyc0xpc3Q7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xyXG5cclxuXHRcdHJldHVybiBsYWJlbDtcclxuXHR9LFxyXG5cclxuXHRfb25JbnB1dENsaWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSwgaW5wdXQsIG9iaixcclxuXHRcdCAgICBpbnB1dHMgPSB0aGlzLl9mb3JtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpLFxyXG5cdFx0ICAgIGlucHV0c0xlbiA9IGlucHV0cy5sZW5ndGg7XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlucHV0c0xlbjsgaSsrKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRvYmogPSB0aGlzLl9sYXllcnNbaW5wdXQubGF5ZXJJZF07XHJcblxyXG5cdFx0XHRpZiAoaW5wdXQuY2hlY2tlZCAmJiAhdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllcikpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIob2JqLmxheWVyKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQgJiYgdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllcikpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIob2JqLmxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9yZWZvY3VzT25NYXAoKTtcclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMuX2NvbnRhaW5lci5jbGFzc05hbWUucmVwbGFjZSgnIGxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnLCAnJyk7XHJcblx0fVxyXG59KTtcclxuXHJcbkwuY29udHJvbC5sYXllcnMgPSBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5MYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcbiAqIEwuUG9zQW5pbWF0aW9uIGlzIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IGZvciBwYW4gYW5pbWF0aW9ucy5cbiAqL1xuXG5MLlBvc0FuaW1hdGlvbiA9IEwuQ2xhc3MuZXh0ZW5kKHtcblx0aW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxuXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7IC8vIChIVE1MRWxlbWVudCwgUG9pbnRbLCBOdW1iZXIsIE51bWJlcl0pXG5cdFx0dGhpcy5zdG9wKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsO1xuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuX25ld1BvcyA9IG5ld1BvcztcblxuXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuXHRcdGVsLnN0eWxlW0wuRG9tVXRpbC5UUkFOU0lUSU9OXSA9ICdhbGwgJyArIChkdXJhdGlvbiB8fCAwLjI1KSArXG5cdFx0ICAgICAgICAncyBjdWJpYy1iZXppZXIoMCwwLCcgKyAoZWFzZUxpbmVhcml0eSB8fCAwLjUpICsgJywxKSc7XG5cblx0XHRMLkRvbUV2ZW50Lm9uKGVsLCBMLkRvbVV0aWwuVFJBTlNJVElPTl9FTkQsIHRoaXMuX29uVHJhbnNpdGlvbkVuZCwgdGhpcyk7XG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGVsLCBuZXdQb3MpO1xuXG5cdFx0Ly8gdG9nZ2xlIHJlZmxvdywgQ2hyb21lIGZsaWNrZXJzIGZvciBzb21lIHJlYXNvbiBpZiB5b3UgZG9uJ3QgZG8gdGhpc1xuXHRcdEwuVXRpbC5mYWxzZUZuKGVsLm9mZnNldFdpZHRoKTtcblxuXHRcdC8vIHRoZXJlJ3Mgbm8gbmF0aXZlIHdheSB0byB0cmFjayB2YWx1ZSB1cGRhdGVzIG9mIHRyYW5zaXRpb25lZCBwcm9wZXJ0aWVzLCBzbyB3ZSBpbWl0YXRlIHRoaXNcblx0XHR0aGlzLl9zdGVwVGltZXIgPSBzZXRJbnRlcnZhbChMLmJpbmQodGhpcy5fb25TdGVwLCB0aGlzKSwgNTApO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHQvLyBpZiB3ZSBqdXN0IHJlbW92ZWQgdGhlIHRyYW5zaXRpb24gcHJvcGVydHksIHRoZSBlbGVtZW50IHdvdWxkIGp1bXAgdG8gaXRzIGZpbmFsIHBvc2l0aW9uLFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gbWFrZSBpdCBzdGF5IGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uXG5cblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHRoaXMuX2dldFBvcygpKTtcblx0XHR0aGlzLl9vblRyYW5zaXRpb25FbmQoKTtcblx0XHRMLlV0aWwuZmFsc2VGbih0aGlzLl9lbC5vZmZzZXRXaWR0aCk7IC8vIGZvcmNlIHJlZmxvdyBpbiBjYXNlIHdlIGFyZSBhYm91dCB0byBzdGFydCBhIG5ldyBhbmltYXRpb25cblx0fSxcblxuXHRfb25TdGVwOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHN0ZXBQb3MgPSB0aGlzLl9nZXRQb3MoKTtcblx0XHRpZiAoIXN0ZXBQb3MpIHtcblx0XHRcdHRoaXMuX29uVHJhbnNpdGlvbkVuZCgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyBqc2hpbnQgY2FtZWxjYXNlOiBmYWxzZVxuXHRcdC8vIG1ha2UgTC5Eb21VdGlsLmdldFBvc2l0aW9uIHJldHVybiBpbnRlcm1lZGlhdGUgcG9zaXRpb24gdmFsdWUgZHVyaW5nIGFuaW1hdGlvblxuXHRcdHRoaXMuX2VsLl9sZWFmbGV0X3BvcyA9IHN0ZXBQb3M7XG5cblx0XHR0aGlzLmZpcmUoJ3N0ZXAnKTtcblx0fSxcblxuXHQvLyB5b3UgY2FuJ3QgZWFzaWx5IGdldCBpbnRlcm1lZGlhdGUgdmFsdWVzIG9mIHByb3BlcnRpZXMgYW5pbWF0ZWQgd2l0aCBDU1MzIFRyYW5zaXRpb25zLFxuXHQvLyB3ZSBuZWVkIHRvIHBhcnNlIGNvbXB1dGVkIHN0eWxlIChpbiBjYXNlIG9mIHRyYW5zZm9ybSBpdCByZXR1cm5zIG1hdHJpeCBzdHJpbmcpXG5cblx0X3RyYW5zZm9ybVJlOiAvKFstK10/KD86XFxkKlxcLik/XFxkKylcXEQqLCAoWy0rXT8oPzpcXGQqXFwuKT9cXGQrKVxcRCpcXCkvLFxuXG5cdF9nZXRQb3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbGVmdCwgdG9wLCBtYXRjaGVzLFxuXHRcdCAgICBlbCA9IHRoaXMuX2VsLFxuXHRcdCAgICBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcblxuXHRcdGlmIChMLkJyb3dzZXIuYW55M2QpIHtcblx0XHRcdG1hdGNoZXMgPSBzdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXS5tYXRjaCh0aGlzLl90cmFuc2Zvcm1SZSk7XG5cdFx0XHRpZiAoIW1hdGNoZXMpIHsgcmV0dXJuOyB9XG5cdFx0XHRsZWZ0ID0gcGFyc2VGbG9hdChtYXRjaGVzWzFdKTtcblx0XHRcdHRvcCAgPSBwYXJzZUZsb2F0KG1hdGNoZXNbMl0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZWZ0ID0gcGFyc2VGbG9hdChzdHlsZS5sZWZ0KTtcblx0XHRcdHRvcCAgPSBwYXJzZUZsb2F0KHN0eWxlLnRvcCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KGxlZnQsIHRvcCwgdHJ1ZSk7XG5cdH0sXG5cblx0X29uVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2VsLCBMLkRvbVV0aWwuVFJBTlNJVElPTl9FTkQsIHRoaXMuX29uVHJhbnNpdGlvbkVuZCwgdGhpcyk7XG5cblx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fZWwuc3R5bGVbTC5Eb21VdGlsLlRSQU5TSVRJT05dID0gJyc7XG5cblx0XHQvLyBqc2hpbnQgY2FtZWxjYXNlOiBmYWxzZVxuXHRcdC8vIG1ha2Ugc3VyZSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24gcmV0dXJucyB0aGUgZmluYWwgcG9zaXRpb24gdmFsdWUgYWZ0ZXIgYW5pbWF0aW9uXG5cdFx0dGhpcy5fZWwuX2xlYWZsZXRfcG9zID0gdGhpcy5fbmV3UG9zO1xuXG5cdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLl9zdGVwVGltZXIpO1xuXG5cdFx0dGhpcy5maXJlKCdzdGVwJykuZmlyZSgnZW5kJyk7XG5cdH1cblxufSk7XG5cblxuLypcbiAqIEV4dGVuZHMgTC5NYXAgdG8gaGFuZGxlIHBhbm5pbmcgYW5pbWF0aW9ucy5cbiAqL1xuXG5MLk1hcC5pbmNsdWRlKHtcblxuXHRzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XG5cblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcblx0XHRjZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihMLmxhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdGlmICh0aGlzLl9wYW5BbmltKSB7XG5cdFx0XHR0aGlzLl9wYW5BbmltLnN0b3AoKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcblxuXHRcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG9wdGlvbnMuem9vbSA9IEwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGV9LCBvcHRpb25zLnpvb20pO1xuXHRcdFx0XHRvcHRpb25zLnBhbiA9IEwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGV9LCBvcHRpb25zLnBhbik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cblx0XHRcdHZhciBhbmltYXRlZCA9ICh0aGlzLl96b29tICE9PSB6b29tKSA/XG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkWm9vbSAmJiB0aGlzLl90cnlBbmltYXRlZFpvb20oY2VudGVyLCB6b29tLCBvcHRpb25zLnpvb20pIDpcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XG5cblx0XHRcdGlmIChhbmltYXRlZCkge1xuXHRcdFx0XHQvLyBwcmV2ZW50IHJlc2l6ZSBoYW5kbGVyIGNhbGwsIHRoZSB2aWV3IHdpbGwgcmVmcmVzaCBhZnRlciBhbmltYXRpb24gYW55d2F5XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBhbmltYXRpb24gZGlkbid0IHN0YXJ0LCBqdXN0IHJlc2V0IHRoZSBtYXAgdmlld1xuXHRcdHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20pO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcblx0XHRvZmZzZXQgPSBMLnBvaW50KG9mZnNldCkucm91bmQoKTtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcblx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcblxuXHRcdFx0dGhpcy5fcGFuQW5pbS5vbih7XG5cdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcblx0XHRcdFx0J2VuZCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZFxuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gZG9uJ3QgZmlyZSBtb3Zlc3RhcnQgaWYgYW5pbWF0aW5nIGluZXJ0aWFcblx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0Ly8gYW5pbWF0ZSBwYW4gdW5sZXNzIGFuaW1hdGU6IGZhbHNlIHNwZWNpZmllZFxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcblxuXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpO1xuXHRcdFx0dGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSwgbmV3UG9zLCBvcHRpb25zLmR1cmF0aW9uIHx8IDAuMjUsIG9wdGlvbnMuZWFzZUxpbmVhcml0eSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKS5maXJlKCdtb3ZlZW5kJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcblx0fSxcblxuXHRfb25QYW5UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XG5cdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XG5cdH0sXG5cblx0X3RyeUFuaW1hdGVkUGFuOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7XG5cdFx0Ly8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBuZXcgYW5kIGN1cnJlbnQgY2VudGVycyBpbiBwaXhlbHNcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2Zsb29yKCk7XG5cblx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcblx0XHRpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRlKSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdHRoaXMucGFuQnkob2Zmc2V0LCBvcHRpb25zKTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxuXG4vKlxuICogTC5Qb3NBbmltYXRpb24gZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gdGhhdCBwb3dlcnMgTGVhZmxldCBwYW4gYW5pbWF0aW9uc1xuICogaW4gYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMuXG4gKi9cblxuTC5Qb3NBbmltYXRpb24gPSBMLkRvbVV0aWwuVFJBTlNJVElPTiA/IEwuUG9zQW5pbWF0aW9uIDogTC5Qb3NBbmltYXRpb24uZXh0ZW5kKHtcblxuXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkgeyAvLyAoSFRNTEVsZW1lbnQsIFBvaW50WywgTnVtYmVyLCBOdW1iZXJdKVxuXHRcdHRoaXMuc3RvcCgpO1xuXG5cdFx0dGhpcy5fZWwgPSBlbDtcblx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcblx0XHR0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDAuMjU7XG5cdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24oZWwpO1xuXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cblx0XHR0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cblx0XHR0aGlzLl9hbmltYXRlKCk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3N0ZXAoKTtcblx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLl9hbmltSWQgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcblx0XHR0aGlzLl9zdGVwKCk7XG5cdH0sXG5cblx0X3N0ZXA6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWxhcHNlZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG5cdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG5cdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfcnVuRnJhbWU6IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQodGhpcy5fb2Zmc2V0Lm11bHRpcGx5QnkocHJvZ3Jlc3MpKTtcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cblx0XHR0aGlzLmZpcmUoJ3N0ZXAnKTtcblx0fSxcblxuXHRfY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JZCk7XG5cblx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG5cdFx0dGhpcy5maXJlKCdlbmQnKTtcblx0fSxcblxuXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcblx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCB0aGlzLl9lYXNlT3V0UG93ZXIpO1xuXHR9XG59KTtcblxuXG4vKlxuICogRXh0ZW5kcyBMLk1hcCB0byBoYW5kbGUgem9vbSBhbmltYXRpb25zLlxuICovXG5cbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdHpvb21BbmltYXRpb246IHRydWUsXG5cdHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IDRcbn0pO1xuXG5pZiAoTC5Eb21VdGlsLlRSQU5TSVRJT04pIHtcblxuXHRMLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb24gJiYgTC5Eb21VdGlsLlRSQU5TSVRJT04gJiZcblx0XHRcdFx0TC5Ccm93c2VyLmFueTNkICYmICFMLkJyb3dzZXIuYW5kcm9pZDIzICYmICFMLkJyb3dzZXIubW9iaWxlT3BlcmE7XG5cblx0XHQvLyB6b29tIHRyYW5zaXRpb25zIHJ1biB3aXRoIHRoZSBzYW1lIGR1cmF0aW9uIGZvciBhbGwgbGF5ZXJzLCBzbyBpZiBvbmUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHNcblx0XHQvLyBoYXBwZW5zIGFmdGVyIHN0YXJ0aW5nIHpvb20gYW5pbWF0aW9uIChwcm9wYWdhdGluZyB0byB0aGUgbWFwIHBhbmUpLCB3ZSBrbm93IHRoYXQgaXQgZW5kZWQgZ2xvYmFsbHlcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcFBhbmUsIEwuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLCB0aGlzKTtcblx0XHR9XG5cdH0pO1xufVxuXG5MLk1hcC5pbmNsdWRlKCFMLkRvbVV0aWwuVFJBTlNJVElPTiA/IHt9IDoge1xuXG5cdF9jYXRjaFRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20gJiYgZS5wcm9wZXJ0eU5hbWUuaW5kZXhPZigndHJhbnNmb3JtJykgPj0gMCkge1xuXHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xuXHRcdH1cblx0fSxcblxuXHRfbm90aGluZ1RvQW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpLmxlbmd0aDtcblx0fSxcblxuXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XG5cblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2Vcblx0XHRpZiAoIXRoaXMuX3pvb21BbmltYXRlZCB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8IHRoaXMuX25vdGhpbmdUb0FuaW1hdGUoKSB8fFxuXHRcdCAgICAgICAgTWF0aC5hYnMoem9vbSAtIHRoaXMuX3pvb20pID4gdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb25UaHJlc2hvbGQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBvZmZzZXQgaXMgdGhlIHBpeGVsIGNvb3JkcyBvZiB0aGUgem9vbSBvcmlnaW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgY2VudGVyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9kaXZpZGVCeSgxIC0gMSAvIHNjYWxlKSxcblx0XHRcdG9yaWdpbiA9IHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKS5fYWRkKG9mZnNldCk7XG5cblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHR0aGlzXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnem9vbXN0YXJ0Jyk7XG5cblx0XHR0aGlzLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIG9yaWdpbiwgc2NhbGUsIG51bGwsIHRydWUpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcmlnaW4sIHNjYWxlLCBkZWx0YSwgYmFja3dhcmRzLCBmb3JUb3VjaFpvb20pIHtcblxuXHRcdGlmICghZm9yVG91Y2hab29tKSB7XG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBwdXQgdHJhbnNmb3JtIHRyYW5zaXRpb24gb24gYWxsIGxheWVycyB3aXRoIGxlYWZsZXQtem9vbS1hbmltYXRlZCBjbGFzc1xuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcblxuXHRcdC8vIHJlbWVtYmVyIHdoYXQgY2VudGVyL3pvb20gdG8gc2V0IGFmdGVyIGFuaW1hdGlvblxuXHRcdHRoaXMuX2FuaW1hdGVUb0NlbnRlciA9IGNlbnRlcjtcblx0XHR0aGlzLl9hbmltYXRlVG9ab29tID0gem9vbTtcblxuXHRcdC8vIGRpc2FibGUgYW55IGRyYWdnaW5nIGR1cmluZyBhbmltYXRpb25cblx0XHRpZiAoTC5EcmFnZ2FibGUpIHtcblx0XHRcdEwuRHJhZ2dhYmxlLl9kaXNhYmxlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5maXJlKCd6b29tYW5pbScsIHtcblx0XHRcdFx0Y2VudGVyOiBjZW50ZXIsXG5cdFx0XHRcdHpvb206IHpvb20sXG5cdFx0XHRcdG9yaWdpbjogb3JpZ2luLFxuXHRcdFx0XHRzY2FsZTogc2NhbGUsXG5cdFx0XHRcdGRlbHRhOiBkZWx0YSxcblx0XHRcdFx0YmFja3dhcmRzOiBiYWNrd2FyZHNcblx0XHRcdH0pO1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vblpvb21UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gZmFsc2U7XG5cblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XG5cblx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tLCB0cnVlLCB0cnVlKTtcblxuXHRcdGlmIChMLkRyYWdnYWJsZSkge1xuXHRcdFx0TC5EcmFnZ2FibGUuX2Rpc2FibGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9XG59KTtcblxuXG4vKlxuXHRab29tIGFuaW1hdGlvbiBsb2dpYyBmb3IgTC5UaWxlTGF5ZXIuXG4qL1xuXG5MLlRpbGVMYXllci5pbmNsdWRlKHtcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fYW5pbWF0aW5nKSB7XG5cdFx0XHR0aGlzLl9hbmltYXRpbmcgPSB0cnVlO1xuXHRcdFx0dGhpcy5fcHJlcGFyZUJnQnVmZmVyKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGJnID0gdGhpcy5fYmdCdWZmZXIsXG5cdFx0ICAgIHRyYW5zZm9ybSA9IEwuRG9tVXRpbC5UUkFOU0ZPUk0sXG5cdFx0ICAgIGluaXRpYWxUcmFuc2Zvcm0gPSBlLmRlbHRhID8gTC5Eb21VdGlsLmdldFRyYW5zbGF0ZVN0cmluZyhlLmRlbHRhKSA6IGJnLnN0eWxlW3RyYW5zZm9ybV0sXG5cdFx0ICAgIHNjYWxlU3RyID0gTC5Eb21VdGlsLmdldFNjYWxlU3RyaW5nKGUuc2NhbGUsIGUub3JpZ2luKTtcblxuXHRcdGJnLnN0eWxlW3RyYW5zZm9ybV0gPSBlLmJhY2t3YXJkcyA/XG5cdFx0XHRcdHNjYWxlU3RyICsgJyAnICsgaW5pdGlhbFRyYW5zZm9ybSA6XG5cdFx0XHRcdGluaXRpYWxUcmFuc2Zvcm0gKyAnICcgKyBzY2FsZVN0cjtcblx0fSxcblxuXHRfZW5kWm9vbUFuaW06IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZnJvbnQgPSB0aGlzLl90aWxlQ29udGFpbmVyLFxuXHRcdCAgICBiZyA9IHRoaXMuX2JnQnVmZmVyO1xuXG5cdFx0ZnJvbnQuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuXHRcdGZyb250LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZnJvbnQpOyAvLyBCcmluZyB0byBmb3JlXG5cblx0XHQvLyBmb3JjZSByZWZsb3dcblx0XHRMLlV0aWwuZmFsc2VGbihiZy5vZmZzZXRXaWR0aCk7XG5cblx0XHR0aGlzLl9hbmltYXRpbmcgPSBmYWxzZTtcblx0fSxcblxuXHRfY2xlYXJCZ0J1ZmZlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAobWFwICYmICFtYXAuX2FuaW1hdGluZ1pvb20gJiYgIW1hcC50b3VjaFpvb20uX3pvb21pbmcpIHtcblx0XHRcdHRoaXMuX2JnQnVmZmVyLmlubmVySFRNTCA9ICcnO1xuXHRcdFx0dGhpcy5fYmdCdWZmZXIuc3R5bGVbTC5Eb21VdGlsLlRSQU5TRk9STV0gPSAnJztcblx0XHR9XG5cdH0sXG5cblx0X3ByZXBhcmVCZ0J1ZmZlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGZyb250ID0gdGhpcy5fdGlsZUNvbnRhaW5lcixcblx0XHQgICAgYmcgPSB0aGlzLl9iZ0J1ZmZlcjtcblxuXHRcdC8vIGlmIGZvcmVncm91bmQgbGF5ZXIgZG9lc24ndCBoYXZlIG1hbnkgdGlsZXMgYnV0IGJnIGxheWVyIGRvZXMsXG5cdFx0Ly8ga2VlcCB0aGUgZXhpc3RpbmcgYmcgbGF5ZXIgYW5kIGp1c3Qgem9vbSBpdCBzb21lIG1vcmVcblxuXHRcdHZhciBiZ0xvYWRlZCA9IHRoaXMuX2dldExvYWRlZFRpbGVzUGVyY2VudGFnZShiZyksXG5cdFx0ICAgIGZyb250TG9hZGVkID0gdGhpcy5fZ2V0TG9hZGVkVGlsZXNQZXJjZW50YWdlKGZyb250KTtcblxuXHRcdGlmIChiZyAmJiBiZ0xvYWRlZCA+IDAuNSAmJiBmcm9udExvYWRlZCA8IDAuNSkge1xuXG5cdFx0XHRmcm9udC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdFx0XHR0aGlzLl9zdG9wTG9hZGluZ0ltYWdlcyhmcm9udCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gcHJlcGFyZSB0aGUgYnVmZmVyIHRvIGJlY29tZSB0aGUgZnJvbnQgdGlsZSBwYW5lXG5cdFx0Ymcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHRcdGJnLnN0eWxlW0wuRG9tVXRpbC5UUkFOU0ZPUk1dID0gJyc7XG5cblx0XHQvLyBzd2l0Y2ggb3V0IHRoZSBjdXJyZW50IGxheWVyIHRvIGJlIHRoZSBuZXcgYmcgbGF5ZXIgKGFuZCB2aWNlLXZlcnNhKVxuXHRcdHRoaXMuX3RpbGVDb250YWluZXIgPSBiZztcblx0XHRiZyA9IHRoaXMuX2JnQnVmZmVyID0gZnJvbnQ7XG5cblx0XHR0aGlzLl9zdG9wTG9hZGluZ0ltYWdlcyhiZyk7XG5cblx0XHQvL3ByZXZlbnQgYmcgYnVmZmVyIGZyb20gY2xlYXJpbmcgcmlnaHQgYWZ0ZXIgem9vbVxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9jbGVhckJnQnVmZmVyVGltZXIpO1xuXHR9LFxuXG5cdF9nZXRMb2FkZWRUaWxlc1BlcmNlbnRhZ2U6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcblx0XHR2YXIgdGlsZXMgPSBjb250YWluZXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpLFxuXHRcdCAgICBpLCBsZW4sIGNvdW50ID0gMDtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRpbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAodGlsZXNbaV0uY29tcGxldGUpIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNvdW50IC8gbGVuO1xuXHR9LFxuXG5cdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXG5cdF9zdG9wTG9hZGluZ0ltYWdlczogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdHZhciB0aWxlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW1nJykpLFxuXHRcdCAgICBpLCBsZW4sIHRpbGU7XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGlsZSA9IHRpbGVzW2ldO1xuXG5cdFx0XHRpZiAoIXRpbGUuY29tcGxldGUpIHtcblx0XHRcdFx0dGlsZS5vbmxvYWQgPSBMLlV0aWwuZmFsc2VGbjtcblx0XHRcdFx0dGlsZS5vbmVycm9yID0gTC5VdGlsLmZhbHNlRm47XG5cdFx0XHRcdHRpbGUuc3JjID0gTC5VdGlsLmVtcHR5SW1hZ2VVcmw7XG5cblx0XHRcdFx0dGlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRpbGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cblxuLypcclxuICogUHJvdmlkZXMgTC5NYXAgd2l0aCBjb252ZW5pZW50IHNob3J0Y3V0cyBmb3IgdXNpbmcgYnJvd3NlciBnZW9sb2NhdGlvbiBmZWF0dXJlcy5cclxuICovXHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHRfZGVmYXVsdExvY2F0ZU9wdGlvbnM6IHtcclxuXHRcdHdhdGNoOiBmYWxzZSxcclxuXHRcdHNldFZpZXc6IGZhbHNlLFxyXG5cdFx0bWF4Wm9vbTogSW5maW5pdHksXHJcblx0XHR0aW1lb3V0OiAxMDAwMCxcclxuXHRcdG1heGltdW1BZ2U6IDAsXHJcblx0XHRlbmFibGVIaWdoQWNjdXJhY3k6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0bG9jYXRlOiBmdW5jdGlvbiAoLypPYmplY3QqLyBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnMgPSBMLmV4dGVuZCh0aGlzLl9kZWZhdWx0TG9jYXRlT3B0aW9ucywgb3B0aW9ucyk7XHJcblxyXG5cdFx0aWYgKCFuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvcih7XHJcblx0XHRcdFx0Y29kZTogMCxcclxuXHRcdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gbm90IHN1cHBvcnRlZC4nXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb25SZXNwb25zZSA9IEwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlLCB0aGlzKSxcclxuXHRcdFx0b25FcnJvciA9IEwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG5cdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHN0b3BMb2NhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fbG9jYXRpb25XYXRjaElkKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdFx0dmFyIGMgPSBlcnJvci5jb2RlLFxyXG5cdFx0ICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMSA/ICdwZXJtaXNzaW9uIGRlbmllZCcgOlxyXG5cdFx0ICAgICAgICAgICAgKGMgPT09IDIgPyAncG9zaXRpb24gdW5hdmFpbGFibGUnIDogJ3RpbWVvdXQnKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyAmJiAhdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuZml0V29ybGQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZXJyb3InLCB7XHJcblx0XHRcdGNvZGU6IGMsXHJcblx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBlcnJvcjogJyArIG1lc3NhZ2UgKyAnLidcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHR2YXIgbGF0ID0gcG9zLmNvb3Jkcy5sYXRpdHVkZSxcclxuXHRcdCAgICBsbmcgPSBwb3MuY29vcmRzLmxvbmdpdHVkZSxcclxuXHRcdCAgICBsYXRsbmcgPSBuZXcgTC5MYXRMbmcobGF0LCBsbmcpLFxyXG5cclxuXHRcdCAgICBsYXRBY2N1cmFjeSA9IDE4MCAqIHBvcy5jb29yZHMuYWNjdXJhY3kgLyA0MDA3NTAxNyxcclxuXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoTC5MYXRMbmcuREVHX1RPX1JBRCAqIGxhdCksXHJcblxyXG5cdFx0ICAgIGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKFxyXG5cdFx0ICAgICAgICAgICAgW2xhdCAtIGxhdEFjY3VyYWN5LCBsbmcgLSBsbmdBY2N1cmFjeV0sXHJcblx0XHQgICAgICAgICAgICBbbGF0ICsgbGF0QWNjdXJhY3ksIGxuZyArIGxuZ0FjY3VyYWN5XSksXHJcblxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnNldFZpZXcpIHtcclxuXHRcdFx0dmFyIHpvb20gPSBNYXRoLm1pbih0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzKSwgb3B0aW9ucy5tYXhab29tKTtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KGxhdGxuZywgem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuXHRcdFx0dGltZXN0YW1wOiBwb3MudGltZXN0YW1wXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG5cdFx0XHRpZiAodHlwZW9mIHBvcy5jb29yZHNbaV0gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0ZGF0YVtpXSA9IHBvcy5jb29yZHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZm91bmQnLCBkYXRhKTtcclxuXHR9XHJcbn0pO1xyXG5cblxufSh3aW5kb3csIGRvY3VtZW50KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmpzXG4gKiogbW9kdWxlIGlkID0gMTA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");
},,function(module,exports,__webpack_require__){eval("'use strict';\n\nvar getRootInstancesFromReactMount = __webpack_require__(108);\n\nvar injectedProvider = null,\n    didWarn = false;\n\nfunction warnOnce() {\n  if (!didWarn) {\n    console.warn(\n      'It appears that React Hot Loader isn\\'t configured correctly. ' +\n      'If you\\'re using NPM, make sure your dependencies don\\'t drag duplicate React distributions into their node_modules and that require(\"react\") corresponds to the React instance you render your app with.',\n      'If you\\'re using a precompiled version of React, see https://github.com/gaearon/react-hot-loader/tree/master/docs#usage-with-external-react for integration instructions.'\n    );\n  }\n\n  didWarn = true;\n}\n\nvar RootInstanceProvider = {\n  injection: {\n    injectProvider: function (provider) {\n      injectedProvider = provider;\n    }\n  },\n\n  getRootInstances: function (ReactMount) {\n    if (injectedProvider) {\n      return injectedProvider.getRootInstances();\n    }\n\n    var instances = ReactMount && getRootInstancesFromReactMount(ReactMount) || [];\n    if (!Object.keys(instances).length) {\n      warnOnce();\n    }\n\n    return instances;\n  }\n};\n\nmodule.exports = RootInstanceProvider;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvUm9vdEluc3RhbmNlUHJvdmlkZXIuanM/YzViNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTA3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0Um9vdEluc3RhbmNlc0Zyb21SZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9nZXRSb290SW5zdGFuY2VzRnJvbVJlYWN0TW91bnQnKTtcblxudmFyIGluamVjdGVkUHJvdmlkZXIgPSBudWxsLFxuICAgIGRpZFdhcm4gPSBmYWxzZTtcblxuZnVuY3Rpb24gd2Fybk9uY2UoKSB7XG4gIGlmICghZGlkV2Fybikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdJdCBhcHBlYXJzIHRoYXQgUmVhY3QgSG90IExvYWRlciBpc25cXCd0IGNvbmZpZ3VyZWQgY29ycmVjdGx5LiAnICtcbiAgICAgICdJZiB5b3VcXCdyZSB1c2luZyBOUE0sIG1ha2Ugc3VyZSB5b3VyIGRlcGVuZGVuY2llcyBkb25cXCd0IGRyYWcgZHVwbGljYXRlIFJlYWN0IGRpc3RyaWJ1dGlvbnMgaW50byB0aGVpciBub2RlX21vZHVsZXMgYW5kIHRoYXQgcmVxdWlyZShcInJlYWN0XCIpIGNvcnJlc3BvbmRzIHRvIHRoZSBSZWFjdCBpbnN0YW5jZSB5b3UgcmVuZGVyIHlvdXIgYXBwIHdpdGguJyxcbiAgICAgICdJZiB5b3VcXCdyZSB1c2luZyBhIHByZWNvbXBpbGVkIHZlcnNpb24gb2YgUmVhY3QsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ2FlYXJvbi9yZWFjdC1ob3QtbG9hZGVyL3RyZWUvbWFzdGVyL2RvY3MjdXNhZ2Utd2l0aC1leHRlcm5hbC1yZWFjdCBmb3IgaW50ZWdyYXRpb24gaW5zdHJ1Y3Rpb25zLidcbiAgICApO1xuICB9XG5cbiAgZGlkV2FybiA9IHRydWU7XG59XG5cbnZhciBSb290SW5zdGFuY2VQcm92aWRlciA9IHtcbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0UHJvdmlkZXI6IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgaW5qZWN0ZWRQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIH1cbiAgfSxcblxuICBnZXRSb290SW5zdGFuY2VzOiBmdW5jdGlvbiAoUmVhY3RNb3VudCkge1xuICAgIGlmIChpbmplY3RlZFByb3ZpZGVyKSB7XG4gICAgICByZXR1cm4gaW5qZWN0ZWRQcm92aWRlci5nZXRSb290SW5zdGFuY2VzKCk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlcyA9IFJlYWN0TW91bnQgJiYgZ2V0Um9vdEluc3RhbmNlc0Zyb21SZWFjdE1vdW50KFJlYWN0TW91bnQpIHx8IFtdO1xuICAgIGlmICghT2JqZWN0LmtleXMoaW5zdGFuY2VzKS5sZW5ndGgpIHtcbiAgICAgIHdhcm5PbmNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb290SW5zdGFuY2VQcm92aWRlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1ob3QtbG9hZGVyL1Jvb3RJbnN0YW5jZVByb3ZpZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n\nfunction getRootInstancesFromReactMount(ReactMount) {\n  return ReactMount._instancesByReactRootID || ReactMount._instancesByContainerID || [];\n}\n\nmodule.exports = getRootInstancesFromReactMount;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvZ2V0Um9vdEluc3RhbmNlc0Zyb21SZWFjdE1vdW50LmpzPzA2NDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjEwOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0Um9vdEluc3RhbmNlc0Zyb21SZWFjdE1vdW50KFJlYWN0TW91bnQpIHtcbiAgcmV0dXJuIFJlYWN0TW91bnQuX2luc3RhbmNlc0J5UmVhY3RSb290SUQgfHwgUmVhY3RNb3VudC5faW5zdGFuY2VzQnlDb250YWluZXJJRCB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSb290SW5zdGFuY2VzRnJvbVJlYWN0TW91bnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtaG90LWxvYWRlci9nZXRSb290SW5zdGFuY2VzRnJvbVJlYWN0TW91bnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(module) {/* REACT HOT LOADER */ if (true) { (function () { var ReactHotAPI = __webpack_require__(114), RootInstanceProvider = __webpack_require__(107), ReactMount = __webpack_require__(9), React = __webpack_require__(40); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } (function () {\n\n"use strict";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };\n\nvar React = _interopRequire(__webpack_require__(40));\n\n__webpack_require__(196);\n\nvar L = _interopRequire(__webpack_require__(105));\n\nvar imgSrc = _interopRequire(__webpack_require__(199));\n\nvar femHist = _interopRequire(__webpack_require__(200));\n\nvar femHistChoice = _interopRequire(__webpack_require__(201));\n\nvar disHist = _interopRequire(__webpack_require__(197));\n\nvar disHistChoice = _interopRequire(__webpack_require__(198));\n\nvar femGayHist = _interopRequire(__webpack_require__(203));\n\nvar femGayHistChoice = _interopRequire(__webpack_require__(202));\n\nvar warHist = _interopRequire(__webpack_require__(210));\n\nvar warHistChoice = _interopRequire(__webpack_require__(211));\n\nvar domHist = _interopRequire(__webpack_require__(205));\n\nvar domHistChoice = _interopRequire(__webpack_require__(206));\n\nvar slaveHist = _interopRequire(__webpack_require__(207));\n\nvar slaveHistChoice = _interopRequire(__webpack_require__(208));\n\nvar lords = _interopRequire(__webpack_require__(204));\n\nvar tulp = _interopRequire(__webpack_require__(209));\n\nvar Map = React.createClass({\n    displayName: "Map",\n\n    createMap: function createMap(element) {\n        var map = L.map(element);\n        L.tileLayer("http://tile.osm.org/{z}/{x}/{y}.png", {\n            attribution: "&copy; <a href=\\"http://osm.org/copyright\\">OpenStreetMap</a> contributors" }).addTo(map);\n\n        var markers = [\n        //Alan Turing Pardon\n        [-0.124809, 51.49948, "On December 24th 2013 Alan Turing was pardoned for his conviction for gross indecency for which he was chemically castrated. His pardon comes a mere 59 years after his death, and only for him. Not for the other 49.000 men who have been convicted for homosexual relations.<br><a href=\\"https://www.change.org/p/british-government-pardon-all-of-the-estimated-49-000-men-who-like-alan-turing-were-convicted-of-consenting-same-sex-relations-under-the-british-gross-indecency-law-only-repealed-in-2003-and-also-all-the-other-men-convicted-under-other-uk-anti-gay\\" target=\\"_blank\\">People are striving to get that done </a><button class=\\"button\\"> Choose </button> ", femGayHist, femGayHistChoice],\n        // Rembrandt House\n        [4.901235, 52.369369, " The Rembrandt House<br><iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/tVBsi5LFQwc\\" frameborder=\\"0\\" allowfullscreen></iframe><button class=\\"button\\"> Choose </button>", domHist, domHistChoice],\n        //Gay Monument Amsterdam\n        [4.884913, 52.37442, "The idea of a permanent memorial to gay and lesbian victims of persecution dated from 1970, when gay activists were arrested for attempting to place a wreath at the National War Memorial on Dam Square in the centre, as is done to commemorate victims of WWII on Mey 4th of every year. The wreath was removed by police and denounced as a disgrace. After that, a campaign was started that resulted in the worlds first monument in public space, that is a memorial to the persecution of homosexuals. <br><a href=\\"http://en.wikipedia.org/wiki/Homomonument\\" target=\\"_blank\\"> Wikipedia </a><button class=\\"button\\"> Choose </button>", femGayHist, femGayHistChoice],\n        // Plaquette aanslag bevolkingsregister\n        [4.911924, 52.366478, "On March 27, 1943 members of a resistance group, dressed as police officers, entered the civil register office and set fire to the building. Twelve people involved in the group known as the Artists Reistance were executed non July 1st. What is less known is that most members of this group were gay, such as one of the leaders of the group Willem Arondéus. <button class=\\"button\\"> Choose </button>", femGayHist, femGayHistChoice],\n        // Anne Frank House\n        [4.883989, 52.375184, "This is the Anne Frank House. Now a museum, but former hiding place of 8 people, amongst who a young girl named Anne Frank, who had little else to do but write in her diary about her life as a Jewish girl in hiding in WWII.<br><a href=\\"http://www.annefrank.org/en/Anne-Frank/Not-outside-for-2-years/\\">The museums website</a><button id=\\"open-overlay\\"> Choose </button>", domHist, domHistChoice],\n        //KVV\n        [4.891827, 52.36507, "<iframe width=\\"420\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/yd-t7OkBF3g\\" frameborder=\\"0\\" allowfullscreen></iframe> <button class=\\"button\\"> Choose </button>", femHist, femHistChoice],\n        //1st vrouwelijke politieagenten\n        [4.89356, 52.373228, "<iframe width=\\"420\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/eSqB_Zln9Fo\\" frameborder=\\"0\\" allowfullscreen></iframe><button class=\\"button\\"> Choose </button>", femHist, femHistChoice],\n        //Major Bosshardt\n        [4.899873, 52.375477, "This building, for a long time, was the workspace of<br><a href=\\"http://en.wikipedia.org/wiki/Alida_Bosshardt\\" target=\\"_blank\\">Major Bosshardt</a><button class=\\"button\\"> Choose </button>", femHist, femHistChoice],\n        //Aletta Jacobs practice\n        [4.897627, 52.374635, "The former practice of dr. Aletta Jacobs <iframe width=\\"560\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/ivCxBCzj1J8\\" frameborder=\\"0\\" allowfullscreen></iframe><button class=\\"button\\"> Choose </button>", femHist, femHistChoice],\n        //Widow Johanna Borski\n        [4.895486, 52.3742, "Johanna Borski was one of the richest people in her day (1764-1864), and one of the few female bankers. She was co-owner of the Dutch National Bank and saved another, laying the basis for what is now ABN-AMRO, one of the 15 largest banks in the world <br><a href=\\"http://en.wikipedia.org/wiki/Johanna_Borski\\" target=\\"_blank\\">wikipedia</a><button class=\\"button\\"> Choose </button>", femHist, femHistChoice],\n        //Marretje Arents\n        [4.900137, 52.373058, "Marretje Arents was a rebellion leader, leading the pacher riots in 1748. After the rebellion she was sentenced to death by hanging and hung from the window of the Waag.<br><a href=\\"http://en.wikipedia.org/wiki/Marretje_Arents\\" target=\\"_blank\\">wikipedia</a><button id=\\"open-overlay\\"> Choose </button>", femHist, femHistChoice],\n        //Haesje Claes\n        [4.895986, 52.369303, "The Oudemanhuispoort; the gate to the Old Mens House, founded by Haesje Claes, a woman who also founded the Old Womens House and was involved in the founding of the Burgerweeshuis (a city orphanage).<br><a href=\\"http://resources.huygens.knaw.nl/vrouwenlexicon/lemmata/data/claes\\" target=\\"_blank\\">Time to learn some Dutch</a><button class=\\"button\\"> Choose </button>", femHist, femHistChoice],\n        //Johanna Reynvaan\n        [4.894633, 52.368562, "The Binnengasthuis, the first workplace of Johanna Reynvaan, who was at the basis of Dutch nursing, and later assistant-director of the Buitengasthuis on the Overtoom.<br><a href=\\"http://books.google.nl/books?id=fk7K4WQVllYC&pg=PA92&lpg=PA92&dq=johanna+reynvaan&source=bl&ots=30b7SE3TPW&sig=kK0Se7lL1rldS-JMcFOwmJkqTuQ&hl=en&sa=X&ei=8AJXVayUOYmOsAHRnIC4BQ&ved=0CGYQ6AEwDw#v=onepage&q=johanna%20reynvaan&f=false\\" target=\\"_blank\\">Nursing History Review</a><button class=\\"button\\"> Choose </button>", femHist, femHistChoice],\n        //The Shakespeare Club\n        [4.885188, 52.365276, "Former Café De La Paix, where in September 1946 150 people gathered for the founding of the Shakespeare Club. It was the largest gathering of gay people in the country until then. The Shakespeare Club is now known as the C.O.C., the oldest surviving LGBT organisation.<br><a href=\\"http://nl.wikipedia.org/wiki/Nederlandse_Vereniging_tot_Integratie_van_Homoseksualiteit_COC\\" target=\\"_blank\\">Dutch wikipedia</a><button class=\\"button\\"> Choose </button>", femGayHist, femGayHistChoice],\n        // April 1st 2001\n        [4.902281, 52.368078, "On  April 1st 2001, four couples were wed by mayor Job Cohen. Anne-Marie Thus and Hélène Faasen become the first two women in the world to legally marry.<br><a href=\\"www.news.com.au/world/worlds-first-legally-wed-lesbian-couple-celebrates-their-10th-wedding-anniversary/story-e6frfkyi-1226030866529\\" target=\\"_blank\\">Interview</a><button class=\\"button\\"> Choose </button>", femGayHist, femGayHistChoice],\n        //Monument Deaf Jews\n        [4.906952, 52.366255, "The world remained deaf. The first monument for deaf victims of the Second World War.<br><img src=\\" " + imgSrc + "\\"><button class=\\"button\\"> Choose </button>", disHist, disHistChoice],\n        //Education for the Blind.\n        [4.819959, 52.378813, "In 1808 the Institute for the Education of the Blind is founded in Amsterdam, the first school for the blind.<button class=\\"button\\"> Choose </button>", disHist, disHistChoice],\n        //River Kwai\n        [99.532811, 14.02278, "Well done! You looked beyond the frame you were given. This is the River Kwai, famous for its railway bridge built by Japan in WWII. But did you know that Thailand was never occupied? And that it was the only country in South East Asia to not be colonised?<br><a href=\\"www.stickmanbangkok.com/ReadersSubmissions2014/reader8591.htm\\" target=\\"_blank\\">Why Thailand Was Never Colonized</a><button class=\\"button\\"> Choose </button>", warHist, warHistChoice],\n        // Slave Compensation\n        [4.89456, 52.361602, "Joan Muijsken first lived on the Singel 274, later on this address, Prinsengracht 712. With the abolishment of slavery he was one of the people to receive 300 guilders compensation per slave, owning as many as 128 slaves at that time.<br> <a href=\\"https://www.google.com/maps/d/viewer?mid=z_50lGRHy2eM.kOvGbMjogrkc&msa=0&hl=nl&ie=UTF8&t=m&ll=52.372874,4.894152&spn=0.043441,0.077162&source=embed\\" target=\\"_blank\\">A full map of the slave owners in Amsterdam that recieved compensation</a><button class=\\"button\\"> Choose </button>", slaveHist, slaveHistChoice],\n        //Deportation of handicapped\n        [4.90974, 52.367695, "On February 3 1943 the A.C. Wertheimhuis, a care home, was cleared. How many people were taken, and what happened to them remains unclear. What we do know is that between 1939 and 1945 hundreds of thousands of children and adults with disabilities were systematically killed by the nazi-regime, as part of a so called \\"euthanasia-programme\\".<button class=\\"button\\"> Choose </button>", disHist, disHistChoice],\n        //Golden Bend\n        [4.889367, 52.366376, "Since 2010 the Amsterdam Canals have been placed on the Unesco World Heritage list. Part of it is this, the Golden Bend, in the Golden Age (and perhaps still) the most prestigious part of the canals. The rich people that lived there made most money by owning plants in Suriname. In 1814 trade in slaves is abolished, but it takes until July 1st 1863 until slavery is abolished entirely, because economic impact of abolishment is too great for those in power. And then slaves are forced to work until 1873 due to discussions about the height of compensation.<button class=\\"button\\"> Choose </button>", slaveHist, slaveHistChoice],\n        //Slave plays\n        [4.881924, 52.36367, "At the end of the 18th century many books were published against slavery. Plays with the same topic were staged in the Stadsschouwburg. \\"Monzongo\\" or \\"The Royal Slave\\" was one of them, but an adaptation of this play was quickly forbidden in 1810. Voices against slavery would only rise again in the 1840s.<button class=\\"button\\"> Choose </button>", slaveHist, slaveHistChoice],\n        //Mayor\'s residence\n        [4.893444, 52.364861, "Now the official residence of the mayor of Amsterdam, formerly the house of Paulus Godin(1618-1690), very active in slavery and one of the richest people in the city in his day. Mayor Job Cohen (mayor from 2001-2010) had a plaquette attached to the building reminding of the relationship this building has with slavery.<button class=\'button\'> Choose </button>", slaveHist, slaveHistChoice],\n        //Royal Palace\n        [4.891368, 52.373186, "Known as the Royal Palace of Amsterdam, this house is actually the former city\'s Town Hall that became a palace after Louis Napoleon became king of the country.<br> <a href=\'http://www.paleisamsterdam.nl/en/the-palace/history/napoleonic-palace/city-hall-becomes-napoleonic-palace\'>Official Website</a><button class=\'button\'> Choose </button>", domHist, domHistChoice],\n        //Royal Palace\n        [4.891368, 52.373186, "The Town Hall, as it was before Louis Napoleon. The place where Amsterdam business was conducted in the Golden Age. The place where the West-Indian Company was founded, that had the exclusive rights to trade people in the Atlantic area. Most people in the WIC were also politically active as mayors, council members etc. The WIC, in the first 100 years of its existence, had already shipped a quarter of a million Africans across the ocean under force.<button class=\'button\'> Choose </button>", slaveHist, slaveHistChoice],\n        //Lords XVII\n        [4.897986, 52.371108, "The Lords Seventeen was the name of the central board of the East India Company.<br> <img src=\\" " + lords + "\\"> <a href=\\"http://european-heritage.org/netherlands/alkmaar/dutch-east-india-company\\"> More info</a><button class=\\"button\\"> Choose </button>", domHist, domHistChoice],\n        //Heineken\n        [4.891491, 52.357941, "The original brewery, bought by Gerard Adriaan Heineken on February 15th, 1864. Since then, it developed to become a famous, prize winning beer brewery, sold in over 170 countries. <a href=\\"http://en.wikipedia.org/wiki/Heineken\\"> Wikipedia </a><button class=\\"button\\"> Choose </button>", domHist, domHistChoice],\n        //Marie Heineken\n        [4.891457, 52.357305, "The Heineken plein, actually the Marie Heineken plein, and not named after the brewery, but after a niece of Gerard Adriaan Heineken. Yet the choice of her name was mostly due to the area being named after painters, and the city wanting to name that square to the brewery of Marie\'s uncle.<button class=\\"button\\"> Choose </button>", femHist, femHistChoice],\n        //Nicolaes Tulp\n        [4.884696, 52.373545, "Nicolaes Tulp was a surgeon and from 1654 he was mayor of Amsterdam four times. His house can be recognised by the signboard above the door. Painted by Rembrandt in one of his most famous paintings: <img src=\\" " + tulp + " \\"> <a href=\\"http://en.wikipedia.org/wiki/Nicolaes_Tulp\\">Wiki</a><button class=\\"button\\"> Choose </button>", domHist, domHistChoice],\n        //André Hazes\n        [4.893199, 52.355512, "In 2005 a statue was raised on the corner of the Albert Cuypstraat for folk singer André Hazes, who died a year before. He was discovered in a pub, by comedian and singer Johnny Kraaijkamp Sr., who saw 8-year old André singing on Liberation Day.<button class=\\"button\\"> Choose </button>", domHist, domHistChoice],\n        //Olympics\n        [4.85413, 52.34342, "In 1928 the Summer Olympics were held in Amsterdam. For a lot of data and participating countries, see <a href=\\"http://en.wikipedia.org/wiki/1928_Summer_Olympics\\"> Wikipedia</a><button class=\\"button\\"> Choose </button>", domHist, domHistChoice],\n        //Deaf olympics\n        [4.85413, 52.34342, "In 1928, for the second time in the history of the world, the Deaflympics were held. Since deaf athletes need other signs than gunshots, the deaflympics had started four years earlier in Paris. They still go on today and are generally seen as a very early precursor of the paralympics, that had its first edition as late as 1960.<button class=\\"button\\"> Choose </button>", disHist, disHistChoice],\n        //Café \'t Mandje\n        [4.90096, 52.37484, "The famous Café \'t Mandje, run by Bet van Buuren since 1927, an openly gay woman. She was the first pub owner that allowed openly gay people in her bar (she did not allow kissing of same sex couples on every day of the week. They got to dance with each other only on Queensday.). \'T Mandje became the most famous place for gays in the city, and remained such until the Zeedijk was runover by whores and heroin users. It closed its doors in 1982, but was reopened in 2008.<button class=\\"button\\"> Choose </button>", femGayHist, femGayHistChoice]];\n        //Loop through the markers array\n        for (var i = 0; i < markers.length; i++) {\n            var opacity = 1;\n            var selected = false;\n            var lon = markers[i][0];\n            var lat = markers[i][1];\n            var popupText = markers[i][2];\n            var initIcon = L.Icon.extend({ options: { iconUrl: markers[i][3], popupAnchor: [5, 7], selected: selected, opacity: opacity } });\n            var id = [i];\n            var markerLocation = new L.LatLng(lat, lon);\n            var marker = new L.marker(markerLocation, { icon: new initIcon() });\n            map.addLayer(marker);\n\n            marker.bindPopup(popupText);\n\n            var button = document.getElementsByClassName(".selected");\n\n            marker.on("click", (function (markerData, e) {\n                var choiceIcon = L.Icon.extend({ options: { iconUrl: markerData[4], popupAnchor: [5, 7], selected: true } });\n                e.target.setIcon(new choiceIcon());\n            }).bind(this, markers[i]));\n        }\n        return map;\n    },\n\n    setupMap: function setupMap() {\n        this.map.setView([this.props.lat, this.props.lon], this.props.zoom);\n    },\n\n    componentDidMount: function componentDidMount() {\n\n        if (this.props.createMap) {\n            this.map = this.props.createMap(this.getDOMNode());\n        } else {\n            this.map = this.createMap(this.getDOMNode());\n        }\n\n        this.setupMap();\n    },\n\n    render: function render() {\n        return React.createElement(\n            "div",\n            { className: "map" },\n            " "\n        );\n    }\n\n});\n\nReact.render(React.createElement(Map, { lat: "52.3710", lon: "4.900", zoom: "14" }), document.body);\n\n/* REACT HOT LOADER */ }).call(this); if (true) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = __webpack_require__(111), foundReactClasses = false; if (makeExportsHot(module, __webpack_require__(40))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot not apply hot update to " + "entry.jsx" + ": " + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(103)(module)))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vRDovRG9jdW1lbnRlbi9HaXRIdWJSZXBvcy9tYXAtcHJvamVjdC9zcmMvZW50cnkuanN4PzJjYTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0lBQ08sS0FBSyx1Q0FBTSxFQUFPOztvQkFDbEIsR0FBeUI7O0lBQ3pCLENBQUMsdUNBQU0sR0FBUzs7SUFDaEIsTUFBTSx1Q0FBTSxHQUFrQzs7SUFDOUMsT0FBTyx1Q0FBTSxHQUFrQzs7SUFDL0MsYUFBYSx1Q0FBTSxHQUFrQzs7SUFDckQsT0FBTyx1Q0FBTSxHQUFrQzs7SUFDL0MsYUFBYSx1Q0FBTSxHQUFvQzs7SUFDdkQsVUFBVSx1Q0FBTSxHQUFvQzs7SUFDcEQsZ0JBQWdCLHVDQUFNLEdBQW9DOztJQUMxRCxPQUFPLHVDQUFNLEdBQTZCOztJQUMxQyxhQUFhLHVDQUFNLEdBQTZCOztJQUNoRCxPQUFPLHVDQUFNLEdBQXNDOztJQUNuRCxhQUFhLHVDQUFNLEdBQXNDOztJQUN6RCxTQUFTLHVDQUFNLEdBQWlDOztJQUNoRCxlQUFlLHVDQUFNLEdBQWlDOztJQUN0RCxLQUFLLHVDQUFNLEdBQTRDOztJQUN2RCxJQUFJLHVDQUFNLEdBQTRCOztBQUs3QyxJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDOzs7QUFDekIsYUFBUyxFQUFFLG1CQUFVLE9BQU8sRUFBRTtBQUM3QixZQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3hCLFNBQUMsQ0FBQyxTQUFTLENBQUMscUNBQXFDLEVBQUU7QUFDaEQsdUJBQVcsRUFBRSw0RUFBMEUsRUFDckYsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzs7QUFHbkIsWUFBSSxPQUFPLEdBQUc7O0FBRVosU0FBRSxDQUFDLFFBQVEsRUFBRSxRQUFTLEVBQUUsd3BCQUFrcEIsRUFBRSxVQUFVLEVBQUUsZ0JBQWdCLENBQUM7O0FBRXpzQixTQUFDLFFBQVEsRUFBRSxTQUFT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LElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFO0FBQ3RCLGdCQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO1NBQ3RELE1BQU07QUFDSCxnQkFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO1NBQ2hEOztBQUVELFlBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztLQUNuQjs7QUFHSixVQUFNLEVBQUUsa0JBQVc7QUFDWixlQUFROztjQUFLLFNBQVMsRUFBQyxLQUFLOztTQUFRLENBQUU7S0FDekM7O0NBRUosQ0FBQyxDQUFDOztBQUdILEtBQUssQ0FBQyxNQUFNLENBQUMsb0JBQUMsR0FBRyxJQUFDLEdBQUcsRUFBQyxTQUFTLEVBQUMsR0FBRyxFQUFDLE9BQU8sRUFBQyxJQUFJLEVBQUMsSUFBSSxHQUFHLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxDIiwiZmlsZSI6IjEwOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgJy4uL3N0eWxlcy9tYXBzdHlsZXMuY3NzJztcclxuaW1wb3J0IEwgZnJvbSAnbGVhZmxldCc7XHJcbmltcG9ydCBpbWdTcmMgZnJvbSAnLi4vcHJvamVjdC1pbWFnZXMvZG92ZW5zaG9haC5qcGcnO1xyXG5pbXBvcnQgZmVtSGlzdCBmcm9tICcuLi9wcm9qZWN0LWltYWdlcy9mZW1hbGUtMl8xLnBuZyc7XHJcbmltcG9ydCBmZW1IaXN0Q2hvaWNlIGZyb20gJy4uL3Byb2plY3QtaW1hZ2VzL2ZlbWFsZS0yXzIucG5nJztcclxuaW1wb3J0IGRpc0hpc3QgZnJvbSAnLi4vcHJvamVjdC1pbWFnZXMvZGlzYWJpbGl0eS5wbmcnO1xyXG5pbXBvcnQgZGlzSGlzdENob2ljZSBmcm9tICcuLi9wcm9qZWN0LWltYWdlcy9kaXNhYmlsaXR5XzIucG5nJztcclxuaW1wb3J0IGZlbUdheUhpc3QgZnJvbSAnLi4vcHJvamVjdC1pbWFnZXMvZ2F5LWZlbWFsZV8yLnBuZyc7XHJcbmltcG9ydCBmZW1HYXlIaXN0Q2hvaWNlIGZyb20gJy4uL3Byb2plY3QtaW1hZ2VzL2dheS1mZW1hbGVfMS5wbmcnO1xyXG5pbXBvcnQgd2FySGlzdCBmcm9tICcuLi9wcm9qZWN0LWltYWdlcy93YXJfMS5wbmcnO1xyXG5pbXBvcnQgd2FySGlzdENob2ljZSBmcm9tICcuLi9wcm9qZWN0LWltYWdlcy93YXJfMi5wbmcnO1xyXG5pbXBvcnQgZG9tSGlzdCBmcm9tICcuLi9wcm9qZWN0LWltYWdlcy9zbWlsZXlfaGFwcHlfMS5wbmcnO1xyXG5pbXBvcnQgZG9tSGlzdENob2ljZSBmcm9tICcuLi9wcm9qZWN0LWltYWdlcy9zbWlsZXlfaGFwcHlfMi5wbmcnO1xyXG5pbXBvcnQgc2xhdmVIaXN0IGZyb20gJy4uL3Byb2plY3QtaW1hZ2VzL3RvcnR1cmVfMS5wbmcnO1xyXG5pbXBvcnQgc2xhdmVIaXN0Q2hvaWNlIGZyb20gJy4uL3Byb2plY3QtaW1hZ2VzL3RvcnR1cmVfMi5wbmcnO1xyXG5pbXBvcnQgbG9yZHMgZnJvbSAnLi4vcHJvamVjdC1pbWFnZXMvaGVyZW4temV2ZW50aWVuLXh2aWkuanBnJztcclxuaW1wb3J0IHR1bHAgZnJvbSAnLi4vcHJvamVjdC1pbWFnZXMvdHVscC5qcGcnO1xyXG5cclxuXHJcblxyXG5cclxudmFyIE1hcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgY3JlYXRlTWFwOiBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgdmFyIG1hcCA9IEwubWFwKGVsZW1lbnQpO1xyXG4gICAgIEwudGlsZUxheWVyKCdodHRwOi8vdGlsZS5vc20ub3JnL3t6fS97eH0ve3l9LnBuZycsIHtcclxuICAgICAgICBhdHRyaWJ1dGlvbjogJyZjb3B5OyA8YSBocmVmPVwiaHR0cDovL29zbS5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzJyxcclxuICAgICAgICAgfSkuYWRkVG8obWFwKTtcclxuXHJcblxyXG4gICAgdmFyIG1hcmtlcnMgPSBbXHJcbiAgICBcdFx0Ly9BbGFuIFR1cmluZyBQYXJkb25cclxuICAgIFx0XHRbIC0wLjEyNDgwOSwgNTEuNDk5NDgwLCAnT24gRGVjZW1iZXIgMjR0aCAyMDEzIEFsYW4gVHVyaW5nIHdhcyBwYXJkb25lZCBmb3IgaGlzIGNvbnZpY3Rpb24gZm9yIGdyb3NzIGluZGVjZW5jeSBmb3Igd2hpY2ggaGUgd2FzIGNoZW1pY2FsbHkgY2FzdHJhdGVkLiBIaXMgcGFyZG9uIGNvbWVzIGEgbWVyZSA1OSB5ZWFycyBhZnRlciBoaXMgZGVhdGgsIGFuZCBvbmx5IGZvciBoaW0uIE5vdCBmb3IgdGhlIG90aGVyIDQ5LjAwMCBtZW4gd2hvIGhhdmUgYmVlbiBjb252aWN0ZWQgZm9yIGhvbW9zZXh1YWwgcmVsYXRpb25zLjxicj48YSBocmVmPVwiaHR0cHM6Ly93d3cuY2hhbmdlLm9yZy9wL2JyaXRpc2gtZ292ZXJubWVudC1wYXJkb24tYWxsLW9mLXRoZS1lc3RpbWF0ZWQtNDktMDAwLW1lbi13aG8tbGlrZS1hbGFuLXR1cmluZy13ZXJlLWNvbnZpY3RlZC1vZi1jb25zZW50aW5nLXNhbWUtc2V4LXJlbGF0aW9ucy11bmRlci10aGUtYnJpdGlzaC1ncm9zcy1pbmRlY2VuY3ktbGF3LW9ubHktcmVwZWFsZWQtaW4tMjAwMy1hbmQtYWxzby1hbGwtdGhlLW90aGVyLW1lbi1jb252aWN0ZWQtdW5kZXItb3RoZXItdWstYW50aS1nYXlcIiB0YXJnZXQ9XCJfYmxhbmtcIj5QZW9wbGUgYXJlIHN0cml2aW5nIHRvIGdldCB0aGF0IGRvbmUgPC9hPjxidXR0b24gY2xhc3M9XCJidXR0b25cIj4gQ2hvb3NlIDwvYnV0dG9uPiAnLCBmZW1HYXlIaXN0LCBmZW1HYXlIaXN0Q2hvaWNlXSxcclxuICAgIFx0XHQvLyBSZW1icmFuZHQgSG91c2VcclxuICAgIFx0XHRbNC45MDEyMzUsIDUyLjM2OTM2OSwgJyBUaGUgUmVtYnJhbmR0IEhvdXNlPGJyPjxpZnJhbWUgd2lkdGg9XCI1NjBcIiBoZWlnaHQ9XCIzMTVcIiBzcmM9XCJodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC90VkJzaTVMRlF3Y1wiIGZyYW1lYm9yZGVyPVwiMFwiIGFsbG93ZnVsbHNjcmVlbj48L2lmcmFtZT48YnV0dG9uIGNsYXNzPVwiYnV0dG9uXCI+IENob29zZSA8L2J1dHRvbj4nLCBkb21IaXN0LCBkb21IaXN0Q2hvaWNlXSxcclxuICAgIFx0XHQvL0dheSBNb251bWVudCBBbXN0ZXJkYW1cclxuICAgIFx0XHRbIDQuODg0OTEzLCA1Mi4zNzQ0MjAsICdUaGUgaWRlYSBvZiBhIHBlcm1hbmVudCBtZW1vcmlhbCB0byBnYXkgYW5kIGxlc2JpYW4gdmljdGltcyBvZiBwZXJzZWN1dGlvbiBkYXRlZCBmcm9tIDE5NzAsIHdoZW4gZ2F5IGFjdGl2aXN0cyB3ZXJlIGFycmVzdGVkIGZvciBhdHRlbXB0aW5nIHRvIHBsYWNlIGEgd3JlYXRoIGF0IHRoZSBOYXRpb25hbCBXYXIgTWVtb3JpYWwgb24gRGFtIFNxdWFyZSBpbiB0aGUgY2VudHJlLCBhcyBpcyBkb25lIHRvIGNvbW1lbW9yYXRlIHZpY3RpbXMgb2YgV1dJSSBvbiBNZXkgNHRoIG9mIGV2ZXJ5IHllYXIuIFRoZSB3cmVhdGggd2FzIHJlbW92ZWQgYnkgcG9saWNlIGFuZCBkZW5vdW5jZWQgYXMgYSBkaXNncmFjZS4gQWZ0ZXIgdGhhdCwgYSBjYW1wYWlnbiB3YXMgc3RhcnRlZCB0aGF0IHJlc3VsdGVkIGluIHRoZSB3b3JsZHMgZmlyc3QgbW9udW1lbnQgaW4gcHVibGljIHNwYWNlLCB0aGF0IGlzIGEgbWVtb3JpYWwgdG8gdGhlIHBlcnNlY3V0aW9uIG9mIGhvbW9zZXh1YWxzLiA8YnI+PGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSG9tb21vbnVtZW50XCIgdGFyZ2V0PVwiX2JsYW5rXCI+IFdpa2lwZWRpYSA8L2E+PGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiPiBDaG9vc2UgPC9idXR0b24+JywgZmVtR2F5SGlzdCwgZmVtR2F5SGlzdENob2ljZV0sXHJcbiAgICBcdFx0Ly8gUGxhcXVldHRlIGFhbnNsYWcgYmV2b2xraW5nc3JlZ2lzdGVyXHJcbiAgICBcdFx0WyA0LjkxMTkyNCwgNTIuMzY2NDc4LCAnT24gTWFyY2ggMjcsIDE5NDMgbWVtYmVycyBvZiBhIHJlc2lzdGFuY2UgZ3JvdXAsIGRyZXNzZWQgYXMgcG9saWNlIG9mZmljZXJzLCBlbnRlcmVkIHRoZSBjaXZpbCByZWdpc3RlciBvZmZpY2UgYW5kIHNldCBmaXJlIHRvIHRoZSBidWlsZGluZy4gVHdlbHZlIHBlb3BsZSBpbnZvbHZlZCBpbiB0aGUgZ3JvdXAga25vd24gYXMgdGhlIEFydGlzdHMgUmVpc3RhbmNlIHdlcmUgZXhlY3V0ZWQgbm9uIEp1bHkgMXN0LiBXaGF0IGlzIGxlc3Mga25vd24gaXMgdGhhdCBtb3N0IG1lbWJlcnMgb2YgdGhpcyBncm91cCB3ZXJlIGdheSwgc3VjaCBhcyBvbmUgb2YgdGhlIGxlYWRlcnMgb2YgdGhlIGdyb3VwIFdpbGxlbSBBcm9uZMOpdXMuIDxidXR0b24gY2xhc3M9XCJidXR0b25cIj4gQ2hvb3NlIDwvYnV0dG9uPicsIGZlbUdheUhpc3QsIGZlbUdheUhpc3RDaG9pY2UgXSxcclxuICAgIFx0XHQvLyBBbm5lIEZyYW5rIEhvdXNlXHJcbiAgICBcdFx0WyA0Ljg4Mzk4OSwgNTIuMzc1MTg0LCAnVGhpcyBpcyB0aGUgQW5uZSBGcmFuayBIb3VzZS4gTm93IGEgbXVzZXVtLCBidXQgZm9ybWVyIGhpZGluZyBwbGFjZSBvZiA4IHBlb3BsZSwgYW1vbmdzdCB3aG8gYSB5b3VuZyBnaXJsIG5hbWVkIEFubmUgRnJhbmssIHdobyBoYWQgbGl0dGxlIGVsc2UgdG8gZG8gYnV0IHdyaXRlIGluIGhlciBkaWFyeSBhYm91dCBoZXIgbGlmZSBhcyBhIEpld2lzaCBnaXJsIGluIGhpZGluZyBpbiBXV0lJLjxicj48YSBocmVmPVwiaHR0cDovL3d3dy5hbm5lZnJhbmsub3JnL2VuL0FubmUtRnJhbmsvTm90LW91dHNpZGUtZm9yLTIteWVhcnMvXCI+VGhlIG11c2V1bXMgd2Vic2l0ZTwvYT48YnV0dG9uIGlkPVwib3Blbi1vdmVybGF5XCI+IENob29zZSA8L2J1dHRvbj4nLCBkb21IaXN0LCBkb21IaXN0Q2hvaWNlIF0sXHJcbiAgICBcdFx0Ly9LVlZcclxuICAgICAgICBbIDQuODkxODI3LCA1Mi4zNjUwNzAsICc8aWZyYW1lIHdpZHRoPVwiNDIwXCIgaGVpZ2h0PVwiMzE1XCIgc3JjPVwiaHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQveWQtdDdPa0JGM2dcIiBmcmFtZWJvcmRlcj1cIjBcIiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+IDxidXR0b24gY2xhc3M9XCJidXR0b25cIj4gQ2hvb3NlIDwvYnV0dG9uPicsIGZlbUhpc3QsIGZlbUhpc3RDaG9pY2UgIF0sXHJcbiAgICAgICAgLy8xc3QgdnJvdXdlbGlqa2UgcG9saXRpZWFnZW50ZW5cclxuICAgICAgICBbIDQuODkzNTYsIDUyLjM3MzIyOCwgJzxpZnJhbWUgd2lkdGg9XCI0MjBcIiBoZWlnaHQ9XCIzMTVcIiBzcmM9XCJodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC9lU3FCX1psbjlGb1wiIGZyYW1lYm9yZGVyPVwiMFwiIGFsbG93ZnVsbHNjcmVlbj48L2lmcmFtZT48YnV0dG9uIGNsYXNzPVwiYnV0dG9uXCI+IENob29zZSA8L2J1dHRvbj4nLCBmZW1IaXN0LCBmZW1IaXN0Q2hvaWNlIF0sXHJcbiAgICAgICAgLy9NYWpvciBCb3NzaGFyZHRcclxuICAgICAgICBbIDQuODk5ODczLCA1Mi4zNzU0NzcsICdUaGlzIGJ1aWxkaW5nLCBmb3IgYSBsb25nIHRpbWUsIHdhcyB0aGUgd29ya3NwYWNlIG9mPGJyPjxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FsaWRhX0Jvc3NoYXJkdFwiIHRhcmdldD1cIl9ibGFua1wiPk1ham9yIEJvc3NoYXJkdDwvYT48YnV0dG9uIGNsYXNzPVwiYnV0dG9uXCI+IENob29zZSA8L2J1dHRvbj4nLCBmZW1IaXN0LCBmZW1IaXN0Q2hvaWNlIF0sXHJcbiAgICAgICAgLy9BbGV0dGEgSmFjb2JzIHByYWN0aWNlXHJcbiAgICAgICAgWyA0Ljg5NzYyNywgNTIuMzc0NjM1LCAnVGhlIGZvcm1lciBwcmFjdGljZSBvZiBkci4gQWxldHRhIEphY29icyA8aWZyYW1lIHdpZHRoPVwiNTYwXCIgaGVpZ2h0PVwiMzE1XCIgc3JjPVwiaHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQvaXZDeEJDemoxSjhcIiBmcmFtZWJvcmRlcj1cIjBcIiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+PGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiPiBDaG9vc2UgPC9idXR0b24+JywgZmVtSGlzdCwgZmVtSGlzdENob2ljZSAgXSxcclxuICAgICAgICAvL1dpZG93IEpvaGFubmEgQm9yc2tpXHJcbiAgICAgICAgWyA0Ljg5NTQ4NiwgNTIuMzc0MjAwLCAnSm9oYW5uYSBCb3Jza2kgd2FzIG9uZSBvZiB0aGUgcmljaGVzdCBwZW9wbGUgaW4gaGVyIGRheSAoMTc2NC0xODY0KSwgYW5kIG9uZSBvZiB0aGUgZmV3IGZlbWFsZSBiYW5rZXJzLiBTaGUgd2FzIGNvLW93bmVyIG9mIHRoZSBEdXRjaCBOYXRpb25hbCBCYW5rIGFuZCBzYXZlZCBhbm90aGVyLCBsYXlpbmcgdGhlIGJhc2lzIGZvciB3aGF0IGlzIG5vdyBBQk4tQU1STywgb25lIG9mIHRoZSAxNSBsYXJnZXN0IGJhbmtzIGluIHRoZSB3b3JsZCA8YnI+PGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSm9oYW5uYV9Cb3Jza2lcIiB0YXJnZXQ9XCJfYmxhbmtcIj53aWtpcGVkaWE8L2E+PGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiPiBDaG9vc2UgPC9idXR0b24+JywgZmVtSGlzdCwgZmVtSGlzdENob2ljZSBdLFxyXG4gICAgICAgIC8vTWFycmV0amUgQXJlbnRzXHJcbiAgICAgICAgWyA0LjkwMDEzNywgNTIuMzczMDU4LCAnTWFycmV0amUgQXJlbnRzIHdhcyBhIHJlYmVsbGlvbiBsZWFkZXIsIGxlYWRpbmcgdGhlIHBhY2hlciByaW90cyBpbiAxNzQ4LiBBZnRlciB0aGUgcmViZWxsaW9uIHNoZSB3YXMgc2VudGVuY2VkIHRvIGRlYXRoIGJ5IGhhbmdpbmcgYW5kIGh1bmcgZnJvbSB0aGUgd2luZG93IG9mIHRoZSBXYWFnLjxicj48YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXJyZXRqZV9BcmVudHNcIiB0YXJnZXQ9XCJfYmxhbmtcIj53aWtpcGVkaWE8L2E+PGJ1dHRvbiBpZD1cIm9wZW4tb3ZlcmxheVwiPiBDaG9vc2UgPC9idXR0b24+JywgZmVtSGlzdCwgZmVtSGlzdENob2ljZSBdLFxyXG4gICAgICAgIC8vSGFlc2plIENsYWVzXHJcbiAgICAgICAgWyA0Ljg5NTk4NiwgNTIuMzY5MzAzLCAnVGhlIE91ZGVtYW5odWlzcG9vcnQ7IHRoZSBnYXRlIHRvIHRoZSBPbGQgTWVucyBIb3VzZSwgZm91bmRlZCBieSBIYWVzamUgQ2xhZXMsIGEgd29tYW4gd2hvIGFsc28gZm91bmRlZCB0aGUgT2xkIFdvbWVucyBIb3VzZSBhbmQgd2FzIGludm9sdmVkIGluIHRoZSBmb3VuZGluZyBvZiB0aGUgQnVyZ2Vyd2Vlc2h1aXMgKGEgY2l0eSBvcnBoYW5hZ2UpLjxicj48YSBocmVmPVwiaHR0cDovL3Jlc291cmNlcy5odXlnZW5zLmtuYXcubmwvdnJvdXdlbmxleGljb24vbGVtbWF0YS9kYXRhL2NsYWVzXCIgdGFyZ2V0PVwiX2JsYW5rXCI+VGltZSB0byBsZWFybiBzb21lIER1dGNoPC9hPjxidXR0b24gY2xhc3M9XCJidXR0b25cIj4gQ2hvb3NlIDwvYnV0dG9uPicsIGZlbUhpc3QsIGZlbUhpc3RDaG9pY2UgXSxcclxuICAgICAgICAvL0pvaGFubmEgUmV5bnZhYW5cclxuICAgICAgICBbIDQuODk0NjMzLCA1Mi4zNjg1NjIsICdUaGUgQmlubmVuZ2FzdGh1aXMsIHRoZSBmaXJzdCB3b3JrcGxhY2Ugb2YgSm9oYW5uYSBSZXludmFhbiwgd2hvIHdhcyBhdCB0aGUgYmFzaXMgb2YgRHV0Y2ggbnVyc2luZywgYW5kIGxhdGVyIGFzc2lzdGFudC1kaXJlY3RvciBvZiB0aGUgQnVpdGVuZ2FzdGh1aXMgb24gdGhlIE92ZXJ0b29tLjxicj48YSBocmVmPVwiaHR0cDovL2Jvb2tzLmdvb2dsZS5ubC9ib29rcz9pZD1mazdLNFdRVmxsWUMmcGc9UEE5MiZscGc9UEE5MiZkcT1qb2hhbm5hK3JleW52YWFuJnNvdXJjZT1ibCZvdHM9MzBiN1NFM1RQVyZzaWc9a0swU2U3bEwxcmxkUy1KTWNGT3dtSmtxVHVRJmhsPWVuJnNhPVgmZWk9OEFKWFZheVVPWW1Pc0FIUm5JQzRCUSZ2ZWQ9MENHWVE2QUV3RHcjdj1vbmVwYWdlJnE9am9oYW5uYSUyMHJleW52YWFuJmY9ZmFsc2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5OdXJzaW5nIEhpc3RvcnkgUmV2aWV3PC9hPjxidXR0b24gY2xhc3M9XCJidXR0b25cIj4gQ2hvb3NlIDwvYnV0dG9uPicsIGZlbUhpc3QsIGZlbUhpc3RDaG9pY2UgXSxcclxuICAgICAgICAvL1RoZSBTaGFrZXNwZWFyZSBDbHViXHJcbiAgICAgICAgWyA0Ljg4NTE4OCwgNTIuMzY1Mjc2LCAnRm9ybWVyIENhZsOpIERlIExhIFBhaXgsIHdoZXJlIGluIFNlcHRlbWJlciAxOTQ2IDE1MCBwZW9wbGUgZ2F0aGVyZWQgZm9yIHRoZSBmb3VuZGluZyBvZiB0aGUgU2hha2VzcGVhcmUgQ2x1Yi4gSXQgd2FzIHRoZSBsYXJnZXN0IGdhdGhlcmluZyBvZiBnYXkgcGVvcGxlIGluIHRoZSBjb3VudHJ5IHVudGlsIHRoZW4uIFRoZSBTaGFrZXNwZWFyZSBDbHViIGlzIG5vdyBrbm93biBhcyB0aGUgQy5PLkMuLCB0aGUgb2xkZXN0IHN1cnZpdmluZyBMR0JUIG9yZ2FuaXNhdGlvbi48YnI+PGEgaHJlZj1cImh0dHA6Ly9ubC53aWtpcGVkaWEub3JnL3dpa2kvTmVkZXJsYW5kc2VfVmVyZW5pZ2luZ190b3RfSW50ZWdyYXRpZV92YW5fSG9tb3Nla3N1YWxpdGVpdF9DT0NcIiB0YXJnZXQ9XCJfYmxhbmtcIj5EdXRjaCB3aWtpcGVkaWE8L2E+PGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiPiBDaG9vc2UgPC9idXR0b24+JywgZmVtR2F5SGlzdCwgZmVtR2F5SGlzdENob2ljZSBdLFxyXG4gICAgICAgIC8vIEFwcmlsIDFzdCAyMDAxXHJcbiAgICAgICAgWyA0LjkwMjI4MSwgNTIuMzY4MDc4LCAnT24gIEFwcmlsIDFzdCAyMDAxLCBmb3VyIGNvdXBsZXMgd2VyZSB3ZWQgYnkgbWF5b3IgSm9iIENvaGVuLiBBbm5lLU1hcmllIFRodXMgYW5kIEjDqWzDqG5lIEZhYXNlbiBiZWNvbWUgdGhlIGZpcnN0IHR3byB3b21lbiBpbiB0aGUgd29ybGQgdG8gbGVnYWxseSBtYXJyeS48YnI+PGEgaHJlZj1cInd3dy5uZXdzLmNvbS5hdS93b3JsZC93b3JsZHMtZmlyc3QtbGVnYWxseS13ZWQtbGVzYmlhbi1jb3VwbGUtY2VsZWJyYXRlcy10aGVpci0xMHRoLXdlZGRpbmctYW5uaXZlcnNhcnkvc3RvcnktZTZmcmZreWktMTIyNjAzMDg2NjUyOVwiIHRhcmdldD1cIl9ibGFua1wiPkludGVydmlldzwvYT48YnV0dG9uIGNsYXNzPVwiYnV0dG9uXCI+IENob29zZSA8L2J1dHRvbj4nLCBmZW1HYXlIaXN0LCBmZW1HYXlIaXN0Q2hvaWNlIF0sXHJcblx0ICAgICAgLy9Nb251bWVudCBEZWFmIEpld3NcclxuXHQgICAgICBbIDQuOTA2OTUyLCA1Mi4zNjYyNTUsICdUaGUgd29ybGQgcmVtYWluZWQgZGVhZi4gVGhlIGZpcnN0IG1vbnVtZW50IGZvciBkZWFmIHZpY3RpbXMgb2YgdGhlIFNlY29uZCBXb3JsZCBXYXIuPGJyPjxpbWcgc3JjPVwiICcrIGltZ1NyYysnXCI+PGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiPiBDaG9vc2UgPC9idXR0b24+JywgZGlzSGlzdCwgZGlzSGlzdENob2ljZSBdLFxyXG5cdCAgICAgIC8vRWR1Y2F0aW9uIGZvciB0aGUgQmxpbmQuXHJcbiAgICAgICAgWyA0LjgxOTk1OSwgNTIuMzc4ODEzLCAnSW4gMTgwOCB0aGUgSW5zdGl0dXRlIGZvciB0aGUgRWR1Y2F0aW9uIG9mIHRoZSBCbGluZCBpcyBmb3VuZGVkIGluIEFtc3RlcmRhbSwgdGhlIGZpcnN0IHNjaG9vbCBmb3IgdGhlIGJsaW5kLjxidXR0b24gY2xhc3M9XCJidXR0b25cIj4gQ2hvb3NlIDwvYnV0dG9uPicsIGRpc0hpc3QsIGRpc0hpc3RDaG9pY2UgXSxcclxuICAgICAgICAvL1JpdmVyIEt3YWlcclxuICAgICAgICBbIDk5LjUzMjgxMSwgMTQuMDIyNzgwLCAnV2VsbCBkb25lISBZb3UgbG9va2VkIGJleW9uZCB0aGUgZnJhbWUgeW91IHdlcmUgZ2l2ZW4uIFRoaXMgaXMgdGhlIFJpdmVyIEt3YWksIGZhbW91cyBmb3IgaXRzIHJhaWx3YXkgYnJpZGdlIGJ1aWx0IGJ5IEphcGFuIGluIFdXSUkuIEJ1dCBkaWQgeW91IGtub3cgdGhhdCBUaGFpbGFuZCB3YXMgbmV2ZXIgb2NjdXBpZWQ/IEFuZCB0aGF0IGl0IHdhcyB0aGUgb25seSBjb3VudHJ5IGluIFNvdXRoIEVhc3QgQXNpYSB0byBub3QgYmUgY29sb25pc2VkPzxicj48YSBocmVmPVwid3d3LnN0aWNrbWFuYmFuZ2tvay5jb20vUmVhZGVyc1N1Ym1pc3Npb25zMjAxNC9yZWFkZXI4NTkxLmh0bVwiIHRhcmdldD1cIl9ibGFua1wiPldoeSBUaGFpbGFuZCBXYXMgTmV2ZXIgQ29sb25pemVkPC9hPjxidXR0b24gY2xhc3M9XCJidXR0b25cIj4gQ2hvb3NlIDwvYnV0dG9uPicsIHdhckhpc3QsIHdhckhpc3RDaG9pY2UgXSxcclxuICAgICAgICAvLyBTbGF2ZSBDb21wZW5zYXRpb25cclxuICAgICAgICBbIDQuODk0NTYsIDUyLjM2MTYwMiwgJ0pvYW4gTXVpanNrZW4gZmlyc3QgbGl2ZWQgb24gdGhlIFNpbmdlbCAyNzQsIGxhdGVyIG9uIHRoaXMgYWRkcmVzcywgUHJpbnNlbmdyYWNodCA3MTIuIFdpdGggdGhlIGFib2xpc2htZW50IG9mIHNsYXZlcnkgaGUgd2FzIG9uZSBvZiB0aGUgcGVvcGxlIHRvIHJlY2VpdmUgMzAwIGd1aWxkZXJzIGNvbXBlbnNhdGlvbiBwZXIgc2xhdmUsIG93bmluZyBhcyBtYW55IGFzIDEyOCBzbGF2ZXMgYXQgdGhhdCB0aW1lLjxicj4gPGEgaHJlZj1cImh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vbWFwcy9kL3ZpZXdlcj9taWQ9el81MGxHUkh5MmVNLmtPdkdiTWpvZ3JrYyZtc2E9MCZobD1ubCZpZT1VVEY4JnQ9bSZsbD01Mi4zNzI4NzQsNC44OTQxNTImc3BuPTAuMDQzNDQxLDAuMDc3MTYyJnNvdXJjZT1lbWJlZFwiIHRhcmdldD1cIl9ibGFua1wiPkEgZnVsbCBtYXAgb2YgdGhlIHNsYXZlIG93bmVycyBpbiBBbXN0ZXJkYW0gdGhhdCByZWNpZXZlZCBjb21wZW5zYXRpb248L2E+PGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiPiBDaG9vc2UgPC9idXR0b24+Jywgc2xhdmVIaXN0LCBzbGF2ZUhpc3RDaG9pY2VdLFxyXG4gICAgICAgIC8vRGVwb3J0YXRpb24gb2YgaGFuZGljYXBwZWRcclxuICAgICAgICBbNC45MDk3NCwgNTIuMzY3Njk1LCAnT24gRmVicnVhcnkgMyAxOTQzIHRoZSBBLkMuIFdlcnRoZWltaHVpcywgYSBjYXJlIGhvbWUsIHdhcyBjbGVhcmVkLiBIb3cgbWFueSBwZW9wbGUgd2VyZSB0YWtlbiwgYW5kIHdoYXQgaGFwcGVuZWQgdG8gdGhlbSByZW1haW5zIHVuY2xlYXIuIFdoYXQgd2UgZG8ga25vdyBpcyB0aGF0IGJldHdlZW4gMTkzOSBhbmQgMTk0NSBodW5kcmVkcyBvZiB0aG91c2FuZHMgb2YgY2hpbGRyZW4gYW5kIGFkdWx0cyB3aXRoIGRpc2FiaWxpdGllcyB3ZXJlIHN5c3RlbWF0aWNhbGx5IGtpbGxlZCBieSB0aGUgbmF6aS1yZWdpbWUsIGFzIHBhcnQgb2YgYSBzbyBjYWxsZWQgXCJldXRoYW5hc2lhLXByb2dyYW1tZVwiLjxidXR0b24gY2xhc3M9XCJidXR0b25cIj4gQ2hvb3NlIDwvYnV0dG9uPicsIGRpc0hpc3QsIGRpc0hpc3RDaG9pY2VdLFxyXG4gICAgICAgIC8vR29sZGVuIEJlbmRcclxuICAgICAgICBbNC44ODkzNjcsIDUyLjM2NjM3NiwgJ1NpbmNlIDIwMTAgdGhlIEFtc3RlcmRhbSBDYW5hbHMgaGF2ZSBiZWVuIHBsYWNlZCBvbiB0aGUgVW5lc2NvIFdvcmxkIEhlcml0YWdlIGxpc3QuIFBhcnQgb2YgaXQgaXMgdGhpcywgdGhlIEdvbGRlbiBCZW5kLCBpbiB0aGUgR29sZGVuIEFnZSAoYW5kIHBlcmhhcHMgc3RpbGwpIHRoZSBtb3N0IHByZXN0aWdpb3VzIHBhcnQgb2YgdGhlIGNhbmFscy4gVGhlIHJpY2ggcGVvcGxlIHRoYXQgbGl2ZWQgdGhlcmUgbWFkZSBtb3N0IG1vbmV5IGJ5IG93bmluZyBwbGFudHMgaW4gU3VyaW5hbWUuIEluIDE4MTQgdHJhZGUgaW4gc2xhdmVzIGlzIGFib2xpc2hlZCwgYnV0IGl0IHRha2VzIHVudGlsIEp1bHkgMXN0IDE4NjMgdW50aWwgc2xhdmVyeSBpcyBhYm9saXNoZWQgZW50aXJlbHksIGJlY2F1c2UgZWNvbm9taWMgaW1wYWN0IG9mIGFib2xpc2htZW50IGlzIHRvbyBncmVhdCBmb3IgdGhvc2UgaW4gcG93ZXIuIEFuZCB0aGVuIHNsYXZlcyBhcmUgZm9yY2VkIHRvIHdvcmsgdW50aWwgMTg3MyBkdWUgdG8gZGlzY3Vzc2lvbnMgYWJvdXQgdGhlIGhlaWdodCBvZiBjb21wZW5zYXRpb24uPGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiPiBDaG9vc2UgPC9idXR0b24+Jywgc2xhdmVIaXN0LCBzbGF2ZUhpc3RDaG9pY2UgXSxcclxuICAgICAgICAvL1NsYXZlIHBsYXlzXHJcbiAgICAgICAgWzQuODgxOTI0LCA1Mi4zNjM2NzAsICdBdCB0aGUgZW5kIG9mIHRoZSAxOHRoIGNlbnR1cnkgbWFueSBib29rcyB3ZXJlIHB1Ymxpc2hlZCBhZ2FpbnN0IHNsYXZlcnkuIFBsYXlzIHdpdGggdGhlIHNhbWUgdG9waWMgd2VyZSBzdGFnZWQgaW4gdGhlIFN0YWRzc2Nob3V3YnVyZy4gXCJNb256b25nb1wiIG9yIFwiVGhlIFJveWFsIFNsYXZlXCIgd2FzIG9uZSBvZiB0aGVtLCBidXQgYW4gYWRhcHRhdGlvbiBvZiB0aGlzIHBsYXkgd2FzIHF1aWNrbHkgZm9yYmlkZGVuIGluIDE4MTAuIFZvaWNlcyBhZ2FpbnN0IHNsYXZlcnkgd291bGQgb25seSByaXNlIGFnYWluIGluIHRoZSAxODQwcy48YnV0dG9uIGNsYXNzPVwiYnV0dG9uXCI+IENob29zZSA8L2J1dHRvbj4nLCBzbGF2ZUhpc3QsIHNsYXZlSGlzdENob2ljZV0sXHJcbiAgICAgICAgLy9NYXlvcidzIHJlc2lkZW5jZVxyXG4gICAgICAgIFs0Ljg5MzQ0NCwgNTIuMzY0ODYxLCBcIk5vdyB0aGUgb2ZmaWNpYWwgcmVzaWRlbmNlIG9mIHRoZSBtYXlvciBvZiBBbXN0ZXJkYW0sIGZvcm1lcmx5IHRoZSBob3VzZSBvZiBQYXVsdXMgR29kaW4oMTYxOC0xNjkwKSwgdmVyeSBhY3RpdmUgaW4gc2xhdmVyeSBhbmQgb25lIG9mIHRoZSByaWNoZXN0IHBlb3BsZSBpbiB0aGUgY2l0eSBpbiBoaXMgZGF5LiBNYXlvciBKb2IgQ29oZW4gKG1heW9yIGZyb20gMjAwMS0yMDEwKSBoYWQgYSBwbGFxdWV0dGUgYXR0YWNoZWQgdG8gdGhlIGJ1aWxkaW5nIHJlbWluZGluZyBvZiB0aGUgcmVsYXRpb25zaGlwIHRoaXMgYnVpbGRpbmcgaGFzIHdpdGggc2xhdmVyeS48YnV0dG9uIGNsYXNzPSdidXR0b24nPiBDaG9vc2UgPC9idXR0b24+XCIsIHNsYXZlSGlzdCwgc2xhdmVIaXN0Q2hvaWNlXSxcclxuICAgICAgICAvL1JveWFsIFBhbGFjZVxyXG4gICAgICAgIFs0Ljg5MTM2OCwgNTIuMzczMTg2LCBcIktub3duIGFzIHRoZSBSb3lhbCBQYWxhY2Ugb2YgQW1zdGVyZGFtLCB0aGlzIGhvdXNlIGlzIGFjdHVhbGx5IHRoZSBmb3JtZXIgY2l0eSdzIFRvd24gSGFsbCB0aGF0IGJlY2FtZSBhIHBhbGFjZSBhZnRlciBMb3VpcyBOYXBvbGVvbiBiZWNhbWUga2luZyBvZiB0aGUgY291bnRyeS48YnI+IDxhIGhyZWY9J2h0dHA6Ly93d3cucGFsZWlzYW1zdGVyZGFtLm5sL2VuL3RoZS1wYWxhY2UvaGlzdG9yeS9uYXBvbGVvbmljLXBhbGFjZS9jaXR5LWhhbGwtYmVjb21lcy1uYXBvbGVvbmljLXBhbGFjZSc+T2ZmaWNpYWwgV2Vic2l0ZTwvYT48YnV0dG9uIGNsYXNzPSdidXR0b24nPiBDaG9vc2UgPC9idXR0b24+XCIsIGRvbUhpc3QsIGRvbUhpc3RDaG9pY2UgXSxcclxuICAgICAgICAvL1JveWFsIFBhbGFjZVxyXG4gICAgICAgIFs0Ljg5MTM2OCwgNTIuMzczMTg2LCBcIlRoZSBUb3duIEhhbGwsIGFzIGl0IHdhcyBiZWZvcmUgTG91aXMgTmFwb2xlb24uIFRoZSBwbGFjZSB3aGVyZSBBbXN0ZXJkYW0gYnVzaW5lc3Mgd2FzIGNvbmR1Y3RlZCBpbiB0aGUgR29sZGVuIEFnZS4gVGhlIHBsYWNlIHdoZXJlIHRoZSBXZXN0LUluZGlhbiBDb21wYW55IHdhcyBmb3VuZGVkLCB0aGF0IGhhZCB0aGUgZXhjbHVzaXZlIHJpZ2h0cyB0byB0cmFkZSBwZW9wbGUgaW4gdGhlIEF0bGFudGljIGFyZWEuIE1vc3QgcGVvcGxlIGluIHRoZSBXSUMgd2VyZSBhbHNvIHBvbGl0aWNhbGx5IGFjdGl2ZSBhcyBtYXlvcnMsIGNvdW5jaWwgbWVtYmVycyBldGMuIFRoZSBXSUMsIGluIHRoZSBmaXJzdCAxMDAgeWVhcnMgb2YgaXRzIGV4aXN0ZW5jZSwgaGFkIGFscmVhZHkgc2hpcHBlZCBhIHF1YXJ0ZXIgb2YgYSBtaWxsaW9uIEFmcmljYW5zIGFjcm9zcyB0aGUgb2NlYW4gdW5kZXIgZm9yY2UuPGJ1dHRvbiBjbGFzcz0nYnV0dG9uJz4gQ2hvb3NlIDwvYnV0dG9uPlwiLCBzbGF2ZUhpc3QsIHNsYXZlSGlzdENob2ljZV0sXHJcbiAgIFx0XHQgIC8vTG9yZHMgWFZJSVxyXG4gICBcdFx0ICBbNC44OTc5ODYsIDUyLjM3MTEwOCwgJ1RoZSBMb3JkcyBTZXZlbnRlZW4gd2FzIHRoZSBuYW1lIG9mIHRoZSBjZW50cmFsIGJvYXJkIG9mIHRoZSBFYXN0IEluZGlhIENvbXBhbnkuPGJyPiA8aW1nIHNyYz1cIiAnKyBsb3JkcysnXCI+IDxhIGhyZWY9XCJodHRwOi8vZXVyb3BlYW4taGVyaXRhZ2Uub3JnL25ldGhlcmxhbmRzL2Fsa21hYXIvZHV0Y2gtZWFzdC1pbmRpYS1jb21wYW55XCI+IE1vcmUgaW5mbzwvYT48YnV0dG9uIGNsYXNzPVwiYnV0dG9uXCI+IENob29zZSA8L2J1dHRvbj4nICwgZG9tSGlzdCwgZG9tSGlzdENob2ljZSBdLFxyXG4gICAgIFx0XHQvL0hlaW5la2VuXHJcbiAgICAgXHRcdFs0Ljg5MTQ5MSwgNTIuMzU3OTQxLCAnVGhlIG9yaWdpbmFsIGJyZXdlcnksIGJvdWdodCBieSBHZXJhcmQgQWRyaWFhbiBIZWluZWtlbiBvbiBGZWJydWFyeSAxNXRoLCAxODY0LiBTaW5jZSB0aGVuLCBpdCBkZXZlbG9wZWQgdG8gYmVjb21lIGEgZmFtb3VzLCBwcml6ZSB3aW5uaW5nIGJlZXIgYnJld2VyeSwgc29sZCBpbiBvdmVyIDE3MCBjb3VudHJpZXMuIDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlaW5la2VuXCI+IFdpa2lwZWRpYSA8L2E+PGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiPiBDaG9vc2UgPC9idXR0b24+JywgZG9tSGlzdCwgZG9tSGlzdENob2ljZSBdLFxyXG4gICAgIFx0XHQvL01hcmllIEhlaW5la2VuXHJcbiAgICAgXHRcdFs0Ljg5MTQ1NywgNTIuMzU3MzA1LCAnVGhlIEhlaW5la2VuIHBsZWluLCBhY3R1YWxseSB0aGUgTWFyaWUgSGVpbmVrZW4gcGxlaW4sIGFuZCBub3QgbmFtZWQgYWZ0ZXIgdGhlIGJyZXdlcnksIGJ1dCBhZnRlciBhIG5pZWNlIG9mIEdlcmFyZCBBZHJpYWFuIEhlaW5la2VuLiBZZXQgdGhlIGNob2ljZSBvZiBoZXIgbmFtZSB3YXMgbW9zdGx5IGR1ZSB0byB0aGUgYXJlYSBiZWluZyBuYW1lZCBhZnRlciBwYWludGVycywgYW5kIHRoZSBjaXR5IHdhbnRpbmcgdG8gbmFtZSB0aGF0IHNxdWFyZSB0byB0aGUgYnJld2VyeSBvZiBNYXJpZVxcJ3MgdW5jbGUuPGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiPiBDaG9vc2UgPC9idXR0b24+JywgZmVtSGlzdCwgZmVtSGlzdENob2ljZV0sXHJcbiAgICAgXHRcdC8vTmljb2xhZXMgVHVscFxyXG4gICAgIFx0XHRbNC44ODQ2OTYsIDUyLjM3MzU0NSwgJ05pY29sYWVzIFR1bHAgd2FzIGEgc3VyZ2VvbiBhbmQgZnJvbSAxNjU0IGhlIHdhcyBtYXlvciBvZiBBbXN0ZXJkYW0gZm91ciB0aW1lcy4gSGlzIGhvdXNlIGNhbiBiZSByZWNvZ25pc2VkIGJ5IHRoZSBzaWduYm9hcmQgYWJvdmUgdGhlIGRvb3IuIFBhaW50ZWQgYnkgUmVtYnJhbmR0IGluIG9uZSBvZiBoaXMgbW9zdCBmYW1vdXMgcGFpbnRpbmdzOiA8aW1nIHNyYz1cIiAnK3R1bHArJyBcIj4gPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmljb2xhZXNfVHVscFwiPldpa2k8L2E+PGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiPiBDaG9vc2UgPC9idXR0b24+JywgZG9tSGlzdCwgZG9tSGlzdENob2ljZV0sXHJcbiAgICAgXHRcdC8vQW5kcsOpIEhhemVzXHJcbiAgICAgXHRcdFs0Ljg5MzE5OSwgNTIuMzU1NTEyLCAnSW4gMjAwNSBhIHN0YXR1ZSB3YXMgcmFpc2VkIG9uIHRoZSBjb3JuZXIgb2YgdGhlIEFsYmVydCBDdXlwc3RyYWF0IGZvciBmb2xrIHNpbmdlciBBbmRyw6kgSGF6ZXMsIHdobyBkaWVkIGEgeWVhciBiZWZvcmUuIEhlIHdhcyBkaXNjb3ZlcmVkIGluIGEgcHViLCBieSBjb21lZGlhbiBhbmQgc2luZ2VyIEpvaG5ueSBLcmFhaWprYW1wIFNyLiwgd2hvIHNhdyA4LXllYXIgb2xkIEFuZHLDqSBzaW5naW5nIG9uIExpYmVyYXRpb24gRGF5LjxidXR0b24gY2xhc3M9XCJidXR0b25cIj4gQ2hvb3NlIDwvYnV0dG9uPicsIGRvbUhpc3QsIGRvbUhpc3RDaG9pY2VdLFxyXG4gICAgIFx0XHQvL09seW1waWNzXHJcbiAgICAgXHRcdFs0Ljg1NDEzLCA1Mi4zNDM0MjAsICdJbiAxOTI4IHRoZSBTdW1tZXIgT2x5bXBpY3Mgd2VyZSBoZWxkIGluIEFtc3RlcmRhbS4gRm9yIGEgbG90IG9mIGRhdGEgYW5kIHBhcnRpY2lwYXRpbmcgY291bnRyaWVzLCBzZWUgPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvMTkyOF9TdW1tZXJfT2x5bXBpY3NcIj4gV2lraXBlZGlhPC9hPjxidXR0b24gY2xhc3M9XCJidXR0b25cIj4gQ2hvb3NlIDwvYnV0dG9uPicsIGRvbUhpc3QsIGRvbUhpc3RDaG9pY2VdLFxyXG4gICAgIFx0XHQvL0RlYWYgb2x5bXBpY3NcclxuICAgICBcdFx0WzQuODU0MTMsIDUyLjM0MzQyMCwgJ0luIDE5MjgsIGZvciB0aGUgc2Vjb25kIHRpbWUgaW4gdGhlIGhpc3Rvcnkgb2YgdGhlIHdvcmxkLCB0aGUgRGVhZmx5bXBpY3Mgd2VyZSBoZWxkLiBTaW5jZSBkZWFmIGF0aGxldGVzIG5lZWQgb3RoZXIgc2lnbnMgdGhhbiBndW5zaG90cywgdGhlIGRlYWZseW1waWNzIGhhZCBzdGFydGVkIGZvdXIgeWVhcnMgZWFybGllciBpbiBQYXJpcy4gVGhleSBzdGlsbCBnbyBvbiB0b2RheSBhbmQgYXJlIGdlbmVyYWxseSBzZWVuIGFzIGEgdmVyeSBlYXJseSBwcmVjdXJzb3Igb2YgdGhlIHBhcmFseW1waWNzLCB0aGF0IGhhZCBpdHMgZmlyc3QgZWRpdGlvbiBhcyBsYXRlIGFzIDE5NjAuPGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiPiBDaG9vc2UgPC9idXR0b24+JywgZGlzSGlzdCwgZGlzSGlzdENob2ljZV0sXHJcbiAgICAgXHRcdC8vQ2Fmw6kgJ3QgTWFuZGplXHJcbiAgICAgXHRcdFs0LjkwMDk2LCA1Mi4zNzQ4NDAsICdUaGUgZmFtb3VzIENhZsOpIFxcJ3QgTWFuZGplLCBydW4gYnkgQmV0IHZhbiBCdXVyZW4gc2luY2UgMTkyNywgYW4gb3Blbmx5IGdheSB3b21hbi4gU2hlIHdhcyB0aGUgZmlyc3QgcHViIG93bmVyIHRoYXQgYWxsb3dlZCBvcGVubHkgZ2F5IHBlb3BsZSBpbiBoZXIgYmFyIChzaGUgZGlkIG5vdCBhbGxvdyBraXNzaW5nIG9mIHNhbWUgc2V4IGNvdXBsZXMgb24gZXZlcnkgZGF5IG9mIHRoZSB3ZWVrLiBUaGV5IGdvdCB0byBkYW5jZSB3aXRoIGVhY2ggb3RoZXIgb25seSBvbiBRdWVlbnNkYXkuKS4gXFwnVCBNYW5kamUgYmVjYW1lIHRoZSBtb3N0IGZhbW91cyBwbGFjZSBmb3IgZ2F5cyBpbiB0aGUgY2l0eSwgYW5kIHJlbWFpbmVkIHN1Y2ggdW50aWwgdGhlIFplZWRpamsgd2FzIHJ1bm92ZXIgYnkgd2hvcmVzIGFuZCBoZXJvaW4gdXNlcnMuIEl0IGNsb3NlZCBpdHMgZG9vcnMgaW4gMTk4MiwgYnV0IHdhcyByZW9wZW5lZCBpbiAyMDA4LjxidXR0b24gY2xhc3M9XCJidXR0b25cIj4gQ2hvb3NlIDwvYnV0dG9uPicsIGZlbUdheUhpc3QsIGZlbUdheUhpc3RDaG9pY2UgXVxyXG4gICAgICAgXHRcdF07XHJcbiAgICAgICAgIC8vTG9vcCB0aHJvdWdoIHRoZSBtYXJrZXJzIGFycmF5XHJcbiAgICAgICAgIGZvciAodmFyIGk9MDsgaTxtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgIFx0dmFyIG9wYWNpdHkgPSAxXHJcbiAgICAgICAgIFx0dmFyIHNlbGVjdGVkID0gZmFsc2VcclxuICAgICAgICAgIHZhciBsb24gPSBtYXJrZXJzW2ldWzBdO1xyXG4gICAgICAgICAgdmFyIGxhdCA9IG1hcmtlcnNbaV1bMV07XHJcbiAgICAgICAgICB2YXIgcG9wdXBUZXh0ID0gbWFya2Vyc1tpXVsyXTtcclxuICAgICAgICAgIHZhciBpbml0SWNvbiA9IEwuSWNvbi5leHRlbmQoe29wdGlvbnM6IHtpY29uVXJsOiBtYXJrZXJzW2ldWzNdLCBwb3B1cEFuY2hvcjogIFs1LCA3XSwgc2VsZWN0ZWQ6IHNlbGVjdGVkLCBvcGFjaXR5OiBvcGFjaXR5fSB9KTtcclxuICAgICAgICAgIHZhciBpZCA9IFtpXVxyXG4gICAgICAgICAgdmFyIG1hcmtlckxvY2F0aW9uID0gbmV3IEwuTGF0TG5nKGxhdCwgbG9uKTtcclxuICAgICAgICAgIHZhciBtYXJrZXIgPSBuZXcgTC5tYXJrZXIobWFya2VyTG9jYXRpb24sIHtpY29uOiBuZXcgaW5pdEljb259KTtcclxuICAgICAgICAgIG1hcC5hZGRMYXllcihtYXJrZXIpO1xyXG5cclxuICAgICAgICAgIG1hcmtlci5iaW5kUG9wdXAocG9wdXBUZXh0KTtcclxuXHJcblxyXG4gICAgICAgICAgdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCIuc2VsZWN0ZWRcIik7XHJcblxyXG4gICAgICAgICAgbWFya2VyLm9uKCdjbGljaycsIGZ1bmN0aW9uKG1hcmtlckRhdGEsIGUpe1xyXG4gICAgICAgICAgdmFyIGNob2ljZUljb24gPSBMLkljb24uZXh0ZW5kKHtvcHRpb25zOiB7aWNvblVybDogbWFya2VyRGF0YVs0XSwgcG9wdXBBbmNob3I6ICBbNSwgN10sIHNlbGVjdGVkOiB0cnVlfSB9KTsgXHJcbiAgICAgICAgICBlLnRhcmdldC5zZXRJY29uKCBuZXcgY2hvaWNlSWNvbil9LmJpbmQodGhpcywgbWFya2Vyc1tpXSlcclxuXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gIFx0XHQgfVxyXG4gICAgcmV0dXJuIG1hcFxyXG4gfSxcclxuXHJcbiBzZXR1cE1hcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMubWFwLnNldFZpZXcoW3RoaXMucHJvcHMubGF0LCB0aGlzLnByb3BzLmxvbl0sIHRoaXMucHJvcHMuem9vbSk7XHJcbiAgICB9LFxyXG5cclxuIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmNyZWF0ZU1hcCkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcCA9IHRoaXMucHJvcHMuY3JlYXRlTWFwKHRoaXMuZ2V0RE9NTm9kZSgpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1hcCA9IHRoaXMuY3JlYXRlTWFwKHRoaXMuZ2V0RE9NTm9kZSgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2V0dXBNYXAoKTtcclxuICAgIH0sXHJcblxyXG5cclxuIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICg8ZGl2IGNsYXNzTmFtZT1cIm1hcFwiPiA8L2Rpdj4pO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5cclxuUmVhY3QucmVuZGVyKDxNYXAgbGF0PVwiNTIuMzcxMFwiIGxvbj1cIjQuOTAwXCIgem9vbT1cIjE0XCIgLz4sIGRvY3VtZW50LmJvZHkpO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBEOi9Eb2N1bWVudGVuL0dpdEh1YlJlcG9zL21hcC1wcm9qZWN0L3NyYy9lbnRyeS5qc3hcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9');
},function(module,exports,__webpack_require__){eval("var isReactClassish = __webpack_require__(69);\n\nfunction isReactElementish(obj, React) {\n  if (!obj) {\n    return false;\n  }\n\n  return Object.prototype.toString.call(obj.props) === '[object Object]' &&\n         isReactClassish(obj.type, React);\n}\n\nmodule.exports = isReactElementish;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvaXNSZWFjdEVsZW1lbnRpc2guanM/ZTU4YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzUmVhY3RDbGFzc2lzaCA9IHJlcXVpcmUoJy4vaXNSZWFjdENsYXNzaXNoJyk7XG5cbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50aXNoKG9iaiwgUmVhY3QpIHtcbiAgaWYgKCFvYmopIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iai5wcm9wcykgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmXG4gICAgICAgICBpc1JlYWN0Q2xhc3Npc2gob2JqLnR5cGUsIFJlYWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1JlYWN0RWxlbWVudGlzaDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1ob3QtbG9hZGVyL2lzUmVhY3RFbGVtZW50aXNoLmpzXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar isReactClassish = __webpack_require__(69),\n    isReactElementish = __webpack_require__(110);\n\nfunction makeExportsHot(m, React) {\n  if (isReactElementish(m.exports, React)) {\n    // React elements are never valid React classes\n    return false;\n  }\n\n  var freshExports = m.exports,\n      exportsReactClass = isReactClassish(m.exports, React),\n      foundReactClasses = false;\n\n  if (exportsReactClass) {\n    m.exports = m.makeHot(m.exports, '__MODULE_EXPORTS');\n    foundReactClasses = true;\n  }\n\n  for (var key in m.exports) {\n    if (!Object.prototype.hasOwnProperty.call(freshExports, key)) {\n      continue;\n    }\n\n    if (exportsReactClass && key === 'type') {\n      // React 0.12 also puts classes under `type` property for compat.\n      // Skip to avoid updating twice.\n      continue;\n    }\n\n    if (!isReactClassish(freshExports[key], React)) {\n      continue;\n    }\n\n    if (Object.getOwnPropertyDescriptor(m.exports, key).writable) {\n      m.exports[key] = m.makeHot(freshExports[key], '__MODULE_EXPORTS_' + key);\n      foundReactClasses = true;\n    } else {\n      console.warn(\"Can't make class \" + key + \" hot reloadable due to being read-only. You can exclude files or directories (for example, /node_modules/) using 'exclude' option in loader configuration.\");\n    }\n  }\n\n  return foundReactClasses;\n}\n\nmodule.exports = makeExportsHot;\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvbWFrZUV4cG9ydHNIb3QuanM/ZDU0MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIxMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc1JlYWN0Q2xhc3Npc2ggPSByZXF1aXJlKCcuL2lzUmVhY3RDbGFzc2lzaCcpLFxuICAgIGlzUmVhY3RFbGVtZW50aXNoID0gcmVxdWlyZSgnLi9pc1JlYWN0RWxlbWVudGlzaCcpO1xuXG5mdW5jdGlvbiBtYWtlRXhwb3J0c0hvdChtLCBSZWFjdCkge1xuICBpZiAoaXNSZWFjdEVsZW1lbnRpc2gobS5leHBvcnRzLCBSZWFjdCkpIHtcbiAgICAvLyBSZWFjdCBlbGVtZW50cyBhcmUgbmV2ZXIgdmFsaWQgUmVhY3QgY2xhc3Nlc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBmcmVzaEV4cG9ydHMgPSBtLmV4cG9ydHMsXG4gICAgICBleHBvcnRzUmVhY3RDbGFzcyA9IGlzUmVhY3RDbGFzc2lzaChtLmV4cG9ydHMsIFJlYWN0KSxcbiAgICAgIGZvdW5kUmVhY3RDbGFzc2VzID0gZmFsc2U7XG5cbiAgaWYgKGV4cG9ydHNSZWFjdENsYXNzKSB7XG4gICAgbS5leHBvcnRzID0gbS5tYWtlSG90KG0uZXhwb3J0cywgJ19fTU9EVUxFX0VYUE9SVFMnKTtcbiAgICBmb3VuZFJlYWN0Q2xhc3NlcyA9IHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gbS5leHBvcnRzKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZnJlc2hFeHBvcnRzLCBrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoZXhwb3J0c1JlYWN0Q2xhc3MgJiYga2V5ID09PSAndHlwZScpIHtcbiAgICAgIC8vIFJlYWN0IDAuMTIgYWxzbyBwdXRzIGNsYXNzZXMgdW5kZXIgYHR5cGVgIHByb3BlcnR5IGZvciBjb21wYXQuXG4gICAgICAvLyBTa2lwIHRvIGF2b2lkIHVwZGF0aW5nIHR3aWNlLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCFpc1JlYWN0Q2xhc3Npc2goZnJlc2hFeHBvcnRzW2tleV0sIFJlYWN0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobS5leHBvcnRzLCBrZXkpLndyaXRhYmxlKSB7XG4gICAgICBtLmV4cG9ydHNba2V5XSA9IG0ubWFrZUhvdChmcmVzaEV4cG9ydHNba2V5XSwgJ19fTU9EVUxFX0VYUE9SVFNfJyArIGtleSk7XG4gICAgICBmb3VuZFJlYWN0Q2xhc3NlcyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNhbid0IG1ha2UgY2xhc3MgXCIgKyBrZXkgKyBcIiBob3QgcmVsb2FkYWJsZSBkdWUgdG8gYmVpbmcgcmVhZC1vbmx5LiBZb3UgY2FuIGV4Y2x1ZGUgZmlsZXMgb3IgZGlyZWN0b3JpZXMgKGZvciBleGFtcGxlLCAvbm9kZV9tb2R1bGVzLykgdXNpbmcgJ2V4Y2x1ZGUnIG9wdGlvbiBpbiBsb2FkZXIgY29uZmlndXJhdGlvbi5cIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvdW5kUmVhY3RDbGFzc2VzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1ha2VFeHBvcnRzSG90O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtaG90LWxvYWRlci9tYWtlRXhwb3J0c0hvdC5qc1xuICoqIG1vZHVsZSBpZCA9IDExMVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("'use strict';\n\nfunction bindAutoBindMethod(component, method) {\n  var boundMethod = method.bind(component);\n\n  boundMethod.__reactBoundContext = component;\n  boundMethod.__reactBoundMethod = method;\n  boundMethod.__reactBoundArguments = null;\n\n  var componentName = component.constructor.displayName,\n      _bind = boundMethod.bind;\n\n  boundMethod.bind = function (newThis) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (newThis !== component && newThis !== null) {\n      console.warn(\n        'bind(): React component methods may only be bound to the ' +\n        'component instance. See ' + componentName\n      );\n    } else if (!args.length) {\n      console.warn(\n        'bind(): You are binding a component method to the component. ' +\n        'React does this for you automatically in a high-performance ' +\n        'way, so you can safely remove this call. See ' + componentName\n      );\n      return boundMethod;\n    }\n\n    var reboundMethod = _bind.apply(boundMethod, arguments);\n    reboundMethod.__reactBoundContext = component;\n    reboundMethod.__reactBoundMethod = method;\n    reboundMethod.__reactBoundArguments = args;\n\n    return reboundMethod;\n  };\n\n  return boundMethod;\n}\n\n/**\n * Performs auto-binding similar to how React does it.\n * Skips already auto-bound methods.\n * Based on https://github.com/facebook/react/blob/b264372e2b3ad0b0c0c0cc95a2f383e4a1325c3d/src/classic/class/ReactClass.js#L639-L705\n */\nmodule.exports = function bindAutoBindMethods(internalInstance) {\n  var component = typeof internalInstance.getPublicInstance === 'function' ?\n    internalInstance.getPublicInstance() :\n    internalInstance;\n\n  for (var autoBindKey in component.__reactAutoBindMap) {\n    if (!component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {\n      continue;\n    }\n\n    // Skip already bound methods\n    if (component.hasOwnProperty(autoBindKey) &&\n        component[autoBindKey].__reactBoundContext === component) {\n      continue;\n    }\n\n    var method = component.__reactAutoBindMap[autoBindKey];\n    component[autoBindKey] = bindAutoBindMethod(component, method);\n  }\n};//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvfi9yZWFjdC1ob3QtYXBpL21vZHVsZXMvYmluZEF1dG9CaW5kTWV0aG9kcy5qcz84ZGQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjExMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG5cbiAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuXG4gIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lLFxuICAgICAgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuXG4gIGJvdW5kTWV0aG9kLmJpbmQgPSBmdW5jdGlvbiAobmV3VGhpcykge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ2JpbmQoKTogUmVhY3QgY29tcG9uZW50IG1ldGhvZHMgbWF5IG9ubHkgYmUgYm91bmQgdG8gdGhlICcgK1xuICAgICAgICAnY29tcG9uZW50IGluc3RhbmNlLiBTZWUgJyArIGNvbXBvbmVudE5hbWVcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICtcbiAgICAgICAgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgK1xuICAgICAgICAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJyArIGNvbXBvbmVudE5hbWVcbiAgICAgICk7XG4gICAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gICAgfVxuXG4gICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuXG4gICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gIH07XG5cbiAgcmV0dXJuIGJvdW5kTWV0aG9kO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGF1dG8tYmluZGluZyBzaW1pbGFyIHRvIGhvdyBSZWFjdCBkb2VzIGl0LlxuICogU2tpcHMgYWxyZWFkeSBhdXRvLWJvdW5kIG1ldGhvZHMuXG4gKiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iMjY0MzcyZTJiM2FkMGIwYzBjMGNjOTVhMmYzODNlNGExMzI1YzNkL3NyYy9jbGFzc2ljL2NsYXNzL1JlYWN0Q2xhc3MuanMjTDYzOS1MNzA1XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kcyhpbnRlcm5hbEluc3RhbmNlKSB7XG4gIHZhciBjb21wb25lbnQgPSB0eXBlb2YgaW50ZXJuYWxJbnN0YW5jZS5nZXRQdWJsaWNJbnN0YW5jZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5nZXRQdWJsaWNJbnN0YW5jZSgpIDpcbiAgICBpbnRlcm5hbEluc3RhbmNlO1xuXG4gIGZvciAodmFyIGF1dG9CaW5kS2V5IGluIGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICBpZiAoIWNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXAuaGFzT3duUHJvcGVydHkoYXV0b0JpbmRLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGFscmVhZHkgYm91bmQgbWV0aG9kc1xuICAgIGlmIChjb21wb25lbnQuaGFzT3duUHJvcGVydHkoYXV0b0JpbmRLZXkpICYmXG4gICAgICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0uX19yZWFjdEJvdW5kQ29udGV4dCA9PT0gY29tcG9uZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbWV0aG9kID0gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZE1hcFthdXRvQmluZEtleV07XG4gICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtaG90LWxvYWRlci9+L3JlYWN0LWhvdC1hcGkvbW9kdWxlcy9iaW5kQXV0b0JpbmRNZXRob2RzLmpzXG4gKiogbW9kdWxlIGlkID0gMTEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar bindAutoBindMethods = __webpack_require__(112);\nvar traverseRenderedChildren = __webpack_require__(119);\n\nfunction setPendingForceUpdate(internalInstance) {\n  if (internalInstance._pendingForceUpdate === false) {\n    internalInstance._pendingForceUpdate = true;\n  }\n}\n\nfunction forceUpdateIfPending(internalInstance, React) {\n  if (internalInstance._pendingForceUpdate === true) {\n    // `|| internalInstance` for React 0.12 and earlier\n    var instance = internalInstance._instance || internalInstance;\n\n    if (instance.forceUpdate) {\n      instance.forceUpdate();\n    } else if (React && React.Component) {\n      React.Component.prototype.forceUpdate.call(instance);\n    }\n  }\n}\n\n/**\n * Updates a React component recursively, so even if children define funky\n * `shouldComponentUpdate`, they are forced to re-render.\n * Makes sure that any newly added methods are properly auto-bound.\n */\nfunction deepForceUpdate(internalInstance, React) {\n  traverseRenderedChildren(internalInstance, bindAutoBindMethods);\n  traverseRenderedChildren(internalInstance, setPendingForceUpdate);\n  traverseRenderedChildren(internalInstance, forceUpdateIfPending, React);\n}\n\nmodule.exports = deepForceUpdate;\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvfi9yZWFjdC1ob3QtYXBpL21vZHVsZXMvZGVlcEZvcmNlVXBkYXRlLmpzPzgwYzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZEF1dG9CaW5kTWV0aG9kcyA9IHJlcXVpcmUoJy4vYmluZEF1dG9CaW5kTWV0aG9kcycpO1xudmFyIHRyYXZlcnNlUmVuZGVyZWRDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VSZW5kZXJlZENoaWxkcmVuJyk7XG5cbmZ1bmN0aW9uIHNldFBlbmRpbmdGb3JjZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRm9yY2VVcGRhdGUgPT09IGZhbHNlKSB7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmUGVuZGluZyhpbnRlcm5hbEluc3RhbmNlLCBSZWFjdCkge1xuICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0ZvcmNlVXBkYXRlID09PSB0cnVlKSB7XG4gICAgLy8gYHx8IGludGVybmFsSW5zdGFuY2VgIGZvciBSZWFjdCAwLjEyIGFuZCBlYXJsaWVyXG4gICAgdmFyIGluc3RhbmNlID0gaW50ZXJuYWxJbnN0YW5jZS5faW5zdGFuY2UgfHwgaW50ZXJuYWxJbnN0YW5jZTtcblxuICAgIGlmIChpbnN0YW5jZS5mb3JjZVVwZGF0ZSkge1xuICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICB9IGVsc2UgaWYgKFJlYWN0ICYmIFJlYWN0LkNvbXBvbmVudCkge1xuICAgICAgUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZS5jYWxsKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBVcGRhdGVzIGEgUmVhY3QgY29tcG9uZW50IHJlY3Vyc2l2ZWx5LCBzbyBldmVuIGlmIGNoaWxkcmVuIGRlZmluZSBmdW5reVxuICogYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIHRoZXkgYXJlIGZvcmNlZCB0byByZS1yZW5kZXIuXG4gKiBNYWtlcyBzdXJlIHRoYXQgYW55IG5ld2x5IGFkZGVkIG1ldGhvZHMgYXJlIHByb3Blcmx5IGF1dG8tYm91bmQuXG4gKi9cbmZ1bmN0aW9uIGRlZXBGb3JjZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlLCBSZWFjdCkge1xuICB0cmF2ZXJzZVJlbmRlcmVkQ2hpbGRyZW4oaW50ZXJuYWxJbnN0YW5jZSwgYmluZEF1dG9CaW5kTWV0aG9kcyk7XG4gIHRyYXZlcnNlUmVuZGVyZWRDaGlsZHJlbihpbnRlcm5hbEluc3RhbmNlLCBzZXRQZW5kaW5nRm9yY2VVcGRhdGUpO1xuICB0cmF2ZXJzZVJlbmRlcmVkQ2hpbGRyZW4oaW50ZXJuYWxJbnN0YW5jZSwgZm9yY2VVcGRhdGVJZlBlbmRpbmcsIFJlYWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwRm9yY2VVcGRhdGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1ob3QtbG9hZGVyL34vcmVhY3QtaG90LWFwaS9tb2R1bGVzL2RlZXBGb3JjZVVwZGF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("'use strict';\n\nmodule.exports = __webpack_require__(116);//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvfi9yZWFjdC1ob3QtYXBpL21vZHVsZXMvaW5kZXguanM/NWFjZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSIsImZpbGUiOiIxMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tYWtlTWFrZUhvdCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LWhvdC1sb2FkZXIvfi9yZWFjdC1ob3QtYXBpL21vZHVsZXMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n\n/**\n * Returns a function that establishes the first prototype passed to it\n * as the \"source of truth\" and patches its methods on subsequent invocations,\n * also patching current and previous prototypes to forward calls to it.\n */\nmodule.exports = function makeAssimilatePrototype() {\n  var storedPrototype,\n      knownPrototypes = [];\n\n  function wrapMethod(key) {\n    return function () {\n      if (storedPrototype[key]) {\n        return storedPrototype[key].apply(this, arguments);\n      }\n    };\n  }\n\n  function patchProperty(proto, key) {\n    proto[key] = storedPrototype[key];\n\n    if (typeof proto[key] !== 'function' ||\n      key === 'type' ||\n      key === 'constructor') {\n      return;\n    }\n\n    proto[key] = wrapMethod(key);\n\n    if (storedPrototype[key].isReactClassApproved) {\n      proto[key].isReactClassApproved = storedPrototype[key].isReactClassApproved;\n    }\n\n    if (proto.__reactAutoBindMap && proto.__reactAutoBindMap[key]) {\n      proto.__reactAutoBindMap[key] = proto[key];\n    }\n  }\n\n  function updateStoredPrototype(freshPrototype) {\n    storedPrototype = {};\n\n    Object.getOwnPropertyNames(freshPrototype).forEach(function (key) {\n      storedPrototype[key] = freshPrototype[key];\n    });\n  }\n\n  function reconcileWithStoredPrototypes(freshPrototype) {\n    knownPrototypes.push(freshPrototype);\n    knownPrototypes.forEach(function (proto) {\n      Object.getOwnPropertyNames(storedPrototype).forEach(function (key) {\n        patchProperty(proto, key);\n      });\n    });\n  }\n\n  return function assimilatePrototype(freshPrototype) {\n    if (Object.prototype.hasOwnProperty.call(freshPrototype, '__isAssimilatedByReactHotAPI')) {\n      return;\n    }\n\n    updateStoredPrototype(freshPrototype);\n    reconcileWithStoredPrototypes(freshPrototype);\n    freshPrototype.__isAssimilatedByReactHotAPI = true;\n  };\n};//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvfi9yZWFjdC1ob3QtYXBpL21vZHVsZXMvbWFrZUFzc2ltaWxhdGVQcm90b3R5cGUuanM/NTA2YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGVzdGFibGlzaGVzIHRoZSBmaXJzdCBwcm90b3R5cGUgcGFzc2VkIHRvIGl0XG4gKiBhcyB0aGUgXCJzb3VyY2Ugb2YgdHJ1dGhcIiBhbmQgcGF0Y2hlcyBpdHMgbWV0aG9kcyBvbiBzdWJzZXF1ZW50IGludm9jYXRpb25zLFxuICogYWxzbyBwYXRjaGluZyBjdXJyZW50IGFuZCBwcmV2aW91cyBwcm90b3R5cGVzIHRvIGZvcndhcmQgY2FsbHMgdG8gaXQuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWFrZUFzc2ltaWxhdGVQcm90b3R5cGUoKSB7XG4gIHZhciBzdG9yZWRQcm90b3R5cGUsXG4gICAgICBrbm93blByb3RvdHlwZXMgPSBbXTtcblxuICBmdW5jdGlvbiB3cmFwTWV0aG9kKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc3RvcmVkUHJvdG90eXBlW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIHN0b3JlZFByb3RvdHlwZVtrZXldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoUHJvcGVydHkocHJvdG8sIGtleSkge1xuICAgIHByb3RvW2tleV0gPSBzdG9yZWRQcm90b3R5cGVba2V5XTtcblxuICAgIGlmICh0eXBlb2YgcHJvdG9ba2V5XSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAga2V5ID09PSAndHlwZScgfHxcbiAgICAgIGtleSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByb3RvW2tleV0gPSB3cmFwTWV0aG9kKGtleSk7XG5cbiAgICBpZiAoc3RvcmVkUHJvdG90eXBlW2tleV0uaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIHByb3RvW2tleV0uaXNSZWFjdENsYXNzQXBwcm92ZWQgPSBzdG9yZWRQcm90b3R5cGVba2V5XS5pc1JlYWN0Q2xhc3NBcHByb3ZlZDtcbiAgICB9XG5cbiAgICBpZiAocHJvdG8uX19yZWFjdEF1dG9CaW5kTWFwICYmIHByb3RvLl9fcmVhY3RBdXRvQmluZE1hcFtrZXldKSB7XG4gICAgICBwcm90by5fX3JlYWN0QXV0b0JpbmRNYXBba2V5XSA9IHByb3RvW2tleV07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU3RvcmVkUHJvdG90eXBlKGZyZXNoUHJvdG90eXBlKSB7XG4gICAgc3RvcmVkUHJvdG90eXBlID0ge307XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhmcmVzaFByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBzdG9yZWRQcm90b3R5cGVba2V5XSA9IGZyZXNoUHJvdG90eXBlW2tleV07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVXaXRoU3RvcmVkUHJvdG90eXBlcyhmcmVzaFByb3RvdHlwZSkge1xuICAgIGtub3duUHJvdG90eXBlcy5wdXNoKGZyZXNoUHJvdG90eXBlKTtcbiAgICBrbm93blByb3RvdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvdG8pIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0b3JlZFByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHBhdGNoUHJvcGVydHkocHJvdG8sIGtleSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBhc3NpbWlsYXRlUHJvdG90eXBlKGZyZXNoUHJvdG90eXBlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmcmVzaFByb3RvdHlwZSwgJ19faXNBc3NpbWlsYXRlZEJ5UmVhY3RIb3RBUEknKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZVN0b3JlZFByb3RvdHlwZShmcmVzaFByb3RvdHlwZSk7XG4gICAgcmVjb25jaWxlV2l0aFN0b3JlZFByb3RvdHlwZXMoZnJlc2hQcm90b3R5cGUpO1xuICAgIGZyZXNoUHJvdG90eXBlLl9faXNBc3NpbWlsYXRlZEJ5UmVhY3RIb3RBUEkgPSB0cnVlO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1ob3QtbG9hZGVyL34vcmVhY3QtaG90LWFwaS9tb2R1bGVzL21ha2VBc3NpbWlsYXRlUHJvdG90eXBlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar makePatchReactClass = __webpack_require__(117);\n\n/**\n * Returns a function that, when invoked, patches a React class with a new\n * version of itself. To patch different classes, pass different IDs.\n */\nmodule.exports = function makeMakeHot(getRootInstances, React) {\n  if (typeof getRootInstances !== 'function') {\n    throw new Error('Expected getRootInstances to be a function.');\n  }\n\n  var patchers = {};\n\n  return function makeHot(NextClass, persistentId) {\n    persistentId = persistentId || NextClass.displayName || NextClass.name;\n\n    if (!persistentId) {\n      console.error(\n        'Hot reload is disabled for one of your types. To enable it, pass a ' +\n        'string uniquely identifying this class within this current module ' +\n        'as a second parameter to makeHot.'\n      );\n      return NextClass;\n    }\n\n    if (!patchers[persistentId]) {\n      patchers[persistentId] = makePatchReactClass(getRootInstances, React);\n    }\n\n    var patchReactClass = patchers[persistentId];\n    return patchReactClass(NextClass);\n  };\n};//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvfi9yZWFjdC1ob3QtYXBpL21vZHVsZXMvbWFrZU1ha2VIb3QuanM/ZTYwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFrZVBhdGNoUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vbWFrZVBhdGNoUmVhY3RDbGFzcycpO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGludm9rZWQsIHBhdGNoZXMgYSBSZWFjdCBjbGFzcyB3aXRoIGEgbmV3XG4gKiB2ZXJzaW9uIG9mIGl0c2VsZi4gVG8gcGF0Y2ggZGlmZmVyZW50IGNsYXNzZXMsIHBhc3MgZGlmZmVyZW50IElEcy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYWtlTWFrZUhvdChnZXRSb290SW5zdGFuY2VzLCBSZWFjdCkge1xuICBpZiAodHlwZW9mIGdldFJvb3RJbnN0YW5jZXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGdldFJvb3RJbnN0YW5jZXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciBwYXRjaGVycyA9IHt9O1xuXG4gIHJldHVybiBmdW5jdGlvbiBtYWtlSG90KE5leHRDbGFzcywgcGVyc2lzdGVudElkKSB7XG4gICAgcGVyc2lzdGVudElkID0gcGVyc2lzdGVudElkIHx8IE5leHRDbGFzcy5kaXNwbGF5TmFtZSB8fCBOZXh0Q2xhc3MubmFtZTtcblxuICAgIGlmICghcGVyc2lzdGVudElkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnSG90IHJlbG9hZCBpcyBkaXNhYmxlZCBmb3Igb25lIG9mIHlvdXIgdHlwZXMuIFRvIGVuYWJsZSBpdCwgcGFzcyBhICcgK1xuICAgICAgICAnc3RyaW5nIHVuaXF1ZWx5IGlkZW50aWZ5aW5nIHRoaXMgY2xhc3Mgd2l0aGluIHRoaXMgY3VycmVudCBtb2R1bGUgJyArXG4gICAgICAgICdhcyBhIHNlY29uZCBwYXJhbWV0ZXIgdG8gbWFrZUhvdC4nXG4gICAgICApO1xuICAgICAgcmV0dXJuIE5leHRDbGFzcztcbiAgICB9XG5cbiAgICBpZiAoIXBhdGNoZXJzW3BlcnNpc3RlbnRJZF0pIHtcbiAgICAgIHBhdGNoZXJzW3BlcnNpc3RlbnRJZF0gPSBtYWtlUGF0Y2hSZWFjdENsYXNzKGdldFJvb3RJbnN0YW5jZXMsIFJlYWN0KTtcbiAgICB9XG5cbiAgICB2YXIgcGF0Y2hSZWFjdENsYXNzID0gcGF0Y2hlcnNbcGVyc2lzdGVudElkXTtcbiAgICByZXR1cm4gcGF0Y2hSZWFjdENsYXNzKE5leHRDbGFzcyk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LWhvdC1sb2FkZXIvfi9yZWFjdC1ob3QtYXBpL21vZHVsZXMvbWFrZU1ha2VIb3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar makeAssimilatePrototype = __webpack_require__(115),\n    requestForceUpdateAll = __webpack_require__(118);\n\nfunction hasNonStubTypeProperty(ReactClass) {\n  if (!ReactClass.hasOwnProperty('type')) {\n    return false;\n  }\n\n  var descriptor = Object.getOwnPropertyDescriptor(ReactClass, 'type');\n  if (typeof descriptor.get === 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getPrototype(ReactClass) {\n  var prototype = ReactClass.prototype,\n      seemsLegit = prototype && typeof prototype.render === 'function';\n\n  if (!seemsLegit && hasNonStubTypeProperty(ReactClass)) {\n    prototype = ReactClass.type.prototype;\n  }\n\n  return prototype;\n}\n\n/**\n * Returns a function that will patch React class with new versions of itself\n * on subsequent invocations. Both legacy and ES6 style classes are supported.\n */\nmodule.exports = function makePatchReactClass(getRootInstances, React) {\n  var assimilatePrototype = makeAssimilatePrototype(),\n      FirstClass = null;\n\n  return function patchReactClass(NextClass) {\n    var nextPrototype = getPrototype(NextClass);\n    assimilatePrototype(nextPrototype);\n\n    if (FirstClass) {\n      requestForceUpdateAll(getRootInstances, React);\n    }\n\n    return FirstClass || (FirstClass = NextClass);\n  };\n};//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvfi9yZWFjdC1ob3QtYXBpL21vZHVsZXMvbWFrZVBhdGNoUmVhY3RDbGFzcy5qcz9lNTAyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFrZUFzc2ltaWxhdGVQcm90b3R5cGUgPSByZXF1aXJlKCcuL21ha2VBc3NpbWlsYXRlUHJvdG90eXBlJyksXG4gICAgcmVxdWVzdEZvcmNlVXBkYXRlQWxsID0gcmVxdWlyZSgnLi9yZXF1ZXN0Rm9yY2VVcGRhdGVBbGwnKTtcblxuZnVuY3Rpb24gaGFzTm9uU3R1YlR5cGVQcm9wZXJ0eShSZWFjdENsYXNzKSB7XG4gIGlmICghUmVhY3RDbGFzcy5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJlYWN0Q2xhc3MsICd0eXBlJyk7XG4gIGlmICh0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvdG90eXBlKFJlYWN0Q2xhc3MpIHtcbiAgdmFyIHByb3RvdHlwZSA9IFJlYWN0Q2xhc3MucHJvdG90eXBlLFxuICAgICAgc2VlbXNMZWdpdCA9IHByb3RvdHlwZSAmJiB0eXBlb2YgcHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJztcblxuICBpZiAoIXNlZW1zTGVnaXQgJiYgaGFzTm9uU3R1YlR5cGVQcm9wZXJ0eShSZWFjdENsYXNzKSkge1xuICAgIHByb3RvdHlwZSA9IFJlYWN0Q2xhc3MudHlwZS5wcm90b3R5cGU7XG4gIH1cblxuICByZXR1cm4gcHJvdG90eXBlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcGF0Y2ggUmVhY3QgY2xhc3Mgd2l0aCBuZXcgdmVyc2lvbnMgb2YgaXRzZWxmXG4gKiBvbiBzdWJzZXF1ZW50IGludm9jYXRpb25zLiBCb3RoIGxlZ2FjeSBhbmQgRVM2IHN0eWxlIGNsYXNzZXMgYXJlIHN1cHBvcnRlZC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYWtlUGF0Y2hSZWFjdENsYXNzKGdldFJvb3RJbnN0YW5jZXMsIFJlYWN0KSB7XG4gIHZhciBhc3NpbWlsYXRlUHJvdG90eXBlID0gbWFrZUFzc2ltaWxhdGVQcm90b3R5cGUoKSxcbiAgICAgIEZpcnN0Q2xhc3MgPSBudWxsO1xuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaFJlYWN0Q2xhc3MoTmV4dENsYXNzKSB7XG4gICAgdmFyIG5leHRQcm90b3R5cGUgPSBnZXRQcm90b3R5cGUoTmV4dENsYXNzKTtcbiAgICBhc3NpbWlsYXRlUHJvdG90eXBlKG5leHRQcm90b3R5cGUpO1xuXG4gICAgaWYgKEZpcnN0Q2xhc3MpIHtcbiAgICAgIHJlcXVlc3RGb3JjZVVwZGF0ZUFsbChnZXRSb290SW5zdGFuY2VzLCBSZWFjdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZpcnN0Q2xhc3MgfHwgKEZpcnN0Q2xhc3MgPSBOZXh0Q2xhc3MpO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1ob3QtbG9hZGVyL34vcmVhY3QtaG90LWFwaS9tb2R1bGVzL21ha2VQYXRjaFJlYWN0Q2xhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("var deepForceUpdate = __webpack_require__(113);\n\nvar isRequestPending = false;\n\nmodule.exports = function requestForceUpdateAll(getRootInstances, React) {\n  if (isRequestPending) {\n    return;\n  }\n\n  /**\n   * Forces deep re-render of all mounted React components.\n   * Hat's off to Omar Skalli (@Chetane) for suggesting this approach:\n   * https://gist.github.com/Chetane/9a230a9fdcdca21a4e29\n   */\n  function forceUpdateAll() {\n    isRequestPending = false;\n\n    var rootInstances = getRootInstances(),\n        rootInstance;\n\n    for (var key in rootInstances) {\n      if (rootInstances.hasOwnProperty(key)) {\n        rootInstance = rootInstances[key];\n\n        // `|| rootInstance` for React 0.12 and earlier\n        rootInstance = rootInstance._reactInternalInstance || rootInstance;\n        deepForceUpdate(rootInstance, React);\n      }\n    }\n  }\n\n  setTimeout(forceUpdateAll);\n};//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvfi9yZWFjdC1ob3QtYXBpL21vZHVsZXMvcmVxdWVzdEZvcmNlVXBkYXRlQWxsLmpzPzhlMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMTE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRlZXBGb3JjZVVwZGF0ZSA9IHJlcXVpcmUoJy4vZGVlcEZvcmNlVXBkYXRlJyk7XG5cbnZhciBpc1JlcXVlc3RQZW5kaW5nID0gZmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWVzdEZvcmNlVXBkYXRlQWxsKGdldFJvb3RJbnN0YW5jZXMsIFJlYWN0KSB7XG4gIGlmIChpc1JlcXVlc3RQZW5kaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBkZWVwIHJlLXJlbmRlciBvZiBhbGwgbW91bnRlZCBSZWFjdCBjb21wb25lbnRzLlxuICAgKiBIYXQncyBvZmYgdG8gT21hciBTa2FsbGkgKEBDaGV0YW5lKSBmb3Igc3VnZ2VzdGluZyB0aGlzIGFwcHJvYWNoOlxuICAgKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9DaGV0YW5lLzlhMjMwYTlmZGNkY2EyMWE0ZTI5XG4gICAqL1xuICBmdW5jdGlvbiBmb3JjZVVwZGF0ZUFsbCgpIHtcbiAgICBpc1JlcXVlc3RQZW5kaW5nID0gZmFsc2U7XG5cbiAgICB2YXIgcm9vdEluc3RhbmNlcyA9IGdldFJvb3RJbnN0YW5jZXMoKSxcbiAgICAgICAgcm9vdEluc3RhbmNlO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHJvb3RJbnN0YW5jZXMpIHtcbiAgICAgIGlmIChyb290SW5zdGFuY2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcm9vdEluc3RhbmNlID0gcm9vdEluc3RhbmNlc1trZXldO1xuXG4gICAgICAgIC8vIGB8fCByb290SW5zdGFuY2VgIGZvciBSZWFjdCAwLjEyIGFuZCBlYXJsaWVyXG4gICAgICAgIHJvb3RJbnN0YW5jZSA9IHJvb3RJbnN0YW5jZS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlIHx8IHJvb3RJbnN0YW5jZTtcbiAgICAgICAgZGVlcEZvcmNlVXBkYXRlKHJvb3RJbnN0YW5jZSwgUmVhY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldFRpbWVvdXQoZm9yY2VVcGRhdGVBbGwpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1ob3QtbG9hZGVyL34vcmVhY3QtaG90LWFwaS9tb2R1bGVzL3JlcXVlc3RGb3JjZVVwZGF0ZUFsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDExOFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("'use strict';\n\nfunction traverseRenderedChildren(internalInstance, callback, argument) {\n  callback(internalInstance, argument);\n\n  if (internalInstance._renderedComponent) {\n    traverseRenderedChildren(\n      internalInstance._renderedComponent,\n      callback,\n      argument\n    );\n  } else {\n    for (var key in internalInstance._renderedChildren) {\n      traverseRenderedChildren(\n        internalInstance._renderedChildren[key],\n        callback,\n        argument\n      );\n    }\n  }\n}\n\nmodule.exports = traverseRenderedChildren;\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvfi9yZWFjdC1ob3QtYXBpL21vZHVsZXMvdHJhdmVyc2VSZW5kZXJlZENoaWxkcmVuLmpzPzkwZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjExOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gdHJhdmVyc2VSZW5kZXJlZENoaWxkcmVuKGludGVybmFsSW5zdGFuY2UsIGNhbGxiYWNrLCBhcmd1bWVudCkge1xuICBjYWxsYmFjayhpbnRlcm5hbEluc3RhbmNlLCBhcmd1bWVudCk7XG5cbiAgaWYgKGludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgdHJhdmVyc2VSZW5kZXJlZENoaWxkcmVuKFxuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQsXG4gICAgICBjYWxsYmFjayxcbiAgICAgIGFyZ3VtZW50XG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgdHJhdmVyc2VSZW5kZXJlZENoaWxkcmVuKFxuICAgICAgICBpbnRlcm5hbEluc3RhbmNlLl9yZW5kZXJlZENoaWxkcmVuW2tleV0sXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBhcmd1bWVudFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZVJlbmRlcmVkQ2hpbGRyZW47XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1ob3QtbG9hZGVyL34vcmVhY3QtaG90LWFwaS9tb2R1bGVzL3RyYXZlcnNlUmVuZGVyZWRDaGlsZHJlbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExOVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");
},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(module,exports,__webpack_require__){eval('/*\r\n	MIT License http://www.opensource.org/licenses/mit-license.php\r\n	Author Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n	memoize = function(fn) {\r\n		var memo;\r\n		return function () {\r\n			if (typeof memo === "undefined") memo = fn.apply(this, arguments);\r\n			return memo;\r\n		};\r\n	},\r\n	isIE9 = memoize(function() {\r\n		return /msie 9\\b/.test(window.navigator.userAgent.toLowerCase());\r\n	}),\r\n	getHeadElement = memoize(function () {\r\n		return document.head || document.getElementsByTagName("head")[0];\r\n	}),\r\n	singletonElement = null,\r\n	singletonCounter = 0;\r\n\r\nmodule.exports = function(list, options) {\r\n	if(false) {\r\n		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\r\n	}\r\n\r\n	options = options || {};\r\n	// Force single-tag solution on IE9, which has a hard limit on the # of <style>\r\n	// tags it will allow on a page\r\n	if (typeof options.singleton === "undefined") options.singleton = isIE9();\r\n\r\n	var styles = listToStyles(list);\r\n	addStylesToDom(styles, options);\r\n\r\n	return function update(newList) {\r\n		var mayRemove = [];\r\n		for(var i = 0; i < styles.length; i++) {\r\n			var item = styles[i];\r\n			var domStyle = stylesInDom[item.id];\r\n			domStyle.refs--;\r\n			mayRemove.push(domStyle);\r\n		}\r\n		if(newList) {\r\n			var newStyles = listToStyles(newList);\r\n			addStylesToDom(newStyles, options);\r\n		}\r\n		for(var i = 0; i < mayRemove.length; i++) {\r\n			var domStyle = mayRemove[i];\r\n			if(domStyle.refs === 0) {\r\n				for(var j = 0; j < domStyle.parts.length; j++)\r\n					domStyle.parts[j]();\r\n				delete stylesInDom[domStyle.id];\r\n			}\r\n		}\r\n	};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n	for(var i = 0; i < styles.length; i++) {\r\n		var item = styles[i];\r\n		var domStyle = stylesInDom[item.id];\r\n		if(domStyle) {\r\n			domStyle.refs++;\r\n			for(var j = 0; j < domStyle.parts.length; j++) {\r\n				domStyle.parts[j](item.parts[j]);\r\n			}\r\n			for(; j < item.parts.length; j++) {\r\n				domStyle.parts.push(addStyle(item.parts[j], options));\r\n			}\r\n		} else {\r\n			var parts = [];\r\n			for(var j = 0; j < item.parts.length; j++) {\r\n				parts.push(addStyle(item.parts[j], options));\r\n			}\r\n			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n		}\r\n	}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n	var styles = [];\r\n	var newStyles = {};\r\n	for(var i = 0; i < list.length; i++) {\r\n		var item = list[i];\r\n		var id = item[0];\r\n		var css = item[1];\r\n		var media = item[2];\r\n		var sourceMap = item[3];\r\n		var part = {css: css, media: media, sourceMap: sourceMap};\r\n		if(!newStyles[id])\r\n			styles.push(newStyles[id] = {id: id, parts: [part]});\r\n		else\r\n			newStyles[id].parts.push(part);\r\n	}\r\n	return styles;\r\n}\r\n\r\nfunction createStyleElement() {\r\n	var styleElement = document.createElement("style");\r\n	var head = getHeadElement();\r\n	styleElement.type = "text/css";\r\n	head.appendChild(styleElement);\r\n	return styleElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n	var styleElement, update, remove;\r\n\r\n	if (options.singleton) {\r\n		var styleIndex = singletonCounter++;\r\n		styleElement = singletonElement || (singletonElement = createStyleElement());\r\n		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n	} else {\r\n		styleElement = createStyleElement();\r\n		update = applyToTag.bind(null, styleElement);\r\n		remove = function () {\r\n			styleElement.parentNode.removeChild(styleElement);\r\n		};\r\n	}\r\n\r\n	update(obj);\r\n\r\n	return function updateStyle(newObj) {\r\n		if(newObj) {\r\n			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n				return;\r\n			update(obj = newObj);\r\n		} else {\r\n			remove();\r\n		}\r\n	};\r\n}\r\n\r\nfunction replaceText(source, id, replacement) {\r\n	var boundaries = ["/** >>" + id + " **/", "/** " + id + "<< **/"];\r\n	var start = source.lastIndexOf(boundaries[0]);\r\n	var wrappedReplacement = replacement\r\n		? (boundaries[0] + replacement + boundaries[1])\r\n		: "";\r\n	if (source.lastIndexOf(boundaries[0]) >= 0) {\r\n		var end = source.lastIndexOf(boundaries[1]) + boundaries[1].length;\r\n		return source.slice(0, start) + wrappedReplacement + source.slice(end);\r\n	} else {\r\n		return source + wrappedReplacement;\r\n	}\r\n}\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n	var css = remove ? "" : obj.css;\r\n\r\n	if(styleElement.styleSheet) {\r\n		styleElement.styleSheet.cssText = replaceText(styleElement.styleSheet.cssText, index, css);\r\n	} else {\r\n		var cssNode = document.createTextNode(css);\r\n		var childNodes = styleElement.childNodes;\r\n		if (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n		if (childNodes.length) {\r\n			styleElement.insertBefore(cssNode, childNodes[index]);\r\n		} else {\r\n			styleElement.appendChild(cssNode);\r\n		}\r\n	}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n	var css = obj.css;\r\n	var media = obj.media;\r\n	var sourceMap = obj.sourceMap;\r\n\r\n	if(sourceMap && typeof btoa === "function") {\r\n		try {\r\n			css += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(JSON.stringify(sourceMap)) + " */";\r\n			css = "@import url(\\"data:text/css;base64," + btoa(css) + "\\")";\r\n		} catch(e) {}\r\n	}\r\n\r\n	if(media) {\r\n		styleElement.setAttribute("media", media)\r\n	}\r\n\r\n	if(styleElement.styleSheet) {\r\n		styleElement.styleSheet.cssText = css;\r\n	} else {\r\n		while(styleElement.firstChild) {\r\n			styleElement.removeChild(styleElement.firstChild);\r\n		}\r\n		styleElement.appendChild(document.createTextNode(css));\r\n	}\r\n}\r\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanM/Yjk4MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0EsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELHNDQUFzQztBQUN0QyxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE5NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxyXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xyXG5cdFx0dmFyIG1lbW87XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRyZXR1cm4gbWVtbztcclxuXHRcdH07XHJcblx0fSxcclxuXHRpc0lFOSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gL21zaWUgOVxcYi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcclxuXHR9KSxcclxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xyXG5cdH0pLFxyXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxyXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XHJcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XHJcblx0XHRpZih0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcclxuXHR9XHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU5LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc0lFOSgpO1xyXG5cclxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xyXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xyXG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcclxuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYobmV3TGlzdCkge1xyXG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xyXG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XHJcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXHJcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xyXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0aWYoZG9tU3R5bGUpIHtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XHJcblx0dmFyIHN0eWxlcyA9IFtdO1xyXG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xyXG5cdFx0dmFyIGlkID0gaXRlbVswXTtcclxuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xyXG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcclxuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xyXG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xyXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pXHJcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcclxuXHR9XHJcblx0cmV0dXJuIHN0eWxlcztcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KCkge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcclxuXHJcblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XHJcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcclxuXHRcdHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKSk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XHJcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR1cGRhdGUob2JqKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xyXG5cdFx0aWYobmV3T2JqKSB7XHJcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVwbGFjZVRleHQoc291cmNlLCBpZCwgcmVwbGFjZW1lbnQpIHtcclxuXHR2YXIgYm91bmRhcmllcyA9IFtcIi8qKiA+PlwiICsgaWQgKyBcIiAqKi9cIiwgXCIvKiogXCIgKyBpZCArIFwiPDwgKiovXCJdO1xyXG5cdHZhciBzdGFydCA9IHNvdXJjZS5sYXN0SW5kZXhPZihib3VuZGFyaWVzWzBdKTtcclxuXHR2YXIgd3JhcHBlZFJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnRcclxuXHRcdD8gKGJvdW5kYXJpZXNbMF0gKyByZXBsYWNlbWVudCArIGJvdW5kYXJpZXNbMV0pXHJcblx0XHQ6IFwiXCI7XHJcblx0aWYgKHNvdXJjZS5sYXN0SW5kZXhPZihib3VuZGFyaWVzWzBdKSA+PSAwKSB7XHJcblx0XHR2YXIgZW5kID0gc291cmNlLmxhc3RJbmRleE9mKGJvdW5kYXJpZXNbMV0pICsgYm91bmRhcmllc1sxXS5sZW5ndGg7XHJcblx0XHRyZXR1cm4gc291cmNlLnNsaWNlKDAsIHN0YXJ0KSArIHdyYXBwZWRSZXBsYWNlbWVudCArIHNvdXJjZS5zbGljZShlbmQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gc291cmNlICsgd3JhcHBlZFJlcGxhY2VtZW50O1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcclxuXHJcblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0LCBpbmRleCwgY3NzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xyXG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2RlcztcclxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYShKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSArIFwiICovXCI7XHJcblx0XHRcdGNzcyA9IFwiQGltcG9ydCB1cmwoXFxcImRhdGE6dGV4dC9jc3M7YmFzZTY0LFwiICsgYnRvYShjc3MpICsgXCJcXFwiKVwiO1xyXG5cdFx0fSBjYXRjaChlKSB7fVxyXG5cdH1cclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(43);\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(195)(content, {});\n// Hot Module Replacement\nif(true) {\n	// When the styles change, update the <style> tags\n	module.hot.accept(43, function() {\n		var newContent = __webpack_require__(43);\n		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n		update(newContent);\n	});\n	// When the module is disposed, remove the <style> tags\n	module.hot.dispose(function() { update(); });\n}//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZXMvbWFwc3R5bGVzLmNzcz8zYWVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQXVIO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIxOTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhRDpcXFxcRG9jdW1lbnRlblxcXFxHaXRIdWJSZXBvc1xcXFxtYXAtcHJvamVjdFxcXFxub2RlX21vZHVsZXNcXFxcY3NzLWxvYWRlclxcXFxpbmRleC5qcyFEOlxcXFxEb2N1bWVudGVuXFxcXEdpdEh1YlJlcG9zXFxcXG1hcC1wcm9qZWN0XFxcXG5vZGVfbW9kdWxlc1xcXFxwb3N0Y3NzLWxvYWRlclxcXFxpbmRleC5qcyFEOlxcXFxEb2N1bWVudGVuXFxcXEdpdEh1YlJlcG9zXFxcXG1hcC1wcm9qZWN0XFxcXHN0eWxlc1xcXFxtYXBzdHlsZXMuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiFEOlxcXFxEb2N1bWVudGVuXFxcXEdpdEh1YlJlcG9zXFxcXG1hcC1wcm9qZWN0XFxcXG5vZGVfbW9kdWxlc1xcXFxzdHlsZS1sb2FkZXJcXFxcYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIUQ6XFxcXERvY3VtZW50ZW5cXFxcR2l0SHViUmVwb3NcXFxcbWFwLXByb2plY3RcXFxcbm9kZV9tb2R1bGVzXFxcXGNzcy1sb2FkZXJcXFxcaW5kZXguanMhRDpcXFxcRG9jdW1lbnRlblxcXFxHaXRIdWJSZXBvc1xcXFxtYXAtcHJvamVjdFxcXFxub2RlX21vZHVsZXNcXFxccG9zdGNzcy1sb2FkZXJcXFxcaW5kZXguanMhRDpcXFxcRG9jdW1lbnRlblxcXFxHaXRIdWJSZXBvc1xcXFxtYXAtcHJvamVjdFxcXFxzdHlsZXNcXFxcbWFwc3R5bGVzLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIUQ6XFxcXERvY3VtZW50ZW5cXFxcR2l0SHViUmVwb3NcXFxcbWFwLXByb2plY3RcXFxcbm9kZV9tb2R1bGVzXFxcXGNzcy1sb2FkZXJcXFxcaW5kZXguanMhRDpcXFxcRG9jdW1lbnRlblxcXFxHaXRIdWJSZXBvc1xcXFxtYXAtcHJvamVjdFxcXFxub2RlX21vZHVsZXNcXFxccG9zdGNzcy1sb2FkZXJcXFxcaW5kZXguanMhRDpcXFxcRG9jdW1lbnRlblxcXFxHaXRIdWJSZXBvc1xcXFxtYXAtcHJvamVjdFxcXFxzdHlsZXNcXFxcbWFwc3R5bGVzLmNzc1wiKTtcblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zdHlsZXMvbWFwc3R5bGVzLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval('module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAlCAYAAAAjt+tHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAhdEVYdENyZWF0aW9uIFRpbWUAMjAxNTowNToyMyAxMTo0MjozMPzRK2QAAAU+SURBVFhHtVdrbFRFGD3b3W232+3udukDWqkYkCYlTSttIxQtBFswUgMmYqN/jPyQBh8xIfUd0EAgIWqM2kQMCRITFSWAD4ilBhMbWk2tRWuqaCylcS19uH3sq92n3zfcWbbtbfcu0JOczM6d9p4zM9839xtdNBoFo7a21kBNCjFVabl/KxEiRogBbltaWrgPYUARZ2GTQv4tDd0KsDALsvikwgCb0NXU1EhxM9GqtGxiIVaAhX3ECaUNsAEWtxDtxNxt7d+2U7tgOL22Zi01Q8QxoocNsDjP3EHi3cuWpcNs1sNk0tOjW4fJyTB8vjD6+vxsooQeuYgTvMcy8HjZF0Scwe/kdyuQcZYio11yXnEO2OFhL/r7xzEw4Bat2z2ljCZG3LtjmjLKNUV7MBiBfzKCdYdPYmu3BysefxoTE9oNzIDQ1CQsodfrkLWqDLdtfgh6UzqKd71Iz5J6xSwk9d/hcBTu3j/h7vtL9J0tX9IzTvEbR9IrEPJ5cK6uAm1P1aPz1V0URTpl9MaQlAFxautSUHOyDVVNx1H6yhvXBm4CSRqIwpSzGLaVq0R/cfUmsS03A80GQqGI2O8Ug8jWGCKRqEhHycFBjzKiDZoMTE2FcPUqvdieD0MGH5zXYC8qQX1fNMbNp1rhcKQro9qQ0ADPemTEh7yKNaj67Aek2hzKCEQ2nKsrj/HCc09gaMgLrzcgtksLEhrweAIwkmjlu5/jn7Mn4Pu3XxmhYyzdjKySihhzqzaioO5R/OeaEv+nBdM3VAU8m5UNOxEYc+Hnvc/CYL6+Bel5Bag8eFjpXYfRYsXlT96ns9+Y8KBKuAKhUBRLH9iOvz89QvsRQGDchYv7d8PV3anKcGAKJY37Ych0YHw88TGtKQgtt6/A+KXfxIzsdhN6j72N89sq0fJgxSxeOvIW0uyLhAneBr8/GMsgNWgywNCnmSjlqHCwpmHJkkwUFFhRWGiLMS8vA3qDHs7m0/APOrH8sSdhLy6DLzUbI17jnKuhycBoTxdy12wQs1GbCUf86KgfOavvRunLh3DxwPN0YOpRffRrbGntRVnj62ScP/+zkdBAWpoevR814Y76HTAtyhFpFgyGlVEpPolAECjefRA+Zz/6v/gYwx2tMFAwdr+5Bz/ta6TPtnpWJDRgsaTiylfHMdz2He491oz0wjupGPGIwoTPB6fTDV8wBeX73qMlL8Uf7+wVH6iOxh34ZmMRfm86gExTFFlZouCahYQGMjJSqZIxoGtPA0JeNzad6ULpS4dgXb0B1sr7ULTzBdzf/CtlysP4sWErJq5cRna2GdbgIGwpboqVTNhsJuh06l9NaWDejzofr2H3GM4/sh5drz0DOxUl1UfP4J4PTmHplu3oO/Ehzq5fjoH275GTkyEMc/4bjfr5zgGhyVWxqIiJ2VQVdxQXW+asCzmtfL4gVbjiUhODwaATK5WZmTZvfcCVcU+Ph6viSuqOEF1sj53IG4sonfkP1cDxkJubMS39mPn5VrHMicT53QrEzYgY0Xwx4fuCw6GeSjPhcgVE/a8GtYsJfw/4zXNdzcQmkrELWkxIcRJapzyS8aV+NeM8TnA55VaQTHTOZyJOvJy6LCjJJridfTmV3+05rueylebMZKJLzUSc+F3U5dnJfY43IONt+vV8PijGWJzjhMkmfok3ESdeSl0W57qMOSmF5kJCAwwVExa5Eoy4mUthTeIMTQYYM0xwsLKJTmrlnrMoB5dmcYZmA4w4E5wpTBkIvK+89GLvtYozkjLAUEzIoOTfDBaMRbZ4ognA/zH9Za/gHTu/AAAAAElFTkSuQmCC"//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy9kaXNhYmlsaXR5LnBuZz80NTFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiIxOTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFsQ0FZQUFBQWp0K3RIQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFoZEVWWWRFTnlaV0YwYVc5dUlGUnBiV1VBTWpBeE5Ub3dOVG95TXlBeE1UbzBNam96TVB6UksyUUFBQVUrU1VSQlZGaEh0VmRyYkZSRkdEM2IzVzIzMiszdWR1a0RXcWtZa0NZbFRTdHRJeFF0QkZzd1VnTW1ZcU4valB5UUJoOHhJZlVkMEVBZ0lXcU0ya1FNQ1JJVEZTV0FENGlsQmhNYldrMnRSV3VxYUN5bGNTMTl1SDNzcTkybjN6ZmNXYmJ0YmZjdTBKT2N6TTZkOXA0ek05ODM5eHRkTkJvRm83YTIxa0JOQ2pGVmFibC9LeEVpUm9nQmJsdGFXcmdQWVVBUloyR1RRdjR0RGQwS3NEQUxzdmlrd2dDYjBOWFUxRWh4TTlHcXRHeGlJVmFBaFgzRUNhVU5zQUVXdHhEdHhOeHQ3ZCsyVTd0Z09MMjJaaTAxUThReG9vY05zRGpQM0VIaTNjdVdwY05zMXNOazB0T2pXNGZKeVRCOHZqRDYrdnhzb29RZXVZZ1R2TWN5OEhqWkYwU2N3ZS9rZHl1UWNaWWlvMTF5WG5FTzJPRmhML3I3eHpFdzRCYXQyejJsakNaRzNMdGptakxLTlVWN01CaUJmektDZFlkUFltdTNCeXNlZnhvVEU5b056SURRMUNRc29kZnJrTFdxRExkdGZnaDZVenFLZDcxSXo1SjZ4U3drOWQvaGNCVHUzai9oN3Z0TDlKMHRYOUl6VHZFYlI5SXJFUEo1Y0s2dUFtMVAxYVB6MVYwVVJUcGw5TWFRbEFGeGF1dFNVSE95RFZWTngxSDZ5aHZYQm00Q1NScUl3cFN6R0xhVnEwUi9jZlVtc1MwM0E4MEdRcUdJMk84VWc4aldHQ0tScUVoSHljRkJqektpRFpvTVRFMkZjUFVxdmRpZUQwTUdINXpYWUM4cVFYMWZOTWJOcDFyaGNLUXJvOXFRMEFEUGVtVEVoN3lLTmFqNjdBZWsyaHpLQ0VRMm5Lc3JqL0hDYzA5Z2FNZ0xyemNndGtzTEVocndlQUl3a21qbHU1L2puN01uNFB1M1h4bWhZeXpkakt5U2loaHpxemFpb081Ui9PZWFFdituQmRNM1ZBVThtNVVOT3hFWWMrSG52Yy9DWUw2K0JlbDVCYWc4ZUZqcFhZZlJZc1hsVDk2bnM5K1k4S0JLdUFLaFVCUkxIOWlPdno4OVF2c1JRR0RjaFl2N2Q4UFYzYW5LY0dBS0pZMzdZY2gwWUh3ODhUR3RLUWd0dDYvQStLWGZ4SXpzZGhONmo3Mk44OXNxMGZKZ3hTeGVPdklXMHV5TGhBbmVCcjgvR01zZ05XZ3l3TkNubVNqbHFIQ3dwbUhKa2t3VUZGaFJXR2lMTVM4dkEzcURIczdtMC9BUE9ySDhzU2RoTHk2REx6VWJJMTdqbkt1aHljQm9UeGR5MTJ3UXMxR2JDVWY4NktnZk9hdnZSdW5MaDNEeHdQTjBZT3BSZmZScmJHbnRSVm5qNjJTY1AvK3prZEJBV3BvZXZSODE0WTc2SFRBdHloRnBGZ3lHbFZFcFBvbEFFQ2plZlJBK1p6LzZ2L2dZd3gydE1GQXdkcis1QnovdGE2VFB0bnBXSkRSZ3NhVGl5bGZITWR6MkhlNDkxb3owd2p1cEdQR0l3b1RQQjZmVERWOHdCZVg3M3FNbEw4VWY3K3dWSDZpT3hoMzRabU1SZm04NmdFeFRGRmxab3VDYWhZUUdNakpTcVpJeG9HdFBBMEplTnphZDZVTHBTNGRnWGIwQjFzcjdVTFR6QmR6Zi9DdGx5c1A0c1dFckpxNWNSbmEyR2RiZ0lHd3Bib3FWVE5oc0p1aDA2bDlOYVdEZWp6b2ZyMkgzR000L3NoNWRyejBET3hVbDFVZlA0SjRQVG1IcGx1M29PL0VoenE1ZmpvSDI3NUdUa3lFTWMvNGJqZnI1emdHaHlWV3hxSWlKMlZRVmR4UVhXK2FzQ3ptdGZMNGdWYmppVWhPRHdhQVRLNVdabVRadmZjQ1ZjVStQaDZ2aVN1cU9FRjFzajUzSUc0c29uZmtQMWNEeGtKdWJNUzM5bVBuNVZySE1pY1Q1M1FyRXpZZ1kwWHd4NGZ1Q3c2R2VTalBoY2dWRS9hOEd0WXNKZncvNHpYTmR6Y1Fta3JFTFdreEljUkphcHp5UzhhVitOZU04VG5BNTVWYVFUSFRPWnlKT3ZKeTZMQ2pKSnJpZGZUbVYzKzA1cnVleWxlYk1aS0pMelVTYytGM1U1ZG5KZlk0M0lPTnQrdlY4UGlqR1dKempoTWttZm9rM0VTZGVTbDBXNTdxTU9TbUY1a0pDQXd3VkV4YTVFb3k0bVV0aFRlSU1UUVlZTTB4d3NMS0pUbXJsbnJNb0I1ZG1jWVptQTR3NEU1d3BUQmtJdksrODlHTHZ0WW96a2pMQVVFeklvT1RmREJhTVJiWjRvZ25BL3pIOVphL2dIVHUvQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3Byb2plY3QtaW1hZ2VzL2Rpc2FiaWxpdHkucG5nXG4gKiogbW9kdWxlIGlkID0gMTk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval('module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAlCAYAAAAjt+tHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAhdEVYdENyZWF0aW9uIFRpbWUAMjAxNTowNToyMyAxMTo0MzowNGgt29sAAAU/SURBVFhHvVdrTFxFGD3sLuwLdtktD1u00ohBqbWVR201tsQsTQhqbKyl/tBUTTAQ+VGktjVpqbXFRI1RkaaN0RDqozShMQSjFawhqa1NBaJtiLYJIpFSHt3lsQv7YnG+6Z11197lXgh4kpNh7l3mnPnmm7nfxM3OzoJQVFSkY42GMUFqqb+YCDKGGP3UtrW1UR/cgCROwgaJ9LcwtBggYRIkca9EP5mIczgcQtzEaJFaMrEUESDhKcYJqfWTARJPZExmTLuob7/A2iXDwz7HRtYMM44xuskAidPM7Uz8cmZmEkwmHQyGxQ2A1xvE1FQQfX2TZGINe+RknKA1FolHYV8ScQKNSWNLEHmmEdkuOKc4JezIyDj6+0cwOOjk7eTktPRWGRFjhzVFlqvK9kAgyEN5rPI0fqufxAuOVzExQbm0IHBNVcICWq0Wq+9ehy15W6FPMKK8ZC97Nq8hbsO8/ntmZga9g1fRN3SN99u7W9gz2uILx7wjMOVz46mafFQeLcX+xgqWRXHS24VhXgYoCePiNGjefx51FU14Y8d70puFY94GUq134N6M1bz/2ANb/r8lCAZnuJhOE71NQ6FZvh0Fh4bogFMPVQZ8vgBu3HAh2ZgOk4EOzlvIvnMNehtmw2w+cA52e5L0Vh0UDdCsR0cnkJ+9ESd3n0ey2S69Ad8NT9bkhVl1bCeGh8fg8Xj5cqmBogG3expWsw0flp3Ct7804/rNfukNYEww4cFV+WE+kvM4Sgp2wOn0sP+jD58yYp+7Emg2rxTvwpjHhYMnKqOWIN2WgSM7j0u9f5FotOBkx3F29usVDyrFCASDIRQXbENTxyeYmQ1g3OPEka9ew5W+Tln6gz5UP3MYSUYbxsc90iixoRgBQmZaFv74+wqbUQJ0Oh0az36EhvYPZLfg7m21KH9iHzdBB5XRqEd8vJadH3Gy0VCMAIHSSR9v4FvOYjFh+XIbMjKWYeXK1DDT05OZOS2+7/oaQ64BPFdYhvtXrkNCyArPOFg05D9aqgz09Hdjw32FmJ72y86aMt7lciM3awP2bn8Hbze9zo5oLT7b1YqOd3tR/ewhZtwo/Toaigb0eh0+P1uP7ZtewjJLKt9m9FkWEOKBQAhVW2tx3dmPlp+/xKWr53gyvn/6AN76opp9tuXrBkUDiYlGtF48hQu//4iGqjO4KyWLFSMuXpiMjk5iYOAm/D7g0PMfs5CvRV3LQf6B2vPpi3Dsy8bR1loYTRrYbGZpxGgoGjCbDaySiUfNiXK4vZP45s1uHubcVZuQf08hyor34LvDl/lOqah/Gn8N/YmUFAsCOhc0Bh/PFavVzJNQDlSU0tFGTKGKODc3lb+IhDgN6Ugu3fwyStaXYn32Zhb+EK4N9OBMZzMaf6iDx+tm4lZuOBa6ukZEZTzK6CQDvCJmJAOXcnJsMetCOhWnpnysLAtIT26Bst9s1iMpyTRnfUDlXE+PiwwUsC43QEtAaS1uLLx0ph/KgfIhLS05avsRV6yw8zAridPYEvjNiDGk+mJC9wW7nVfuinA6vbz+l4PcxYTiPdfVjCcqM/aTGhNCnAk9Kj0SB4f81Yz2scLllFpOZqJzLhMR4nmsS4KCZILa2y+n4rsd43ouWmHOxEx0y5mIEH+IdWl2Yp0jDYh8i76ezwXJGKlRnhDJxK+RJiLE17IuibsleoVQLCgaIMiYSBSRIETMXAirEieoMkD4jwlKVjLRyVqx5iRKyaVanKDaACHCBO0UIuUGgdaVQs/XXq04YV4GCJIJkZT0N4EEw5nNn6gC8A8EBm7d4dDKiwAAAABJRU5ErkJggg=="//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy9kaXNhYmlsaXR5XzIucG5nPzY3NTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDIiwiZmlsZSI6IjE5OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWxDQVlBQUFBanQrdEhBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQWhkRVZZZEVOeVpXRjBhVzl1SUZScGJXVUFNakF4TlRvd05Ub3lNeUF4TVRvME16b3dOR2d0MjlzQUFBVS9TVVJCVkZoSHZWZHJURnhGR0Qzc0x1d0xkdGt0RDF1MDBvaEJxYldWUjIwMXRzUXNUUWhxYkt5bC90QlVUVEFRK1ZHa3RqVnBxYlhGUkkxUmthYU4wUkRxb3pTaE1RU2pGYXdocWExTkJhSnRpTFlKSXBGU0h0M2xzUXY3WW5HKzZaMTExOTdsWGdoNGtwTmg3bDNtblBubW03bmZ4TTNPem9KUVZGU2tZNDJHTVVGcXFiK1lDREtHR1AzVXRyVzFVUi9jZ0NST3dnYUo5TGN3dEJnZ1lSSWtjYTlFUDVtSWN6Z2NRdHpFYUpGYU1yRVVFU0RoS2NZSnFmV1RBUkpQWkV4bVRMdW9iNy9BMmlYRHd6N0hSdFlNTTQ0eHVza0FpZFBNN1V6OGNtWm1Fa3dtSFF5R3hRMkExeHZFMUZRUWZYMlRaR0lOZStSa25LQTFGb2xIWVY4U2NRS05TV05MRUhtbUVka3VPS2M0SmV6SXlEajYrMGN3T09qazdlVGt0UFJXR1JGamh6VkZscXZLOWtBZ3lFTjVyUEkwZnF1ZnhBdU9WekV4UWJtMElIQk5WY0lDV3EwV3ErOWVoeTE1VzZGUE1LSzhaQzk3TnE4aGJzTzgvbnRtWmdhOWcxZlJOM1NOOTl1N1c5Z3oydUlMeDd3ak1PVno0Nm1hZkZRZUxjWCt4Z3FXUlhIUzI0VmhYZ1lvQ2VQaU5HamVmeDUxRlUxNFk4ZDcwcHVGWTk0R1VxMTM0TjZNMWJ6LzJBTmIvcjhsQ0FabnVKaE9FNzFOUTZGWnZoMEZoNGJvZ0ZNUFZRWjh2Z0J1M0hBaDJaZ09rNEVPemx2SXZuTU5laHRtdzJ3K2NBNTJlNUwwVmgwVURkQ3NSMGNua0orOUVTZDNuMGV5MlM2OUFkOE5UOWJraFZsMWJDZUdoOGZnOFhqNWNxbUJvZ0czZXhwV3N3MGZscDNDdDc4MDQvck5mdWtOWUV3dzRjRlYrV0Ura3ZNNFNncDJ3T24wc1ArakQ1OHlZcCs3RW1nMnJ4VHZ3cGpIaFlNbktxT1dJTjJXZ1NNN2owdTlmNUZvdE9Ca3gzRjI5dXNWRHlyRkNBU0RJUlFYYkVOVHh5ZVltUTFnM09QRWthOWV3NVcrVGxuNmd6NVVQM01ZU1VZYnhzYzkwaWl4b1JnQlFtWmFGdjc0K3dxYlVRSjBPaDBhejM2RWh2WVBaTGZnN20yMUtIOWlIemRCQjVYUnFFZDh2SmFkSDNHeTBWQ01BSUhTU1I5djRGdk9ZakZoK1hJYk1qS1dZZVhLMUREVDA1T1pPUzIrNy9vYVE2NEJQRmRZaHZ0WHJrTkN5QXJQT0ZnMDVEOWFxZ3owOUhkanczMkZtSjcyeTg2YU10N2xjaU0zYXdQMmJuOEhiemU5em81b0xUN2IxWXFPZDN0Ui9ld2hadHdvL1RvYWlnYjBlaDArUDF1UDdadGV3akpMS3Q5bTlGa1dFT0tCUUFoVlcydHgzZG1QbHArL3hLV3I1M2d5dm4vNkFONzZvcHA5dHVYckJrVURpWWxHdEY0OGhRdS8vNGlHcWpPNEt5V0xGU011WHBpTWprNWlZT0FtL0Q3ZzBQTWZzNUN2UlYzTFFmNkIydlBwaTNEc3k4YlIxbG9ZVFJyWWJHWnB4R2dvR2pDYkRheVNpVWZOaVhLNHZaUDQ1czF1SHViY1ZadVFmMDhoeW9yMzRMdkRsL2xPcWFoL0duOE4vWW1VRkFzQ09oYzBCaC9QRmF2VnpKTlFEbFNVMHRGR1RLR0tPRGMzbGIrSWhEZ042VWd1M2Z3eVN0YVhZbjMyWmhiK0VLNE45T0JNWnpNYWY2aUR4K3RtNGxadU9CYTZ1a1pFWlR6SzZDUUR2Q0ptSkFPWGNuSnNNZXRDT2hXbnBueXNMQXRJVDI2QnN0OXMxaU1weVRSbmZVRGxYRStQaXd3VXNDNDNRRXRBYVMxdUxMeDBwaC9LZ2ZJaExTMDVhdnNSVjZ5dzh6QXJpZFBZRXZqTmlER2srbUpDOXdXN25WZnVpbkE2dmJ6K2w0UGN4WVRpUGRmVmpDY3FNL2FUR2hOQ25BazlLajBTQjRmODFZejJzY0xsbEZwT1pxSnpMaE1SNG5tc1M0S0NaSUxhMnkrbjRyc2Q0M291V21IT3hFeDB5NW1JRUgrSWRXbDJZcDBqRFloOGk3NmV6d1hKR0tsUm5oREp4SytSSmlMRTE3SXVpYnNsZW9WUUxDZ2FJTWlZU0JTUklFVE1YQWlyRWllb01rRDRqd2xLVmpMUnlWcXg1aVJLeWFWYW5LRGFBQ0hDQk8wVUl1VUdnZGFWUXMvWFhxMDRZVjRHQ0pJSmtaVDBONEVFdzVuTm42Z0M4QThFQm03ZDRkREtpd0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3Byb2plY3QtaW1hZ2VzL2Rpc2FiaWxpdHlfMi5wbmdcbiAqKiBtb2R1bGUgaWQgPSAxOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('module.exports = "data:image/jpeg;base64,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"//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy9kb3ZlbnNob2FoLmpwZz81MWFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGtDQUFrQyIsImZpbGUiOiIxOTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQVNBQklBQUQvNFFCbVJYaHBaZ0FBVFUwQUtnQUFBQWdBQkFFYUFBVUFBQUFCQUFBQVBnRWJBQVVBQUFBQkFBQUFSZ0VvQUFNQUFBQUJBQU1BQUFFeEFBSUFBQUFRQUFBQVRnQUFBQUFBQUc2NkFBQUQ2QUFBYnJvQUFBUG9jR0ZwYm5RdWJtVjBJRFF1TUM0MUFQL2JBRU1BQWdFQkFnRUJBZ0lDQWdJQ0FnSURCUU1EQXdNREJnUUVBd1VIQmdjSEJ3WUhCd2dKQ3drSUNBb0lCd2NLRFFvS0N3d01EQXdIQ1E0UERRd09Dd3dNRFAvYkFFTUJBZ0lDQXdNREJnTURCZ3dJQndnTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EUC9BQUJFSUFjOEJYZ01CSWdBQ0VRRURFUUgveEFBZkFBQUJCUUVCQVFFQkFRQUFBQUFBQUFBQUFRSURCQVVHQndnSkNndi94QUMxRUFBQ0FRTURBZ1FEQlFVRUJBQUFBWDBCQWdNQUJCRUZFaUV4UVFZVFVXRUhJbkVVTW9HUm9RZ2pRckhCRlZMUjhDUXpZbktDQ1FvV0Z4Z1pHaVVtSnlncEtqUTFOamM0T1RwRFJFVkdSMGhKU2xOVVZWWlhXRmxhWTJSbFptZG9hV3B6ZEhWMmQzaDVlb09FaFlhSGlJbUtrcE9VbFphWG1KbWFvcU9rcGFhbnFLbXFzck8wdGJhM3VMbTZ3c1BFeGNiSHlNbkswdFBVMWRiWDJObmE0ZUxqNU9YbTUranA2dkh5OC9UMTl2ZjQrZnIveEFBZkFRQURBUUVCQVFFQkFRRUJBQUFBQUFBQUFRSURCQVVHQndnSkNndi94QUMxRVFBQ0FRSUVCQU1FQndVRUJBQUJBbmNBQVFJREVRUUZJVEVHRWtGUkIyRnhFeUl5Z1FnVVFwR2hzY0VKSXpOUzhCVmljdEVLRmlRMDRTWHhGeGdaR2lZbktDa3FOVFkzT0RrNlEwUkZSa2RJU1VwVFZGVldWMWhaV21Oa1pXWm5hR2xxYzNSMWRuZDRlWHFDZzRTRmhvZUlpWXFTazVTVmxwZVltWnFpbzZTbHBxZW9xYXF5czdTMXRyZTR1YnJDdzhURnhzZkl5Y3JTMDlUVjF0ZlkyZHJpNCtUbDV1Zm82ZXJ5OC9UMTl2ZjQrZnIvMmdBTUF3RUFBaEVERVFBL0FQMkMvWmovQUdZL2h2ci9BT3pmOFA3NisrSC9BSUp2YjY5OE5hZGNYRnhjYUZheVRYRWoyc2JNN3NVeXpFa2trOGttdTRIN0ozd3RQL05OdkFIL0FJVDFwLzhBRzZyL0FMS1ZpNS9aVitHNFNlUmQzaGZUU1c0SlhOckVlTWp0MEE5SzZTUzh2cmtUUXlPZExaaDhreGlFcS9lSURCajhvSkczNVdIVTRHYXJsR2pEUDdKM3d0SC9BRFRid0IvNFQxcC84Ym9YOWsvNFdOL3pUYjRmL3dEaFBXbi9BTWJyVTAvdzRzVm5IY1hWeFByVjNhcjh0ektZNUprZm43cUtpUnEzVVpDZzQ0clBzOVE4S3I0bTh2N0xiV1YvZEl5ZVpKRTF2TktBU1Nxc3dHNEE1KzZ4d1QweHpSeWpzWlBpejlsdjRWNlZvazE1L3dBSzU4QnhwWkQ3VEpzOFAyWTNJaDNNUDlYZzVVSHJXT3Z3YitEK3ArSTVySFR2aHQ0RDFPVzF0MGxaYlRRTE9SY3lFN2N2czJMd2hQek5rZzhWNlY0bDhJNkxQSzJwWDFuYlN5VzhUbnpaRTM3Rks0YmowSzV5TzljNzhLdmlOWWVKSnJpTzNXNCswV09ud3JjeHRidkZza2phUkdYREFjaDFaZU01MmtqUFdxamJsdUdsanlqeDkreHY0WDhTejJ0M3JQZzN3RjRkMFhUNFpyNlMwMGZSNFZtbW1SazhwSloxUlM4WlZtekdpcVMyMzVpT0s3L3d4K3liOFBQc3BtMUQ0YitBMXVycHhJWVA3QXRHUzFYQUFpQjJZSkhVbnUyN29NQWRwWitISnpxdDFxVjFQNXR4SXVMYURKOHUwWGFNcU9jTXhZWjNFWjV4MEdLNlNXTXlJTnJiV0hJT0tKeXVyQkpuaUZ0K3ozOE03ejRxM21ueWZEZndQRGI2YlpRbFYvNFIrekVNOHM3U0VIT3pxcXdrRGdjdWV2RlpxZkFuNFUyZnhDMVRTN2o0ZCtEYm04M3JMYkxCb2RxMGNTTkdnOHNydHh1REFzZHd3QTRPUU9CMlhpL3hCQ2ZEZXNheGNXMHl6TGN0YTI0V1ZRczBrTXNnakJ5Y0FPNENZUGNxUnpnMXAvQ3I0YU40ZTFQVjc3VkJiWFdzYTFKSGQzZHhHdUZWaWdVd0pubnkwMkRHZW9ia2RxZWlWMlVjbnAvN08vdzliVFB0a2Z3bjhDWERURENRZjJIWVpVcnd3M0tyS2VSeDM2OTgxc2FGK3gzOE5kUGU2ZTY4QStBN3ByaVl5SXA4UFdnUzNUQUFSUVVKNEF5U1Rra2s4REFIWWFqb1AyQyswNU5QZ3Q3YXhTVXlYS3gvdStPQ3VGQXh5d0JKNDRCSE9SWEJmR240cnorSDlmc3JYVDVOUXUzYVZJNXJPenR2TmNvSER5N2p4c0pqUmdOektNQjJ6d0tTVjNhSW5xSjQyL1p5K0Z1aC9ZY2ZEdndFQmRUTEFzY2ZoeTBhU2R0Nm5hdjd2cnREazlnQVNTQUNSamVJL3dCbW40YWVLdEF0TEt4OEErQ05MWFU3aGJHT2FQUkxUN1J2UXMwNmxoSGxHVklaa3lEbmQzR00xM1Zwb3VwYTdKWTZocmJSNldOTm1lUzFzNEhWNUhZcTBhYnBXNmxnekVoUU1rZ1pJQno1aDhYUEV3dVBpNWE2ZmE2eEhvT2xlSGxTWFdyNkpWaUNhalBHL2s0a2NnZkxCSkxLNEc0a1BDQ01Fa1ZHSzBYVUxIZFIvc3ZmQzI5bHVyWC9BSVZ2OFA1SklRckF4YURhS2VTUUFjSndRVjU1L3dBSzFJLzJUL2hheURQd3o4QUw3ZjhBQ1BXbi93QWJvK0YveFQwSHh0NGZtYndrejZsYVdiUEVMZ3hTUTJzOGluNW04NHJpVEpPU3k3aVNTVHpYVDZqcHVxNmtzTzIvaTAxVVlOTDVNUWxkeHh3clB3T2M1SlE1SHBVU1d0bUxsT1R2djJXUGhYWld6eUg0YS9EOXRxbHNmOEk5YWM0R2YrZWRmbnQvd1ZlL1oxMHY0T1gvQUlQdU5Ic2RQMFArMmJLVkpKTEczanRZRGNwS1hjN0ZYSEFtUlFNRVlVREdCWDZNWEhnaTMxanhSYTNWNWJ5WFc2MmxqZWVlUWd4SnVqSVFCU0FONVRjY0QrRWducFh5Vi93V2QrQzdlSXYyYTdEeEZaVHlycWVrNm1scmJTVFhFa3lRd1RvVjNZTzRseTZvY2prN3UvRktVZmRzbVZDeVorYVhndVc5dXZGVFdkeGZMTkJ3cU15N2RwRERlRDh2b1NSMzRIWWcxMjJqL3RBeTMzd3UwdndqZWVFZkR3dXJEVXBwcE5VdHJHM2JVTHBTVktRUE1xbGlvWXVPVzUzcUR3Z3JqdEkvMFB4UGNTNUVEWU4wckRtU01FRENxQUNSeHpudG4ycGZDT2t4K012SEZ2SlpMcHNjZDFzdkhra1FoSmRwM3VEOHVBMmNuR1JuQXp6ZzF6eHUzWTJTVno5TXYrQ1cvd0N4MTRZMWY0TFRlS1BGbWc2TDRrbDFhVHliSWFscHNOd3NVVVh5TTREcWZtWncyVC9zKzVyNlA4VWZzamZEV2ZTWkJaL0Rqd0ZIZFJsWlk5dmgrMFhlVllOc1A3dm8yTnA5aWE2WDRMZURWK0d2dzYwdlFWWlpGMG15dDdiekZHRmtLUW9yTVBxeXNmcWE2WFVrbWF5bFdGbDh4a1lJVzZBNDRyb2I5NDU1UFc1OHZmRzN4MSt6WCt6N3FNc1BpSHdmOE8xa2hZUXZCQjRldFpaL016akFRUjlzOG4vQ3ZTUGh6OEd2Z2Y4QUZqUUlkWDhQK0NmaHZxVmpPZ1pYaTBHMCtYUEkzTDVlVk9PeEZmaEgrM2Y4V3ZGV2cvdFdlTmRNOGNSeHg2dFphcmNCMGdjdEZHVEl4QlFubGtJNUJ3TWc1d00xai9BNzl1VHh0OEhQRlZqcTNodnhScU9ueVc1QldDS1pqRzRCKzY2SDVXVStoQkdLOUQ2bkdVZmQzSnMxdWYwS04reWI4TE1mOGsyOEEvaDRldFAvQUkzU245a3o0V1ovNUpyNEIvOEFDZXRQL2pkZkwzL0JPci9nc1hwWDdWK3NhZDRROFZhWC9ZdmpLOXpIYnkyeWxySytaVlpqMUphTmlGUEJ5Q2U0NlY5d1JPc2czS2R3NlpyaHFVNVFkcEFjQi93eWI4TGYraWErQVA4QXduclQvd0NOMGY4QURKdnd0LzZKcjRBLzhKNjAvd0RqZGVnMGpESXJNRHovQVA0Wk4rRnYvUk5mQUgvaFBXbi9BTWJvL3dDR1RmaGIvd0JFMThBZitFOWFmL0c2dy9pdCszSjhMUGdmTFBINGk4WjZURGRSTUVhMWhrKzBUSzNwdFRKQit2U3VuK0JmN1F2aFg5bzd3bkpyWGhQVWhxRmxESjVNdVkyamtpZmFHQVpXQUl5Q09jWVBQcFZja2t1WnJRQ3Avd0FNbWZDMy9vbXZnRC93bnJUL0FPTjBmOE1tL0MzL0FLSnI0QS84SjYwLytOMTZEUlVnZWZmOE1tL0MzL29tdmdEL0FNSjYwLzhBamRIL0FBeWI4TGYraWErQVAvQ2V0UDhBNDNYb05GQUhuMy9ESnZ3dC93Q2lhK0FQL0NldFAvamRIL0RKdnd0LzZKcjRBLzhBQ2V0UC9qZGVnMFVBZWZmOE1tL0MzL29tdmdEL0FNSjYwLzhBamRIL0FBeWI4TGYraWErQVAvQ2V0UDhBNDNYb05GQUhuMy9ESnZ3dC93Q2lhK0FQL0NldFAvamRIL0RKdnd0LzZKcjRBLzhBQ2V0UC9qZGVnMFVBZWZmOE1tL0MzL29tdmdEL0FNSjYwLzhBamRIL0FBeWI4TGYraWErQVAvQ2V0UDhBNDNYb05GQUhuMy9ESnZ3dC93Q2lhK0FQL0NldFAvamRmTFgvQUFWeCtCZmd2NGMvczQ2SGZlSGZDUGhmUWI2WHhKQkE5eHAyazI5dEs4WnRicGloWkVCS2txcHgweW85Sys1cStRLytDMGYvQUNhN29IL1kwMi8vQUtTWGxBSHV2N0xLeVA4QXNyZkRaWTJDTTNoVFRCdi9BTHYraHhjNDcxNkJhV1p0MSthUXl5WUFMRVl6K0hTdUYvWk0vd0NUV2Zoci93Qml0cG4vQUtTUlY2RFFBZ0d3VmdhemZXYzgxeFkzbHJ1aGxpQ01rOFlhR2RUd1ZHZmxQWEJCL3dEcjFzM2RzYnRHVE96S2taeG5PUlZLejhOQzEwejdLMTFjeng3ZHU1Mi9lZlhjTUhOT0kwN0hrL2lqNGMyT2crSHRObDBmeFpxM2hpM3Q1QkE4Qm1GNVpPR09HaUlrQlpFR09GaWVNQlVJNEZjNzRmOEFpSHFudzExVHhOTnJPazZmcTBkNDl0YTJsMTRkblJZM3lzb1ZtaWtjZVVUSWo1VldmRDVIUFUvUVVlaVc4VVN4K1dqS3JtUlF3M2JXSkp5TTk4a244YThQK05tamYyYiswQjRlMWE1aHZZZE51a3RMSHpyZHlrVTk3OXVoa2lFcXFmbTJ4eE9BU09raEhVQ3Q0MUU5SkZ4ZDlEMHIvaGNPaTZabzBkMXJGeE40ZmprS2gyMWFFMmFSTy9JamFSaDVlN2tEQVk4K3RkQnBHdTJtdDZjc2tGNWEzU0ZjTkpCTUhVa1pCd1FmVUg4alZqVmRHdGRjMDZXMHU0WXJpMm5VcEpGSWdaWEh1RFhuK3FmczVmRDAzYzBkeDRNOFBzTlFSdDhvc0lseHlvMmJnTWdzV3lNZjdYMHJHUExmVW5SbkIvRUQ0aDJlai9EUzYxYlZyejdMWStCdkVna3VOOHlvYjB4emVZVHdjWU1iYmxVNHkyT3dHZTA4SmZ0SGVEWWZCa1Y3TjRwOFB5U1hEczBodHJuemwzbHNCRlVmTi9kVURHU2NBWkpHZkZ2RnY3TWZ3ODBUOW16eFhxMW40VDB1YS9odkwxamR4d0Y1YmFJWGtrZVZiUFNPRWRBZG9Dbkl3U0Q2TGUrTXIvd1Y0czBEd25mYW5GSDRaMWVKWk5NMU1vcXp5Mjl2QzhseEZJeTdWWEtpRUk2cUNRWDRCQVk3ZTQ5UCtCL21YeW95UGlMKzF6NE44ZTZRK202ZmVhanFscHFNcVcwMHVuNkpkWHIycXJKdFlNcVJIRE02dWdIVlNqWXl3eFhPYWwrMU44TFBDWGkzVmJqVjQvRm1tMzJwMzBNZHROTDRjMU1MZEZiWUhZbm1SZmNIbXlOc0FIeW5PQ3ByYStLM3g5MHI5bnhyNlMxMWp3dnBlalhXa0ttamFjTGQ1cElicEhNaG1rU1BCVlgrMFJrZzg1d3h3U1FmbG40Vy93REJTbVQ0eWZIZWZ3ZHJqK0RiSHhacVZoY3c2TnJ0bFlzbHlzNFFaZ0RzU1Ewc1l3cEE1SUFBM2JhM3AwMDE3cWR2VVYwblk5eCtNLzhBd1U5K0gvaHpTSWJuUmJ2eEZxbDVha0JOTlRTcDdjSThmbWJsdUdraXl1NFJuQ3FDdzhzbmo1c2VNUWZFYVhXMzFUeE40bzhFL0ZMWHZFVnpKSGUyVmphYUVZTkkwVy9SUmIyNm1HUmo1aHd0c044aWt0bHNBWU9mVFBHZnhJWDRnNm5yMXZMcGVtZUk3clJiVVdpblZvdkxoQ0tUUE50Y2gyU1Jvc1JnRVpBRGtzU1J2NjN3OUpKUExxdXFhUHFVdXZXa2tLVzk0SVhTM3VMRjQxWHlYV0podUcwbElodkpLamZ3b0pKeWpKTFlyUkd6NEcvNEtKK0E1ZEtzZitFd1hXdmgvZlNPMFAyRFc5TG1zL05JY0lIM2xBakx0S0hBYjVja0VIQUo5MDhOZVA4QVMvaVJ1dk5KMUxUTlMwVzFRRnJpMnVJNTRwSk9HSHpLVGpZQUQvd0llbGN6cTJtNmI4UWRIbnM3NGFiZmFhMDdMcVU0ajJNMGdSQ0FwL2hrd0J1eDkzQkdRYTh5K08zN0lHZzZqUERxbmdlR2J3VnExMFRBZFcwQ2MycXV6SmhQTnQ0OFJ6SVgybHpqSVZlRHljUytWK3BOazl6M3U1bGJXZ3RrMExZdW92TnVzNVhaRytWQ1pIOFhVWkI2S2VtVno0WC9BTUZPRm5YOWgveEV4K3p6UFl5V3ZuaVpUODU4NUZVcjB3ZDdJMzBCcmw1LzJpUGliK3lYcjBHbi9GcXpnOFRlRlhWMlh4UG8xb1kyd0d3RGRLT0FWVEJJQ2dZWElMa0dybi9CU0R4ZHBYeEovWTY4VURUOVF0NzJ4dmJMVHRUczVMZDJtdDc1UHRMTWNNbkcwcEdDU0R4Z2VnckdVZE5Db3hha2o4c2ZCR2tSNjFlYWhlVEZZV21qbDZjNzFiQlRCNnI4d2J0akRaeDFydVAyTGJMUzIvYUI4QmFiZVdrY2R0ZjZ6WmxXbXhJeUxHOEprTGRTQTZyR3BPY0VubnZYRStGYmRiclZiNjhFWTNTYllENVpKSkc1OHN2SjQyc25UKzhjWUhGZTZmc1dlQXRKajhWK0dmRWZpang1NE84RngrRnRUdHBKTEhVOVJqRjVyTWF5SXpScEVjc1F3QWo1NjRHTWpOYytIVW5VdEUzbTBscWZyUnFPaFhHcFJ0Y1dWeXNNNVBseXh5SVRIT3FseGc0SUtrNSs4TTQ0eUdIRmViL3RVL3RWYVg4RWZnUnErdFhVeWFkcXl3eTI5dmF6VENLVHp3ZzRERWY3U2tNQWM3MUl6a0N0VDRkZkhmd3V1aDNGdlkrSUlkVWt0MGFlS0dRU3BNWUFkbys4Q3pZNEdlL1U5YStLUCtDZ0g3V2ZnZjhBYVY4N1JZYlhVcHBmQzRhZVBaTEg5bjFDUWZmakpLa2hrR1FEN3NBUm5OZWhUdzhuSzBsb2NNcExZL0tqNHphWmQvRmZ4MzRpOFJYMDI3VU5XdUpyd2huM2J1U3pZSkp5Qnpqbk9BS2gvWlgvQUdTUEhYN1VYeEloOE8rQ3RGdU5Udk9IbmtRWWhzMHlCNWtqbmhGeVJ5VDN4eVNCVy80dDhSNlg4VWJsTExTTkkvc1I5UEJXZUlxN1QzMGhPREl6QWJRT0FBQjB5MzRmc0wvd1F6L1kvYjRBZnMxU2VMTllzcDdQeEo0MmN1MGM4WlI3ZTBSaXNTNEl6ODVCZlBjRk8xZWpLb3FVZVovSkduTjNLLzhBd1NiL0FPQ1YrcC9zZ2FycVhpcngwMm1YWGlwa050cDBkckw1MGRsRTMzNUNTQis4YjdveG5DbHY3MkI5M01tOHIvczlLZFRVa0Q5T2E4bXRXbFZsenlJWTZ2aGYvZ3MzOFZ0YThIZUdmRGVoMmZpcSs4S2FicjBOeVpKYmVab1Z2SFR5d0luZFZMYmNOMEhCTGM4VjkwVitlZjhBd2NDWGxtdndvOEUyMDBmbVhNbDFlU1E4ZEFxUWh1ZWdIekRyVlliK0loeDFQenVXNThMK0VmdEV3MVM0MUhWZHBiemczbUpuMTh6T2M5VHdQeXI5aS84QWdsMzhKdEg4QmZzMDJPdGFUY2ZhZitFdVdPL2xjU2VZRklqRWUzUCs4cnNmZHlPMWZnLzhLZmhKcW54ZitKMm02SHBQbWFmZTN6bDRaWCs3RXE1WnBISzVPQXFzZStjWTcxK2tYN05IL0JTMngvWTYrRmVtL0RYdzdvMTU4VG0wQ1Z2N1IxV083UzFoaWVRNzNqaFZSSnZDRWtjTUFTRDNyMWNWVGxPbnl3TXJwUFUvVkNpdklmMmRQMjEvQS83U09oM2srajZuYXczK2xRZmFkUnNaWmRzbGpIL2Zja0FiZlU5dStLNnJ4RCswRjRROExXV20zTjlybGpCQnEyVGFPWC8xNEhWbEhVcnlCa1p5U0s4WjA1cDJhTkU3N0I4ZXZqdm9QN092Z0NUeEY0aW5hQ3hTWklGMmpjenU1NEFIZkFCWSt5bXZrVDQ3ZjhGbExIVDNmVC9oN28vOXN6WUFPcVh3YTFzMEo2N0ZjQnBQMEgxNjE2VC9BTUZQOU5tK0x2N0tkaTNodlR2K0VzanVOVWhuaGp0TXpKS25sUzVrM0tjQlZ6bkpPTWdEcWEvSlA0Z2VPOVYwbnhGSGI2MWFYR29OWnEwTnZaM01mMmE2c1NTYzhEQllLUmo1c2dBWXhYZmc4TkNVZWFXNU1qOWhmMkRQMnV0VS9hUTBTK3RkZXNiZTMxS3hYemt1SVpCc3ZJOXdCSVVjRGFTQmtFZyt4Ni9SdGZrLy93QUVZL0hlcmE5KzBkYjJOdmZhbGRhVERaWGMxMUNJeDltZ0RLdTA4RTRKWUx6eGs0NHI5QlAyMVAybWwvWlQrQzAzaVpiV08rdkd1STdhMmdjdGhtWTlUdDV3TWVvSEk1NTV4eEZDMVhrZ3R5dGVwNjVSWGx2N0t2N1FkMSswRjhPNGRVdjlBdXRCdlFBSkVkZzBNM0ErZU5oL0R6MFBUcHpYcVZjc291TXVXUUozMkNpaWlwQUtLS0tBQ3ZrUC9ndEgvd0FtdTZCLzJOTnYvd0NrbDVYMTVYeUgvd0FGby84QWsxM1FQK3hwdC84QTBrdktBUGUvMlRQK1RXZmhyLzJLMm1mK2trVmVnMTU5K3laL3lhejhOZjhBc1Z0TS93RFNTS3ZRYUFDcU41clJ0TGpZMXRjbGM0OHhWM0w5MG50azlzZE90WHFLQU1QVjlYMVBjSTdIVFk1c2pKZVc1OGxWem5waFd5ZW5idlhGL3RIZUNOUzF2NE5MYjZTc2wxckdtWFZwZTJoTzN6Sko0WmtZRW5JRzRuUDFKNmM0cjFDcW1yeWlLQmR5aGxNaUE1eGdaZFIzK3Y2VlhNVnpFSGgzVzdYeGpvRnJxRnUyNjN1VUVpblBJUHA5UWVQd3JuZmlwcUg5aVFwcUxhbDlraTBhMHVkU2VKZ3BTNDh0QnczQmJiOHhQeW5PZHA3WUxkSnZiYjRjZUt2N0xrYnk5UDE2NGtuc1NjN1k1bSthU0hQVDVtTE9vT1B2TUIwcmhmMm12RWdmWGRQOEp3MjhrMTU0c3Ruc1lXR1dXTlhtaTg4c09lUkZrZzhZNTloVlErSUV0VHJORTBWdkUvd3NUU1VXNEVjMW9JNXBKQUYrMFN2dTgwdjY0Y3NXR0J1UEhRblBodnhYOGI2aDQ3K0UxcXRyWS9iUEdIZ09MZnFtbXdneVdrUDJhYTFhY1NrZ2Jpd2pMSWluYzBjaDlUWDB4YTZqSmRhTkpKWlJxMFFqSzJnYmtUWUJ3ZjhBZFBiMkdjODE4eGZIUzU4UWZCcndYOFN2SDFqSkZjYWY0OXRwTGE4ZWFNUS8ySEpER0xXR1RIRzlTb2tCejgyNHhEbnZVZFpYL3E1VVgxUEFmMjI1dmhYKzBQOEFEbTE4TStJdml4cE9rNjVld0xmWE1xWC9BSmw5dkprSWlRRGJISEN1Ny9WZ0FzY0VnbmsvSG53citKZndNL1p0MDI4OE9hYjRrOFN3NjFkT1lycnhISGFiTCsyaUk1TUQ3SkdqR2RwNEF6enoxRmZLL3dDMHY4SnZFemVLWDFEYmNYV25UZVpjUEpLMzc1Z0d5N1ovdTd0M1QxckEvWjl1RnNmRml6TmRXOXBEYlNLOHFUUHVTYU1aREp0UDNtUFFIakJ4eUs5YW11VmNxSTFhMVordmY3QTkvb2Z4WGg4YXlSK0tQRjJ2YUg5amt1TEZkU2RwcEwxNGtBZVB6cEVEZVdRWVRzYmFXR0J4c09mcHJWL0RIdzRrOEI2eXVqMk5ySk5lSmJYU1NtelBtd0YzM2VSR0c1ampieVNOaThMMXl3d1I4b2Y4RWpmRzcrT2wrSVdtZUQ5WHN0UHZwckMxdTdNM2JnVFc2SThtOW1Ua0tTZHFrRElIWEp4WHFmaVh4VmNlTE5kdk5kMTdUN082MU96djdXOE1kck5MRlpUVzhZQ2xVUm1LTWhhTkEyTVB1YkdPcTF3WXVTaE94Vks3UjlCWCtndzJIZ1JvZkRXdFhFSWxsTnZBOEd4Z0huWWxsUEM0SU1rekV0a1JqbkdUWHBIZ09TYTdzdnM3V3Mybi93QmtyRmJXc1hsaEVhSnR1SlZISUhBSzRPY1lQVE9LOFo4QWVIZkRQeGY4ZHhTYUhwdWoyK2xRUXlSU1c2V25sbzNPNVdWbEt1Q3pGMncyRHNRSEdXd083MUh3ZjR4OEU2WGEvWk5ZL3dDRWgwKzRtTFhBa3Q5MGx2RUdVcDViQnNrS0F3d0ZKT2M4RTFsS3pHZWs2bm9OdmIrRmJtMHZyVzMxRFQxdDNFOFV5ZVlreVlPVjJOdUJCSEdPOWZubisyMzhQOVcvWmMwSHhGcEhoOWJ3L0RqeEpwOGt1bldwTHl4NlBkTE9rMHR0RzJTWVdibDA0NVRkMVpjMTk3ZUV0ZHU5UXRiRnRRVm83NW8zTCtYdUNqNXdOcktlL0dNNHdjZ2c0TmZLUC9CWEMwOFFXM2dydzIybWxMSFFOUyswL2IxanlyaTlTM1o0V0s5d0kxbEdjSE9BTzRyQ2VrUzZiZk5ZK0RmRE1WdkpaeU5wc1ZyYzM2Um5PWnM0VVNnZ2JUd01lWVFRUVJrREhHMFZ6UHdCMHZVTlYvNEtHU1gxalphZnExOTRWdGZNZ2oxSU5MYTJVc2x1bm1PRkdNdUdtSkFQUmducGl0clJOSXZ0RThSYWI5bHVJNU5QdkxtUjlydnVZUnNtL2FPZHpiSEtnREdjS09vSUpxL3MyZnRxWDN3UzhRZVB2RUZwcHVpdHJWM3JiMmQ5ZTNNUWVOb0pYK1JZZ3JEYmxZaWR5amJnSUFBQnp2bDlOODdtUEVQM2JJOTgrUHZ4djhTZkFyNE82cDRpdC83TXRkY2tVdzZaTklwVm5rSkEyN2QyU29VTWNEb1FlMmErSC9odjhVOVdhOGd0dFZpczdXMTFUZmNLMElJWlN5c0dHU1RsVHdSNlpBcXgrM24rMGJOOGMvR09tNnd0eHFHbS9ZVjh0TEl1engzRWpISm5WRys3R3dPMGNrblowNXJpL0RtdFA0aDBXTzR1TGhZMWpBV0NGQUE2UzhBYnV4VGFOMk9NQTE2eWR6aGpHeU5ieFA0eDA3d0w4Zm9sODYzanQ5U1pKNEpZNUhIbDU0YU00NHlTZjRoZ0RKNHpYOURuN00zeFIwbjRoZkFmUUwvUzdxRzZXMXNZcmFaVWJMSkxIR29ZWTkrQ1BVTXA2R3Y1Mzdyd2RaL0ZENGUyY3Q3WnlYRjlvT3JvbjJ0aVdOemJTRnBESHQ1SitZTnljZmZHSyswLytDZnYvQlN1ei9aeC9hTHQvQjk5QmNMNEp2TFZJN3VUQW1rdEpHQzdKQTJNbU5XT05vemhTZUNSV09Jb3VjTGRTK2JVL1pHZWFSeW9qQ2pCK2JmbnBXVjR5K0lPaS9EbTFnbDFpK3RkUGl1bVpZMm1iYXJGVVoyNTlsVW4vd0N2Vi93OTRodFBGR2xRWDFqTXR4YTNFYXlSeUtlR1VqSU5mUGYvQUFVMS9aSEg3V1A3UDAxdEI0Z3Z2RDJyZUd2TjFQVFpvcENJWlpsaklDU0RJKzk5ME1PVjNIR1FTRDVNRW5QbG5vV1Y3djhBNEtLYVBlNnZxcmFmcDgwbWg2WENYKzNKaWVTZHhnTUJHR1VBSVNNa3RqM0hiNU0vNEtJZnRRZkNyOXRxSFNiT1BVcGJheDhNeU9UZlhLbUdGMmtBRHhLQ0NaR08xVDhtNEhaMTlmTFBoR1BFSHd2K0RNT21XOCttNmhlYWs4Y2R6cTEvTWx0YmlGV2RVaVgrK0hMQnQzUXEyZTZyWGx1cC9zV3ovR1Q0b25UdEp2dkQ4bjJ5ZEJOYjZMNXlXOW96S1hhV1dRNUJ3c2JsUXVNN0NRQmcxNjlPaFNUMCs4eGNwWDNHNkg4RTlJK0ZVVjVyM2gyNHZ0VTFiVzdUK3o3YUhUVjgrZFk1Y1BrS2NFRTdRTUQ1c05qSFVWZThVZmJ2Z0ZiTko0ZzhLK0pvNXJyRFN6M0dtdFlRYmowSkxJQTJNcUNGSjU2bnNmY3ZEWGpQUWYyRGRVdGRCOEI2dDRYOFRlTzd3R3gxZiszOVFZWGxnNlJBeHgyd1FFK2FWa2N2eDhtUXJPV0hGVHdyOFEvRzM3UjEvcldtM25oMjN1dFV1clg3Tk5iV1IrejZYSGFLZHgrMFQzY20xcEQ1Z094WFZtR0RnWUxWMHFYM0UyYjNQSnZoVisxTkg0ZDhTSkhwTFRXMGpReVRsRmdYeTc2M0M1a2psK1ZqNWVRdVRnWUlCR01Bam1QaS93RHR4ZkVQeHo0eG0xcWZ4UkpjUWFnakpaYVpwbDU1VUdud00rZGdMb1dEY0FFcmhqZ1pidlh0SDdTbmcyeitBUHc1OFNXZmhtUFQ3cU82UjQ3cit6ZkliN1BHK2NRcUZET3Fad2NieURqOEsvTnZ3RHArdTZ2OFVyZlNaTFcwaU4zZHJFMHQrQ3NGaUdiRzlqMlVkYWxXbEs1dlRpdVUvUlA5bFQvZ3A1cm43S1hnMyt4L0YxbnJsOWIzMnNQZGVRc2ZuUVcxdTBNWnlmTVFsZ2VXQ3hTQTV6dUk3L1FIanY4QWFFK0JIL0JRZjRkcnAyazZkTHJXclNBQ1dDS3pXQzUwNEVuNTFablZoNjdVTEE1d2M4MTh4L0hqUklmZzU4RHJlRFEyMHZVTlQwZEI5b2ZXQTh5ek1WWThCVGxXa09TRkIyNEl4MHI0KytIZnh3MW40bC9HV3lzN0M0cy9COGQxTHVrZ3NaV2dRNTZ2azVHNDRBSkdEajF4V25LbTdvempIbTk1SDdzL3NGL0J2NFovc2IrRWJ6UnRKMTd6TlExeVlYTWx6cUtDRjJRQWhJVmZhRmJiOHh4MStZOFl4V2YrM0g4UUwrODg0SllXM2liUllJd0lOT3NpMDdYT2VkN2xGWWc3aGpCQVJRdVN6RWhhK0Y5Uy9hLzhDL0RCN2U5MWJ4SE40Z3ZvNFZnamhnMUdTNHQ3UUtBTnNhRnlGQndNOXVQVGl1WjhYLzhBQlRiUmsxYTN1dEpYVWJ1SWxjMmtMdEZGRU9uSlVLUHpKcmxqaDM3VDJtNDVPVWxabnZ2N00vN1YrdTJ2N1F1bHh5YXhjMlBobHI1TGFmVGJhUUlrVWdjRGxWQTNBQTdTV0hJeVI3ZnFhT2xma2oreXArMTc4UFBqTCswTjRWdU5jOEdpMTFJM3NNY1Y5QXdXUXNIR3hwY1lFb0RFWjNBdGdjSGpGZnJjT2xjdVArSkZSalpCUlJSWG5sQlJSUlFBVjhoLzhGby8rVFhkQS83R20zLzlKTHl2cnl2a1AvZ3RIL3lhN29IL0FHTk52LzZTWGxBSHZmN0puL0pyUHcxLzdGYlRQL1NTS3ZRYTgrL1pNLzVOWitHdi9ZcmFaLzZTUlY2RFFBVVVVVUFGSXk3cWpsdkk0WkZSbVVPLzNWTFlMZlNxbHo0a3Q3YWJ5K1pKQVFDa1lNakxucGtLRGpQcWVLTndLM2pqd2RhK090QmwwKzYzS3NuelJ5cHhKQklQdXlJZXpLZVFhOGYwN3hIYjZyNHM4THllSnpiMi9pVHc5cnI2UmNJaTd2dEVzdHU0dDVzNXlxeUlNamprbGh4dElyMm1IV29VSy9MZE41M3pMKzRrSUgvanZIME9LK2RQMnl2RDJoM2x1dml5MHVGMC93QVFlSDNpbWxndW9uZ0dvd3huSzRMYmZtakxraGgwK1lIaXExV3BwRyt6UGZmRW5pcVB3OHhXWlNzUGtNL21zNm91L2NpcW1TUWNrdGpJNEhHU09NK1lmdFdhRDRUMVg5bUxYL0N1c2FzMWpwbW9XeTZmRmNwS0pwTGFZRU5FN2IyeXhFaXFUdVBQZnZWM1UvMm52QU4zK3o3ZGVQdFcxZTIwL3dBTncyNWZVSE00TWtFZ0dEQjhweVpOd3dvWGxqZ3JuSUovSmY4QWF3LzRLbk44ZHZHVjVxV2tXK28ydHZielNSYVBZd0h5NExDTmZuZVdUYjkrZDhsaVJ3TTlRQms5R0hwODc5RE9XMWx1Ty9hMTBENFcvRHp3L0phM1BpZVdDYUtWb0VsVlk1cE9Wd1JJRUFWczdOMjNHN0FHTW5PUHpwK0pIZ3UrMWZXTG54QjRmMUNQN0xxZHlZYmVJUS9aZk1Va0RjVVppRnllZnZkT2VPbGUyZkVENGMzSDdTc2Myb1c3WGxuZTI4QW5udFpKaDVubUV1TTRIeTUrNmNZWDd4NlYwM3czc2RMMFR3eHBlazZsKzhuM0h5NVlvRk1rcUJjRXVxZzRVWUhBd1N4UHBYcUt5M0pqS3lzZlRuN0FYd0prL1lPdExlOStJSGo3d2Y4QTIvNHlzYmRJckxROVJlUzZzYkJuQmVXV2RRSTF3eUJCdEpCSG5mTVFqQ3Z2TDQvK0JySHc1OEV0UTFMUVpHZTQwT0JySUpKR3dtblNUZTdKS0dSdHpiWkM0ZktZeHlCeWEvRkx3ejhLOUU4SmZGcXgxVjVOVFhSYmk3KzB6V3lNVm5tZ1FzN3hiVlpXeXdWMXdHQklKNzErd3VsZnRzL0RuOW83NGI2cStnK0tiZlRkVTFMUzVyUzcwZTRaRll1cVNFWVU4R1RPSXNnNXhnWndLNXNaVGMxenJmeU5JMUZjMC9CMnM2Yit4ejREYnhoNGptdGRIV09IeVpCQmlPT1ZIQ2ZaN2R5eEcrUXF5UGhjT05rak51eVNmbXp4eC93V0s4UnlTNnBxUGczeFZwZDlwTUUvMmlhYWJSSlprakdXSGtScXhqSnlvQlovdWc0QzV5eHE1L3djSytLTFUvc0srQWRCMDY4MUtMVzc3V0lOYWtzSTk3T0loYXpKSXJNT0l3clRnQlNja0xnREE0L0d6UWZqUmZXQXQ5TnVKNVZodFd4RnZCVXNPQ2R3R004ajE3VkdIakczdklKTG0xUi9Sbi93VGcvYkR1UDJ3L2hKcVhpNitadE5rMFdVMnQ3Q3hiTVpFYk1DMGJkc1lZTXYzczdmNENUemYvQlZHUDhBNFNQNFllRk5maldhMXNZOVZsdDVHQmszeTdsQVdVb0IvZGpZcWNFaFNEeHlCei8vQUFSUCtOY1hqZjhBWWEwL1U3L1R0Um51clc2bXRraGlzMm5sdTFqbVlwS1dSZm1BQkNydis2VUlIR01kcC93VVk4QzZ0OFgvQU5uanhWZFNhYmNhTlphUDVWN1p4bVFIVWJwMGRRN1JDSm1RQm95NEFKTGtnNVVmSVJ5NHFDY3BKSXVsbzFjL05uUlBIay9qalI3aVN4VythLzB1MWEzWmxpTHpSNWpTQzVZOE1RUXl6QW5jVjJ2a2s3UmpKOEo2NzRjMVB3cHBzT29hWElQN1lhYStSTG1EYXZrU1hCaEEzTHdUdWlZN3VneU9GSHkxMFg3Ui93Q3k1Y2FOOEt2Rm1tdy9FRHd6bytxMy9tUzJWbEcwOTFxV294c3pUVFd6ckRFVVZBcXMvd0F6QUpqbkMvZDhoK0dueGUxWmZEdWsrSGJodEtodnRMdFA3TjNIWmVSeFFrT1hZTWpmZmJMUG5nS1pTTWNjOVdGaTQwN1BjbXRxN280SDlxL3gvd0Q4SWJyOWxvOW1xMjJveVR5VERlcXVzVVcwQXFPM3A5S2swTzR0ZFIwMU5TdUlCYXdNRkphM1ZoNXA2dGpPU2VBUnhuR1RXZjhBRW40WGF0OFh2R24yeUhUYmg3dlRZakhjTXlzR21EUGxKUG13U3pCdVZ4dXlQdTRyMGJ3ajRFMWJ3ejRkR2krSUp2RCttNlVzbm13VDM5MzVicTVBTElDSW5jbkFPQXVCeWNrNDQ3STJTTVRBKzJiV2kxTFM3ZVEycnlvdGc3TVZacERnYkdBeHhrWnp6a0FjODE1bjR0K1BkNVpmdE5lVHFOMWJ5TnA0anM1MnRVU09KenRHNEFLQUQ5Y2NuMTYxMFh4djhKWDNoTDRpMmRuUHFOdk10cGNaaHZMUjJFYTRRa25CVU12emJSbHNFYzhITmVRZkg3d1BKZjhBaS9UZFJ0V1daNyt3amthUkg4d21SQ3lIZGo3cElSVDgzUEpyU1BjY2JYMVA2THYrQ1ZIN1Yrai9BQnUvWjF0L0R4MVpCckhoV0VSa1NPTnkydldNZ25obFFFSjdLRit0ZC84QUd2NFZlSlAyaU5ZbnN0VThSUStIUGg3WWdZdGJIZDl0MXVRYmxjenlaVVIyL09GalhjelkzbGwrVUQrZW45aFQ0MGF6OE92aVBwY2ozMHRyYTJjZ2xtc1hVZ2FpZys5Q3gzcDhwVW4rSUhuaXYxdjBiNG82ajR4K0g4bmlQNGMrSC9HMTYxd2tmMnU0a3RJLzdGMDhxTU1rTWZMeTdCd2R2SEI1QnpYRkxEeDV1ZE1VNU5hSDBOckg3RVhnVklyT2FiVDlMMXRMWXRHRjFDR05sU0p3RmNCMkIyOEFZNFBBMmdqZ2p5djQ5K04vaFA4QXNpZUR0U2gwUFdQREdtNjB0bGMvWUxHemxobG1nbGFKdjM4aXEyUXE0OUN4NEhUTmZFUDdRZjdZdmp2Uk5Wdk5IazFYeFZjYWhHcGh2b0wyTjRvVXlNaU5ZV3p0T1BtR3pBeGpQY1Y0SDR3K0tHbmFaWVNYdXA1MWxEKy84b2pZdHlNWlpXYmhnVHlEN2NWckdtK3JJNUd6MHZ4ajhFUEJkMTRacy9GVndieStoMVNWZkx2cjI2TWR4ZFRNeGFTV0dWRHRLcnl6T3c3Y0xucjNxZUtmQmZ3TytFMm55YXQ0ZTFEeERGZmhwclhUWlpQTFZIWW5NczdTN2p6aFFYSWNuQ2pPQU1mQWY3VEh4dTAzNHhhNUhxdWxhdGIyT20ycXExbnBGcXNzQzJENUJLeHE3c1NkM0pjWUJJemdjVnd1ay9GL3hKNDExOWJUVnZFV3ZYbW4za29WMXVkUWxrVWp0bmMyT1BldGxGMnRjMDltMmZvdDRqL2Evd0JRK0kvdzhrOE8rSC9DbmhMd2pIQ2p6SmF3V2EzazdxcW5PMWxiNzVHVGxZOXh4K0ZmSmJhcmVYOW5CSGN2SmVYQ2xvNWxTSWVkTUVZOG5na0hCeCtITmVnV3Z3NGhzdmgweXlRMzBseHB6aTZXZWFSOTdSaDBCMk1ja0RidSs2ZTllYjMrc0xZZkVaMjAxY1EyaU5zbExIZFB5d0xIUFhKL1FDbW5ZYWlsc1U5UThSM1hnL3d6Y3dRMlVselo2azZzUmNPMjYzVlNDZGljQldPTWJzZERqaXVEMFh3ZmRhMTRqdS8zbjJSbzVIaVdRU2JoR0FDQ01yMUdPT090ZHQ4UXZGRjU0dlBtWEVpeXpBQ1B5OW16WU8yQUJpdS8rRlBoand6YmFmRHBpeHpYRjJWVGQ1SU1nTXAvaE8wY0QxSk9BQnlhMVdpdWFLZGp4N1F2Q0Y1SnFzVnJkU041VWtpcjVtMC9OazRKNUZmVkhnSDRSV1dsVytrNlRwdG5IZVgydHJHc1lrVVBJZ0xZUEI3c2VQWUEvaDVQNHkweDlHOFN4d1NNMGRxdDBGa0NqTGV1UFU0d2ErM3YrQ01Yd2l0ZmlKKzFucGR4Y1JTYnRDZ2wxdTVoYVBDUXFtSTRrejYrWTZFNXhrS2V0UlZseXc1aVpPN1BzYjltUC9naWg0TitGVnJvZXFlSU5hMWpVdkVWaXFUVHJhVENDMVNZYy9JUXZtWVU5RHVCT000R2NWOXdScDVhWTYrNXAxRmVCVXJUbjhUQnl1RkZGRlppQ2lpaWdBcjVELzRMUi84QUpydWdmOWpUYi84QXBKZVY5ZVY4aC84QUJhUC9BSk5kMEQvc2FiZi9BTkpMeWdEM3Y5a3ovazFuNGEvOWl0cG4vcEpGWG9OZWZmc21mOG1zL0RYL0FMRmJUUDhBMGtpcjBHZ0Fvb29vQWptQ2hQbTI0eDFQYXFjcGowUzF4RGJ5U3E3Y3JDZ0pHZTVxL3QrWS93QXFXZ0NqYitJTGVaOWhieXBBQ2ZMbEhsdVFEZ25EWU9QZnBYanY3VEg3VFdnZkNMd3hmU1hQaUxSYlNaNEMzbVNTYnhaUkhibHlxa2wyMmlRb29HV0lIUmR6RHF2ajk0cDBQNFMvQzNYdkZmaUtSWk5QMHEyTXJpZU5wYmVQNWdxWmpBUEc1bHljZE1rbkhUOFMvd0JwNzlwUDRqLzhGQWZpZGRhZm9XZzNIaXExa2wrejJWdHBXbFNpT0tNQWhBc2Z6SElHNzVqeVJuc0JqcXc5SG5kMFVvdDdITC90Mi84QUJUUFQvaTVQcUhodndUNFcvc1h3bkhlUGMyMFVsd1hlOVk0QnVaeHorOWZBNHl3VUFBRWZNVytWdmh0NG91ZkVIalc0bXZiaU9GWUlUS0VJUGx4bmNpa2hWQi9oUE9CbjhxL1ZQOWovQVA0TjFwZkV0cHAydGZGNjh0dEhoWXJOSm9lbHNYdkpodXo1ZHhQbmFuQUEyeGhqZy9lVWcxNEIvd0FGRXYyRGZEWDdIbnhrdnRQMHl4aDBYUzlhdDkxbkswanliNDBjNEtqa2xtQlVFOU53YnAzNnZhUWpKVTA3dnlOSFpJK2M5TStMczBNa01kakpQL2FVOHlReFJScUdFNUp3Y25yeC9JbXZUUEU2UWZEVzFqdDRVKzFhczFySERIYnh0dWRtWVpVSDY3ZDMwNTlLNTc0VmZFS3grRzFuZVgwMms2VnJHcVdOcVVzSjVFUStReDRHOHJna0J1ZVRqcG12UnZocDRUbTBTQWVLTlIwNjQxclVMeG1sekxDelRUeXliUzBvVUFISENoVkdNS08yNGl0MDdtTW8yUERmaVo0MHVQaHpaYWZINHd2VWwxUzF0emZwQlpqWk11UmlLTnlBRkdWSkpJSElHY25QUG5YN0cveDkxbnczKzBEcUdyUjNWNDhNMWxOSkxIRWhjbVpoazRVZDl4NjlqZzAvNDR5WG5qN1RmRjNpeTh6ZTNsNVBOTTA4a3U3eW91SW8wR1Brd0FVd0JrQUtCbkFxUDlnYjRmeGF6OFNXUmRVbTAyU0t3ZDViaEZ5dzNaSEJQQUhUSlBBQVBjQ3ROa0Nqb2ZUL0FJUmg4WC90RDZuZFErSUxhOHRiVXZCSERaM2plWGhFUVJveTl6OHE4Z25JT2U0QnJ6LzlvSC9nbi9jeWE4MTR0M0ZIYjdnRHNVSk1XSkkycXA2a1lQb2VDY1lyaHZIdXZlTnZnZjQxdUxpSHhCcTAwT2xYajIzbFQzTFlBVmlEZ1o0ejdZeURYV3kvdGNlTC9qcDRwMHEwc2JUVXJTNkYwbHliaHcwMXJFUmxVWURrb0FybnFTRG5ub0RXZHJzT1ZyWSt4dkNQN2JmeEIvNEorZURMVHd2b0dyV09yZUZZb2JleHNORjFXUU1ZUkpER2g4dmpmOGtoTHRqQXd4emxzMGZFei9ndEg0bDFpR3gwTFdMZTN0NTlZaUFrbU55TGVOVlhjck0zeUhlN0VkdHVPZlVZK0Zmak44ZlBGUHhhOFQ2VFllSXBWV1R3cTBrOWxJa0dJNFVDQXYweTdGOWlrZXVCOWF6UGlIbytnK0xmRVVtdWF2cWkzVnRMYnhxdHVNMi8yaVZVSmJFbTBsTWdEa2dET1FmU3I1RmU3STZlOGZWbnhKMC9WUEUray8ybnBzOTVEL2FRYnpibTZmeklsaktrdVFWRzdEWTI5RzRZam5JcnduVTlhajhFZkVlejFLUzk4T3A4OGF4MjlqTDUwZHloNTh6Y0FHL3VqQjVCeU9vTlVmaHA4Vk5GK0RrMm42MXBQaC9WdE8wcnlEYXpYazJwdGRLek9mblZVbE8xaDhwVU1xb1NHT0NwQkJ2YTU4V1BoN292aXU0MXk0MEszdm90Y0R6UmVacVNlWkFSOHpLUWlzeW1RakM3bEFCYmhpTWtaeTdCRzU2UjhPdmpWWXlmRVhYTlA4OFFhdHJGckpjdzNtbXloallzRnd3MnFkcnFWd2RyS2VEd2NqTldJL0R2aVRWWjVDc1Z2ZFhTMnlhaUx5NmpVWE01RVlLS29ZaFkvTTI4Y1pMRGdqR2E4TjhDZnRKNkxwZnhXWFdKTkRYVDdPNGFaWllkR1pIZTNRcXFqRzRBWkdPV3lDZHh4amtWcFhuN1JIaDc3RHFmOWphaWJlMzFDWXRjV0wyVHh5SXBHREswaVB0Snp4My9BQjVvZXc3TnN4UEVOanFIalh4SGRUZWRKSEpMT2QxdE5pSXhGc014d1RoZWVPdllHdU84UnJkZUxQSEVkOVl0YXJiNmZzZ3p1YmJPb0FCQUhvZm05enVQcmluYXBwMmwrSXZFb2p1TlRhYTFtKzdNWkRndU55Y0ZjOFpBNTdEcWNqbkwwbUhWdEU4WlhVVXIzRWRydk1hRkN4UU1tUXdYYVBtKzduNVNPdGJRa0hLZXVhaDQ3WHdEcGxtSTAwK0VYcGFWWmRubU5FRkJKVUFqR0MyTy9yNzFKOE1QMjh2aUY0QjFhKzAyMStJR3BXOWpic1dFVUY5NWx1Z0c0aUdGWER4N2VXemhjSHZYbFdvV0hpRHhmbzgwV202R2x6RzB5d1NtUWxaQTVHL3F4SDN0NTR3VGo4YXYzLzdIZDFjK0F0TjFYU3RUanVyMjRXUk5VdHBvL0tYVEo0NUdIbGhnV0RxeTdTRDh1Q0d5QU1FaFduVTdpeS9hRTFyNHJIVnRRdkxlOGwxRzd2V1pyeVNVTklHNE8vYUFOcWdERzBjQURHYTV6WDB1ZFp0N3FHUzQwK0NPUlNTc2pPMlNSeVZ3RHlmV3RIVXZnZko4QWRFMG1HLzFkN3E2MVlTTkZFWUJDaUQ1RG5PNGtrNzhZN1k3NUZVOUo4RGF4OFJOU3U0L0QyamE5cVIwK015U20xc1piankxN2xnb0xLdkI2akFBcDdocDBQRWRkOERhaG9OeGxvWlBzMTFJZGpyeXVlZy8vWFdscG1uTkZwMGtleHN4bkVoeGdxUlhyM2hEVnZBV28zMGVoNnRyMzlqWHpTQkdrdVlwSkJHY2NmT0YycVBRRWdEdlhlZkhENFY2UHF5VDNlZ3FydGVIZkkwVzBxUndjZ2duT2ZmQnB5SzlwWVAyV3ZpOW84R2hTNlpybXJXa2Nja0xRbUc2QlpHaWRlUUhHZGpZT0JqZ04xNlZIcW53cG0wRHhWZk5jWGRwZVF6Uy93Q2ozSy82dTR0c0JWZGNnalBCeng4cHozRmVBNmI0S3RkRTF1K2lPb3pXK3JSZ05aMnhoM3BjRW5CUWtmZEpKd0Rudlhxbnc5L2FrOFQrSHROYncvcVdtMnZpWFE3ZVlSUzZYZVFGcENZMjVFY3E3WkZPQmpPN2tkY2loZVJPcFk4VGEzYWFkY1NXOGR0RE5PVThscmpmbEkvbFlIWVR6em5IUEdQZkZkZEJvR2wvRHp4STJzLzJqRmF3UVN4bDhTWnkza2h2dXJra3R0a1hIVHBuRmRSTiswNzhMMnRMaUhWUGcrMW4vYU1ZdDFqMVNXNGI3QW1RUE10MlJTUzV5U2M0Mmc4QnVLOEQ4YjZoQnJldFgxdFl5TkcwZDUrN1M3a0svdWlTQVpDL1JncFgrNzBJeHlCVktRY3R6c3ZpQnE4SGlKVzFKSGxXMXZybVpsbktsZnZPMkF2cWR1T01qR2EvUmovZ2tKNGkxYjlsWDltaWJYZFAwbU83dlBHbXErZGNOZVA1V0xPQkNzQ3A4MjU4dThyTVF1RlVxQmtrN2Z6TTBqd05EcTkxcDlyYjNsdmNGcjJDMUp0bzh4czhoUlFNNXh6bnFlL3ZrRDloOUt2ZFMwZndicHRqcHRyWjJPajZUcG9FY1VuM1BzOE1JRzVtdzJHMm9wNHlPRkhTdkh6VEZWSUtOT21ydC9vZXZsdUJwVll5bldkb28rNnZDdnhtMEh4cHBWdkxEcldsd1hUUm84OEJ1VUx4TVZERk9TUGNaNzROZHBET3MwYXNyS3lzTWdnNUJyODcvQmZocnh4NHZzbWJUL0NjekxlTkxMZVgwWVNabjNENVVIekJ4OHVNRGJrS1ZPQ1NXcjBqdzU0UDFMd3pNTlB2TmExKzFXWWVmTkdnUG5TTHh1M0VrN2NiUU1qS2pHT01FVjVFOFc0ZnhJdGZpYnJKNFZOTVBVVW4yNm4yWlJYRC9CL1c1b3RFdDdHOHVJNTVmSzMyNzc4dElnNFlIZ2NodlRvR1d0eXgrSU9pYW5yaDAyMzFLeG12bDNaaGptRE1wWGhnY2R4M0hXdXM4T1VXbTEyTnlpZ0hORkJJVjhoLzhGby8rVFhkQS83R20zLzlKTHl2cnl2Z1AvZ3J6KzBQcGZpN3d0RjRDdHJlNCsyNkhybHZlVDNXNEdJbjdOT0NnSFhJODBaOTFJcW9VNVRkb29ENjcvWk0vd0NUV2Zoci93Qml0cG4vQUtTUlY2RFhuMzdKbi9KclB3MS83RmJUUC9TU0t2UWFrQW9vb29BQ2NDa1lacGF6OVQxS2JUQW5sMmR6ZWJpZjlVMFlLOVR6dVpmMHByVUExblRMUFc5TnVMSytnaHVMTzRpYU9lR2RBOFV5TUNHVmczREFnNElQVUdxdmd2d0RvbncrMGhkUDBIU2ROMGV4aXdGdDdLMVNDSmZvcWdDdUwxdjlwVHducFdzdzZSZGF0YVIzM25lUmNyY28wS3dzRnpoOXd5bVRqazVIUFd1cmgrS0doeXdidjdXMDFwRmozeVJSWEtTT283NENrazRQcFRzOWtWWm5STXU2dmhML0FJTHEvc21YbjdSSHdYOEg2aHBOczBtb2FIclF0N21WRk82R3luWDk0NUk3SzBhQVo0QmZOZllVM3hZcy93QzBHdDROUDhRWFcxYytiRnBVNWhmMldRcUZQYmtISFBYZzQrTmYrQ3pIN1FObmYvc25UV0duZjIzYjZ4WjZ4RkxlUmZZSjQzc0lGamxEVFNmTGpZQ1V3VlAzbVU5QWFxbnBKTmhHTDZId2ZvbjdNMmgrQjcrMTFEVzU5TlczczNTYU93VUJiaTVWRGxYd3h6dExjN2lCazl1NTR2OEFhZStQemE5RmZlR2RIM05xRjh1TlV2YlpqdDArQnhoTENIai9BRmpqL1dFY2dFZzR3d3JoL2h6OFR0VThRM0Z6ZFNYZHpxVnY4N05leitaTTZZNjdXUElmSFFrbmI2SHYxNjZ0NGR0ZFoweVhTMnM5UXVycVpwRnRsTEJvR1BKbGtMQU00WERaMjUzSEFZZ241dlVqSWh4dHVVTC9BUFpwdVBFSHd4cy9EazBxMmR2Y2FlOTFjVzBZQWVDRkFmSzN0bm1SeUMyT2loUjE0SitLL2hEOFI5US9aeStMeXlTS3NkenBVeHRybVBKS3lMa2hzODlDcFBBNElOZmJIeFgrSld2U2FMSmErRjlYL3NlZlV5RW1udTdHTzVtMVIrMGNhRVlFWUFHZWdJNENuclg1Ni9IS2JWTG54NXFLNnBjdGQ2eEhkeXczVXVGQWtkWElKRzNnZzlRZW1NVnV0QngxUDBZdmRWK0Yvd0MyZDRZZ3U5SDFLRFJ2RVRKR0xtSXVpcTdvb0NOODJDR0F3R2JHT004OG12UVBoZDhCYmo0VzZSSkdSNE52dEx0L3UzOXhkUmwya2JvWGRaVkFIZmxRZmJwajhxdkNjdC9vZXBvMXJlVFdjbUFWa2ljcVViSEp5UHJYcVdtYWI0NThRUXh6YWRxbDFxZm5ZVHpsZDNkVDA1UHJ6MzlheWRrdzVIM1BvLzhBYnEwRHc3OEp2RnQzcVdrM2xscTJxV3NBZTRXemtXU0c0OHlNbC9uQzdpRVE1RGxtQUE5TVY4OC9BcnhGcE1ac1pOUVNhZUN5dURiM3JtUGRzakljSTZybm43M1BYZ1VINEthNTRZUzRYVzdyN0xEZkw1TThrMHV5S0ZXSUxNM1U4NHdjZGMxNWI0QzhVNmo0VzhWU3lXN0xKRE51amZjZGtNZ09TTW5qSEl5TjN0eFcxUFlEM0Q0NDZacTE3bzl2YVhOOHQ3NGJGeVVzbGl0UkdzUzdpUW9ibzdBSEc0bko5ZlR4ZngzNFVoc05YWjlMVzhXMVViSFV0emtkK3B4bm5nOGl1K3NkVmJ4VjRqMHZkTmNYVnU5eEg1OXFMbnowU011Q3hBWTdWSkFZRVl4aHNrZDY2UDRzMytuVzN4RXVEUEN5M2wxSjlvbmpVNGhHNVIyeDk0bm5QLzY2aWV3NHV4OC9XOXRJeFpTMHlEL2FZMXZlRHRDZlZkWFNHNFpqR3d5MjduQzkrdGQ5NHA4RHdYTnFaclNHTmVRemJNZFQyTk8wTHdmY2VGTk91TlN1b3d3dDRpM2x1T0dMWVVmcXc0OXZyV0tWaDh3QzhnOEVYODlucGNqUVNPZG9mN3dVa2RqNmduNlZreWZFaVh3MzRya2orelFUWEd4Slk1bWJmNVRsZysvYWNnK25PU09vUFNtMmZoUysrSURtYXhtdFZ1bWNnUXZNSXlTV0FBWDN6dEhiclhKK0lMSzZ0dkZYazZrd1M0ampMT3FJV0xyZ2tmTUJqR08vYXQ2Y3RkU2o2RjhFL0Y1dkVmd3IxYlNacjNVSTc2R0tUVTQ1WXZ1N293TnhiYXVWVUFaOUJqUEhiVzFMeDZ1by9CaC9GZW02dEhEcUVjNW51WXA3bm1RbEdVTXE0d0R5UGxBNm5JUElyNW10OWRYWHJpQ3hXWmJXTVlqVEtqYWM5ZDMreWNET2VLK29QMlcvZzM0QzhiYUpkYVA0czhRTm9lb1NRR3dUVElZaTVsa2RUdG1KQlB5aHRqY0RvTzNVVVp5U1dwZStMODFyTit6NzRGMVJiaWE2aGpWWG1PUXJXNEN1WEs4SG9SZ0tTT2R2U3ZSdmdEL3dWbXUvMmNQQkZyb2ZocFRaNlQ1Ynd6NmF1OVk1MllFZmFHbFhhek9WWWdrazVDampnQWRuZGFMOEl2Qy93OC80UlNHN3VQRkZ2cE9DWS9PM1dVVWhBMnlDZEVLeU9jYmpHQ0ZCNjV6eDh6ZU1QMkhydjRoNmIvYmZndTR0Rml1SmtTQzBTWmg1cWo1Q0ZMOEJ0MmNobUhPUjE0ck8rdHVoTWVYcWNmOEFHdnh4cFBpajRrZUp0WXQ0OUo4bldHRndscWtIbG5McEdaQURnYmh2M2tFOG5PY2Q2NTN3dDRLaDhUNnQ1VnMrb2FPNm9YRnZEQkw4eTR5V0RiaVFOdllrREE5VFZpLzhGeWFWNDlIaHZWOUxhMXZyZVQ3RTBRWXRNa3FIYXp1TWM5K21CeDdIUFplSmZCUGw2WXRuZXM5dW1uZ3FaREpoWFFmZEF3T21QVW5wVzJ4cHNjSnFYaDJid05xU2FoYTMzMnFUbnlUY1prWURCVU1NOGdqUEh1UGFyL2hqeEgvWVZpbDdlU1NTWE4wSkJMdWtkVGNCaWR3TEtRUVNDZWMwMjdpdDRQQm1wWERSN210WFFvUzNDcG5hUDUrbGJPbEovWitrMnNrTFJ0NWVOeWlOWFBQVEtrZCszWTFRY3hvNkxyR2wrTHA3RzV0TE85dDJzN3BQTXQvdGNzeTVBSlZzc3hJQTQ0OU0vU3ZTTlErR2R2OEFFK2U4VzN0WlBPdm9RMHpDUTdneUZWVUt2OFlPMDllUWZZMXdlc1R3K0tQRHN6YVhwOXZwZXB4dkhGTElzcktzb1lnZktvNEhJT1FjZ1lHSzc3NGIrT05WOEorS3RIMEtPMG0xWFVMVC9TWklvbDNvOGJxVmtEWTZBYmdRVHdPT25XcGV4bXowRC9nay93REFQd3A0MS9iRXRiTHhsZEpwK2o2UEZOZG5kSnNMU0xHZktBSUIrYmV5bmdkQWNjNHI5Q1BpZi9ZdXQrUE5Icy9Ec2R2TDRmMUFMTllTUnVCSmN0NUJ3UXNnM2VYNTNseHFTQUdZdDF3TS9Idi9BQVQ5K0V0djQ3OFFlS1BFaXlRMnBOcExLMGhCbVh5U3JzMlVYaGdHaFU0SUk0SjdjZlNYd0ErSWQ5L3dzelNOSGhrdFpyclQwK3hHYVNFbU96amlkSlVtQlVESjNJaVB1eUFpQUVvT2E4WEh4VHFybTZXUFN3bUluR25KUTJlalI3cDRZK0QvQUlaMWZVOVQwdUxUN2h2RVZuNTBjQWhXUmJpNHhhd2p6aVVLS0Y4MHliVzZFNEdTZXZWNnA4QmZFRmg4U3A0cksza2JTRjh3UkhVTlJXU1FxenN4MklITFlHVmJCSXlSejNyQTFlZU5QaWMwbDdwdW9hbFl5SzlsTHJON1BheXhpT1NNU0FCVnc4ZTFzS0ZDa0F1U0dCUFBaVyt1NmRaeVJySmZRNmcwd0gyYTNhS080M2hsVmRwRFAvdTlDTTRISEpOY2xmbHF4NVpMUU1MV3FVSiswZzlSUEFPdnI0RjBmV3B0WVdhWFZQRGhtdWJSUk1Wakp4dEtrS3hJREtBZVRudmdZeFhDYUQ4VjdQeEg4WDlEbTBYVDdMUXd0L0hIaUM0THRjZ3lLTTdTbzIvTGtZeTNCNjEwWHhLMGYvaFYzaFRWYmU4dFk5T3Z0WXVKdGlvZ2pqTUxTdEtXeXJGV3dtMGNnRUdUSE8wNCtXL0QraEw0ZS9hOWE0dGZPUkpHdTVMWmRnQnRuRWtxakE1SUh5SEhBK25GWENOMWEraVJuVm1wUzUrNTlOZnRBL3RBZUpQQjN4NzFtejA3VnJxemhzV2lqU0dKbThwZ0kxYjdtU00vTjE3KzFmU1h3UStLdHI4VXZoeFo2dWpiWkJINWQwR1lmdTVWKy9uL0FOQ3o2TUs0WHhQK3l4cFB4bnZaUEVtc1c5eHAycmFscFlpbXQ5NTIyOXlGd3N1Rkl6Z0FBcWVvQTZITmZQdjdKdnhTL3dDRmEvRmpVUEI5OWNRTnBPdlhJc2c3amJDWjFrMkFqUE9IWEs4ams3TTRHYTZWeXpoWmJvNDVhSDI3b3ZpUCsxN0I3aVMxbnNZMWRsVVhBMk02Z2tic2RnZW96Mk5mbTkvd1VpL1padVBoZDRKazhjYWo0bEdzWDNpTHhHc2NrRVZtWTQ0dk1pdVpTUTVjNXhzeGpBNFB0WDBKcWY4QXdVSDFqeExwMDhXajZMNFIwSzh0TDZXMWxsMS9YQ2x1eW9jWlJWUlpIWThraFFkb0hQVVY4LzhBL0JScjQ5Nmw4UmZodk5vT3JlSXZEZDlKWStJclM3MDYyMHJTN3kzWTJyV2x3Uk5NODZsQXhXV0loRWR1SHoweFV4alVwN2FBbGRYUHUvOEFaTS81TlorR3YvWXJhWi82U1JWNkRYbjM3Sm4vQUNhejhOZit4VzB6L3dCSklxNzhTZk95K2d6MXJBQjFGSXJCaHh6V1BkZUtJTGk4K3l4U0x1TEdKNVZZRVJQeGhlUmplZlEvajFBTFN1QmMxWHhGWTZJeUxlWGRyYStZQ1Y4NlpZOTJNQTR5ZmNmblhHZkViNHA2Um90allTVGF2WTJ2blhrQ3MvbnFRcW1RRE83b005T2NEREhrVnI2SFphU1o3dTUyeDNGMWFsbzU1N2o1blZRVGtBdG5hdkJPMWNEMkZZWGk3VVI0ZDhCYWxjTGIyY1ZwcGJ0ZGdRNWlYSzRtWGxSaGcyOEFuamtrODlhdEpKbFJzeWJRTlM4SnJxdDVIWjIrbDd0VWFXU1pvRWlaTDBzUUpHY3JuZG5CSkxkUWFvK09QaXphZUhORHZMcTM4bXp2b1lmM2FUTUdrbUpKQ3FpODVVc09PVjY1NEh6VjRMOFFMajRmK0w5YyszWHY5azZQY0Yxa2tLQXJkWENzU2pITWJMdUFDN2hrTWVRZWNrRG5kTHRkQXNkUHVOZDA2VFhtaG11WGcwOTdXYUtRcWlLd01oam1ETklXZU5oOTFPZzVHVFJaaHludC93QVJQajlydWwrSWRCMFcwVzM4N3hEYVMzS3ZGYVRDU09PSUJwZkxmRHI1bTFsNWRmTEc0RXZpdU4rSWZ4ZjhMZUhQMmIvRmtjV256V09xYWxFOFF0dGRXV080MVY1RTJFdDVpL3YyRWVTeWdzcEk1d0RYa254UStJdmlMVi9IMmxMRnFtcDNkbmIzZmtMZWFnbzhtRGZHb2s4c3FnWlFGa0tzcE8wbGxBRFk0MnZpeTNpblRiRzhzMXM5TDhSV3VvYWJjejIxeElra1Z6TmErVTd5UENKWFpGZEM3THRYNTl3QklPY0RLY200dEpGOHRtZmpUKzBQYWF4OEpQaWpyMmg2RGIvWWRKMHUrYTBzWVREdW04dkN0bGdnQms0Y2ZlejFHZlN2Q1BIdml1NTFhTzN0WmpQYnF6NGxjemN6dnVKQlBDN1FCZ2JlUURrOThEN0EvYlJNMmxmR1NQeEN5d3JvdXVRbVpGV1lMTGFxaWhXNnFPTWd0a2Nra2pIQXg4WS9FQkQ0ajhhTXRncG5obWVTWkV1SCtVb0NSamdaSko2RGs1SXIwY0xKdW1teHkzUHBmNGMvQmpTWlBDY09xK0NaZGVrMXFHMzgxM2NBUnhPRkRIR2Z2RWNZT1BjZEFhK1EvRzhHb2FycmQxZVhoVjlTZTdkWDJBS3FrSEJ3QU1ZSFRBNEFBcjd2L1llK09WcnJYZ2FidzdlVzhkcjloakZtYjlZeDVveU1LbUNlT2grYjNyNXAvYXU4RngvRGo0NDZoYjZmRGIvMlZjc0o0SGlrWW93enRaRjNBRWZNTTRJQkFPQ1BUdWpLejFPZU43Mlp5bmhqVDdhMDFhMW1tU05vWW8xd0dHQTJNRG5ucWNZelhZMjN4ZDBmd05KSjVuaEZtbWxVRkpmdGFxQm5CUFlnK3dQVDhLMGZoSDhGN1A0Z1NmYXJtRnBKYlV4YjJPRmlJZG15b09CbGh0OThZUE5keDhRL0RYdzk4TmZEalVyMjFtVjcrSjRFdGhNQVpiamV4SDdwZHczS0FyYzQ0RzA4NXJLVjc2R2lrdG1mUHZ4ZC9hQzFUNG5GTlB0YlZiZTJIQ3hMaG1WUnp6Z0Fldk9PMWNsNGcwWmRKc2RPdXJhNmtsKzNZOHlFT0RnZ2xRU00vTG5rOCt0ZTQydndyczdqd3BlU1dUV09uNmhmaDdkSGtsVjVtWHl5enY2SW9VZ2NET1QxSE5lYi9Dand2SGVMcW1uM0ZnTCtTNFh6RVl5aU5TQXB3QWZyazlzWTdWckhZSlcyUk44TjcrNjhIZUo5TjFDYlVMUFM0MHVvNDVibHhIY3JBQzRWbU1ZSjNiUWNrZTFmU2VzL3N5dDQxbGsxaVBWQnJWeGRLWi90bnl5TGNkZHUwTDhvWGpnTGdkaGl2Q2JQd1l2aGpUMjhxMnQ3M1RaN1VuemRWTFJyYnNCOHlLTjNKSkxmZHllbVNlSzg4OE42ZnIxM3FOMXArZ2FscVMyak92bVIyOHpvcEpiQzVYSXp5Y1pJb2t0QTNQcExTZkNiYWFaSkpoYXcyOWl4RFFsU3BZZ0RrRmp5UFRrNDk2dy9pVjQ2dDlROEtXRTB5cmJmYkxrVzl1c2pnZ1JBa1BJVUF5VlZjRFBkangwRmZQdmlueERyMmd2L0FHZmVYMTV0dGdZMGp5UmdZL3orZFdQaDNQZGVLTlR0dnRsMU5OYjJpN0ZReWJ2TFRkbkF6N2tuNjFNRjNKNWJhbjBScjNoM3c1NEo4STJ1cFEyRnJmUTJyeE1KTWlOMVhvcDRHWEF6bjVqMUE2bXZEdmk1ckExWHhWYjMrbXRiWFgyV0k3VlVCb1ZqUEd3ZzhkaWNlaHI3QTBId1Y0ZCtMM3dJdmRCdGJOZnRFbG0wTDNSajNORGhEdFlucG5QWWR4WHhSb2ZoRzU4TnpTL2FJVzJ4dVlHWCtJdURncGpIWHJWeFYyVEZsZnc1cjk5NGptVlgwdTFXR0c0RzFZMWNsano4bnpFNFhMRGdZL25YYitNUGlEZFRSNmI5aGhXdzFld2NzdHpHTjByais2elp3VkgrUFBOZW4vczUvQ3JUTGxkUmp2YnlHeHZiSGJkU1JFZ0dCeUdDcTR6d1J1M2ZYSTRLMGZHSDRUV2ZoRFM3RnJWVnZycldHTFE3SEc2QUtEdUpJeUdCM0w2Y2dZNzBYMXNVbXVwNXI0VDBYV0x5QzYxS1RVcnFHUml6QlM1WDdSay9NdlhIUTV4M3hYclh3WC9hMTFENENhYmNhZmFhUmE2dmJYRC9BT3BsTGI0Mkl3SGpaZnVzRHowUEkrbU5yNGRmQkxRL0hIZ3JWbDhTYTUvWmMybnN6MjluSC9ySmlWeHVHZVBsS25QSGNWNUg0VThHZUpaSjdxM3NkUGE0bmhIN3FTU1NPTjE2L2MzRUZtSEdNY2pQMHpsSzl4M2pKV1o2VjhlcDdmeGY0d3NmRXgwK0xRN21YUzQydUlWT0hubmZsTWpydWJJUEErNkFUbmtuTzEzeE40cjE3d0l0bnIydVdMYkl2UGFOVVNEZkV2T0drQStZOEFCVlZja2tFOXEwTEx4aloydG5ZMlBpWFJMalM5V3M3ZFlHMUhWcDlzTWUwQkYyeHFwWmdGQStYZ2tqR1FLMTlMVFFMbTFhd3M1TGk2ajFKeVo5WnVyRXJheUZtemhRUG1WUVFlU0NwSEF3T2E2SXBwRWN4d3ZpVFFiZTUrRit0VzhVMFVqWDlsOXFzNWxHVmtDRVNNdVJubjVDUHhya2ZEV3JTUjJGdTh3MUM2a0Z1cWtRd0dSaW0wWUQ5UGw5Q01uaXZxTHdwNGQ4SGVEVmwweHBOSjFDemszT1ZlNWdDdzV3cmxWT1BsSk9PRHhuMUp6ODkrUGZDOW40UjhVWEZyb3krZHBDeUZyTzRUZXhaRHdGREhydEl4eDZkVFJ1RVRXOEM2Wk5Ock1jbHErcVFRWGlHUHlvb2c3UGpEYldIOElCd2M0N0VWNjFkZUdydlZmREdyWDFscWsybXRvNkc1UzBhNkhuYW5nZk1BZ0dUdDJnZGU1ejcrTDZkNHQxVHc1Y3BmdzYxRGJYdHVTVVdaUXpZNkViR1hhUVFlQnljanBXalkrSVQ0eDFYVDlTaFpvWDAwc0x5NWh0MmZPNWVaWFhQUTllbjRVbXJEYXVmUy8vQUFUMzhhV1BoWHhScURXT3Bha2ROdXJCcmU4a3VYWXdXN1ozQWJrQktvUXpEa1lPOXVSelgwcjRidXJ6d1JwMDAxeEpwL2gyNnRiaUNLWDdaRkkwYWh4UGRIRHFYREREc3VWR0RoZW1SWHhaOE1mRnlhUjlybThKUmVIN0x4S29hMGl1SlNMWkwrRTQyc2k1WGN6SEozWndDRHdSZ1Y5VWZEKzIxajRpL0NxM3N0ZnZQTjFUUlV0bnVsdXJ0bmk4dk55WWhHNnhuY0gzNEhtY3A1ZUZ3R0dPTEhVVTF6bXVIcU9MNVQ2ZThPZVBGOFBhbG5WTCsxa2ptc1Z2THlPNTBLYlV4dERyRjUxdWdsajJBc3lnNTZjdDhvNHF6OFYvai9ENEQrTEhoKzZpVzhrdDdTSzN1SjdlQ2RJN2E0OHVWMVZpc2VTRGxGQjVPRkdNa0VFK1NmdE1lTXZEZm42Wk5hMkEweUc0MHlPeTh5NnZmc2NZUDlwdVM4anUreFYyUmtuSjZEQnd3R0xQakxUL0FBUDQ2K05GbnJFZjdRWGh1dzBqV0V1Tkx1ZExqMTJGTkwwMFc0SVdjeGVjQXl6U1JqYnRVOHNKTW11R05GeVIxUnMzYzlyOGYvdHZTZkc3VFp0SGJUZE4wNks0S3k1a20zeWdSa3NmTDNBZHV2SFJqMnJsZkRYeDYwYTYxdXowK08raEdwM0VyYi9Mczlna2tYZElXYVNPSVJzMlF4M014eVQzNHo0VDRTMFN4OFgvQUJuaG0wZSt0UEVHa1MyU1R5WGxuZXczS1F2S24rcFl4N3RrbWVOajRJeDNKT05MUi9nQjQrOE5mR2liVU5SOE5hL1krSGJXOXV0bHhjMlVrYXBHd2tqaklNblVNV0FCSEJKVTU0R2VmMmJUYVpweXhSNzVyWDdiK3RlSXZHdHhvTW1xNjlEZVdjMGtNN1c1OG1JR1BQbURLbFQwVThoU1BlazhTK0Z2Q2RwSGEzVjVhYTh1cFhFSzNzMTdiYXFvWjVRdTVuSmtoa09TeEorOE9vck0wLzhBWnMxQ1A0bDZuZFgwM2h1eGoxL1daMHRFdDc2M3VybVkzTThvajRqY3NvK2RNbGdRTW5wMFAweHBIN0ZPamFucGhrMTVacnFZeGlNb3QyOGUwRGdCU2hBR0FCeXdiSjU0NlZwZHhmdW5KVXNmQ2Z4QStPV2hQNDMxUlc4TVd1dFcxemNHOWovdEc1blFpVmtWWlhQMmVTUE85MVpzY0RKT01kQjIzL0JTeTd0N3J3dFpSdzZmcGRyR3Q5WXZDMGFTaTUydHB5N2c1WnlNWndBQUFjSXVjbkpPRCsxcit5Um8vd0FCZmlQYi9iUEcyazZUcDJwV3JTd3ZxTWQxUExNd1k3bzR4YndPQ3k1R2R4WDd5blBKeGY4QTI1ZmpkNFIrT1h3SzAzVlBDODJ0WGtjbXZSVzYzTjFaTGIyNm1DellTUnFkM21NdzgyRnVWQXdldVJpdXFyS1RoR1VCVWxHUE1wZHRQdlBwdjRSL3RvZUcvaDUrelY0Q3MzdHRTdUxuUy9EdW5KT3NhTHlzZHZDSDIvTjZnZ0E0L3JYcXkvdGYrRHpESk1zMXl5aXlXOEFSRmRtWExncUFySExBb2VQeHlSelg1Mi9DN3hNMnBhSllXa2QwbHJIRnBsdXJ1SkFHZmJFaWxNRWM1UFVBRThHdW8wZnhmRE5GOW51bzdXem1zckI0cFpFM041M2x2S1IzKzh5dEdEZ1k2RHAwNTlMRGxUU1BvRHg3KzNaRHJzMGE2TEpmYWZwLzJ1Tlo1NVlEdWl5V1p0b2pPV3dSemxoa1o3NUJkOE9mamsxOXF0cmJ3NmdMNnhFa1UxNDg4Z0FNcktOekRhck16Z2pjVzJsTXNNa0RrL0k5M3FzK2srQ1k3dEx5Mmo4dTJXUjBHZjNjakFrNERFWklCL2hMRGsrdkdiOE5manJybncxOFVRNnBvdDVKWXpSdXpqeXZtM2xsWGR1VTVESngwT1J4bjNDalVzN01yMlNhMFAxVThIM3R3TmZ2bFNXR1NDWkZsSG1qYmQ1NVVCaHRBd05qWUpCeWU1cng3OW9ueGhONEswdnhab0VKYnk5YXN6SkVKQ3plVyszeWlpNUl3Q2ZJd003Q0hkY1p3RDR0OEZmMjVycnhOOFJ0TVh4ZGNUV2ErY2pXMDlxbnlPck9TeU9DQ1NDeFVZM2NjNFU1d08xK0pQanZ3djhBSHp4RGFhVHBldUc1MWJWSUxqWkdtYmFhMm5qY0FBRWtBa2tLZHVjRVIrNEIwaWs5VVk4clRPRzBYd2JlNjE0KzA2eGh2NExPNHNaRzB3Q0dJUno3TjBvT1NNZk1GUDEya2NBQW12UlBCWjAvUS9ocmVUUGRmMm5McFdxUVFhYzRrL2R3U2xJTm93T01ncVFTTUVLT01HdkQvQlh4WG10dkUybWF4Y1hWei9hRnJHWlpaSkFzazF3OGpOSTdzTm9EYml6amFOcThBSEhmUStHdnhWajhMZUtkZWJVdE51cjYzRjU5c21uVUdIN0VvR3hTRlB5OHNTTnJBampIdWM0eUw1V1dmQ0h3enZ2RVV2alM2VlZrMWFHVTYxcFcyU0tTTjFlUlZNaHp1Y28vbHVBdVRzTHFkbzRyMjM0YjNVM3hPOFRSNmJKY2FmcU1XbklrVnpBSVBrQ1J4TXF0RzJTdi9Md29PUnV3cHd4NHo4LzNQajZYd0JybHQ0dzBQVWJrQ2FjeFJXOFVMc2dWNXJlVklHSUJVWmlFbUUzRGFRQjdVZnM0YXpxVWVpYWZERGFJYnlFMkwzRnZHekdTN1EzRWJ0SzM3MVN4YnprUW9BRkN4ZGZXNDIyUkxmVStEUDhBZ3JMZUw0SytLZGpvYTJQK2xRNldVa0prS0NCRm5sVUVLT0N6RldaaWNnaGdPMlQ4TlhldFdkaGQ2cmRUeDMwK293aVA3S2JXUEVmN3dIZnZZWUs4SXYzU0Qxd1JYMEQvQU1GQnZqbkg4YS8yanZHV3RYc2lUWjFCNHJVVzhiUlFCWThSRGFyZk50SVRQemM1SlBldm5lMDA2MGw4TFM2ck5xMEZ2UHFMdHR0UWhjZVdqRlFQbHlWYk9UODIwWXh6WFpRaHl4NVFreVg0SjZ2TmN3WFgyZTZtc2JxeGdlUVBHeks3S3FsaU01NUJBeGovQUdCWFdmRkx4bGErSWZoWlk2ZXR2ZDNPclc5MzlyYTVsVlJzQlVEQUkrWmd5aGM3dTZaSFUxd1BnRzZoOEwvRWF6bmt1SXJqVDNrOG01S04vd0FzbStWamc0NkE1L0N1NzFXeXRZTkZsYUx5aXJMNWJDVTdaQ29JSXdjZGZvYTI1WEV6Nm1MNGExYldKZEJodFRyU3d4M01tSHNWMzdtVWdobVk4RHAyenptclhqelVyMis4VWFmcGQ1QkpieUt5N1ltNFpJd003c2RWM0U5K2NEODRwbmJTcjI2a2VNV3RyR3BnbmtVS3pxUG1PVnowYmpqK3VLNkw0YytCdkpaOWN1aFo2akhNaWllUzZjaG9VZGlpL3dBV2R3NVBKT09LMEpqdmMzTmM4Q3pYM2h5K3VMR05vYlcxMDZSMWVSK0lZdkxZeUhwOHhmN29CLzJ1T2hIRmVINGJmd205eGI2aEZJWTVvUThaMjRJeG5Qb1RsUzNCUFlldGV1K0pkZnQ5ZjhQMnZoN1R2RTFsWmFYS3hiVUpUR1VFOEczQkNNeS92R3dTdnlIZ2R1NDh6K08vaWpSTG5VbzViRFVHdWJFa0pCYlJUdzRKMjRNaEtnN2R6QW5CeVFEK05hTHNMY295MkVYaW5UNGJxT1NRMjBhaU5CRktNYlFCamFPZ3gwSVBjVlQrRkIvNFJINGkza3hXNFMxbHRXODA3Zk5PTWpuQXdDQWZYZ0QxRmFHbitLbGowR1NhM3MxbHVicDhnempDd3FvQkxoZlFub0QxNzBlQWZIeWFKNHpuMUhWN21HeGp0SVMwTEpiRldtY2tIYmdFL2x4UjBMT0ovYWNna2oxRVNMNVVyVEFiV0NiR1ZTQU1iY2tnL1d2Ti9BK3R5ZUdkZnRaSkJ1alJ4dlZ2VE5lZ2ZHYVM4OFhlSnBMM3laRlc4WVN3S1ZJSGxZR0NQWS8wcmo3M1FIaUN0NWU3bnNjVnBUam9ITnBZK3V2ZzU0ejFqd1pjMjl4YU5aeFF1TVRSS1pXYVdNam5JQnh3TytLOGkvYW5mK3lQaXZjYXRZd3pYV242bEw5c2h5alFyaHM3dHVWNFlObms1SE9jYzEwLzdPWGo5YnpTYkdHNm1MWGxzTm1TZm1uUlNSalBxTUQvQUw2QjcxNkQrMkI4UFQ0dCtHOXI0cWdnaW1FVjBvdU53Yjl5cFFaemtqa3NvNjFtbzJtVHphbnpsNEkvYVlrOE1YZHhNTkIrWm1iekhpdUNHY0ZtT1pDeXNXYjVnTWpBd280cloxMzlxRFRkZW1oMUtHYSt0TlV0VVhaSExHczBURU1DVkRaQkNZQUE0UFRHQnVPT2E4SCtGa0Q2NUxOKzV0MXRHY2gwM0FnRU1CeDNPT0Q3KythNFhWdkRTUjIwYzBNaXUwbkpUKzZLMzltcmxhZEQ2ZytFbmlEeEQ4YnRCdW8vdDJnMnR0Yk41elhCdDl0eE1yZndiZ1JrWnh4MlBQUVY0MysxM2ZTV1h4YW4wejV0dWxaaVU3ancyZXZQUElDbm5ucDZWNkIreTc0U3N2RWZoQmxtdUpMTjdkdHl5Z2phcmMvZUhKd0NRM0hKQUlyeS93Q1BPbmFocm54VDhRelhjTFNTRytrak01azNxUUhJR0NlVDlhaUZQOTVZSTZDMnZpL3hSWStBNDIrMVNYbW15QXYrOFR6cElRT0NBekRJQXlEMTQ0NlZpV254azhTV2NFa01PdWF2QmJ5Tjh5UjNVZ1Q4czE2RjhSTkF2Ykw0YWFMcHNMTkhaQlJHSFEvTE16NWNnbjBINUhGZWV6ZUZvOU9nYUZoSTByY3N5Z2hFL0d0dHdSNmw4RHZEdHY4QUZ1NCt4emFxdHRlWEFMUGNzcGtidHhucm5PZVRXam9maFhUOUc4Ulh1aTZ0Y0w5c3NwVGJ2dTFMeVBLMnRqY3hkQ01ZNXlEZ0RIYkZlWS9ERzZtOEYrS0k5MXhOYkx1QVhZYzd2NWNkZnh4WDBSKzBmNEVzYjdWTkI4UVFyWm0zMTZ4WHpHbkNLM21SZ0RKUEE1VXBnOFp3VHpXY28yWTA3SE1hNXAzaG5ScmVaYldQVU5TdUpGSmpFV29XdDBtY2RXRVpMY2RlZzY5cTZINENhR3ErSGRRMUxTNTdGdnNzYkpxRm5OTVZ1SWpnbFdDOTE5ZlFnanRYR1EyMy9DT1dyV3VqclkzajZnVEhQOWx0UE9sZ0FYbjVncEdDQ2Z1bnFQcFJiZUhMN3dYNDJhNmdsdUgyMjVta3ViWDVkMHJnc2c2REJKSTQ2am4wcGN1Z2ozWDRXL0ZEUmYyZHBOVTBQVkxXMHY3dlViU0tlT0taMUNpZGwydWhKWU50NUpHQVNOcEhmY1BwMzloRDlvalNieXk4UnRxVnZkZUhiWlk3ZXh0cm1BeU1sMmt6VFRiV2N4T0N5dkMyR1VvUU1Eb0RqODUvaUY4Ry9HSHcyMSt6YlhkTDFGZjdhaGp2NFpXQXVQT1JtWUFod1QxS25nOGdqcDYvWlA4QXdUN0h4QjhEZUhaN3lPQ0hTYlhVYjZJV1Z1MXBGTk5MTEdoSDd1SXFYeWZNVmM0d3hPM09RUlhGaUtsTjA5OXlxY0duYyt2L0FOcEx3aDRGbjhhUitCN2pSN2ovQUlTU2E5MnlYalhNYnh4dmNDUUxHWFl0TElxdEtod1c0SzlXNXIyK3kvWmU4SjNuZ2F5MUszMGxZN2E2c29yemRHcWdFUEdIQUJ4Ny9yWHlaNDBudnBmakhKY2FwY05EcXYycTBsOHlWbGFXM1dYTHFSaGR2eWhWK1pQWGpJUFBxV21mOEZiUEZmaEh3ZFphWEQ4TmRKL3NVYk5JZ3U1ZGJuTTl2RnY4cUtXU0g3TnlBTmdLcXBKeU9jSEk4eEpPTm1kRW95K3ljZjRkK0l1ajZCNG8xendycDg4a2NNZXF6U1JRd2lWbGVXSWlKWmxDallDeXhJY25KNTljRVdmQm43UzNoM3hENGprME9KZFNtdkM3aVdhWkhXTmZMVm5PV2FRbklLakJLODhjQWRmT1BoRnBNbDUrMTFxME5yOXFrYTN1WGhhS1J6dEFPQS9IVFBJT2ZWcTUzNEkvRExWN2o5b0c3dW0wN1UxMGt5WGlzNWpNa0FabzJNWTNqSTdnZXVUZzA1VUk2dnl1YVJrejYzMHpVM3Mwc3d1dWVHWkpwSm8zYXlzcG5lOFRiS3VHS0JOaTRPTS9Qa2NmaDZmNEowZTM4YjNOeC9hWGpXejBYeTRVa1N6dW5FMDh3SmtCS3g1RFkvZDlSbnY2VjVSZGZCdSs4TmZFNjk4U0xwMnBhYnBkbS84QVpoYTVzWnJaWjVwR09HakxJRVlEYmdzQ001R004a2ZVL3dDelEwZmhqNGJTWFY5YTNyTmR4YjRwUlp5U0syR3VWKytxa0RHL3VlaHowcm41VnpXSm5OOGwxM1BtTDQzVGFmWjZwOE5kWWw4QytKdkdXbzZmZTNrOXZiYWJPc2RxTnB0d1JjSTF0TVpGYlBRRk1BTnpuQkZiL2dvSCt3cjRkL1pYK0FWaHFHZ1grcnpSWGZpWllZN2E3dkpKb29GbHRwbVpsUWtSaGlJSWdXQ0FrSUJuaXVGL2JCOGRhNzRkOFovQ3ZSOUwxalVOT3RyKzRtYTRndGJxU0ZKZDkxR28zQlNBMk1kL1d2cTcvZ3MvYnFQMlg5QllLQXg4VTIrVGovcDB2SzZwWFZLS1J6MUc3cytJZkJmakdUUkcwMk9FUk5JTFcyS3M4S01GK1FBOGtaL2l6d2ZyMDR0WHZ4RDFEd2w0bHZHaGJUNVpMaXlSb2hQYVJ1SGpYYWNweHdjcmtrY2tMelhHdmNSV2VqV2QxdWthNlcxVkVWbEo4djhBZERrZGV4NHFIVTlSWFhOWDArU082ZU9Sb1hSV2ZvVmZhTnZQR09UZysvdnh5OHpPdFJWa2RKYmFwZVhtbFEyZDVhaTNpWkFoVm8ySks5RG5ub05yY2NEanYzNXR0YXRyVHhMY1c4RU1mN2tiWXBXa1BsREEyNHcyZTVCd2V3T2M4MXBRNnhOcDhFRWNEaWFQSWVWaVJzMzg3aVd5TWNjSHIwUFhGWXVyWGRucTEvTTBLeFhFM3l0NXluRzVqdFhweHlEejljR3AxNmx5T3Z0ZGZsMVNQN1ZiNlhheHJ0NkNac0tEdUt1bzNmS1ViQnlHMi9LQmpISnRKNDBsY0o5a3R6YjZyRzUxQ0c4anVDcmNvdS9jNUdPVmpianR2eU9tVHhkdFBkV05rb1dWUkR0Q2tNUVdYc3craHgvbklyUjhOVzdhcFp4MmZrcXBYZkVaUmdFcjFRNFAvQVZBenlSbmpCcWJ0RXVLTzgxZjRyV04vb0VNa3pQY1J5VzBVRWptWmxtUW9yWkN1dTNhcDM1d1FTTUFjZEszdmd2KzBSWTIvZ3J4TmJhOXBzMDJxYXZMRkhidUlQTDJPSFJXRE1XQmFQa0hBeGxtSjdDdkt0TjhPeFhQZ2ExYU5aWkJFWVpKWGtHME1TSEJaaWZVODRPT0FCbnRYSjJlclhGcnFuMlMyWnIyTkpXODl5QXd3cUIzSVBIM2NrNXlPQ091ZWJwMUduY3g1VXo2aC9heC9iQzBUNHVhTTFsYWFiY1dGenBjb2t0MGd1VVdGNUVnTWJJUjh3SU80OWg4dUZ5TW1zUDRVZnRXMnZ3MjBqdzdjUTZUZVBlV3lYZHVrVWMrWVZWL01XQnNzcDN1SkpaV1BZQXFCZ0Rud08vMG43TGJSMzAwamJZYmxJWmpISXBCQks5VVg1dU9mbXhqT2ZiUHV2Z1Q5bjc0WncrQnA5VThRK1B0VzBPNDBlSnA3cU9TeldDMVpWRzVkbHp1WUU5VHVCTEFoRlpGY2hHMWp6emxlSk1veGd0VDhiZmpWcUF2TmQxWmxWbzR6Y3lPU0crVUtYWThaeWZvU2F2NlI4Rk5ZdjhBd2pwOS9wOFZ6REZxQ3F5b2svbGtxeTd1cElMREI2akl6a1p5Q0srek5TOExmQnZ3eGZhaFlUWC9BSUcxcTExQXRjUmhHbGFRb1d5dTlwZ09SNlpHZlFWNWJvZndxK0hIdzk4WkR4UTJveXRidzRXMnROUHVEYytVTzYvTElRRnlOeERNQUFTTWRDdnFVN3BXWnk4eDgzYWo0QXUzdlpyTzhXRzVTQnRnODY0M0JRT01ndDJBNllycWJud05yR3U2emRXdGpaejNzSU1oUlF2ek9pNUpLanVRTzN0NmMxOW1lSVBBbmdmNGsyc1dnM3VyM1VjbXV4TGNMZDJjSWo4dkxGUkZ0RGx3VkNnNVVrRW5IdFduQm9IaHY0WjZUL1llZzMrb1dMV1M3L3RVOXBnM0RLNDRRdHZZc3dIelkyOERzT2xTa1R6WFB5NDhhNjdlNnA0bXZiV1NLNisweHpCSFJsOHRsS0RhVjJMZ1l5Ty9QSHZVdXAvR1B4Um8rZ3g2WEl6MjlubEdlSllFajgxbEdGTDdWQllnQURuUFRQTmZjUHhOOEJXM3hZbUZ2ZWE5cDdhZGF1end0ZFd2a3pRdjhtNGhvdDRmT0NvREFFQTVKT0FLZG8vN0YzaC94enBGdC9hRWtsNWJ1UE1hNmh0dG84dFZKNnlPcnFUaFFEdFlCU3pkcTBqVVZ0aXVaSHdKL2FPb2VLNUZWcFpGVk9QbVUvSUNjNHgwQTUvV3RmVGZoOXFObjRpdDdTNGxrakJVT0dQeTR6MDI1RmZkM2gvL0FJSjkvREx3cDluMWpWdGVlMzBHNGhkUFBtMUNFU0Y4QTdRaXFTY0RCeVEyTThnSHA2UnBYN0szd3dQZ243THBmaWE0dnB0V2o4bU5oZHBKWmlNc3JjU2lQYUdCQUpCSStVdHprWnFuTyt3ZTBTUGxQd1o4T04zaGUyTjlCYXpYUmlBZVJaMmpJSnp5UXAvK3RYTCtJUGgrTmU4V1NXZW0yZDFMSmJ3cFBJcTdaRng4eWw4QWJ1ckovd0I5SGl2bzd4bit5cGI2Uk5QSG9kNWJ6ZVQ4L0U2U1c4ZU1kWlF5S3hJeWNLcll3UWUyYlh3NC9aZzFiU2ZFdjlyV2MrbHpYRTBBaGxMWEtzcXIzNHlTZWNrYmx4MDQ0RkRrckV1U1BrcDlJdTN1WWJlNmhtc1pJRVpJUHRBYk13R0MyME1Ed09PT090WkhpNnlid3hJMW5NclJtWnN4dHM0a0hjZzl1dGZiUHhFL1lvazhYYU5DeVcrbTJ1dGVidWw4MWt6TUNkcDJ4a2xqODN2Z1lHY1Z4V3IvQUxDbmovdzVwZHl0MzRkdGJxM3NOcnM4MTVHcVdvWmpqR1gzWVlEb1Z3UFh0V2thcTZrOHlQbGZ3YnBiMkdyMmR0cDgwdHV1N3psZDN5cFlLZW1QWG9mZXZvdlR2RjhPai9DYlZOTjFpNDFiVUYxcTFlTzJoaGczSTBnNUdEdTdNRDFIYjB3YXJhTit4N3J0bjRoam50N094Z3VMcC9LamxqdW9Da1pJSXlmM25PYzhjVjd0NEQrQzhmaEtXUzg4VVcrajZ0cURZVzJlNnRvWXZJWlNNQURlZU9wSnh5Y2RPeFVtbnNITWZEdGhvOTFCOE45ZE0wY3EyMzJvUnV4Ky9FVVhMS3c5V2JhTWV2MHJsOVE4T3d2YmJiU0NOcElvY2tDTTd4ejF6a0Q4Ni9RN3hoK3lsRDhUTkV2clhUZEpzb1A3V2thZTdtZ3ZmTUVqSG9RcXEyU09tNGZpRFhpdXRmc1N5K0JOQk1QaUMrYTFXOG0yd1N5ajkwV3dNQnR5NTJsdU03ZXg2VlVheTZsUmtqei9BUFlmVVI2aEZMSm84bDlITmR4Mm9kWS9NRnMrM2x0dmM5Q01FWTVxaisxYjhGci9BRWZ4RmRhbEMwMGxucVdxU1JTTWtQQ08weElWdnF2UWpIS3NPb3I2bCtBWHd5MWp3bDRWdUZ0N3J3ZmEyY1RxOGFhUkZieWZaTUE3cFpOKzk4bnI4eEk3WlVZRmRIcXZ3RFg0aGVITHg3blViVzhXYVh6emQyVEtwaGZPUXlNQUFweVZ6dHp3ZWh6V2Z0TFQ1aGN5UEFmZ1Q4RE5QK0o5alkyV3VQZlhWbnAwTWdnaHRMZ1IzRnJPQWZtWWJTR1U3ZTY1QXh5Tyt0OFl2K0NmZjlqMlQrSU5GYTh1Tk1oaS93QkpnbkprbEpJQUpYQ2hUamx0dTRuQTZkSzZyd3o0UDhNL0RqWHZNOFRXL2pYUTRiaVh5Mm5XZVZvbUNOdDh5T1ZYREhlcEJ3NnF2YklCclcrSTM3VW1yYU5mV25oUDRjM2Q3ZVdmMmhvYmZWTHVZUExPRkNia0pjUDdIYzJEMDVIU3I1bkozUkhPNzZIeVhOOEZyU3d2SmZzOXJDbDVFaFczY1FPd0pBK20wNTc3Z1B3NHIwVHdIYTNQeFUrQlZ4cEVOcnFGMXFXam1PNnMxV0xleU9NckpCMXpnZ01WOVNWN0RqNnMwM3dONGJUNGNRNjk0Z1MxMURhcXRyRXRoY3BISkRLUWQ3TnRaRmNFcWZrUDhYM1IyUE4zWHd5K0h2Z254SzNpRHdocHVwYWxmWHlueTVCSzdwYno1QytVNklRM2x0Z2xtRFpHVGltNmx5K2J1ZkhOaG9HdGVEZGN0OVliKzJ0T2dXY0pNZzNxRGdIZ3FjZ0FIc1FlQ2VPYTZqVE5mdDAxaTN2b3RVbXRyZTdsTDNwdTRoTkRKSXVXRHR1QXdUbGdQY2oyeDluZkVQeFZCcS9oYTNYV2ZDdGpwOHZFYTNjRnZOTjgvQ2phK0pKQXJaNkhPQWVEMHJuTk0rQnVtK083YTY4TzYxcjAxdGIzc0N3UzZmcGVscE5kaUJYVm1kbUtCMGtLa0t1NGZQak9NZ3RVdW8zdUwyaWVyTzUwdndSRjhTcnJVSkV2cG9yZlEvQmtOMnJDYmF6eU5FOGtjSStVanl5cmJ1bVN1QmtFbGg5UGZCclZOSjhaZUh2RGRsb2QzSmI2VHBPbTJzakxhWHNsb0h2WFFCaVNwSEtvTW5nWjgzbHZsd2VCaC9aUzhMWGVzVzgyamE5NHkwV1AreklHalI5RGp1N2ErU09QWmdTeHpxSUR0QUo4N0M4bkRIa0M1NEMrQk43cjBIaHUzMFhXRTFhNDhIYTFCQzhHb1dTV0QzS0ZvQ0o0NDFsTFR3RGJzTENRTmhGQ3FxcnVmd3FtSGxmYlE3SVZvdlJNaytLdndOdXRMK0tzZmlHT1d6dVpvYnEwMzZlYnFGNHc5dUJHVmFRU096S3d5K0NnSis3eDk2dkYvaUpMYWo0dGFpc1Zqc2I5eHFMeHhUQ09JTTI2TXNVS2NIQ3FDdU1adzJNbXZiUEdkeEZwdjdhdXJhZmVlRmJHN3ZMSFZkUHM1SnJPZStZd0V3Skp2V05aVVhjUXE0WGE0QjY1NXo4KytQdGIzL3RGZUpJOXR2YjZmSkV2bUdXQm83aFN0eTdIQ2s1QXdHR0NNNXgwSXJMcjhqcXBiSHZmdzUrTmx4UEREYnlhbnBrZDdESjlwV3l0VmdOdzVWc2hqdFJXUFlrTU1Eb0NRRnozK21mdGh6ZkVpOWkwcWJ4UmVhbEpJaG5GcEhmcTNuQ01iczdkeHdSdHlEeHppdkMvRFdsUnArMGw0ZmhWb1Z0NU5QVkZTMWp3UWozT043TVdPV1BCendEbklVWnJ6YjlsU0tPMi9hL3RkUGxlU1M0L3MyV2Zkc0FVYjFWY0QwKzkwb2pTNXJ0a3VWajdSdjhBeDVKNG90b1pKcmZXSkxXNGtKaXVMK081V0V1Q0NOcnVBR1BCSXdUOTNJNHJsUEVQN1JPaWVFUEVkcm85MUZIRGVYSlVSRUk1RWhMRk01N2NnOVRYdVB4YzhEM21qL3M0ZUU1cnZXTDNVSWxrdG1nZ21TRlVoRFdwYkkySXBPTWtaSkp3VDM1cjREL2FybW0wcjQ5ZkQ5VVp0dDVMWnhNUjBVdGZ6QTl1NEFxWVVyeTVTWXl2Qy9tZlJYeDA4SjZuNG44YmVBNHRIK0dYL0NhYTRzTXNsaHFNalhxV1ZqS3M3dXZtZVN5cmpLZzVZODV4ME5jMysyTjhmdmpGOFh2Z0o0Yi9BT0ZqYUdtaDJVMnF2UEpiRHc3ZDZhMWpjUnBLa0tHYWR5SmZNaWVWOXFnYmRuSjdWMC9pYlFMWHhSKzBCOExiZTY4Y1d1a1IzRTFpbjlpR083a2ErSjFLWC9ubkdZc1A5M0xPT256REhKeGYyNjRyZC9oLzVsdjQvdVBFaXphN0NZN0JyaTRhT3pVVzBwTEJYaVJRZm5YK0lrQnhqZ25IVEoycHhUUnp0WGswZk9sMUJQZUpieDIvbWJ2c3lTRUh1b1VBNDQ0N2MrLzRVMldHZUM5MHUxdWJTYUdIN1RNa0dJaXlFTXJOc3lPU1Z3Q0FlTnVPd0pydlBGM2gzN0I0VTBDYUR6TFdPYlJoUEtyYlNzZyt6b1pHQis5Z2pCT09BVjl5YTZENHBmQ216MFhWdkJiM1U5NUhwZDVxNlFYTVZ2NVh6RHlIWGNoZEdDeWVYbFEyRGpBYkc1UVJndk02WlNkdERscnJ3SnEwWGhheHZHVlYwMjVpaldLYUhCUk1xRytabHp0YmtmS1NQdkQyRmVjZU5iUnZEbmpwckpsbWhNZ1JoSEoxSWJvQTJBQ1R0eUNCanFlTTRIMkY4WXZpOTRlOElmczg2SUh0OWVoMWpWTE95c2JPS0NhQmtVS3NidnNVd2tCY0xnOEZpU09jNE5lRC9GVDRWUjZ0KzBsWXJaN2xobnVOT3RsVzRadGxxWllyaGducnRCVG9PQjdZcW5UNm9tblViMGtaL3dBT05DMUZyUzd1b2JXNnVvb0Z5d1ZGTzFnTjNWZ1NjQUU0OWhraXMrZUhXUEMybmZhbmxnaGE2QzNQbmVmRXdpS1ljSVNEZ0U1d1Y0T1crbGVqWEh3eDFxejFDUzNpZ1Mzc1cvZHlQTGR4d3JPQVFkdUdjRUpuSEJ4MHljY0FjKzN3bzF1KzhKM1VsdkRwTU1UV3NZaWdsMWkyQmtPMGNzSGtCK1p1Mk9OMkJubW00SngxWXBWTmRCdncxK0lWOXFQd1oxclRiVytHbVdzelpscy9OMjdvd1Z6d0J5Q3lKeU9lblRJQjRteThjVGFGTExmeUxZM1VLelNYRWx1STQ5bVpZUWprSVJqN2lZQnhnWTRHY1o3VDRMK0ZaUEZYd2RqdmxodGJlRzRWNE12ZHdvOFRyS1R0K1p3d0hIY0FZQXhuTmNkcGZ3ZTEvd0FSNnI0eWhTSzFqc1BEOXc5azh6WE1FSDJoMVFrQUNSbExiUm5vT1N4d0IwckNtdGJFODU0N0wvd1UxK0RjRnN0dkw4UHZpQTgwY1lqbFpOYnRZMW1ZTVNXeDVKd09jWUJIQUhmbXAvR0gvQlhiNGUrTWk4Vjk0UDhBR3N0bzZxbjJON2pTMmdWUms0QU5tU3VUeVNDQ1NNbkpKeitmT3FsdjdWdXZ2WkVqZEIwNXFxODdBL01wSDFQVVY5QlRwd1d5T2VYdmJuM1ZmZjhBQlRqNGJxc0xhZjRSOGFXTTFxdTJGMHZOTlh5a3lTUmhiUVorOGVXeWVheWJ6L2dxRG8vMmFTM2pzL0dGeGF6TVdNZDFjMlVnSHR4QU1mOEExcStKMDVPZjczSFR0VG5sQlhPN09lRDZpdFBkN0U4aVB0SzMvd0NDbzJpMkZqSERiK0ZMMVpJem1PWjVMUnBJL294aEpIUUhyMW9qL3dDQ3BHbExONXplRmRXdXBXQTNOTmVXOG5JNXlGYTNJSFU5UFd2aTFmbEc0OWNqNkQvUEZEU0VNVzl4eG5wVjZQb2lmWnhQdUd3LzRLaitEWXJUL1NQQlBpbGJwbVpuZTExaXloVjg5Y2cyVEhKSkp6dXFwNGgvNEtqNkw0bGhqaC9zWHhuWVFSOFp0TlNzVWtrOTJaclE1L0xzSytLUStCejB6ZzBaWkQ4dVI2bW5hUFpCN05MVSt1TGI5djN3aXI1dWRIOGFYblViNXRRc1RJY2pxU0xRRFBBN0QzRmROb1AvQUFVcCtHOWxwWXQ3bndqOFJtMmtNR3Q5ZjArM3lRQ000RmhuT0R5YzRPVFh3OUt3emtjTm44S1F5Zk5uREE0N2RLdGNyNklYS2o3ZzFIL2dvbjhKTDZaR2s4RC9BQk9ZUkFoRmZ4VFpNSS9YYm14eVB3NDlxNXpXZjIvL0FBZmNhdExOWTJQeEN0NFpZekVJcnE3MG00MlpISkRMWlIvcm12a0ZwTThxeDV6a2VsUlBOdFgxNTR4VDVZcm9nNVQ2emwvYjgwZStpU0tlVHhsSkRDcEVhNHNXMjg1SEpqNHgwNHhnVXJmdDdhVTFtMGJTZUxKSmZMYU5aNWJld2VaVlBZTnNIdUIzcjVMamNncmsrcEpwWTVRNGJyblBSalJ5dzdJZktqNjhzLzhBZ29McE1kdUVhZnhzdTBGUjVNZGpIa0hqbjVENi9uVXVtZnQ1ZUZyTDVwN2Z4cEpHQ3dLcXRnakZpZXU0UjV5T25QOEFqWHlLcEVLZ3R5elV5ZTRFa2UzdHh3S3JsZ3VoUElqN2IwZi9BSUtJZkRXMXVwSko5SitLWG10Z2I0dFMwNEZBTS9LTjlzeEE3OGRDQmpITlordS90OCtBOVlnOHVTSDRrWGlJY3h4MzdhWGR4ZTI1VGJxR3gyNkd2akVTWUgrMTNwTjdaNm1seXc3RGNZbjEvd0NCL3dCdTd3cjREOFQyK3FhZEJya045YXE2UnVOQzAwRUt3d2NrRUh2eGpHS21YOXZmUTlYOFp4YTFmWFhpcTl1SXowazB5ek80Y2Y4QVRYYmtkanRQcWMxOGRCMkI2bjg2VVNNUDRtL09qM2V3N0krenZHZjdhdnd2OFg2bERjM0VQeGZ0N2lHTXhob0wzVDR3QWM1Q2dSZktPVHd1S28rRGYycS9nLzRQaXVZNHJMNHJUUjNReElKTG5UV1lqcGpjWXM0L3dyNUd0WldrYjV2bjlqMnFkc0w5NXVlMVdxY1d0ZzBQc1BUUDJ0L2d6cDlwTFpycFB4UmJUNXJzWGIyclhHbmJDNEdBRHRqQndQVE9LOVQrR1A4QXdWSStDL3d2MEZ0UDAvd1I0NXQ3ZVQ1bVZKclVaT1Rua2tudjA2VitkYVRidXZicFRsbTJodjczVWNVT2pGOVB6RGxUM1AwazEzL2dxbDhFZkZVcVNUZUcvaWxhTkdBRit6UzZmOHZUQnlSbkl4Ni8wcXg0Wi80S2pmQkRRTlNlNlhTL2kzSmVOZ0dXVmRPYzQ2Y25lQ2VPNUpPUjI2VithaVM3ZW83OGpybW5SellIM3Z2ZHF4OWpIK3JoN0dLUDAycy8rQ3Avd0dhOWt2THpTUGkxZVhQbGhVbGRiTWJjWTUyaTRDdHlxbmtjVnBXZi9CVVQ5bldLUldmUS9pNHhVK2RCdnRkUG1hR2IrS1RlODVPVytYSUJBeXVSZ2s1L0x4SjJ4M1lIZ2piVnBMdmE2RGN4K1hPUlV5cFFhMVg1ampHenVmcWhwMy9CV0w0Q0R4VC9BR3hKWWZHSnRRYWVLNE53ZE4wc3U3UnhyR3BZL2FCdStVWTU3RS9Xc3U2OFkyUHhSK0kxNTRqMDFMcVBUZFIwNkc0dFZ1SWhIZE5ISk5JUXpydmRRMjF2dXF4SEhIcWZ6UFNmZWdZdHR3Y1k2MTkrZkFWR3VkRXRkMDBFYlIrR3RQU0k1SXdSZzhnZW1jSHZrVjVlTG93akc4VnFkbUhrNzZuMlJhWEhoanhqNGw4UGVJMG0xbzZycFNKQkxzdGJlMFdXMldkcG00RXo3cGR6QlF6Y0FkampCbStHUHdYK0dYdzk4UldPdmVIclB4cExyVnU2STc2cHJWdklHaDNMdWoyckVNWjI4SEo2bnJYbWRwYWZZZmloL1k4TnJJMW5EQ0xoWE1NMGJNNWxFWmlBYjVHQXkyQ296a0RuR2N0K0YzeHBtK0xuakszOFB6YUhIWi9aYlFUZWY5cnVXa2xmY2lCU2tqbE1OdUp5QndSMnJ6MUNmMldYelIwUHE3NG0vRW1QeDc0ZTB2VFlwOVNoc3RKSUFqdkx5S1dQeXhDVVZRc2NFZVdHRitaaWVGUHFUWEY2ejRQK0hIaktEVGJqVlBETFhtc2FZRVczdlRyaGpWWkk1bWxqY3hDTEIydTJkdWVjWXozcnZOWitGdmhud3I4Tk5HdnJiU2RldEpyalNwWkx5NnZiaFp6UGkyU1VGUjVySFBJYm5iMjVCNmZLUGlyeHpaNnorMFY0bTAyUHhKNG1odHhvbXJzdGtsa3JRd011ajNFZ1pDYm5PNVdBWURBRzRBWkgzaFZPak9UYlhRbm5pa2owKzYrSCt0YTUrMlY4SzlRdE5OMUM0MC9UNy9UaFBjUTI3dmJ4aEwrUjJ5K01ER2VUbkFyai93QnJQNFArTS9BL2dPMTFYeE5wOTliMjAycXgyOGJ6U0x0REd5aXdBb1BHVEZMMkdOcDllZnRuNGI2UjRLOEtmczYrSGI3eGhwdW5hbEJmRjRXbnVOR041NXJtZHdxa1licVR4eGl2Ri84QWdwMzRSOEI2Uit6TDRUMWp3bjRmMFBTLzdkMVcxdTdlODAvUWtzbXVMVjdXNGNBc3FCdWNvZGpleHh4V2NzU3BKUjdhR2N0RHpsdEp0Zmo1OEl0SDhOLzhJdFkyZDNvdmhyeTR0VWlsS2lhUTJWdVFKQVdQSlZpeDJnY2xleHdmWlBFWGdyUWZDMmtlRmRCdWRQazFDYS8xS0M1V0c1VGZHZ2ppbFZuWnNsVjIrYUNBdlBYbkdYSGRmQjM0VmFiclh3SjhEM2tOODl0Sk40UXRQdG93NnRQSTlqRXFFRlFNZVhnNHdlZU01d0tQanI4QTcvNHJRK0ZXOFAzMm4yOTNwTjNEYzNVbDFOT3FYVUtZM0lvVldPNWlxY3NlQURnL014UFZIbFMwTTVTYlBqejQyL3RaMnRocFBoKzFoOEQrSFd0N1hVWU43T29uaDhpRFl6R0VMSUdWaTRCUU9jaFZ6a0U3UjdyOEN0RitFUDdUM2pmeEpxR2w2Vkl0MW80c3RYUVNUM0tYSG0vWm1hTjJWSldSMVhjeWxRdkRNUWNqYm5GL2EwLzRKeGVLUGlqZTZTdmhFNk5IWjZYcDl0YWtUenZGSk04Y0lSM3hzSStaaGtaYnVlblN1aS9aRi9ZNThYL3MxZkVyV05lMWE0MG0zczd6dy9iV0ltVzVTUVc3eHdKNXBkY3I4b2FOaU9jRUVkT0sybktQSlpia3h2dTJlbWZIZWJ3djRKMDZQVWRWMC83ZDVjMGtjZ2hjaG9SSXk0Y0FFbGdNazVQSFQyck5zL0R0ckY4SmRMMUczdkxXKzBWcE5GaVM4eXFySjVNbUdCR2NxUVFwMm5rQWpQZXRqWFBCOXY0eThBWFZqcHZqRFJaWGhPK1NTMFFYQ2VWeTJ4TnI1UTg4RWs0NDRPT2ZQL2d2L3dBRS93RHh6NEwwZThzN3pYUEQrdStGZGNpLzRtSGgzVTRKekZMNkZaRURiSEhWWFRsU1JqSE9lUndpbFo3bWtaZGp6WDRQNlhicDhGTlNSWmJaVjAveHRxTVhseHR0SVVlVmdrQThqcnozclUvWXBpaDhYZkRieFlzUy9hSkY4VGFrY09vM01WczR5b0FIVWRjZDZxZUF2MkNkYThDL0d1MTFEK3k5YTAvd3BmekZ2czJxTEY1RWUvR0k1SjQ1QytDQnR5MENubmtDdUtiL0FJSlhmRm53NWJhNDF2NGs4TVc4R29TU1RpSzJ1N3pZMjVUZ0QvUitRT09mYXNaYVM5VFNMWEo1M1B3ajhUeGJOZnZWNmZ2M0EvT3M5eDVmdWM1TmFYaTRlVjRrMUpUL0FBM01tUVIvdEdzenFyZkszVFBGZTlGM1J6ak4rOTl1TnpaOU9EVGxPUnQyNFBZMDNCeWZtNVgwb01ZRFo2WjZnaXRFN2dETG5INVlGT2x5cjRHM0FIU3RMd3A0TDFUeHRxYld1azJqWDEwcWx6RWpBTUFPcEdUeUFCempwV1pMR1NlVzllQjFwK1FDTys5dlQwTkNQajNKL1FWR1hBUHpMZ2RUejFwcm5LOUNQV3E1bUpxNDZWTXQ2WkhQUFdoSHdPL1hwNjAwS3hiUGJHQnpUZ01qNWxKNDdHclRzRFZ4eW5heTkxemdqcCt0TkpBalAxT0tkdTQ5czhVeHlFays2ZW1CZzlCUTNjRXJESWx3UG13dlNwSWR5UHYyNUdjY2l0UHhONEkxYndYOWliVmRQdXJFYWhFSjdielUyK2RHZUF5K3ErL2VueGVDOVd1ZkRUYXlOUHV2N0loa0VMWFNwbU5ISndGSjdIMnF1WkVHZE8yVlhkL2hVVVg3elA4QURpcjJpNkJlZUpkU2pzZE90NXJ5Nm1PSW9ZVTNPNStncTVmZUFOUzBpNWt0NzZGcks2aWtNVHd6S1ZrUmdjRUVmWGluS2E2bGNyZWlNVWpGT1psSTRVL25XMTR0K0htcmVCWklWMWF6bjArUzRpRThTVHh0RzBrWkpBY0FqbFNRY0h2aXNOV2pKLzFnWGpQSXBLU2V3Y2pEdlJubm1wclBUNXI5OXNTRjhkY2RxNlN5K0N2aWpVZEFrMVMzMGU4bXNJVjN0T3E1UUx5TTUvQTlQU2ptUXJNNTIwdUZ0MnoxN25pclNTTEtuekVaNUk5czFSRnBKdUtsZHBYcUQyclMxendIckhoaU8yazFMVGJ6VDQ3eFBNZ2E0aU1ZbVhqNWx5T1J5T1JXdk5iU3dpRkR0R09tM2c4VURjeHhuOFQzb2ROcXJ6emltNUV2OFJZOXZTdFBVQkdZdHhuUHJUdk53U29CeDYxYzhQOEFoWFVQRnQ2MXZwbGpkNmhNcWJ2S3Q0V2tibkE2QWVwSFdvTlIwKzQwbTlrdGJxR2EydUxkdHNrVWlGSGlZZG1CNUIrdFp5a2h0V0pyU1JSSHo5ZDNjbXJRQ2VjeWpPN0FBeVIxclBpY0VxdWN0bkdEVnhKOTl3MjdqcWNuOUt4bDNMTFVhTkV1MXZ1bXYwUy9aejhMM005dnFWdXlMSmRmOEkzcE1rRVlZU0ZGZElTQ0N1Y0VxZVIxQkJ5QWEvTzJQWkZPdnltUmNnNHI5Y1ArQ2RWL1puNHQzWDlvYUZ0dU5XOE5hVnAxcmFLci9JOGNWdUZrSzRCL2ViQStRVHpJZW81SEJpbzNTTnFVclg5RDBDN3NXOFJmR2E2dkxHMHY3dGJHRlVaNDRIWkVkR1ZuQTR4MUs4anFSMTRPT0wvWnI4T2E1ckh4dW0xTC9oRmRlMDYxZ01TcTF4WnNnS0NhM09UMTdBNVBUanI2ZmNYd3grSytrK0pQQVhpSFVvOUg4SHlYWGhyVEpOUWF5dDlUbXVKVWFNWktTZ3hqWndDTWdzUWV4cjFid0w0RDFUeHpvQzM5eG9IZ3V6dGJxM1M0c0hobm51UE9MWUlaMWFKQ0ZJNmQrYzQ3VndTc3R6T05SbkNmdEYrTmRLdVBoVnBkMXBmazZsYjJ1ajNzMjFZeTZLRjAxV1VTQWNxcEViRG5IUTErZFV6UTMzN2RYaks0TWFSd3REckNHMnQxQ2VVR3NKNDlpQTVQRzdBeUQwR2EvVGI0ei9DR3c4RS9BVzgwL1VKL0R1a3RkV2o2VkRkUTI3S3pQTmFUV3h6dVlGamlUZGdZKzZhK1gvRFg3QU1Iakx4VjhRZkUwT3N6ZjJ0cmh1aHBxMjYrV3R2TS9uQjQ1MjJQSXEvUEVNeGtaVnVjNUFHbE9jYWNaU2IwZWhPc3JSNm4xTG8zanZ3WDhLdjJSdkNPcGZFYlVvZEIwd1RvVmxtU1ZmTHVqSkpLaVlVRnMvSzNIVGl2SlA4QWdySGI2Vlkvc1dlQW85RjJ2cEVPcjJVZW52dlBOc0xHNDh2cU04cUZPVHp4WE4vOEZoTkE4UmEvK3dCNEwwYjdDdDE0aXV2RVZwNTFycHpTWEtlWXRyZU80akxnU01veHh1R2NWcWY4RlFkVXNEK3c5OE85Tmh1N2VXOHNkUjA5SGhqbERQR0YwKzRVN2dNa1lPQnlLNFl4anljMFNwWHZxY3I0Qi9ZaitQWHhBK0cvaHpXUEMveFF0ZEgwVy8wWFQ1cksxazFlK2phQ05yU0VoZGlLVlhHU01DdGlEOWdUOXFpeFA3djR5YVczc2RiMUFEOVlUWHpwb24vQlFueFY0UDhBQzJuNkRwOXRaeDIybTJVTnFTZ0srY3NVS29HZnNUdFRyei9TdEhUZitDcUhqYlNrOHo3WkpHZG9UYXI4WSttMDhuL09LMFdLZTF5dnFyM1AwRS9aTStDdmo3NGZXV3RRL0VUWHJmeEpKT2JZV2MwT29UWEJpS1FoWmVKSWt3R2ZKemtrOXdLOUUrTHZoQzFQd3Y4QUVUSzAwWlhUTGs1RG5IRVRkYS9OSFRQK0NzUGpyUWJHVGJNcmJuTW5tTVZWdHB4MUczaysvd0JPdGErZ2Y4RlkvR0hpdUdiVGJ6N0Q1TnhBMjVyaG81RWZqTzBob2lPZmZpcGxXVGQyUDZ2Skt4OVhmOEUvdkNNSGluNFBYOTk5cWtqa2ZVSklCNVFVNEFqVHJrSDFyM01mRDI2UmRxNnc3TDIzV3FaSDlQMHI4NGZCMzdlWGp6U05KYTQwdTRzTks4NlV0c2d0clpVbFVISDNSR01uakdhYkwvd1U0K0todTJnLzRTS0RiakxiYk8yNm5zUDNaUEh0K3RGU29wU3VPTkdXeVB1YnhyOEhidU9ld3U0TllrYTR1TllpQlM1bXVKcmZIbUhJOHJ6UXZRRTRHQVB3cnM5SzhCYWhhL2IxYlhMcVRkTmxBMGE3WWw4dFBsVURIeTV5ZWNuazVKcjgxRi80S1JlT3RLL2VYVjVwOThwdWx1UUh0N1pYRW9BWGVjd241dUQ4L1hCcTVZZjhGYVBpSTFveGtrWE1wWU82RzJHVDBYUDduanQ5Y1ZqelJlNVhzWnJzZmhUOFNiVnJMeDVyRVRmZWp2WmxQcHc1cm4xaVp4MDcrdnJYcEhqSHc5SHFYaXZVcDVGWm5tdVpIWW51eFlrL3FhemYrRVB0OC9jK1d2YmhVVmpIbE9KOHBvempKYnRrSC9QclRyVFRwYjZaSUlZMmtsbVlLZ1VaTE1UZ0FEMU5kaTNnK0YvNGVRT25PRFc3OEw5UHNmQ1B4RDBYVkw2M2trc2JHOWh1SjFRYm1JUndUZ1p4bjYxZnRFU2ROOEwvQUFacC93QUo5WjhiU2ZhSjVOYThLK0hibnpyZ0ZXdDB1WmtFUGtvTVozSTBvRzR0eVZjQmVoT0I0Ry9aeHQ3N1QvRGR6cjAxeFoyL2lZTktzd3VZYmVIVGJjSEFubGFUaGdTQ2RvMi9LUHZaT0s3blhQRTNoZTM4TmZFT3p0NXRTdXJyeFJmeFR4U3RiS2h1RUU3ek1HYmRsQUR0ejFKUFlkc1R4Ny9ZUGp6d0Y0WmFiVTdoTmEwSFR6cDBsckpaY1BHc2p0SDVicWNFRGVRZDRVL1hITSswNmsyUEVOVDB1R3kxaTR0NHJwTGlDS1pranVGQkNTcUNRSEE2NEk1eGpQNDE2ay83TjFoTDRxK0htbHc2dFA4QThWcGFpNm1rbWhDZlpVTXJvcktNbjVUc0pHZWNESngwSE54ZUU3ZGp5bmZrMTcxQjhRZkNWcDQyaHZJcmk0VmRNOEpEUjdDYzJaMjIwd3R5Z0FYT1NkN3VTM0FHTWREa1AycmEwTGNXZUllSGZndGErTVBCOW5jYVRleVQ2eHFYaUQreUlMT1ZBaVBHWXR5eTd1dkJJQjlBZnBtLzRxK0FtaytIdkMrdVhjdXJTV04xbzE1RGF3QzdNWS90ZmN4V1JvWWxQbUtFMjd1ZDJWSXp0SnhYUWZDenhaWmZENzRvZUdkUyt6M0owZlFiaHBER3VQT2tNZzJ5UzlodnhqQXpqRWFqSjVZOC93Q05QQUdqeGVPbWtzZFkvdExUYnE3TW5tQzJramtpaVo4L01HQXl3QjZESU9PdFAybW9XTkx4bCt6WG8vaGJWYlBSSXRYMVM0OFJhN2FXVTJsV1pzd3U5NWlvWVROdXhHb0JiR04zS043Wnl2Ry93RnNQREhoSHhIZFNhaGNXOTk0ZnVvcmFFWEhseHg2dVdjcEo1Q1o4d2JNRnNuT1Y1TzBuRmR2Zi9FMkdYOXJXSHh0SUpyblI3Ty9UeVVSUWppMVJmS1VxblRjRUc3Ym5xZXZVMXpmaXo0ZitIYmY0bXJlVzJ1RFZOSnV0UUU4akMxbFNTS0F2dUlZTW95d1hzdWMwNDFPZ2xGanZqNTRZYlh2aXBvSGhXYThpMDJ5OEkrR2JLMnY3cVFFcGFvc1huU3VSM1l0TmdBY2xpb3FuNDBtMDN3bCt5SnBjT2xUWHl3K0xQRWN0emk2MmlVcGFSZVgvQUE4RUZwUTNzY2puYms5OXJ2aVR3djRtOFEvRmlhNHY3aUgvQUlTeUFMcDk4OXF6bGdrNGNSaEJ5cFpGUlJ1SUhCSks1QUhtL3dBZmZGR2orSXZoL3dDQTlIMFdLKy80a1dtdkZQRThKaldDYVNSbWt5eDRkbXdoeXVGNDc1d0xqTzZKNVNuK3gxb1gvQ1RmdEkrRll5ak10cmQvYlh4eHRFS05Mbjgwcm9QaTlwSytMUGgwdnhDdGRXbjFHUys4UVNhVmRXNWdFWTg0b1p0MFJ5U3lFY0RjQVQzQTZWei9BT3pSZHhlRWZFdXNOcVR6YWF1cmFKZTZaYlh4alpsdEpwb2lxU01GeTIzcUR0QkkzWnhXaWZIdWg2QmRlQWZCOGwwLy9DTitIOVdYVTladmhBKzI3bWVSZDdJbU4reEloc0h5aGpsanRHUUt0Kzh3NW1uZEhTL0dmNFkzM3haK1BWejRldDVwVnNmQUhoMjF0Ym1XR016U0JJSUVMS2laRzUybGtLQUVnWjZrQUd1YmY5bGs2eDRnOEtXZWszdHhEY2E5WjNGNXFGbmR4SzExbzBVRFlhU1JFSkpEZ0VvQ0FTY0RITmJ1amZHUHdmNGk4Vy9GcXoxUFZiclRyUHg0ak5hYXROYXZJc1VpenRNZ2VPTUYxaklJSEFKK1RKQXpoZWEvWjE4WStGL2hsNDQ4VWFkck9zSzJsZUpOQXU5RkdyV3R0TTZXank3Y1NiQ3F5RlJ0SU9GenlPRFZ4NXJhQnFSNjU4R0xYd3ZvL2htL2l1OVVzN25YdFJld09uWGR1aTN3VWJRczZvSCs0ek50dzJPUVFDM1d1cStQZnhwdlBBSHhVMWpTdEMxVytzZjdOalRRN2kzdC9sdFdpdHdxRk1oc3NDNnNTR1VjbHZYbmsvMmZmQk5sYi90SGVIL0oxQ0RYdFAwMlY5VmVlemhsaWpkTFpYbjRFeXhuL2xtT3ZIUFd2Ti9GR3ZUZUtQRStvNmxNMzc3VXJtUzZrSlBkMkxIOVRUNWJ1N0t2cWRmNGQ4S3grSVBEK3JlS05YdUdzZEh0YmhiWmZKakR5WGR5NExDSkFTQndvTE14NkFkeVFLOVgrTVB3OXVQRy93QVRQQy9nZXh1bGd0L0NmaG0zRjVkWEl3bG9nak54Tk02amtZRWcrVVo1d001cm0vRC9BSXg4RDZoOEdmaDFwbC9ySXRaTkQxdWU0MW5Ualp5czF5c3NxYlpkeXJ0S0xFb0JHN2RqSUNuclcxTDhhdkMycGZHUDRuU2YycTBObjR3MDI2c2JEVlpMZVh5WXlXWHkxWlFwbFZHalVLVHRKejFBSFM3dHYwSWJPTDFmNEtqVXZBR2wrSXZEdHhlYWhiYWxxNTBNUTNFQ3hURzQyaDB3RlpnUXlrZCtEeHoxclV1UDJjWUZqOFdXZG5xMGwxclhndTErMWFsRXR2dHRpRUlFeXh2dXlUR1RqSlVad2NkaWR6d1g4YnZEL2dDNitIWGgrMWVUV05KOE9hc2RYMWU3Z2haVnVwM0lYTWF1QTVFVWZHU0ZMSE9Cd0NiMnJYR20rRWZEWGplS3p2SVBFR3FlTUxzS2swVUVxcGFXNG1Nck9USXFuZTVJWEFISEpKNkF6S28wTkptVGJ4YWQ0RS9aZTAyNml2TlVzOVQ4U2EwMTVIUEJhcUh4WnJ0Q2J2Tkh5Q1dUY0c2NUFPMEVWNVg0aTE3VWZHT3RYR3A2cGVYRjlxRjQ1a251Sm0zUEszdWYwOWdCWHIveDQ4TFRXV2krQ2RBalJzYVJvVVVzeWorQ2U0WnBuSC9mTEpYbmkrQ3JoUVAzSjc0R0tVYWdST2JnRytkZmw1WG5uMHF4SHlmbDI3ZmJyWFRXZmdXUm0rWld4Zzg0cXdudzliY3VHeFNkUzVSek1FYllWdHBYSjYrbGZyTit3em8vaUtUNHROSHFWL0hjYUpaNlBESXNOcDU4MTBkdHFwaFR5MFptVEh5S1dDREF6bmpOZm1QYmZENWd5amQwYmtWOXJmc0kvRmZ4QjRXK1B0bGZ3NnRjV3kydHJLemZaNDQ0bmtqd0JzWnZLY2xUM3lEMEI2Z0d1UEVUWEtiVTRjeVorb1g3S3Z4TzhIL0QzKzFMZngzSmIrSFcxYnl4YjI5NldIMjdCRHNRY0F0aGd1UVFBZDJPZS8wWnBYN1RQdzIxbWZ6SS9GVU1VbHFNRkpMMldKY0hQVlMyMDlEeWZTdnpwK0xmeGprK05XbjJGdnEwdXNFNmN3bWtNT3AzU1Ezb0cwTXNzYUlxTW1jSGFSajljK2Fwb0Z2WVBKcWthdzZmNWltSVR5V2MwemhRdzZTQS9kNEIya25xQ1JrWXJ5NVZxYmF1N0VleWRqOUhQMm5mMmd2Z3o4Uk5SMHZ3bnJmaTdRYm0rdDNGK3RsTnFmMk8xa1U1VE1rNGpZS3dVc1FnWkhJUEhCQnI1SS80S0E2cDRhK01Yd3JtK0hQZ052QnRyTkZldzZ5MnVXV3IyeTJrRDdWaWtXU1ZwV2xMaU1ydUxZVXFneVJnVjRSNGY4U1dzZnhka3ZkWW0wN3hDdDlwaXROZDNlbXRMSUhEQ0pVMnloeHRDUmc0MmhjbnBtdlYvZy80dStHWHdxOEtlS05MczRaSUxYeGdrcDFHenVMR1dlQmZPaldPVkFkcENobEE0VGdER0FEazFxNjFLbXJMVWlOT1VucWQ3K3dYZjJmN0YzaFMrdHJYeEQ4Sk5ldUw1MW11cnVUeFEyR1pGWUlZdUpGVEFsWUhHTWpyam10RC9nb3orMGhjZkdYNERhWFlTWDNnbSt0b2RkZ3U0MzBuV1k3bTVIK2ozSzRlRlNXQ2dOeXh4Z2tER1RYeVplZkM3d1g0YzhMTG92aHZYcit6TThwZVpJenFzTVU2eUhCSmhTN1NNSGFjSE9jN2VuOE5jdm92d28wdjRaNlJOSmE2NW9Pb2ZhbmpCZ3Q5SjFDMW5oNGR1WHVKcEVaUm5vT2NzT2NDbEd2Q1YzTDVGU290YW5jVGZzWi9IL1c3S3oxclMvaDNwR3JhSHFWcWsrbnpqUm9wNUpiZVNNRkhKVnR4TEsyZDJNNVBhcTFuK3h6OFpsZTNYVlBnMDBWazB5eHpUalNkUmpFS1pHNXo1Y3crVURuT01BQ3YwRCtBZjdlVTNoTDRMK0RkRms4RTMwcWFUb0ZqYi9hUmZLRm5FZHZHdThMdHlNNHpqbkZkVDR0L2J3cy9Fbmc3VXRQWHd6cVZuTnFWbkxieFhIbkpJc1RPaktDUjhwT0QyL2xYa3ZNc1BGMm5VWDRGYzY2SDVrZUtmMmJmRjhmeGRzL0R1aS9CMjMxTFR0Y1M2dU5IdmJqKzFyVTZsREFFWXRIdnVsVjhvKzdDNU9NWUI2MVQ4Ui9zUS9GTFdZQmNhWDhNOWJzWlkySmt0N1hTOVZaNFFDUjgzbkFqbkdlR0o1RmZvMzRrL2FDdGJqeGg4S3RXdGZEbXZMRDRCZWVPYkFnWjdxS1d5YTNLcVBNR0R2TWJjOGZMMjRyMUN3L2J5MFZ4Kzg4SitNWVdiczhkbUNmL0FDWUg2MFN6TENQYXJFUGF0SDQ2K0hmMlBmanRxTjNQSHArZzYxYnFFNFNlS2FBcU8vM3NWM2x6K3dIOFl0TjhPUjM5NTRMMWllTHljeXpSYS9iRjJQZmJHTnpnYzlPVFg2bjNQL0JRUHczYXlTSzNoZnhzd1FBbDQ3ZTFkZWZjWEI5L3lwYmY5djhBOEszNVpFMFh4VkN3eUdhYTJoVUljZTBwNTlxZjF2RGIrMFgzbGUyWitOL3hFL1p2MS93LzhUZE44TTIzaDd4ZHFYOXJDWTJWNjJvRzJqdWZKVkdmQWVIQUEzOVN3d0Y1eDBIWWVHditDZm54QThTV3pIVC9BQTlxak5aZ3ZJdi9BQW5OZ2hVRHFRcFhqNjVJNS9DdjBWWDR1K0g3RHhuOElieTNXOEVQZ1VYMFdvTkxhaEdranVMUXg1alZXWVpNdXdrRWpqUEpJcjJXZjl0YndNR1JaSnRSVXZramRZeUhianZ3RFRlT3dyZWs0L2VTcXo2bjh4dml2UTIwM3hOcUVFMGUyU0c1ZUpsMzc4RU1RUnVIQndjOGpyV2JKYnJqN3U0ZE1pdTArUE4zRmRmR3Z4ZE5iN3ZKbTFtOGRjOE50TXprY2ZUSEhhdU84Mzd2SUhibXZZanFsWUJqMndrWEFYM3hnVTM3Q0crWGJqak9hbTgxVmRXeGs4Z0grZjhBS2lXUm5VYlNlbmNWYmR3SWZzaWpQM2gvU2tOc0U5OCt0UEdXVmxZOEZlZlUwT25BSi9RVWN6QWExdEV4WEpQemM4ZDZrU3dqQ0VmZXllNC9TaGprcjkzdU9SaWgwYmVUMTdqR09LZk13QVdhaENNZldvM3MxMjRQSDlLbGpaa0h6RWp2akhVVWlwdEc1dHhCL0hGSE1CQ2xsR3E4SjdBSHZVaGdqUk04RGp1S00vUHUyOGNFSEZMSW9CNituV2ptQVp0UXA4bzZpbVBibzQ1VlQ5UlVvaXlmNSsxTU1mUDNhT2FTQWlsdEJMdCtiRzA1NCtsYzNyL3d2ajFxOWt1QmRTUnlPYzQyOERqRmRRRkdlbE9xbzFaTFpoWkhuK29mQis0Q0w1RjFISVQ5NE9wSEZWcGZneGZBaGx1cmRqNkVIaXZTYUt2NnhNTElpajFmeEJONEl0TkR1TldoU0d6c1cwMk9XQ3dnanVGdG1ZRm9mT0NlWVZPTUVaNUJJNkVpdVVnK0RXbnErNlNlNmY4QUVDdXdvSnBlM25lNll1VkhHei9CbXphVE1kM2NJdm9WRFZZaStFOWxIeTF4Y04rUXJxcUN1ZU9sTllpcDNEbFJtK0h2Qjlob2t2bVF4bG42QXR6WGFlR1BIYzNobTAxQzNqdDdHNWcxSkZqbFM0dDFrKzZjZ2c5Vkk5anozcm0xRWNJK1p3b0E2bnVhVnRUdFZmNXA0MS9HclVuSWxxeHM2ejRpdU5mMVdhOHZwV251cmx0enZqcitIUUFEQUFIQUF3S3FHY292SFZldkhXczZYWGJKRC94OFI4SG5EakZOZnhSWkJ2OEFYUjdSVmE5Qkc1Yk51UnovQUxQZm5GQkxSa2RLeHg0dnMwZ0lFMkFjQThIbnZTTDR4czVVSHpNTUFrL0thbjNnTjJPVE9GL3ZFYzE5SWZCM3c1NGkrSFY3TDRnMG1HWTNkbHA0WmRsdXM1MnMrdy9LMlY3NU9ldzdWOHVhVjRzdGJ6VUlZa1YyZVIxVWZKNm5GZnFwNGY4QTJHZmpyNEE4ZStFOUJ1TkVqaGJ4TkhjeHB1MU96YmRGRkNESUNWT0FOcjhoc2xoa0RtdWJFU3NqZWpVNVUwZUdTZnRRZU9yMjNWWmJDYVRjK1hMNlhaYlhPYzVQeWV2TlhCKzBaNDhoczhTNlRkdkNrSmlUYmFXYVFoQ3pFRFpqQjVKUFRKT2EreE5PL3dDQ1UveFVzWi9KbVh3SGRRNExHVm51RllIcUFyaHdkMmU1WEFycUxML2duMThXTk11QXE2VjRWZTNFWVVwYTY5TGFMTXluNVdrSDJkc243MmY5N3JYbVM5NTYyKzRmdFYwUHp4VDR6K0pMM3hCdXVOUDg2THl3VFkvWllrUW5MZnZOb0czZGdFWjY0Tlg3ejQxYWhObU52REtNckxobGFNRDhCdGRTUHlyN1Q4VmY4RTJ2aXRybnhFdjljbjhOMlVscmRSb3EybHZyVVZ4SWhYSi8xc3hqSlhjV0lVZ1lCQTdWNXcvN05HcGExcTJyd05vT3FReGFEZHZwdDVMOWlMUVc5eW0wdkc4MGFQRGtCaG41d3ZQM3V1TktrMjlVVFRrdXA4ekg0NjMwTndBUERFWDhQQVNjWndCanBQaXIya2ZFZTQ4WnJjUXRvRU9teHdzcmVlc2N1U2ZtQVFsNUdIZk9NWjRyN0YrSC93RHdUMnZ2RytuelhXbXdhUnE2NUcwV2VvV2NubCtvSVhjZmJrOGVsY24rMkIreWJxWHdEK0dGbnF0NTRjL3NpTzYxWkxReUM2aGxWMk1VemdEYUFlZGpIbmdZN1ZuR1RMbkpiSG9md29NTm44UC9BQTdJMHlmOGdtME8xMTNZekN1UjBQcCtsZGJGck1JbmRtV0Zvd3dDNVU1M0RvT0Jqbmoxcml2aHBxRnZhL0QvQU1MK1hiU01zdW5XcVN1ckRFUUVDNUpEZXBIUVpQTmRJSjdhM3Y4QTk1SDVhcXpSS0h4dEdSamNjY1lHQnkyUFFaNy9BSXppcDFIV24ydXp6UGFTM043KzMxdGlac05GSEd3UldqVHEzUEJKNDdBWitsSkw0a2phRzJhT3d0N2lSdU56RU16RE9jZy9sWE9USkJmRlUrMExOR3g0M3NHVitveU9NZjE2VmZWUG5qOHVXM2k4c0FaRGRmNmRxNVZpRzloZTJrYjBQaWF6TWhqbXRZV01odzVkV1RiM3dSeitGSlkzZWpXRjR6UGF0TXNpK1dpTk51QkhicU1qazkvejZWejl0cWsxcnBsMWNiSkpHdDJrS0tpQm5uMmc0S1lPRG5HQmtqQjlPYWRQcTBrMW1yMis2ZVdWRStWMU1iQW5IeWs5QWNIK2ZXdEpZdWFpUDIwamQ4clN6ZWJEcDhjREFaS2k0YkpIWEo2WjZkTVZCZmFmNGVuZ20rMFc0YVRneGdaS2o2OEgvd0RYWE56NjRzazZiWWJyZHdycUQ1bXpqQTZkUngxUDUxTGQ2akxJZHUyWk4zSVp2a0Nqamx1Y2YxckNPS2Q3b2wxcGRqOFUvanp0MDM0MmVMb1k5cXBGck40aWpQM1FKM0Fya0RlQUhuYitkVC90UjZacTBuN1J2ajB4Qm5YL0FJU0M5dy8zZDM3OXVhNFZORDFnZnduY0QwejA5Ni9mc0haMElQeVg1STd0YkhadmNSb29adHU3UHJ6UXVvd3Yvd0F0Rkk5TTlLNWp3LzRJMXp4SHJkblp4dGlTOG1XQUVudXh3TTErcmY3UC93Q3pKNFIrRFhnK3lnc3REczdpN1JRcjNrMEt5WEZ3ZWhkbVBQTFpPQndNY0FjNTdhZEZ6Mk1hMkk5bnVmbU8ycVc4Szh5RDVqeHowcHN2aUMxVWN6S2EvVEQ5clA4QVpmMEg5b2Y0ZjNkdGNXY0VPdVFSRjdHL1NNTE5CSW80VXRqSmpQUXFUakhUa0FqOHJibjRhMzF0ZXlReVQ3R2lKVWdqa0VjRVZOU255TzBoMGEzdEZkRytmRWxxbjNiaGNyeWVjMHA4U1dxTC9yb3pqZzF5NytBYno1dDF3dUY0M0VmMXF2b3ZoS1RYSG5IMmgxV0tRcURnODlzMHZkTnRUclc4V1d5Y0xNck4yRlVuOGNSWjI3bEhiQkpyTEh3M2J6V3pkTTJNakpHS2Qvd3JkSGYvQUkrSDlPVjRxYnhIYVJwU2VQb28wKzhuYnBUby9pQmJGdWR6YmFvajRjMnV6NTdpUS9UaXBJUGh4Wkx1M1NUTXJZNzR6Vk9VUXN5MnZqdTFsZjhBMWZmSFhyU1hIaitHSC9sbnRLakJwcWZEdXdBWC9XaytwYXZWdjJZLzJROUgrTHV0WFYxcTAwbGg0ZjAwcXM4NGxDdE5JMzNZVUpCQVBCSk9EZ0QxSXE0OHJka1p5OTFYWjVJM3hDaWsrN0VjOEFjOTYyNEhNc0NOOTNjQWNZcjdsMVg5bWY0UCtEN0tPM2Z3WnAvbHVuRTd4U1hCQTZBbGkrZWV4RFY0ViswSDhGZkRtbDZYSnFYaE9HZXpqc3lmUHRHbE1xTW5KTG96SElBNDRPU1FleEhPMHFiYXNqR05lTFo0aFBLWVl5d1JuUG9LU0tYejRkMjFsOW1ISXFzbXFiN3BZOExoamozcTdYTlVwdURzem9qSlBZYWdMTHlhQ21SMU5DRDZqMnpSL0hVZFNoVjZjOWU5TFJSUUJuK0pZR3VkS1pWVm5iY01BZDZ3b3ZERjJHeDlsWTU5YzQvblhZcEVwKzluQjUrbGV3ZnMyZnN6VGZHS1k2bHFCbXMvRDFwSVVrbFRpUzRjYzdFejB4a1pZajJIUFRhbko3SWlWbHF6NXcvNFJlOGx5UmJvdWUyT3RUcDRWdkhpQ2lGVnoxNEZmZlhqWDlpM3dOckdodEZwa056bzk4cUV4enBQSk1KU0FjYjFrWWpCUHBqNjE4cy9GYjRZYWg4SVBHbDNvbXFCV210L25TU001am5pYjdqcjdIbjNHQ0R5S3VVcFJGVHFRbnNlWS84QUNLWHlScnduT2ZUMnEzYStGTHZCVm1UZDFyZnlzZ09BeWxmbHFhT1NFUnN3M2JzYzU3bjJyTDJqTHNqTjhQYUJjYWRyVm5MdURiSjBPTWRmbUhyWDlHRjE0NjhVYWg4UXZEZmlHNnZmTmJ3MnR3VXQ1N2RKSXliaUVJVkRSaU5nQmpQelo5RFg4OXVnU0M3OFZhUGI4dTA5OUJFRko0T1hBcjk3N1BXWk5PMVNDNmdXM3RXdHlXTWJKOHI1NjV5UmtIUDVuTmZGOFZacFd3c3FTcHlzbmUvNENub2U2YUQrMVV6UnF1bzZTdm03TnhhM213R1BzckR2L3ZWcld2N1dIaG1TTlB0YTNsbThod0FWV1FmbXBOZURmOExKdUxrenhmWmRDdW1DZ3hoTE1iejF6eUR5ZUQxNTVvdXZHMGR6Wkw1Mm13cXZtQi8zY2F4NVhCVWpIUFhnblBJeFh6MytzMWVLdXFpZms0dEdmTXU1OUVhaCswZjRRa3MvbDF1U015S01HTzJrTGpQY2ZJUi9PdVYvWXQ4TDNuL0NqNGRRdXRTdm9OVThRYWpmYXhxRVlFSmFPVzR1WkpRckRZY01xTWlrZHNkQlhqOGZpUFNyMjI4ejdHcXJ1eUdaRHRJNi9Mai9BT3NQclZpMDhVeWFKWi82SGVTNmZJcDVNVHRHekFFRVpHZWg5dWE2Y1B4ZFBtL2ZSVnZMY3I1bnVueEYvWnUwZjRqVE5KcUVFazB6ZzV1NFJiMjkyUDhBZGxXRGVEOUhIU3Z6OS80S2U2SGYvQ3Z4M1llRVl2RUhpelV2RGNlbjJlcUxhYXpxclh5UjNVa2w5SHZVc1RqNUlnQU8yVzlhK3FOTC9hSDhmYUI1bjd6VGRRdDErNzV5NUxEQi91NFBQSFU5VFh5My93QUZHL0VXcGZFdUN6OFZhaGFSMjh6aXgwb2VVLzd0dksrM3lGaHlTTjNtampuRzNxZTN2NExpTEJWcEtLYmkzM1ErYXh0ZkRtd1NmNForRzdlU015SkpwdG80WjR2TVhQbEllbU8zYm10dzZGY1dpUXh0SGJxZ2NnYjFKRC8zc2RoMkdPZWxZL3dtdHMvRDd3OU5HV1pXMHkxQlJ0MlNWZ1RvT21PVDI1eDNybzlTOFpYZmgreFVCcmNDSU1JOTBoQlhvTTdjZmQvS3Z5ckYyVmVibDNad1RpdDJWRTBEN0dzaHZCR3NHd21JUmtSZEFTVGc4NTlnVDdWYWpTMUdrK2JDYlpWVlNDNEdTUWZsT0NSOTd2eFdEcVBpL1VacHJjdGIyMG0zTExKTGdNQWVmdW5qbjZqMnFhYnhGY0pxWGsydG1za0lBVm5Jd0VCQVA4UlBJejBHZURYRjdWYlJSbnpSTmJRZEpZUXMxdklxdzdEZ2xodWNBL1hpcmNrRHdxczF6TmNiWXh0QWluRGIrLzNReFA4QVdxemVKRnVyVm12UExpV01xUDNiQXMzQS9oN2RUMXFHMHRMeXpkcml6dVlaVElEeXcyTWh4amIyeDJQcDdtbEt6VmphMGJhRnA5WmdrYU5CNWtMS2hDN2crM1BxZWVQeDk2dFdsN0pleGI0VWp1bGpVN2R6K1lmYzdlK1BVKzlZdjlzUjZlWklabGprbjZ5aFNycTJjOE42NXpuOUtoamswL1Q1aGNRS1dqUm04cjdNUnZHVk9jZjNlblRvUHdxWXhTZW9KcnFmam4rMCt2OEF4a2Y0OVFMc1pmRUY4TnVOdTMvU0g0cmhZbTJmZDlQWHJYYmZ0ZDZsQmEvdFNlUDFMTkgvQU1UNjlZYno4M016bm4zNXJ6eisxb2xUY3pLMzA2WXI5OHdFbjlXcC93Q0Zma2owb3lWa2VsZnM0K0ZZZkczeGswV3htdVBzYStiNTRjRWN0R3BkUnlSMUtnZmpYNktpZlZvL0RzSnNRdm5CMkRNemhjZ3NUbmtIcG4wN2RxL0xMd2g0N2w4SStJN0xWTlBuV0s3MCtaWlltejBJT2VmYjYxK212d3IrSjExOFFmQU9sM0Y5YVEyTjdOWlJ6UEZFK1ZPNWMvTGtrL2dTU0s5ckNTWEswY0dOaTIwMGFXcGF0cksyTU1jYldra3pmNjkvNFY5TzNUMXhnNUhiTmZtcjhXTk1HbC9FanhCYXBNc3l3Mzh5bVJlakhlU2U1NkhqclgzeDRnOGF5YUhEcm1vWFZuZFdkdG9WcExkTkpMZG8wYTdWSkdWRFpHY0g2ZTFmbkJCcXJlSXRjV1A3UWozTjVOamZJNFVNN0hxekhBSEo1SjQ3MU9KbGRsWVBTN1lUNEVMRXQ4bzlSV1I0RW1QOW5UeUtkdm1Tay9YcFhxSGl2OWwzeDFwT2h6WFg5bHgzVU1NRFRTZVJjUnU4ZTAvZEl6OHpFY2dMbkk2YzhEeG53OXJpYVJackM2azRKT1EzclhLOU56cjVrOVVkZEtRL2ZkN1pxRm5ZTG5kdHdjY25nMWpqeGJGR3hLK1p0N2M5YXEzWGpIOTB2N3NnOXY4QVArRlR6SXJtUjBnQmY4ODRwUTI3dmpQcjNybUxMeGZObjVvOXU0WnpuQk5EK0xtamJhMGUzMDVQUDFvNXV3Y3gxU3k1T1ZPNzNQYXZ1RDloMjMwMlQ5bmUxVjdmZktiK2VlUlRrZWUrUXFzUFg1UUJ4eDhwOUsrQnZCaTZ0NDc4WFdHajZiYStkZmFsTXNFQzV3Q3pjWko3S09TU2VnR2UxZm92K3poOE5ydjRNZkQvQUVmUjlZdXRQdUxxMTgzeld0NW0ySzBrcFpOb2JHY0JpQ1NPNDlLN01POWJuTGlwSnhzYm1zYXJwMm8zL3dEWmQwMGtra2pGbVFmY0JVNXczWEF5TTRQSEFyeFQ0djJlbTZIYWF3YmU1dDVMV09LVGRFajdoQ05wNEpKUDB4eGo4YStnZkd2OW42TEtKNVBzYXMwUlJSTEpza2IxMms5UDYvaHo4Yy90aitKRTB1M3NkSHQ5c2MxNUdicTR3eHlVemhWNTdGZ1Qvd0FCRmRVZFhZNDQ2cytkbWxYN2FtSkZpK1lObHZTdCtHWlo0d3luY3JkRDYxeCtxWERSM1F3dmZIUFlWYXRQR1AyTFQvTDI3MlVFQnM0NXJMRUs3TytEc2pwMmNKMUlIMU5JWlZIZXVBdVBFTTExTHVlVmpnNHdlbFEzMnFTbTJkZk1iNkE1cmtXcnNYekhvTDM4TWJZTWk1OU0wa09wUlN5N2QyRGpQUEZjbG9PWmRxdXhiQXlmZXBwejVqYm1QQ05nbjFycTlqR01ic3o5bzI3SFdKcTl1VVB6TGxUakZmZG43TVdsYWxwL3dhOEl3ckN0dEcwYlRYSm1iQmRaWkdrWGF1Mys0d09janIzeFg1d3BjSjVyZE9wNVBjOXErNFAyTi9qQmIrTmZnREJvMTVPczEvb2p0YXlLd1pwQkdlWW1HQ01LRnl2WCtEcFhQaDVhc2pFTnVPaDdRMXByQ2FpN1hFMXZQWmwvblQxUS9nT0srZXYrQ2dLVzExYzZUcnl6SXNzYXJwdmxGZ1dtQURTYnhnOEFGd1B4SEk2VjdsWjZ2Y2F6YUpackdvbWsrVlNoT2NaQTVCUDAvWDFyNHEvYkkrSk4xNHIrTEY1b2M2MjhGcjRabmV6aldOU3ZtT01CNUc1UHpIYUJ4amhSeDFKMHJ5dEhVNThQZm11amhqNHBqQk9QNGU0cC93RHdsa0xPQUI4b0hYME5jd3dWenRSaXdJNUJGUlJ1U1BsWlR0N1o2MXcrMFo2Q2R6MHY0UDZnbXVmR1R3bmIvY1dUV3JRTWV1Rjg1ZjZWKzhNMTgwK3F4dDlvYVp2TU82S081MlJ4ZzhrN1JnWnp4a2Y0MStDZjdNVnROZmZ0RStCNDRWM1RTNjlaS2k5aXhuVUFmblg3dlI2YmNGczNLMk5vNDZMaGQ3TndEemtZejJPZnc5ZnovaktvM09tbDJaaFY1bTlDMU5aejZSY1MzRU51N2JpUjVoY2tLeDlTVC9qL0FDcXY5cXVydTRqODZDU09ZcUdMQndWSlBYSUJJejBPY2ZqVjZBUjJ6U3JIR3YycVNSV0JCTW5QekVFYzljLzU3MUd1a1R2cUJXVFM5MTB3SVNZU05IdFkvbzJldlVqanZYd2ZzNVh2cll6NUczY2gxYldXMDZOSk14SzBiaU9SbXVUSHdPaDQ0eVIvK3VtYWhycVIyYStROExZa01qZ1RCdDNIWWs4OGtaSEhTcnY5ai9hcDVWYmQ5cFdYWXlsQXJGOGNIR1BRZ2ZUSEhPYXEzbmhPM3UxdUZ0WW5na1kvUEVZZC9VK21Sd1B6NS9QUGtxYnJZSlJtbG9MZDNxaXgvd0JGODFsSzdzck9XRDhzZW9KNUFBUEJ6M3dlL2szN2EydlFhbDhGZE5nakRmdWRZaCs5YmxXNGduQjVQVUg4ejdkQjN5K0hOVXNiMWJoVmlrakIybllpb3B4MHl1UUY0NXlNOVBXdk1mMnpESWZoWFlHVm1qMjZyR213U0JnQ0lwdXVCMTl5VFhzWkhVLzI2bXJkZjBaRlBtdWRQOE81bFg0ZmVHNUZXVXV1bFdxQVI1NitTdko5L2Mxb3RwODE5S1RQYjduQlErV3NoeVYvdTRISXpub081ckMrSGxtMXI0QTBTNElrQ3lhVGFETFB4L3FsKzducDJPUjY5cTZ6UlgxcnhLMGpXZHRDcjJxanpJbk9TYzhjRWtEZDZBYy9LeDQ2MXg0cUxlSW1yZmFaSEsyN3NiSm8rb0d3anVMdG9ZRWI1bFVMdUJiSEhVZGVPbVJTVGgzdElvSjJoWkYrNU5IQ1pPRGpyeVAxNlpOWFlZZFNFY0tYQWhabFVGbVZpektNZFgrdlBmOEFTdWYxTHcybXNhai9BR2UxMWZRUjdRVml0NGdpYlJ6eXd5QmtFZGVlQlhGS0VZdlFsd3RyWTFyKy9tZTE4bEkyVlpaRkc4S004SGs0SnlNZW4xcDl4cHR4UGNFUitSRjVoRE1qUzdVWTU2YmNkK1A4ODFUbnNiTzJieTFrdnRxL2RXVERiaU80T09uMXE5YTNqTENza2tpbzNtbGtFVE1GQUhwdUFPY2o4UHhxSlNUM0JSdnVVMjBTZXhuUnBGV2J6Y1kzcnp1OXU1OU9PdlBwUW1qUjJDeGJGd0YrWjQ5b1RkNmpuazlENmNWWXRudkx2VXc3YkpMZUVFeHRMZG9IVFBmYU9lb3oxNi9wb1hYaEZuaWpaTlFFZ3dRUUdQVEJHTTlEOUtGRTBWUHFmaHgrM3VGZy9iRStJU3NwalU2MU15cVQvZU9mNjE1Y3R6KzVWZHhLK3g3VjYxL3dVYTAxckQ5dG40Z1JsMGwyNm1UdlQ3clpST2xjVjhCZkFTL0ViNGcyMm4zTE5IYUtHbW5LNUJLTC9DUGNuQXo3MSs3WlpGeXd0UDBYNUk3UGhpalorRGZ3VHZmRzk3SHFGMGh0OUZoY004aHovcEJVOG92cm5rRS9sazE5aCtGUGlCY2VHR2pWbmtXMWp6c01mM29oam5IcVBiLzY5YzliQzAwTzJqdDRiZFliZUZCSEdpTDhxQURBR1BwanBVS1RwY0g1aVJHcDRDdHRKR2Y1VjdsT1BzemxuTG0zUFF2RVhpUzQrTldqL3dEQ013WEF1STlhUGt6UnZHc2FQSGdsdHpCUVIweWR2WWRPYTgzOFIvc2kySHdPVmRSOEkyZW9lS3ByZDVMUFc3YVZCTEhkd3Z0THhSS0ZKREo4bnpaNmtnN3VRTysrQVVNZHQ4VDlQTFNTZVV6U0ZVUHJzUFUvVWRxOVArSUhoTHhab2w1bzk3b0dnYXJONGRXWjQ1cGJPSnJpTUt6Z3lCd3VjSG5PNWdPU3VLMjVWTFZtWE80dXlPVytGWGc2eC80VjVZU2FmZDNrdHRKRzhNQW1HWmtRa2tSTUc1ekdlQjBJRzBISkJOZk9mai8vQUlKbWE1NHI4VGVJdFM4UDYxNFVqdDRWa3ZZTkx1YnByZTZsQUl5a1FLYkcrZDFVWmNZM3JuR2MxOWhKOE1OWThPV1VnYlN0UTBwSVo1bWJ6YlY0MVZwR0xzK1NvVUJtYnFPNXhYbG54QzF4UThlcVE2ZUpwTkhaYmRaeU4za0k3aHBHVWRCdjJLdWV1T1BxVktNV3RSUXFTVDBQQlpmMkJyRysrRVdxZlpibTZ2UEZkckd0MWJTUi9MRGN4RmR5Z1I0NDNZWk9Ua09uWlRnL0tFZ2tpa1pRQzNQVTErblhnYlJOTDhFK0dMR08zdU50bmJwT2x0dndHamlsbDh4WS93RGdHQW85aFg1Ny9IYnhCcFBpSDRoWDMvQ1AyRnZwK2oyYkczdDlnK2E0QUp6SzV5Y2xpU2ZZRUR0WERpS2NZMmFPcWhVY203bkdHU1JReFpsSHY3ZlNyM2hidy9lZUxkV2hzYkpXdUxpNjdEaFVBN24wQTlhaXM3Q1M5dVZoaGllZVdZZ0lxcnVaejZBVjlEL0FqNFovOElKb0ptdW9ZNDcrOCtaeUR1WkZ6d3VmdzdkNnpoVFVqYXBMbFJyL0FBQytIa0h3TzFXUFZrbWl1dGFSU3ZteVJia2lWZ1FWUUgxSEJPUXh5UnhuRmZRbmhiVW8vaXI0MGtuTjQ4Y2wxYlJzMXVraFpVVkRqYkgyRE1YSkpHTzJjN2VmR1pYWmxaVlhMT05nSG9PdjEvR3Rqd3RyazNoYlViZS9zNXBJZnNzdVNRZmx3T0NEbnQxSDB6N1YyMDdKV09PWHZPNTdWNHAxSzQwNjNiU1pvVmxrczNJU2N5bkJMRGQweHljSEdhK1Rmalo4SWZFSGpMeHhlYXRIY1FYRFRLRjhtUnRoaUNqQVZjOGJlNHlSMU9mV3ZwUFcvaUJwL2lhWlovdEZuYXN3QVlxWkdrYmdZQlVKaFNPUmtFajlCWENhM1BiNmg0a2ttakxUUXlBRGtjRGFvN0hwMC9VVnZIVFV6amRIeHY0KzhINnQ0UHVkdXBXTnhabVEvS3pZS042aFdCSUo5Z2E1b2dxV1plTjNhdnNINHNlSEl2R1hoRzkwMlNOV2FXTWVUdUhLUzhoV0dmUS9tQ1IzcjVDbExrc2pIYUY2L0wzcmt4TW1wWFoyVVpYVnlKZHNvWDVWT1Q2MGx4QkpiL2VYYm5EQUgwcVNDMFk4QlB2ZHgyTlBlMVpsRVRObkhYSGNWRkNYTkkwbExRMU5CR1lOemNGaG5yMHFPVzZVZmFQOTRBRVZGYTZpdHF5cXUzcmdBbW83U1llZjgzOFJPZmF1NnRwQXlqcTdpbVh6U2ZsWnZwWHVIN0ZHaFhWdDQyT3BTU1RXOXBMRzFva1pVZ1hCWUU1ejdGVjZkL1Rtcy80Qi9CNjF2YkVhdHEwSG1ySWY5R2hmL1ZnZjN5T2paN1o0d00vVDZmOEFnY05OOEhhZnJldVhVRU0wbW4yc2R0YXdzbzJ2SklUMnhqSHlmZ00rdGNGT050UlZLaXRaRDlROGZONGN2NVVzMldPYU5UdWRsNFUrbUc2a1k2L3pyd3o0dC9COXZpN3JNMnNOY2kzMU5oaDJLYmhjbk9jdjN6ejE1N2NWNkQ0bTFpWHhIclVsN0tzYVRYQjh5UlkxQ0lPd3dCMEdCaW9mT052YnRKeUR0K1VEUDRaL3dyV1NVdEdaUjkzWStVL0ZmZ2ZVdkJPb05CZjJ6Ujd1RmxUNW81ZmNOL1RxUFNzbFdkMFpkdnpJeDYrbGZXUGlEUjdMeFZvczloZFErWkRNQ2hZWXpHM1poN2c4OGQ2K1Y5WjAyYlFkWnViTzRSbG10NW1qWVk3Z2tjZmxYRlZqeXM2NmRUbVI2UDhBc2NReVgzN1YzdzdpR2R6ZUlySG9Nay92MFBGZnZOYlhLc3JUTHVoK3p4SHpUSnR5Q0FlaGNZR0Q3NDRQYXZ3cS9ZSXMvd0MwZjJ5L2hyRnVLLzhBRlJXaHlEeU5zZ1BYOFAxcjk4WU5RMHUxdDU3Y1NlV3Nrd0Q4cU1JZUNPZVdCd1JuOFBXdmdPTGJPclR1K2pDUzFPZkdxWEgyQjdxQ2VHOHQwWHlrbWo2bmNBV3l5WU9EeGdqSTlNODFYdHRYdjlSZVlRK2FzaXZqTndXUjJic2ZtR2M1WEdjKzlkTmZYT2lpN0RXc2tra2V3UmhaaW9VTVR5VGdkQmpvT092SE5NMFhXN1BWdFF1NHpjYUxjZVhFR2pXSkFzdHVTQ1F3WTVHMGJSMDdBL2o4Z2syN1hKVnpubzlZMWU1TWlaRnFFRzBSN21sYWJnZzlzNHhqcDJXdEJmRlVsNDBhK1haSk11MWpHWXlzZ1lmdzVKem5KNTkrUHEyNGUxZ0VheDM4WVdZS0VBUUVTOUFjWTdjNDQ3anBXYmZyZFc5NElXbWU0VjMzU09Fanl5N2hoY25HTVk3SHZVU1lYYjBKTlVndXRTMHU0ZGtoWEdWSkU3Wll0MDdZOWVUajg2OEUvYkQwWVdQd3VzRzh1VGQvYWthc1dKK2I5ek1jL2ovU3ZmOEFSZFJTUzZiTnEwc2JxRTh1VUFya0tBUnV4Z1o1NUJCNHJ4djl1NlFQOE43Tmg1MjMrMW9sd1hHMU1RejdRQmpQSVBiSTQ2MTZHUzBVOGJUbDUvb3lWRjN1V3ZoNTRoMUdMNFg2TENzYXBKOWd0VmlrVWxqNVFpQTlPdlBPT2VCeUJVMm1McVYzRkJjTmU2bERIYXlNNVF1MFpZZjN0dUFHWVk0NDZFZmpSK0hmaWUzc1BCdWd4enI5blgrenJZZVo5b0l5ZkpqNTI4LzNRZWxYSlBpVGEyRnBOYVQ2ZkxkWERaK3p6QzVCM2tZSkxESDNmdmZ3bnAxSXlCNStKamZFVkx5czAzK1p6MDRxVW1tN2VwMGw1ckVpMlRGdHRxckx0a2VXZmEwaEE0eUJuSEhybm5wanRxYWRHOWpwTWQ5UDVVMGt5a3h1cmtoOEFqZHV3QVFNRWU5WWZoenhOTmNhYjVsOVp4MjhsMXVBVDdRUExjZEZaMjRISkI3WUpIcldscUVxNmJwTzROWlNMY1JBUitUTnZ4bkJPMGZkKzhEendlRFhQS0xqNzBqVGxhMFpXc2RRc2RmbGVTS09kYmxRSG5NaXNxbm4rSEp4MzljZlNzaWExazFhSXlSelFYVTF0THo4NHlCd2NiangzT01kODFGcU5sZGFrazBoa21oamliYVhWdG1TTXJnYmM1NFZ1dnQ3VmIwblJOUXRiUVNEVXZKdFp1QWdVTVd5QWVEblBCMjlSWEpwSjdHZk0yOXRCdW50cVY3YzIwUzJjbUpHMkVJdTQ1eGdBdGpISjY0cmJ0eEhvSmorMEtza2pmS0VkOExJTWs1NjVPTVk0ejBwYmF4VFRaNUoydlZ1aXppT0loZ3dMSEhKQTU5dXVSeFZyU0xlYTJsbWtXV3pXT1Z3alJUc2pET0J4dHdjWko3ODVKcHdwKzlZMGpSWGMvRlgvZ3B4Z2Z0d2VQSDhzUXRMZVJTYlJ5RjNXOFRmMXJOL1l3dmJjZU9MNy9ucjloSUFiK0lCMHlPZndyby8rQ3AxcjVmN2N2allTZVdyU1NXenNJMjNLbWJXSTdRY0RnZEs4ZStEM2kxZkF2ampUNzVtMndxK3lZQWRVYmh2MEpOZnVtUzFPWERVcjlsK1IwVkUzQ3lQc1M5bml1SlcyL2VYOGgrRlVvaUcrVDVReTlDT0J6MnFhTnJaOXJLek1ySUdVZzlSVXRtOW1MMkY1aXl3NUJmeWpnN2M4NHp4bkZmUk4zT003YjRCYUJkYTc0dXQ3eEZraWgwMG1TVjFQeWhzZkt2NG5CK21UWFNmR1Q0OTZ0NFcxaTF0ZkRldDZscGR6YWwydUpMRzRlQU1XeGhTVkkzZERuUHFQZXRDOStMZWgrQnZoYkROb0tvaXpibzRVSStielA0aTNVNUhjNTVybGZnWDRldGZHUGlHKzFuVkhXVCt6ZHM1YVRHMlNSdHhCUHN1MDRIcmowclRtc3JJeHRkdVRPNCtLM3hHOFRlTGZBL2gvd0Q0U0RXTCs0bWpnVVN3U3ZoUXdRZk93R0FXOVNRVGtuSnJ6WHdsNHBzdFdTOGhhUldzWncxdEtycnhnakFiSDQvenFENDdmRVJieVlRUXliSTV2M1kvNlp4Z2RjSDF4ajhmYXVNOEM2dXNHcHlXMjB2OXFPQ0ZIM1RuZ252M1A0Vk1wWFpjWTZGUDlwUFZienc1OEd0YnU3U2J5WmhISEFIWDVXQWtrUkd3ZlhhU0srSzNCQWJzdWZtejN6WDIxKzFOcGZtZnMrK0k1Vlk3WURiU25QSEhub24vQUxNSytLN3RndzNiUnY3NDR3YTg3Rk44OWpxb2FJOXAvWlI4Q3d2QmVhOWNiWFlGcldCVC9EMDNOL1FFZjdWZXEzUVdLVDVWVUtvR09mdWl2Sy8yV2ZIVnNta1hPaDNFa1VVKy93QXkyeXdIbVp6dUgxeno2NE5lb1h1TEtlWjdxU0haR044Wlo5aXhnQWRUMDdFNTk2MXAyNUZZVlJOeTFCSjFlK1ZWejhwNmtmMC9HdENFR1JBbTFlblBIWC9PS3hmRHVveDZrN1RJelNRVERkR3lqaHczUTU5T08vclczREo1aW1NTDh1UndDUVQwNHJRejVSRUp0NWthUGxHWTR4MzU2ZjRmbFZqVDVjN3BPR2JKUEhHQ2VvL0FZSDRVZ3RGalFqdTNPRDNwQktJM2t3SkF6ZGovQUllby9VVjFVOUVaeTNHYXJFcnl3ODdIM0syQ09tQTV4L0w4NitSdkZXaU5vM2l1K3RXVXFzTTdxT09BdVNRZnl3YSt0ZFNERlkyYnJ1SlVZNjVCL254WHpoKzBscHJhSDhRMmtWbTI2aGJwY0FrZlZQMTJacmx4U3VqZkR1NWsrQ3ZodHJmeEgxUk5OMExUN2pVYnhoa3JHQUZVZXJNU0FvOXlhOTQ4QS84QUJOelZOVWdodXZFV3ZXdWx4ZFpZTFNBM0VpZjdPNGtLUHJ5UHJYQS9CYjlwL3dBYmVGUERscjROOEY2UFkzVjlxRSt5RVcxazl6ZlhzenNkb1ZRVHVmNWdvQVhPRlVZemttSC9BSWJOK0pIaCs0dnJlOHY5OS9KSjVicmQyNFdTMlpTUVZVY2JEbnFNY1k2Vm5oNHc1bDNMcWMvUTZiOW83OWllUDRjYU5IZitGcnJVTmUrenVGdTdZeGg1VlE1SWtVb09RRHdSaklCQjZBMXlud3crQWx6UGZMZGVJSVd0N1pDR1czWnNQS2Y5ckhLcjdkVG50MytoUDJmdmpMRDhWZkROdmROZVJ4YTVhQWZiTGRYd3l2OEEzMVgrNjJNNUhUb2FUeFhwaHR0ZXVFZGRxeUVTSnhuSWJrNUgxQnJzcVJiME1JeWV6TXZTOTFuR3dqaGo4bTNBU01aNEhROGZtS3Z2cVVxUkNGRHZobWtWM0E0eXlnZ2YraE5XeDRSK0YydGEvYnh6RzNpdDdLNVZKSXJpV1Zkc3lIQkRBTGx1UjZnZGZUbXZTZkQzN1BPbG1HT1M4dkxpOFpYeUZqeEVtZnlKL0kxanl0a09TUjQydHV3K2JuYzUrWmNjZTFOdUdKaTh2RHhzcmJRell3VGovUDVWOURQOEsvRE1xRzNTd1czSGxIRHE3Qm9zQVpiY1RsdnZBODU1QitsZVorS1BnWGZXNCsyYVU2NnhiSERmdXVaWXlRTTdsOXNkdTNZVU9MUUtTT0pSMVNFRGNGMjRIT09PUDZWODUvdEMrSC83SCtJY3pqYjVlb290eXA5U2NxZjFXdnBTWHd6TFkzWCtsV2tzWUk1VzRpWldZNDlDSzhWL2E5WUpmYURINWFxNndTZk4zSTNMOHY0WVA1MXo0aFhpZFZQNGk1L3dUZ1dPWDl0djRjYml3alhXSTNmSFVCUVdQOHEvZDYyU3owNjZ0MmhnRnh1M0NSWkl2TDh6alBCQnlWSE9DZWc5T3RmZzUvd1R2azhuOXNMd1ZNcU5JMGQ0N2JWTEFrK1UvVGJ6K1ZmdHhwdmlaTG16aGpqMUEyYlB3UnVad3grN2pIZkhVam5QUEZmbUhGK0k1Y1RCTHQrcHM1V043VnI4YTFmVDNVTnZhd3lPR2tMTEl1UG1KSklLcmtET2M4bm5wNjFsNlJIcVZnMGR4TmErV0ZCTFhWcVNWYmdZd3pxQWNaNVA2bXBkTlM4dnRMdVB0VTBsbENHd3N5RldLcmpJTHBqYjE3RFBIMHhVL2d1ejFHejBuL1NyMmFhM3VvaThjaks4TElCbmFXQS9BRDFCNzE4eEdLbHEzdVRHMGhkWTFHSjdWbmprampqU0lHUm5qOHgwYlB5akFiYXVjNUdjODlPRFdmcTJ1YWhwbG5icmEyZjJxNWtHd0Q1WTBjbkJCd3BKempQNjFxWDJsUjJzMDl4Sk5wZmxEZ281eTdmS2M0T2ZmQXdDRHh6Vlh3clpXL2l2VFZPbkxhcGRCbVpZeGNvcFU5eWR6akErWlJ3Um5uclFzUEtYdXJjdjJiZWkzS28rSXYyQzF0MGxhMmoyanpDcllrWW5JNDU0d1Z3UFhKeG52WGtuN2R1cnplSWZoSnA4ejdVakdzb0VCQjNIOXpNY2oxWGtZSjl3T2xlcTYvSGI2emVadkxDYnpiUjlra1QyNVZXS0VBdjh3QUpKSUhCQU8wOTgxNDMrMlJid3hmQml3U0dFZkxyTWFvQ1Y0VVJYUFRhY2djanIxL0N2U3lpbk5ZeW5CdnIraERqSk96T0c4RGY2ZHAwY2t3bXVGczdLMkh6UlkyNWpRS0F4QjQ3Y1lQNFY2RXBZckQ1bHREYnpKSTdPa3JnSEdGQ3JuSUlibHlRQjZZTlhmQ1hoV3cxajRRNlhjU1hFbGpESHBWcjVtOHNDWDhsY2xPd0p6a0hxYy9URDlQMGVNenJiNmZKZXRkUXlNb2VaRkt6a2pCR2V1U0ZPU1RuQkE0NytUaktTVmVjb2RXL1BxY0xvcE84UjFwSHFFNk5ibTFYYmNLRlVzcWtISHo4ZnhZNTlBT2Npbm5VWHM3dUdPODB1MCt6eGxrRXV6YUVKeGpBQUdmb1ByNjFTZ0VtaStLNGJPUzR1WkpsWDk0dHRFc2l4SWVEZzU1N1pISno2Q24zL0FJd1dWRnM3SFZMZFpGWUh5cGxJRjJWSUxxTnV3bkF6d0NCeHhTcFU1U1dxL3dDQWJLTWtiZWt6L2E3TldrWHlsYVBnaUxZb0xaK1k5ZlFjQVp4eDNxVmJHNjFXL1ZmT2pqaFlGenRWSTI0WDM2OWVNRE9SNlZtMzBTM1RLcGtSZnRTbG8xaWhiYnlRUWg3WVhCQVBVRWM4bXRMVGRWVzR0STJhM21hNVZjeVI3U2UyQmxlT3ZZY2RUMzZjc3JSbGFKTDdFbGxxTnhGcXNsdkpjU05LeVpqYzdGOHNINWprZ0JkM1laeGppa2k4Sy9aVFp0ZFhhM0VnSmZ5bjNLQ05wSVViZTRiQno3ZStScnBxZHZwOXBISFBFOW5lYldralI0OXprRWdjSXZ6YzVHVDZkTURtcElwYmZVWm9iaTVtZG9mTUtLWGphSTVBTzRaSUI3WUhiK2RYTERWYktScEdoUDRtZmpQL0FNRldiYit6UDIzZkZTckVrUG1wYXlCSTJ5dURieDk2K2MwbmVGc2dkOEVEMXI2Zy93Q0N3cVc5cisyNXJqV3Fzc1UxbGFPQXpGeVI1S2cvTjlSMnlCWHpERXFLNDI5Y2V1YS9aTW5iK3AwcjlsK1IwZEQ2TytCSHhkWHhOb0Z2WjMzeVhWZ29pTWgrNjY4N2MvVWNmWDYxNlRmL0FMdVVPc21WeGtiUi9Ldmx6NFBhbkV1cjNVYk44MGlBcjc3VG5INi9wWHVQZ2Z4YzgwVWRuTTdNeXFRanNjWjlzMTlKVG5kSzV6MUlXT3RmVXBiMnloaFpua1dQTG9EamFtU0NjZld1cCtHbmpDNHNXdmJHTnYzZDlFSGM1d0JzempKN2RUWEhTM2tzaVpYOTV0R3dBanBXVHJIaW1IVFptaFdTUlpKRnhJOFhUbmtqci9LdE9heERqY3ErT1BpQkRjK001Ym00bThuVGJOZGpNN2JodDZBbnFlU2Yxcm92aHpQWjZ6ckdtMzFySXNrTWdMUnNRUUdCQnhqSXoxSGV2SGZpQS8yL1F0UzNNVldTTnNobDUrWDVoeitGWnZ3WitPMy9BQWlkb3RoZitkSmJ3a0dHYU1aYURub1JrWkhmanArTlkrMXRMVXVWTzhkRDZVK1BySko4S3RYczU1SDh1K2haSFVlaTRmOEFRcUsrRmI5R1dUTzdqcHdjWXIyYjQ2ZnRMWEhqalMvN1BzWkhraGNGWnBRZ2o0NHlvSHZnWkorbnJYaTk1TXdqeXdWdXc5elhOaUtpY3REU2pUY1ZxUndYQzJ4WDczeTl3YXZ5ZUlMclVvWTQ1cnk0bFJjQUxJNUlVZXd5YXlrZzJvdTVjODVGWDlPMDZPOTFLM2pta2FHR1JsRWtpak94U2NFL2dNbXNZdDNOajZyOEV3Zlo5SXQ0NHNORjVFYUovZEtoUmpuMnlhNkcwVFpHTjBtMXUyQjFySzBTeWowdlRvN1MwakNSMjhheEt2UnNEanZ6MnJaMDRTZlpuZDVJOFJxY0l3T1c1L3orVmVqRjJSd1MzSmJPSW1lUnBQdWpsV0p6eGdaeCt0V0pwWTVWYkJWZTRiT09mcFRMVVJ6RmQyRVJleC9TbjNUUm1ObWpLa2xSakErOXhYUkdXaExWMllNMTBzdTBMOTJPUWhlZWVoNC9BNUg0VjgrL3RTWEVsMThSSW5ta2FSV3M0OWdZOFJydVlZWDJ5Q2Z4cjZBdlk4WEVjaXJzYVZ1ZDQ0QjQ0L1FEODYrYy93QnFEemwrSktyTTBMYmJSRlZWL2dHVzRQNDVQSHFQV3ViRXl1ckcxR05tZFgvd1QwMDRheCsybjhMbzF2TE93a2g4VFdNOFV0d1NzYlBIS3NxUkhBSnpJVUNEQXh1Y1o0cWgrM3A0RnVQQWY3WVh4SDB5KzJyTXV1M2R5b2prRHFzVTBobWo1SGZ5NUZ5T29PUWVSWEJmQ0c5dGJINHBhSE5mYTFlZUhMT0c4aWxmVkxhMyswVGFlVk9SS3NaWk41VWdIRzRIM3JxZjJ1dkVxK0tmMmtmRTNpR0h4SnBQakFlSkxsOVVrMUN4dFpyV0ZtbU84eENLWUIwS1oyNDVBQUdHUFdzNHlTaXZKbTNLM1BYc2NqNEoxbVRRZFFTNXNOUXVMUzZYT3lTR1F4c3ZIT0NEWHBQdzYrSmtZK0oraDNuaTYrMUxVZEsrMHBIZWk0dVpHVm9XeUR1eGtzcWtoaWcrOEFWNkUxNDVvdHBJdW83bFhiMnhuYjE5SzJicldJcldKb2JsbUxNZUFNRWl1bjZ4b0owajlKOUwrTS9nL1cvRHF5ZUhiNlBVck9NK1NpV2tSUUx0NENjaFFpOGpHUU9NZXZMZkV2eGYvd0NFWnNmSnR6YjNXcFNBNUVYendXcW50bmpjMlB3NTdWenYvQkhMd1JjYTk0VThXR3pFZHpKZCtIZFZVdzd4NWt6eVJpSk5vUFhES24wTEQzcmpFdGpZeXlRc3piMWRneWhnU0RuQjUrdnBWYzJsempsVFNkanBXK00yc0MrdWZNWlhndUZDeUxzQUpHZXg1MjllbGRoNGIxNWJtQmJxeG1rQW13VDh4NmdBYlNNOXNkUHhyeWQyeGI3bERNemRBQnpqcldoNFdudXZEMTFKSXN6UnlTY3J6OG40ak9PLzFvNWc1VWV6WGZpYWE2dDVJYmlPS2RabCtZRk1xdzdqSFQ4YStPLzIvTkhnMFB4aG9jY09QSmt0Wkp3R09TdTVzWUh0OHBQNGl2V1BFMzdXdWhmRHp4VC9BR1Rya041REk5dXN3dVlVOHhEa2tZSzV5cEdPb3puUGF2bVA5cC80MHI4YlBpWEpmV3ZtTHBkakd0dFpibDJzVUdTV0k5MkpQMHdPMWN1S2xIbHNhVVl5NXIyUFFQOEFnbCtBMzdjWGdoMmlndUVqbW5rYU9VN1ZrQzI4cElQNVYreU4xckdnK0pOYS9zdTl1TlBzOVJWUFBpdGhkcDV6b0NWRzFCeVQ3LzFOZmoxL3dTWnM0N3Y5dWJ3ajVvWnRpWGo0MmJza1cwdU9PblhIWDByOWd0UXM0N1hWMXVicXhpdFpKY2o3U21aQUZaQ1NvQSs2dkdRQVFQbVd2eXJpNXI2eEc2djd2Nm5STmE2bG53OXJOMTRWdEZzRiswYWhDck96U29nV1FIY3hYY3ZxQm5ucHhqbnROY0xlVEk4UG5hZ2l4cHZNaE82T0llaERkd1dPY1pJejZjbDZXMGtZUm11TE1pWWViNVp0bSswQmR1U2NkU2M0R0R4OHg0RlhyZjdDbGtISCtpckpHWE1pTDhxbHVCbmpjZm0rWG5QUGNkYStTcCswYTFDSlQvNFNPMXVkTS8weU5aSTFVUmo3WEJ0a2NES25iMHl1MFp6a2ppckhoMjJTNW10WkxLRnRNOHB0a1RSbmJFNE9TZVJrQTRidU01R004WnJVMFcvWHc5cUVNTFgwVFIrWGxwbUdXUVliNVNvT0I4Mk1aSEk2NTZWbWF4NGprdWRJdGxqdDJ2VmprVkcyUytWNWhKSUNna2NGaDBBSFgwSFRTRW56TFVyblZ5RHhUWnpKZDJ1MjZFMG04c0VlWnJnTXVCdUJJd0IwSHlualBldkVmMnRudUp2aFBwa2hWNFkyMUpBUTBlMWd3U2ZJWTVQVEp4N0g4QjY5cTBXdVBaeVR3eFBwKzBLcWduem1qUmljS2NoZVZHQU1BWktEb09ua243WWEzemZEcTEvdENBUnQvYU1HWmQvRW1JWmxISHI4cE9jWStiR2VLOVRKcXovdENDYTYvb3c1dFRxZmhwNGdhUDRmNkRZQ09PQ082MDYxRXM4cExIQWhYbE9jWTllbklOZEZCdnUyV2V3K3h4eFJQdS9kc3czNXpoZ0J6ajd2WEovT3VWOE1TcDRUK0ZQaCs0YU9PNysxNlRBelczSytaOGtlUHZjY0t3enRQT0Q2R3BmQ3Q1OXF1ckJiZXppYU84QUVZdDltMkpSbjg4ZW1QVGpHRFhtNHk2eEUxL2VaanpwT3gxZjJDUFZyYTRta3VJWTVJR08wT29UTFpCT1NXejM3WjV4bnBtc2pXUEJlcStJVnRZVWt0N09JeU1zWWpuaWxZcnlkNEdRM1FISUdGSEhvS3Y2aHBGNWM2VTAybngyNXV1VkNCeXJiZ0N2QXdUN24zUDRWRDRiMTYrbTBUZHFHa3h6VFdyYkVXRUZua09mbUlVODdjWnlXNXgyN1ZuRG12Wmx4MTBZMmZ3cnExbmJ5eUp1Ynk0UXJmNlErNWdPaTVHVHVKRGJnb0F5Zlltcm1rNmJjV3M2WFZ4Ynh6TE1xTXNLS3p5Z0x5MHJuSFFuanFjYzEwV2dheXNLU1BjV3M2Q0ZpN1NMSVBsK1hPVkFDa0RvVHlUd2ZwV1g0aThUNnBOSHRzdFBZWUd4SmpIaGwzcU9DU0J4M3huOWEybkdGcnQ2K1Jjb3dhdXpXZ3VMaWE2WlB0RnFyTEdrVUtxKzBLY2VwR2VPbVRVeldzZ3ZMaU9DWm9ycGQ2NEsrWWpmZTU5Y2NqZ2VoTmN4SHJXc3ozQ1IzMXRaUTdNR1I0bER5c2ZtNE8xaUJuQ25qMVBwWFZqeC9icFlYRVU2aTNXYUVOdk1HMVVIQnp3ZWhJT1Jqb2VEMnBScVdsYTRLU3VmalIvd1dPME82MC84QWJHdTJ2YnA3eTRrMHkxY1NNRkJDa05nWVhBNHI1VFdQeXN0L2U3WTYxOWlmOEZxTlp0OWMvYkNXNHRWOHVFNkxib01KamNWZVFaUHY3MThneU1jN3RwNjRCcjlaeWVmTmdxYjhqUXUrRWRkWHcxcjhOMDhSdUk0Mnk4YXZzTGdqa2J1MzVWNkhiZnRGYVpDNi93REZQc3VEZzR2TS93RHNsZVVOdy84QUQxNVBlbkZvMGo2WXordGV0R28wSnBQYzlnbC9hWnNtYjVOQ2wyOWcxOHpLbzl2bHF2Y2Z0SGFmS28vNHArWmR3d1Nidi83R3ZKMmxVcnU1SFlDbE8wRE9XOXVhcjIwaGNpTy84Uy9HVzM4UStIcml4WFNwb0paL2xFcHVkd1VlNjdmVGpxSzRtSzQyWkh5Lzd3cWlzdVYzWndTVDE5S1h6bU1pL01ObzVPQldjcFhLTHF6Wmx5KzcyVTlEVWNyeHlTajVOMkQwejJwcVNoeVczZmVwa2gzTmtaK1U5YWtCYmtocE9QbCtiN25ZVXRsTzNMZk5HM1FsaDkybUFNeDY3Y0gxNjA1UjhwWldHN3JqSEdLRm9CNzk0Yy9hSDhQdHB0dWwwMm9DNWpqVkhrWlZIellBSkh6ZnJXdmZmdEc2Rm9NYXBjUjZtL21EY0RzaU9CN1lmNlY4elJ1eXUyZm03WXhVa2dhY3g1Wm1DakhKNlYwUnhETTNUaWZSai90VStIVmliYkZxd0hwNUNaUC9BSS9WUC9ockR3N2J2dWhoMVptLzI0MDQvd0RINitmV2M3dHU1UVFPYzFCS1FEOHZIclZmV3BFK3dnZlE3L3RWNkZOTEg1ME9vN1FmbUhrSXhKd1IvZTk2OGErTFhqYUh4LzQ0dnRVaWpNTU0rMUVEY01WVUJRVHlRTTR6eDYxemdMTy96LzhBNnFqVldiMEt0NjlEVTFLemx1YVJwcGFvY0dPZnVzM2JQcFRacEdhWmkvNW1wRTNLUDRjOWZhblNRck1tU01udWZXc2VZb2JBN0VLMmM3Y0VqdlUwbGlzaXN4UmVuSlBjMUd0dEkvOEFEOTNqS2pwaW5YRXJlVUZ4bFY3azlLdE5vRDY5L3dDQ2V2N1RQaFQ0UmFCZWFmcS9pcTc4STZ0Y1c5eFp3M1RhYzEzWm1LWU9yYjJqWVNSbGR5c3JLajhyMDRySTFUOXB6d25ZNnJlUitmZVhVY01yUngzRVZ1QkhMZy9lWEpEWU9DZVFENmpPYStWMXVKWVN1MWV2NDFaanUvUDRaUjYvalcvMWhwV01mWXh2YytvN1g5cS93ZkN1ZitKbHVZZDdjZXYrOVYrTDlyYndkNVRZYlV2bXh6OW45eC90VjhsUE1wS3hzeDNNY2dZb0RrcnVMTitkUjlha0hzWW5mZkg3NGpXWHhHOGVOcUduZVk5dUxkSWcwaTdHYkFKWWtaT1BtSjcxdzBzcFFveXIxemxhRlpXWDcyMCtwRlQvQUdiRnZrY25PQnppc0pTdTdzMVNzckkrbi84QWdrSDUwdjdiWGg2NHQ1bHRacmV6dXBGa0tqRVo4b2pQMDUrdjg2L1hhdzhXVzY2anRTK1J2TFVNRndCbGxJQnp1UHZrOWVLL0lML2dsQm9NbmlIOXF5R0ZaUmJ5UjZaY01yTU9QNEJqdDYxK2wzaG5XNU5JMXk2dHpCRmQzRElRemxWWm5ROWNINkxrY2V2QjZuOHY0d3JPT01pbnRaSEZpS2pqTzNROTAxRHhYYWE3YnczRnJxMm5zMTBCdVhPWkVISEFDOGNZL2wyNUhuM2pUVDRQR3QrajZocHRyckZuWk0wRnZJSndqMjdESDhJeWZtNE9WL1RHS3psMUNHOFRUL3M4SGszTVV6ZnVtYmI1Z0FVYlRnOG5rblAreU9weWE2ZnhIZTNrR3NRV2xuSE5jdEpLSkxrL0tvWUtEZ0RKSnpuT2NqblAxcjV1TlZTWE5kL0lQYmRVYS9oYXhtOEs2WEc4R25SUlc4NnNyR09kSGFKdHlzVGpkdWJPNDVPQ0J0N1lPWk5Udkw2MTBwN1czWGFXYU5aMFJ3Y1lVcmdqSXh3T3Z1ZTR3Y3U3dHJyVVd0MUY5RER0aSs2OGU0cTdGUHZjam5jUU1ad01IMXhWcTB0MmZVUHNtb1RUekJnZkpLeG5LZ3NTdlA4QUVPY2tEZ1pib2NHcWpIVzZadEgzaW5wMGxxdW9iZHNzWmRWS3l3cjVnVmcrZVNjcmtnRTljREdNNTRQbUg3YStxMitxL0QrMU51cXFwMVpDTUp6eERKbjJ3U1R4ampGZXNhWHA5MXB4Wlk3T3hleGozbGtYTXVYYjJ5QXVNZ1pCUEp6ajVhOHEvYmZ2R204Qld1Mk8zamIrMG9GS3BGdDJNSXB5eTl4OTQ1STRQekROZW5sRVZUeDFKSjlmMFk1VTNIcVdQQTk1djhLYUJ1dFZaUDdJZ2gzdU9wYUJWSno2NDZEb01EcFhUYW41MXJaTEpKSjlsajNqeTQ4b20za1pLZ2NydXlUMkI0cm0vZzJzTTNnM1RJTHErSnMyc1VsYUpiaFZPOWJjSFlSdTNjL0p3T294MHJXaTBiVGRUMDk3NzdaTXpKdEkzS3h5VDkxdmJnNTU5UG9LOGpGVkpmV0o2MmQyVHlSZXJMbW5hemRYZGkwMXBEYnlObjkzODdTTTRaaUNWR2VRTW5CNkVIclVhZkVUL2hHTlMwKzR1SVVrandQTFZXKy9qTE1NcWY4QWE2QWpxS3lkSTFBd3ZMYjI5MHk3WGFkQUlXTzhrcUNFNXd3KzZPYzQ2ZGFtV1c4MTU1VGNhWmNUZVpGNTBOeVdhTkVQVHF3L1FqdjNGWnhiZTcxRGxTVmtiMmplTnhxV29YVnhhNld4aUEzNzFteDVDN3o4aHlkekRrOGM5RFhTYXo0c1M3OFArUkNRbm1Lc3l5eURMS3hJR1ZQVDdvSUdRQjdWeDF0cGZpSFRQRHR4WTJpeVJ4WGtvbE0wbVptVmY3djNzOStjWXlUVnZSUEExMDlwalVwTlM4bWMrWElGYytWRXdCWUhIWWNkK09BT2E2bFRUaGFMMUxqQjIzSnIzeEZQNVVrUDltelc0allPbHlqS3U0ampKQXlRdkl5VGpPUWNjMUMzaTZRYW0wY2x2R3ZtWmpTSXNqYkZCSTdIc01IT1FSeHdPOWk5K0dKMWF6alN3dnJ5T0tWVEExd0I1bVd5UUNCZ1lJd1NPQnlPL0JxbjRkK0QxeFBKTkZlWEJWb3NSeFNGU3MxMENRWExrbjVjRWVoUCsxMXptcU12SXo5bmQ2SDVhLzhBQlplYVovMm1OTm1aTVBKbzBZQjI0TElKcGdDZjg5TVY4aHBJNStYUFh2bnBYMjEvd1hGOExyb1g3UkhoMW9GdTFqbDBNQUxQamNwRTh2SCtPZWM1NmpCUHhHTGVSVGxtQUhwbnJYNjFrS3RnS1M4am9qb2h6cDVaWm14ejZWRE5HQXk4OXUzcFZxTXFwWmNNM0FPYzFISmJOSWY0ZHZYYlhzRnRXRWpLbUw3b1BIVUwwcEhpV0xhckRIUHJUZG9oWTdWeTN2MHF4R0kxaTNzZmxCd2VLQkVSaWp1RzJzMnpqR0FlOVBnUkRoUTI3M1BHYWpsRWV3RCtFY2ppbk41WWo4emI5MGNBR2dybUhHVm9wTnV4UjZIT1FLUjkwZzNMd0IyeHkzMXFKWjIya2h2d3gwcDczMnphcTVYKzhTYUJPVnhYbTI3V3dOM3ZWZVM2Y3lCVkxIZCtRcHdqKzJENVc1N2pISjk2bU5xajQzZk42Yy9kcHBpR2hXRzM1dVBjVVJsa1U0TzRub2FsbHR1RzIvTHQ5T3BwaUh5UnUyOU9jL3ovQUZwOG9EU2hQekUvTW83VTB6YjVTeW5rOThkYWtDK1kzOEpYdTJPMUVpUnB0NHpuakh0VWdWNDR0MHU3ZDgzU25iY3IxeTJjOGRxV1JRUjh2QXp5ZmFtRkFIenUycjA5aWFkKzREbGsyb2ZtR1A1VVI3Z0IvZHp5YWxrMitUdFZ2dmMvU280bFpHd0c0NjBnSjRyMlMyOHdLekJaRndjZWxSdWdHMDdtWmp4U0ZQTlZXK1hyakE3VThJc2FydXdvWHJtZ2FWeU9SZGk0VnUrS2VRUkpqSlRqazV6bmordEpLNXp0NkwyOVQrTlJpVFB5N2NleG9FT0JraVBHMzNKUE5TVFNxcjQrYmI5S2ptanpqYjh1MDR4bjcxTkxLNXh1YmdmeGV2cFFCTkMyK1ZjRHYwejBxNURNd09UK0dLcE5GdDV5cThaUFBTclVjSmlYbHRxOXZlcGxzVnlvK3ZmK0NNMFU5eCsxMjgwTnhaMjV0ZEZ1WlhhOGplUzNaY29DSFZDR0k1SDNXVTV4empOZnBMUHFLM2VyWHNra2R2SE5HOGtrUWhUYmlJb1NHWThZd0ZLNE9jQTV6bkdQem0vNElsYWRZNmgrMVhxMzIrUXJESDRmbUlaYzdzL2FMY1lYSE9jRS9oWDZuUytFL0R1bENhRzhXOGdoazJZTWJydWxIQllaT2VvNDZBa1k3ODErY2NXVlpTeFNvNldTK1poVmNucDBQSjlSdnJ5S3lpMUxUWDNzbXdqY2N4azRKSEI1eGo1c3FEakF5UmtWMm1qZU45V2dtam12TGVPYUdXMlJwSFFoWkdHd0VrREhPUWNkVGs5dWNEZDFIdzNEcFdpVFF3MmNOekhJVHYzUHVVaGprZ0U5Z0d3Vk9lQWU1T2NTUHdoRHBTdzdZN3FPTzNBZUtLQ0oxQkhRRVpHM0FJeHhrOFlHYStPajdXQzVVa3pralRrbjNMa2NGNWZ4TGZXc0R5Zlk1a2xhT1JkanpSN1Q4cDR4bmNBY2tjN0Z6M3hjMFB4YnFOMWQ3ZDB0M3FheHJMYXhMSmdJQ2NGRGpQSUJ6MnlGQXdhdGVCOWFiU2t2NUlMUzQwNEpnS3R4aDBtSENuSzVPVjV6OHdCeWMvWGpQRkhnZXh1dmlocHZpYVBXcnB0VjBlWVhrVU1LaDJpSUo3OEQ3bVJqZ0hjTStoOWpEL1Y1NjRpWEo2TC9BSUp0RlN0ZG5mNmxxMXhlK0g3YzNFTUgranh0OXFhS1VoQVFEZ0tWNm5QVWZMODJSempueXo5c3U1MDlQZy9ZeFd5d3czWDlyd3ROQmpjd1BrVDg1NjRHUXZYbkg1VXZoOThFbjBqNDM2OTQydGI2MWp0L0V6Nzd1M1NCUE9sMkRKVldZRXhxVGhtMmJXZGxUT1FBS3EvdGF3UXI4TWJmeVp0eXg2dEdteCtYVWVUS09XSExES2tnbis4VDNyME12amg0NCtsN0dYTXI3MnQwTmRHYW5nLzRkWFhpVHdob00ya1dxelhqYWZiU0FTSVVKa1czUlQ4eElHT005Q09SMTV6MlhnN3dQTm9tbE8ycFRLeGFNNzdlQldpREU5TXQ2RTVQYzRCTkh3cnM3WFRQaHQ0Ym10WlpvYjZiVHJWM2VlVXRHY3dvdUVBSEhUSHNEMHprMXJhbjRodXAwOHkwUzN1L3MrMW1WenRhWHJ1eUFjNEdjQWtFa2M4ODE0dUt3MFZpSjFkM3pNSTBiTnlMRVY5YjMydVc5cTFoWmFYRENGaHVaNG5Mc1dCRzdKVmlwQStYR0JrODVKN1EzVjFjYWRKZVIzRWw3TisralNLUXdnUTNDbklCTGRUOTBZSTQ0T2Vlbk0rSGRTMURWcjVXV08wRWpjWVNjTUdCSlltUVp5TVpCNkFmVUVpdlNOYWw4clNJN2U4djJaYlZVYi9VeWJHSUE0Vm1YSXd1ZWdHY2s1NDRuMmJsQ1RxSzNic1dvNlhaWDBwV2gwNk9LVzVFejV5cGpibVBnazlUeCt2Zm5HS3I2LzRwajB1L3RkSHVCOGt6WWtsMmJsVDVlQ1N1UjF4eC9MdHpPb2FzWWRGV096dXZsYVNRaVpkeGtkZmxHMWpqQ25IWEpIM2owcXhvK3Z3YTdweVdjMGJUSGVSKzdVK1p1UUhjRGc1S2pnZ2s0T0RXY2F5dHl4UVBWV1IwYlhzNXVIaHRYOHlHYjVVaUlQemtkTUtPL2ZuMXA5NzRobW51SHVqSjVNbmxiVEZ0TFJuNWNqQXpna1k2RGpudjBxcG9taUxIb3FyY0NhT1RKWVNFRGNSMkp6MkpQNmR1N0xuWE5ObXViWXlYaXJhYmwzc2dCM3NRZUZ3QWNFNEJJd1NNalBRMWNPYTlpUFoyUHpML0FPQzhGKzE1OFh2QmQyRlZtbTBtVlpKVWJkNWhFeDVKOWVhK0JnNnlEUHpibU5mb0Ivd1hPMG1IVFBGbmdGWTVCSXEyVjBwYkh6TURJaHlmZjVqK1ZmQURKR2g3K285Sy9WdUg1TjRDbTM1L21hUjJGUnRzbTRLek4zNHBnR1p2NWo5YTNmRHZnYTYxalFiM1VqRklzRnFFS1lYL0FJK0MwaXg3VTlUbHMrbnltcVdwYVJQcHQxOW51b1pMZVZnR1ZaQjFCNk43aXZiNVdobWZ2Q0llY2oxcVMzVnJrN1YycXErOWFuaXI0ZDMyZ2F0ZFczbHZPdGd3U2FhT05qR3JjWkJPT0NOd0hQY2oxRk84TitBZFUxdnhMYTZaSGJYRnZkWFRLQVpvV1ZZbExiZDdER1ZVSHFjY1V1VmpWdXBpeVdoWVkzZlgyRk1rZyt6cmxYNUhOYWN2aHZVcmhZajlsdUpQdEFQaytYQXhFd0dNN2ZYR1JuSHJUL0R2aGFiWG52RmprZ3QvN09oYWU0YVlzTmloZ3A2QTg3aUJqMU5IS3dkdWhjK0YybjJPdWVLRnRiNjNhYUdWWGxrZmV5ZVZIR3JPNUdQNHRxbkdlQjZHdFd6K0VyZU1KOVBOczlqcFoxWXhMYXdUVEZpd0xHSm43c0ZMbzU1R0FPL3JqdERyWHc2MWk2alZXaG0reWJaSlkxRGhvSmtHRGtnZ0s2TU9lNGJIcUtkYmVNdGNFZG5icTBtN1RvWkliZjhBY2pmRWhERmxCeG5BM01lZWhZbmlyNmFpSzJoZUJKZGIxeThzYksvczVGc2JkN2w1anZXTjFVWk8zNWM5ZU9RTTQrZ08xUDhBQnpVN1p0UmphUzNrYlQ1SGpDTHUzWEpTZFlDVUdPY3lPRkdjRTdXOUt3dkMrcTNtbDNrazFtcmVZeWp6RHREZ3FHVnVjZzhaVmY1ZHlLN3AvaWI0aThONnhIYjZsY3M4ZHBOSFBjZlo0NGxkd1pSY2dieWh3ZDdaR1FRQ1NNWXlLcU1WWVd2UXpaUGd4cVVBV1ZydlRVdHlvWjdoNTlzYW5mTEdGeVFNa21DVEdPb1hJNmpMZFUrR1RXZmhLR1JtUmRRa3VaZk95eDJXOGNjY2JQdndQdkF5eHJ4bjV2bDYxZjFmNGdhdDRrczlXYTJoaFhTNFlyWXp3U3d4eUZRaEtJNjVVWUpNakg1QXVBNUE0SEZiVXZqajRrKzIvYUpQcy84QXBTeU9wTm5FcXliNVZrZGdOdU9aSTFPZW9JT01FbW5vR3BtMmZ3cjFDTHhBdG5kUFl4dXQ1OWtFWG5ZZTVJbldCdkw0K2JETWZmQ3NjSGJVbXFmQ082WFU5UkZ0TkQ1RUtMTmFMa3ZKT0pKekZGSHd1TjV4bkhUdU1qcG9hYjRyOFZlSkRaNm1CWUNheXVKTHEzbmtXQ0tTTm1jdXpESUIyQjhuKzZHOUR4V1d2eE8xZlM3bllzc0N0WnZhN05rTVRETnBrUllJSE9PcElQekhxVFJ5cDdqMUhRL0JEVzdxWkk0MnNHM09pU01MZ2Z1bWN5S0F3NmptTnVvNkVIb2MxWDFMNFd6VGFIQmRSTCs2aHNVdmJxVjVOMFlMUEo1WUdCa1pDQWZOeHU3OGlrc1BpOXFsaGRYajIvMldGYnlkcDVFUzJUYVhNVWtRT0NNY0xMSmdkaTJmVEEveFYxWmJHU05WczQvT3NGMDB1a0lEaUFSaVBaeDF5b0dTUVRua0VHbGFJR1JvZmcyKzF5MXVMaTNWRmhnU1JzczJOK3hESXdYMUlRWlAxQTZrQTZVUHd1MXJiRXlRb3pUTE9RaGtDc3ZreExKSXBCSStZSTZuSHZqcUNBN3cxOFN0UThQZUdKTkpnZ3NtaFl6NWFTQU00RXdpRGdNZlVSSit0ZEI0bitMV3NYMkxpNXM3R3pqMUtDNWxpTUtCZk1TZVFpVmdjbnFVWmVlMjRlbURsUlBXeHhHdmFDL2gzVlpiRzgyeFhFTEFPb2NOakl6MUhGVlFVbUM3Z1dqNTZucml0THhkNGdrOFhlSTlRMVNXQ1B6cjJacHBCR3UxSTJZazRINjR6NlZtSXl4cngwSE9QV3MrVW9hTnArVWpienhrVWJPcHh1YjBweW9IYmN4S2dIT005YWwxUFQ3alNic1FUeFNXN01pU1lrVXEyR1VNcC9GU0Q5Q0trQ0FMNW01dHUzMkZBT0diZHQ5dU85Q3lOTEtFVmovMzExTlRYbW5YRmpJOFU4TWx2Y0tBekxJQ3JjalBRK29JUDQwRlJBenhvblB6TXg5S1EzMG5tSEkrWHFveFZaNENyTHRCejA1NlZKSDVqL015OGRqam9PbEdoUFUrM2Y4QWdoNU0zL0RRbmladmwrZncrMFFISTNscm1BNHoxSDNjOGVucG12MUwxaldiRy9abGtzb1ZoVTdNUktBcXJnNUkvd0JySzhkczQ3NHI4dWYrQ0hsaElmalY0cXZGamFTTzAwMkl5SXI3U1ZNeTV3ZXg2RFBIVThnWnI5RTlSOFJhWC93a3R5STd1T1BVREVDOWlzaGtkQm5DOHFjSEw0SmJ0bm5ubXZ5L2ltVXZyenQyUm43emJzZGpwbDNHTHByQzNzeXl6Ym9CTUpHampXTXJsdU1zT29KeU9EbjZWSHJHZzNUU3h4UTNSTjhzMlBNRHNpeWtFT004NEJLNHlPblFFZFJXVFo2bmUzczlyRXBWb2JlM2JOMEppcDNIa0FLT3BJVXR4ejJKNkFYcDdLNjBocGxqdXRQOHlhTlpHaDJaVkNWSjQ5RjZEZ1lHUitQemNZemFzOVNWRTB0TzErSjdaa3VGZzFDR3p1VElwWW1QZXhYNWh1NFBKeWR1Qnd1T0JtczJiVVJlZUxJM3R0Rmh0TGFabVJaR2cyeTdjRlQwL3VnOURqcWV1UmkzRjhOZFdXeXNyeGJWVyswSzBybEV6NVo0RE53TWpPNFlKd1BseHhrNTZ2d2hwbDFvdHhlemFvc1RXN1JoRjIvNnhGY051WUVaR2NaQjluQXdkMWJVNk1yMm1od2k3YW5CNm40WnVMVFVZNzVZSlZqYzVBbWthTnBCODdmS1dKS2o1QndldTdCNmduenY5cnJ3N05wbndpczVycUdLMy80bktSaEZESGIrNm40NTZjQWNZeCt1ZlZyclZMazNWOTlvczduZEhDV3NuV2RQSkRuZmplRHlDV0FHTUFBRTRCcngvd0RhNThUWHVvZkRmVDdPNlVaZS9qblJCTDVpb0ZqbVU1SXdDZm1IWGtENjVQclpOU1N4MUpMditqSHlvNkw0ZTZwYjZSNEE4UGVhczAxeExaUXlLQStGVlZoUWtmTjdjOGZUQjdiM2h5NjBGbWJVbWJVWmg1dTZhSVovYzRKM09DT2VRRHg2Wno2aXI4T2ZEV2xKNEQ4UHJkWENiYjdTWUdZTTI3bjdMSDh2T2NmTVR3TWRBY2NWMTJvZURiZlRGTW5ucmJUWGFZUXlSUEpDQzNISXdPQWNnak9jRTQ1cmp4R0hsOVluSlBxem41cGMza1RhSHJFemFZMTB0bUxPMTNyYnJheXlZbWtEZFFjQUZlTm5YQjQ5S3IrS3I2VFVkZGI3UmF4MnRyOHFNcGxWbGtiQlZUMkdTRngyeHp4M09CclB3NnRKZGZqUzMxQzR1Ym5CUmlzenhDVGtZRERBSkEyakhUcU05Q0t2YUw4TzExQzcrenJLYmRGWjVOOGtqdXZkaVFNRXNlY1l3Y0FBRGpBck90QlRYSW0yemJtV3kxTGxtTlBPcnJCNWNza0Z1alJLTFNJT3E3dW1BdkFCNC9pSFFuUGFrOElXR256YXZJWW1pc2IxYzIrWmp3aERES2hIeVIxNTRJK2JweHpvK0E5SFhWNUwzVFp2T2g4dUU0emx1UVF1QU1BaGQzQkFKQTU0SjRNMExXT2phcGRSd3RKSXZOc1pXZ0Nic0REc0R3TUFESTlSMjVxcVdIa29xWExvVkdYWkhUK0Z2QkZuZFdNNjZ0cU04a2QwckdHUzFZZk5nWVVCaVR5T25LNDY4ZDZOZCtDMms2Vm95c3NjRTNuU0JZYlFxWmxsd1dMYnlTQ3JBWTNFNHpqcGl1ZjBKSkpiVDdWYkt0OE1zcGZCQVZDQ0YyOVNNNUlBQTR3YzU1eG0rS2ZFR3A2QTQwOWRQdnJlOHVQdnkzVW1HVDBMRGJuN3UzMEhyWG8wNmtZdzFSMUtWbzZuNTZmOEYrYldLMjFMNGN4d3hKQ2tjVjZwS2dBdWYzSjVDZ0FIbXZ6bWtnWEE2YmllY1YraVgvQmM3VUcxaUQ0ZnlHOHRyaFlSY3JzamJjMFRNSW1ZTjZIUGIxQnI4Ny9LeTNiY3ZyNjE5N2tNazhGQzNuK1psSzNROUQ4Ti9IU0h3L3BtbVFwb3R2SkpwNzJ4WnpNMzc0UlBLK01EcHVNdWZxdWVlTWN6WTZ2WTNmaTZhLzFTQysxQzIyL3VvM3ZNVExqRzNjK3c3Z01ZeGdjZW1LeEJGNVIrVmhudmtWSGN6WmorNjJjbm9hOXJuZHRRakZIcFAvRFF2Mk9ZWGY4QVpGdTJwU1RHV1ppK1laVk4yTG8vSjF6dVZWenVQeWpHTTgwYVArMEJZV1dtd3d5YVBOTk5aUitWYnlMZUJXWEVkd011ZGgzSHpibHBCakdNQWM5YTh1RzFDckFldlh0VHJsZkpCS25IYzRxdmFNVmtlbHdmSHpUeHBYMmNhVmVSM0VPbkN5Z3ZFdWtTNFJsa2llTTU4dkdGRVFVY0ZzSDczQUE1endoNHYwdlI5RzhSUjZxbW9YRjFyc2NjUG14U3FyS29tU1Y4bGd4SllvT2Y1OUs1Tkp2TEczZGpPTTVGRThLeUU3L21IWDJGSHRIMUs1VDFEV2ZqNXAycVdFbTNUREJlQ09hMWh3NGFPT0I0WUxkUzNHV2RJb21BT1FDejd1TVlNTi84ZGJPUzc4UVRXOEZ6WnlYTno5cTBtVUpITTFxM21GeXBEWUF5TmczTHl2bEwxUEo4c21JRFJsUUR0empubkZQWTcyWTdmbUhjOUtQYU1sSkhkL0R6eDVwbmgzd3RxMXJmSlBOSnFvQ0tzY1FIbEVEQWNTWkRBaFdrQlhCVmcvT09vN1NUNHgrRWJodFNsRm5xVzdVNXBYa2daVTh0bGE3amw1T2YrZU1ZVEdNTGc5ZHhJOFd0SnZLM0wxNDVCN21yT3EyRjVwRFFpNnRXdC90VVltaURMdDh4RDBZZXg5cXFNMkt4NnRvbngzMG5ROVh2Slo1dFJ2STN2QkxhT1lWVnJhRkJjU0xGamRqbWFWTTlzSzNyaW4rRy9pZm9NdW9hVENGdjNrc1k3Q0dCWkNpeHVVWXZQRXpNNFZJNUhLNWtQUlY1WEZlTE1xbFMyR1ZzL3BVcUswMExzTnhQSFdqbUZ5bnRGL3JVSGhEU0xkcnE5dHBySDdKYTZmNUZwZG83TnZ1UHROMEFxdGxkcFZvc25naGhna0VHc2ZWL2k1cDA4MnJ3dzNMR083dVliZTBuK3dKR2JheTN6UEw4b1k1YjUxVWMvZDNESUdLOHZFVzlXNmhoenhVcXdLNnEyTnZxZlhpam1EbE81MXJ4N29lcmZHdlNkVkVVa09oMjgxdkpjUmlQY0ZDa1BLc2FrbkNGaTJ3TWNnRWRPbFhORDhlK0d2OEFoSFo1THA1WTlTOHE3dG9rVzBWbG1VdzdZV0p6Z0h6WkpuSTV4Kzd3VHNGZVp5SWl4azdkcHp4N2RhYkRaU1BQSEhDcnlTU0VLZ1VibVkrdzlhT1lvN3Y0bGVNZEcxdncxYlcrbXhadW83dmJJVnRCRURFbHZER2ttUWVydUpTd3hqaGVsZExwbmk3d2ZlMldpV045SVBJdEJiUk41bHR1MitYYk9YYzQ1OHMzTXBKQTZxZ09NbkZlUjNjVTFoTzBKaWxobWljcktraWxXUmdjRUVIcGpGT2FYYU56TDdERFp4UktvS3lPMzhkK0xiVFVQQmtGckRKYXJmUGZ5eVhFVnRHeXhORXNVRVVSK2JraytYSTJUa2t1U2VldTJtc2VFcjN3NWEydTZ4aHVZWXJWbW1lei93Q1d5VzB6T1hJVWtvWjVJMFBYY0k4NDVyeXRZdlBPNDVYcnptcHNCc2pJM2RPdFQ3UXBLNTZoNHMxWHd1OE90eTZYZGFhMGx4SGJXbHJGTFk3ZHFwREdzazR3aEc5MzNkd0I4NTVPMDFKZGE3NFBieEdiWC9pV3RwOTFyRnlUY1BaOEpacWlmWndNTHVDczRPN2JodG9Jd054QjhuOHVRbi9lOTZoWXRGSjh1N2JqL0pvNXhIc1VuaHZTVjhBWFd2U1cybnd5VFF0SEdzTms2eFNPSkk0RWFKcEJoaHRTZHpnNUxoc2dZQXFyYTZ6NE52TEsra21GakhOY1MzY3NLTmJzd2hSNUlZNFl5UXZPeGZOazQvaFVBY25GZWFHOGFhMldOV1ljSGdtazhyZEJ0L2liaXBkU3hYS2R6NDkxSHcrdWt6emFPdWxUU2FqZFhBWWVWS3N0b29uM1JtUElDN1RHRkhQUHpQbFJ4WENGbVpOcmRldEtGWklXR1ZQSEM1emlrdFlwTXQ4b0lQcWFtV28wckgzdC93QUVMTkcwM1ZQSFhqNWRTdU5Rc3kybTI2UVRXeE9GZmZJM3pBRVpIeWpnOFYra3VnL0RlTzJ1SXI1N1BTN2k0dUhlR2RWQWFhU1BZM0RQejBBem4zR1BteVIrZGY4QXdRWDhEWFhqSHhuNDJGdkpKR2tVTnI1akx3UXBhVmlBY2pCTzNnam5QVEhXdjBsOE5lRHRROE1OYjMxOUpOY0xISjUveWd4eUQ1bVRCenlDcGNnRWdmYzVGZm5XZnhsTEd0dGFXWDVFYXNhbndzL3NlR0FyY1JyY3dRZVExektWM1FsZDRDcjgyM0hJQllaTzFjREdjaWZSdkJ6WGswbDg2WGR2ZUxBUmN6UnYrN2tYZmgxSVlrcmdGbSs4YzhkZUtaRjhRbmc4UTNGdnFFTFcwa2thUlc2M050NXJTS1cyK2FqY0RKWW5uUEp5Q0NlYW0wenh2WmVLN3U0dDUzV0xUOHJBVWI3MlF6a0t4NERBeGdnOERnNDV6aXZHa29KSlBib1ZlSWxycGtFZHpjUjM0VnJtQWViQ0M0WmwrVk5xN2lkd1VOMUlQM1N3R0JtcGRVMXl6aHNsbWtLdzNMS3F3QVJlWkV4TWlyc0dCbkIrWWtZSUpJNXprVnAzVnRwYWF0ZFhFa2Mxak5GRytZTFNQY0Q4bytSRjUrWWJuNEl6eWV1VFdackduK0h3TE9EVFdmN2Nrc3NieVNNdjJtVmxKUWhmWU9VakI3dHlCeG1yZFAzTkRTTHVRblJycnhubzl6YXRlV1p1SUk0N2lPWER3cUZPTWxzbkJCWXR3YzV5QlhoLzdXdmhtNThMZkRLMGh1cmhwTHh0VWhNaXFTeWpNRXA0OU1BcU9uSXhnbm12YzVmRGNtbGFsSGNHK2JDd3E3TVhHNVczbFAzZ0o0VmtkY0hHRHZYdjA4Vy9iTG11OVQrSDBVOXhieFA5bjFhR0I3MFkvd0JJSml1R1VENVI5MGVwNmJjY1ZyazhZckd3bEpXZC93QkdSVTAzV3AxUHd1c2RTYndkNGJFOEVLd3RwbHFGWklXa2xTSXhvUTVYSHpaQStVNEl6MXdPYTZIeENnMWEwdXBwSWI3Uk5MV1VZanVIWXZNVkFJQUsvS1BtNDJobUl4bm5JcmwvaGRvdHhhZUYvRDhqUGVSeE5wdGxjUnlSc1BzK1BKQllQbmc5Y01DUVJ1SE5kWHAybHcrS1lkMzJQVW50clVsd0VCaWhPU2NIeXcyVlBIR0FjbGdNSGJYUldnM09jSXgrMC9YY3pWTy91b29YZmg3VVROSkZwdm5EVmpDWkRGRElBWCtWR3h2MmtuakpKempBejFydHRPMHFUd3Q0S2p1ZFlsOGxtakxXOEFpZU1iTUV0dWNLZG9CUDkzUHlLTTlxN2I0QWZDK1RRdE12dGF2ck9QN1U2bVMxdkpuQ3pGV3lwQzRYQUJIeThxZU1uK0t1ODFUOXBTejhFejZUWjNPaTJkN3Ftc0VwRnAra3UxeGRrS2NGemxSbFJuR1RnQTV5Y0FrZXhnY2twOG50SzN1c3VNSVE2WFo0M2RlUGxnMUtONTQ5UnM3Tk5QVkZNc0VrZG5jUzd4TGd1SWpsemdBS0RqaklHUmtkcDRKOE9mRDNXcnpVTDdWTHJVRGIzYUY1L05qdUk0WkN4TzRLTm9LZ0VLZVRucDlLN1M0MUR4QnJuaUZyalV2Q21zK1hsSDA5SUd0UExzMTJmT1F5ejVMRW5HY1p3T01na0MzNGg4WFhQaEh3OU5kWEdrNmxicmJ4c1FzOXpieHJKZ0hnWmsrWThjWjU5U090ZTVoOG9wUWtwUzFYbUtWVHNZbDlwbnd6czN0YlBUVmlta3U0aml6aEVzazIwY2tqK1BQVTRCejlhNDM0amVBdEh1cnkyUzUwclhyeTV1R0VXMnlqdUZJUlNTTjdNdVZCK1Vkd08vcFd0YmY4TFAwWHh1MnZONGYwUFdHdWg1RmhiUTN5UnRaeE13YythN0Q1aUIzak9EM3p4aTlydnhrK0tHbVh0cEYvd3Iyem11Sm81SGs4dTVWNHh4aFFYM2ZMeU9UaHVDTytjMVh5bWxXVm5hT3ZSQ2pVYVZucWZsdi9BTUY2UEFHamVFL2czOFA1TlA4QURlcmFMZlI2emV3WEZ4T3p0YjNTaU9NcDVlNDU0QU9UdFhQdjFyOHZYY1NENWZYSkdLL1d6L2c0YThiZU92RzN3WDhHTDRxOEkydmg2MzAvWFpSRE5iWEt6UXp1OExBREk1UHlybnQ3Z0hGZmtxTFhrbmQzQjIxNkdEb3hvMDFUaHNnSVhaWXh1SGZrKzFReVhMTUI4dU1EcjYxWTFRc3lzdnl4c2VtTzlkWjhMUENWanJXaWFqTGNyYkM1YTZzN08za21tOHZ5RExKODBnRzRaQUNuSjV4a2RCbXVxTWJocWNMSTNQcWZTbzBsVjhqTzdubXZiZkYvdzI4TzZwcXVxYSt6WGsxa3NRdlpiUzFkSkpHRWwxTW9aUi9BaXhJdWM1MmxnZVJuUEkvQnJ3Y1QvYW1zM2xySC9aY05sY3d4VHpvcGlhNFpWalFjL3dBU3RLckQvZEpIUWtWN04zc0J3Z1RJMmxkMk0vZDcwVHhzSTlvK1ZXL0VuNjE3VmIvczJhWGVlTGJ6UnJkdGFXYlQ3bUtDNXVKZ2lKSUdrYk1rWXdjcVlrWXJ6eXhBNXpXWDRkK0VtbjYxbzBFTWNsMEk3eS9pZ25tOGhaakN5UU04b0RLaFlLSGRGT08yU1EyQmxxbXdja3p4K1dQN1BibnBqNmRUVVVjYzBoR2M0WS8vQUtzMTdUNHorRnRwcGZ3em5rYUh5N25TM3VMZ09teDJrVnJwTGRBN2dEY3VZNVNwR0J3ZldvZmhSNExUVWZEdmgrUzQwZUM2dDlWMWVWTG01bXQ4ckRhUkpINXJlWmo1QmlSanV5TWJEejJwcUR2WUR5UzFYZktqRXFuT0F6ZEI2bXZZYi94ZjRRdDdtNTg2YXgxSlk0b29iU1I3Um1WRWcwOTQxNnJuNTV5dkhRRlNlT0RWSFVQMmY0V3VZNHJlNHZKcmxiVk5RYUZJZUd0NU52bDRKSDN0MHNTazhnWlluRzBBNXZpcndwWS9EN3c3ZVcva0xmYWhkYW5kV2NjODZBR09DRW9vZFYvaFppemQrTnRWR05nSzN3YTFydzNwVmxjU2E1SGF6U2ZiSVdqam1nODArVXF5UElPaEh6TUkwNS92azhBWnJYMUxVUENzV21YazlxdWkzRjRzZHRickRMREtxcURiWWxaTUtQbVdVOVdQOEtuTERPWXJiNFFXK2szVSs2NCsxVHg2WTEzOW5sdGlBdTYyalpTY09DTVN5aFFlUmxPUWVSVVZ4OEhkUDA5dGVqa3Y3eWE4ME4vc3MwY2RyaGZ0Sm1FWVZTV3lWSURrY0EvTCtGVnFCc2ExcVBnVzh0THhMZjhBcytObDgxWVpVdFdWcEY4MkNOY2ZLTU1VV2FYbkdOd0hIU285VDFEd3haejNndExleDFHOFdKbHRJa2ljcExJOXlQTFVEQUp4Q0Rra1pPNEFrODVxWDN3SGoxRFVkU3VMZStodEk3VzR1b0VnU0JpcmlCNFlndzNPVGgybEFHVDk3Z2NIakE4WGZEMlR3bG9NK3B3NmtMaGJiVW5zVk1LQUZTck5zWnZteXBjS3pMd1FkcCtiSXhTMTdBV1BpZHAybFF6Mk5yYVJRMjBza2NNOTJ5QWcyN05ERUhqd2ZTUlpHMjl0K09DQ0IwR3NXdWsrRXJQVXRRMGRiZVpiRzN1NDRia1JGNHBZNUpZNFlVeXd3WmZLYVJ5ZXVHd2NFRURMMGY0T0JMdXptMWk2L3dCR1ZwWmJ1TlUrZGZLdFJkTWdPNForVWhUMHdXR004R3EvaHZRSS9pSGEzRFJ5UzI5bXVwV2xqYVdFSVpvMm1tSkFQTGtybFkyeWVUbGh5T0JUc0J3dHk4MS9jdExNN3UwcmwyWjJ5ekU4a2s5ejcwQ0FQRmhYOXMxM2ZpZjROdy8yNWRUd1g5blk2TGtTaVdSaXd0UkxMTXNTTWM3bStTSXZrWkpYR0FTUUt4dmgvd0REYTY4Y1EzTXEzVnZacmF6eFc3UEtEMWRYWWRCMkViRSt3SjdWbnlzTG93UW14R0gzdWNubW5JSXdRZHhKOU1mMXJwWVBoWHFNbHBZU3ROQ2sxOVBEYkNBSXpQdWxqODFQWW5hVXlNakJrVUVqbkZmeFQ0S3QvRG5oK0NaTHEzdnBKcis0dFVtaFk3WFNFUjhoU28rVW1UaHNuT0NNREZTNmJRUmwwTWVRckl1NzVsWWM1TklkcUhhc2Fqc0NmV3V3bCtCZDViUkI1TlYwbU8zanQ3ZVc0WjVXUmJmejRmTmlWaXlqNW1VT2NESitROXlBWWsrRTEzcDlzMXhlU1FsRmh1ZDhDeUdPU0tXS09NNFk3Q09HbWpCSGNobHlDTTBlemtWekk0NldWbHovQUJjNStsT1M1TTRPOC91aHlCNlYxbW8vQkRWckRUSkx4cnF5a2lqRWhLeFNNeGNvSVd3UGx4ejU4WStwd2NFak9ENDE4RzNQZ083anQ3eTRzWkxoOTRranQ1aEkwTEt4UXF3SDNXQlg4cWh4YTFaVnpMZWRrbVh5NCtNNUo2L25VeXl5Ti9FbzllZjZWVnQzNVg1K0cvV3JVVnNKVG41aU1qUHVhUUg2V2Y4QUJ2aFpKZDZsOFNJMnR0UnZiaG9iU1JJclFCbUtLSnMvSmdzM3pNbjNRY2M5OFYrbWwzOFl0SmEvaHNkV3RQRm5oM3liZWFJRy93Qkp1SW9pakJkc205MEFHMXkyTURqUEoyZ2dmQmYvQUFic2ZDbXo4VS9CYjRzYThzaXgrSk5IdnJMK3ltTXlSNzJFTndTaERmZVVrcUNNanAxelg2dWZEencxQjhTdkJlaWFsZWFwNGdodXJpMFJya1dtcHp4UkpKdEc5ZGtiQUpoczlEK21LOG5FWmJDdFZiazlXRWEzS2ZQdWxXZW4rTzU1clZkZTBYVlBMazNlV0xrU01TckFydENjRmhzQktFRE9Pb3hnOUJQOEQ5TnROR3VycHBOUGltV3hNMGhzMGNTUmo1eWpJUG13eFlrQU55RlE5RFhybmlIOW1Ydy9mWGpTUzZ2ckZxOHpESG1YWG5Iek1IRDdwUVhIZm93ejZqQXBQaDc4UDlMMG5XSkxIVnRjdmwxaXp0RldlS085MndtRXNSSEtwRzF0dnlzdnpaeGc5Z0RYaDFzaGs2dkpLTjQ5SHArVzRlMGkraDg5Mi9odVN4MDhYTm5mUjZnMFlTTWtSNElWdnZBakpJUFVra0FoVzc0Rlo2K0JJN3J6WTRyL0FGVnJ1YWZiSjVVWVZvV0lERmlqRXB5QnlTRnp5QzNHQjlYM2ZncndySnBVVFI2NXBzZHFDemVaSzhFd21HT3BrY0YrQ2M4TVBUdlhtUHhjOGJ4ZUdkY3N0T3NOUThOMzFqSmV4dTk3Y1hFYzY2ZERodHc4dEc4MFlZQWdqQUg5N0lBcVo1QXFlaWVuNEZSbFR0c2VSMkhoelM5QnU5V3M1YmRtdkFpeWJ6Q3k3a3puRzBIQVE3VzU1eVd4azE0MysxK0xWdmhGWVNXN1NLWnRWaHdKQjh3Vllad01rODV3UU1FNTRyOUFKUGc5L3dBSkRvSzNkdForR2RhYVNNU1F6T1pvVWw0SU9HektRcHpuSXlPVHdUWHg5L3dVZCtHV3QrRC9BSUtXTXVzYVBiMi8vRlFReDJ0NGw0dHh2amFDNUpqK1ZFYkFJR0N5WndCbGlhckRaRFVvNGlGV1RUU2ZUME0zeXk2bEQ0VTIweStCZkM5OXFXcFhsdnBrZWx3cmJ4eFc1dUd1Mzh0VTh2YW96OHBjbnJraGNIZ2l2WFBDdmdQNGtYZmlPSFZQRCtuYUcrazZpcGE1L3Q2VHlNdHNJUUNPTkhMY1k2N01Eam50Yy9acCtFZXRheDhLUEJlc1hYaWlmVDFYUmJFMjBkbzhiR0tQN01nUWp6RWJZMk1mY3h5RDF5YzVmai80cmFaNEx1TGpSZFA4VGVJL0VtcldOd3MxdzF4SThqTVdVaFl1RVZCdXlSOHE4bkk1SzdUNm45bjBzTW5XcTkyN2RkV0MxZG9IYnQ4Ty9pVnFXcHRGRHJPbFNTd3BIRWROMHFWbzRkUEhBWGRKc1hhTVpiRzNjUU9BY2l2Vy9BMzdOV2tlRGJxUy9XKzFDYS91SWxqbm0rUkdmQlp1b1hkamN4SUdjRDA2NXIvQVBSUnBQdzAwOUw2RyswbWFSbXVMeHA3aG9aSlpqeSs3bko1NHkyQ0FvcnJkVThXYVA0YjBLOHZyclZJMHNiU0V6eXppOE1tRUFMRS9LYzlPYTlpamhhYnRWVjcrWm01UFpuT2ExOE83N3c5ZlF6UStKdFMreVNrS2xrOW5CTkl6ZXFOc0REanJ1eUJ5U1FPbUxxWDdNK24rUFBzOTU0dmFmV2RRaEtTRkV1WkliV0JsT1FxSXUzSVBBSWJPY2RBRFVPaS9CbXorTjNpZFBGbXZMcnphWEpiR0xTOUt2THgxVVJQeTAwaUFLVlp4akNNVzJqT2VUdFh0UERmd3M4TCtEcHBFMHVHNHNmUCs4STd1ZFEzNGJzVnY3T0Z0U1N3L2hTM3ZsMnh0Y0syQWhlSUw4dVBxQ00vbWE4MjhUWGV0ZUl2RkYxNGE4RCtJcHIvV3RGbGdHcXk2bGJ3Tlo2YWpuY1ZZeElqdEk2ZzRWYzR4enQ2MTF2eE4rSFUzaXpTNGJYUS9FV3NlR1pJNTBhUzl0NVpKMllja3hoWGNyazVCM2JUakh2WEtlQ3YyUUxQd3pwK3JSWFhqUHhocUUyc2FnMTllUGIzSXRaSjJaQW1IOHRkekFLb0hMWUhKN2sxVXBLV2lBK0lQK0RsajRZTjRTL1lqOElYRW1xWGVvUEg0c1h6RE9GQ2xwTGE0SjJxQjhxZ3JnREp3T3BKNXI4TXBkeWNqNVdia0E4YmhtdjN2L3dDRGs3NGIyT2pmOEU3dEhuZ2E0a25zdkZWbWdsdTU1SnBpaGd1VjI3cEdKeDA5cS9BcVlnVGJWWnZsQnlUMnFJeDZJcU94QkpKKzgzRXNwN0RQV3BwcnVRSVdYTzF1RG50VmVYby96QnVPQ1QwcHJ6bFkvbFhkeDYxWEthY3hJMm90SStOM2JBSU9NMFcrcHpSd05HZmw5QUtyd3lLaFZuVnhqc0JuUC82cWt0OXJxWDh0c1p3QlJxVmU1WVhXSGhHU3paYmtqSi9Xb1p0VmxnNEUzeXRrNHpUYm1JbE55cUNEeDh4em1vV1JyZFYrWEdPUmtaOS84NXF0U1pFbHhyTXBqK1ozTVpJd01uQTlQNjArUHhGTUlCQ3MwdmxyeUUzSGJuMHhWUmR5Ui9OeXJjQUQ5S2dtVGJLQnVYOEQxb0pPZ3RmRitvcVljWDExSDVhZVV1SlcrVmNnN1J6d01qT0JVbmpQeHhjZUpieU5wUEl0MXRVS1JSUUxzalhMRjI0OVN6TWVUN2RBSzVuejJ6dFZsNE9LZEZ6UDh6TnRZNUpQUDRWWE13TmVUeGJxRHpUU3lYbHcwc3lDT1ZpN0V5SUNNS1QzQTJyeC9zajBxMWUvRVBXcjZaNXB0V3YzTWhqWnZNblptWW9TVXp6L0FBODQ5TW4xckNlRm1iNWpubmpiMjRwaXlBdXE4bnNQYWptWUd6L3dtK3JJUE1Pb1h2bWJpMi96MkRFN3hJU2YrQmpkOVFENzFGZWVMOVExcXpTM3V0UXVicTNqazgxRWVVc3F0eVNRQ2VwSlk1OTZ5M1VzMjNucnRCOUtxelFORXpmMEZDYkE3ci9oYlY3ZWVIcmkxdUpKTHE0a2hOdEhkelN5U1NRUUVLREdvM2JSa0lCbkdjRWpwakdOby9pdlU5QnRmTDAvVUxtMWpTNFM1QWljcnRsVElSK0Q5NWNuQjdackh0ZzBjVzZOZUJqSVk5YWtrdlJBMjBlMzQvV2ptWUc0L2o3V1gwK2EyazFHYVMydVlJcmVXSnp1VmtpR0VVQTlOdVRqSFRKOVRWYlFmSG1wZUhVWmRQdUpMZE54YjVEL0FCR05veWZyc2R4N0JqV09adGpOdS9pNXdlOUFIMm91Vlg3dkpJNlZmcUIyay94cThRS2x1cmFndHpIRUNzYXRERzZnR0pZVGtFYy9JcXJrODQrcHJKMVh4ZmZlSUxXMnQ3bWJkRFp2SkpIR0ZDcXJPY3VlUFUveXgwckR0WWxqbGJPZWVnSDNSVW55MnJuanpPd1hQcjNwU2xjRHFQOEFoYWVxeXg2aGIzRTBjOXZxMGtVbDVHOFNQdk1ZS29WeVBsS3F6QUZjWUJJNmNWci9BQkQrT1Y5NHQxS2VTRm5zN2U0dDViZVVTaEpIbVdXZnozTEZWVlF4WUp5cXJrSU01SkpQQktpdk0zWHJ4ejFxVVROT05yTDh1TnVmUTFMcU5Ld2RUbzVmakhyVUZ0TkdMcUxiY0t5dXF3cW9BYVpKbXh4OHVYampQR01CUU9uRlpIaWZ4aGRlTk5ldXRRdmt0bXU3dGpKSjVNQ1JLeEp5V3dnQXlTU1NjYzVyS250SXk3YnQzMHhSRFBzTzFmbFpmbDNDb2xObHZRY2JObG01K3E0N1ZNck1wWEVuYzU0cU5MaG9KdHJIcVFldFNRcElMcFFmdTlDYzlPOVFMbVAyeS80TmlmQnVvYTcreng4U3J5MldGSWhyVUVaWjVHUmdWdDkyQnRCejk3dm5yME5mb0lzWGlMOW1MVnJuV3JYVExmV1BDL2lDL1diVkZGeCs5MHlSa1dQekl5ZVBMWmxqeW9Bd3hKemc4ZkYvL0JyaHA4MC83SmZqeVczdXRPamtQaWJCaWtnTXNtQmJSZ053NjRVNUk2ZGp6WDZYZUwvQ1Y1NG44SFh1a3MrbnQvYVZyTGF6RXhNRVVPaFVNb3kzVElPRDZkUlV5bys5enJjemx1THF1cWFoZnBieVdNRnJkVzBoeXpmYW1qemdIZ2ZJY2pJeG5pdlAvaWw0VHV0WThSV04xRDRUMGZVSnJkd3ozMGswUG1SODU2T0J1VmNrNFk5Y0VMbmthWHc5dE5mK0EzdzBzZFA4VDZsSDR1OGlWYmMzOXBaaTBhSU93Q21SQ3pMdEJZbG4zQUtPMkJYb2M0WXFOMGNMUlBqaG5KQituQi95YXV0UzVsWVVYWThoOE8rT3ZEZmdrUldQaUxRdEswQzRrdm1pMDV6QXJ4MzRHRzNxMGFrSzN6SDVTYzlEM3IwRFh2Q1BoejRpNmNmdDJsMjE5RmNJMFlGeGFsWk5wR0R3eWhsejdZck4rTnZnOWZHUHcrdW9IMCtaN3l4SXZkT2Uxa1ZwTGE2ajVpZE4yT2M4WS9pQkk1emc4Myt5djhUTlc4ZS9DTzF1dkZ0bThIaUt3bGt0THBHajIzQmVOaXVYajRNYkhIM1d3VDE2TUt5OWltdVNlbytZOHErS0NhdCt5VjhaUERVdWkzMGx4NEQxbmZIY2FUSmR5K1phVGYzVUlZRHl5R0cwTVRoZ004Wnp6WC9CWFZMVFZ2MlcvRHVyV1dvM0U4Tjk0aXRaRmprbjg1VVY3UzdZWUdUZzhIb2ZYMnI2NU0xajRpdEZqMUN4RExHUnhjMlpDazU5R0JINm12ZzcvZ3FkOEo0ZkFIZzYzMURSTHEzT2lYbXRReHoyQm5jdllYSDJlZmFJNHlkcXhNaU1RTURCempnMUhzNVE5MXIzUVZub2U5ZkJpNDhMNmI4Qy9obG83YWZlYWhxM2lIdzFweXl4cGNPb2hUN0xHWGxaaS83dFFDeEJRWnlNRG5BcnMvQTN3cCtFL2hEVjRiNjIvc0hVZGV0SFNGcjY4bWp1OVFqa3h0WGRJeExxMkZBSFE4ZXRmUGY3TEdpM1h4L3UvQmV2WHR2SkI0YjhEZUg5TzB5Q0pyZHpIcUZ6RGJLQzdQbll3VmlUakRINVZCQ2pCZjZML3dDRmMrRlhrYStiUi9EOXhjS3lFem0wajg5WDQybmNCbmdnWXh6N2l0NHg1MXpOZWdiYkhhZUpmRFhoWHhSRkQvYWR2cGQxR0ZLbzF4SEhJamc5Ujh3SU9lSzh0K1AvQUljMEcwOER5YUQ0TzhQK0ZiN1VmRUpPbi9aa3RnSXZMR0F4SmhIeXNtNVNDeEMrcEdhcytQdjJndkRQdzNlNFNiV2JXUytzOHExdXMrU0NOcEtuak9jTU8zUmdRRHhXdjhQTkNYV0gwdnhGcU5rOCt2UHVsa2Q0VGJDMUVtUUZDTVNOeXB0VXY5NWdPdU1pcXFXYTVZaHk2WE9mOEVmc1FRNlhiUnphcjQ0OGVhbmZZVXpiZFROdGJzY2tnS0FDK0IwNWJrZmxYb1YvOEovRE50cGZtWHlYSGwybVEwc21vWEROeU1FYnQrVG5wakp6bjZWMVVWMTlwVlkrSWlweW9ZS1FEMjZIakZlVS90TGVJL0QzaU1hWDhQdFoxQjRkUThTVHBkcXRzV1dSWUxkMW5lVEtqZ0hZRXo2dm50bXE5bXRrU2R2OEx2QTBQZzZ6dUNyWEVqWGtobTJYTXpTTkFwNkprOGNBZHUvYzlUMHY5dFc5b3U2NG10NGNrN2Q3aGVCeC9VZm5YbFdzK00vQ2VuV3EybXM2bG9kcEczQ0plWFNJb1BRY1NOa25COS82VnlldS9GLzRaK0IxaSswNmw0UWhWZ1RiRVhjTVpZNStiQUdBRDE0QkordmJhT0hzcklubVBuNy9BSU9QL0VXaitJditDY04xYjIrb1djbDMvd0FKTFplV0VrQllzZ2xEY1p6d0NlYS9uaXU3SmZ0Y2tZWnBHN0JmWDNyOXF2OEFndFo4U3ZEL0FNWXYyVlBFbHpwTjlhWHk2TGM2ZkphTkNqWWxFc2pBc2pNQUd3QVZPM09NSHBtdnh3dGRKQ1JzMkdXUmh6ODNKcVZUOTZ4cEhZd2YrRWF2TU44eU1wSHJ6U3JwZDFiamtCVkE1Sk9UVzNOcGdMYnZ0VTJUaitMbXFldTZhMXBhN2x1SnQwakJRcE5hZXpSUm13Mmx4Yy9kVlF2T0NlcHBaYlNTUGF1NWQzWGFRU1RXbjlqU0lLalN2OVNhSjlPa1czMnh6dEhuMVBEZlg2Vk1xWTA3R081OHlJeDdtM0hvUjJxQXZjWEV6ZnUyZjVRZ0lIVGoxclZzZEJsa3V2TGVTUUwxWnY3eDlCV29mRFgyY2JVbWtDbnJqSFA2VktoY0c3bkwzV215bFZSVmRtSEpQYmtWZDhHZURwUEVmamJTZEprRndzZXBYTWR1WGpIenB1WUx4bjB6bXRiVU5HK3oya2pmYUdXUlJuTEhPTVYwZndaMUMxOEMrSzlQMTNVaGNYc2tDTkpGRkZLSXdISy9LU1NyZE01eGp0VktObUk1L1J2aFBiMzgzaXE4WnRRdU5LOE1mTUJDbzgrNkRUQ05PU0NGNjdpY0hHTVk1cXg0aStDTjVwM3hMWFJiZVNkYk9TRzF1SHVKNC9tdDFuUkdWR0F4bVFGOXVPTWtFOERKSFNlQnRhdC9DbW95M2QxZGFzV3pnaXp1aGIrYkdmNEhZS1R5Y2NqOHU5Ym1rZkgyV3k4ZmYyMXFrTnRlYWZIZHJmdFpyYnhCaVVBV05FZDFabENxcXFNSE9CMXlTYXJsaXlmZVBQNzc0WDJtaFhuaVM1dXJ5NWJSZkQrcGYyYkZKR29FbDlNV2ZBSFpSdFJtSjV4d01jNUdYOFRQQUVudzQ4WVM2WWtqWFVRamh1WXBXVERNa3NheUxrY2dNQTR5UFd1MjBMNGo2VjR1OExYMm42L3A5NTlsdU5ZWFdJbnMxamhNbnlNaGpaY1lYY0NEdVVjSFBEWnJKOGVlTjdqeG40MnU5WWt0VmphU1pUSENvSGx3b3VGUkFEMUNxQXZQcFQ5bXJXQmFuQS9ZNUJHVzJNdTcxL2lQdFUzaG5RNXZFM2lLeDA3ekhoYTl1RXR3eXgrWVF6SEErWEl6ejJ6WGVhOThSZFMxalJwTGU1czdQeVdBM3VtbjI4YjR5RHd5cUNPUjJOSHdiMUhUUERIeEp0dFkxYUc0UzMwK1g3VEdrTWF5U1NPb3lnd3pLQUEyRDE3VWxUN0RNWFNmaFo1dXJlSmc5L2pTL0RJZHJtNlNIZTBpK2FJazJwdXhsbVlIbHNBWjU0d1lQRXZ3bXZkSjhZMnVtMmtxM1VkMWFRMzBjenI1WVdHVkE0WnhrN2NBNEl5ZWVCa2tBOWo0RjhSMmZoYTh2cHJuVXRVMDJPOCtXZExheWpuKzF4RTVJWU00R2NnZFEzcld4YmZIalNkZCtJLzlwYTVwNnBvalhVRXJxWW1tdUZnZ0FXT01IY2dZN1Y3OEZpVGc5S3IyUzNRdVpubnR4OEZudHZIdXU2UGNha25rK0hvNUh1cm1PSXZuYXlvUXFaeWN1d1VjKzlZbDlhMmVtWGNrZG5QTmRXNmdCWGFEeVdjNDV5dVRqQnlPdGVpK0dQR3RycW5pdld0V2JYTlEwTmRXdkROS2xqYU1XbmozN3VmM2d3eFlic0VrWjV6eFdQOEFFWHhUYStNL0hPcTZuQmEvWVlieTRhUkkrcFVIZ1p3T1R4a2tEazVxZlpxd1Jad3M4NjVYNWM3bXhudlRtOHFlTTdXd3dPQjc0clExaDRrdE1GZTQ1MjhFWnJRc2RkMCtOTnFOdDJkZ25GWnlnVVlNa2JJeUh5M1g1Y0ZzZFRVWVpUTGtsbDNkc2ZnSzZyL2hKb1hnQTI1OU1qOWE1L1ZOY1NYVjJZcXFxZzJoZHZYMStwcWVVQ2pMZDVPMzVtN2NjMDJHU05KaWZMK2JnYzlEVzVKR2trZi9BQjdTZk12OE1aNHpWT0sydDVXZFhhUnBNSEg3cytsVjdPd0ZhS1FTM2Z6aGNaejZnVmJsOHBYMnh5ZWN2OFI1QUhTalNkTVRHSkNxdDBYZHczK2VhMkxUUklHaytZZ2hqeVJXWHMyVkUvWEQvZzNNMUh4cDhOUGhocW5pKzBzUHRuZ1NiVWJ5dzFYYStaVW1TR0NWSFZPNEhBM0RPQy9PRjVyOVpQRi94RThUNlRwMXJkYVA0UGJVMm5WUXluVklZeWlrZFFHSURjK2g1RmZueC93YjMrRjJ1ZjhBZ24zZGZaSkxTV0c0OFZYclN3WExPc2NzWWp0USs3Ym4wd0FWSTYrOWZSL2diOXBEeG44Ti9pWEQ4TmZFZmd5NmxaWXlkQzFTeXVZbnRXc2tjSWdrTE11MTBRQUhkOHgvdW5xZWxVNzZHRXR6M1RVL2lQcW1wNkhjMmVzZUNkU2hodXJXVkovOUpnbVRsRDhoVlgzTm5rZktEMnJ6L3dEWUwvYURrK0p2d1hheDFxNnVianhGNGV1cExHNmhOdUZrMkpnUnNFd01BcVJ3ZWMxMDNpYnh4NG8wWFMvUHRkTjArK2h5ZDRPb2kzazM1KzZvYVBibmdqays5ZVUrTS9FMTk0UDhheStQSS9odDR2c2RlMHl6ZUMrWFNIZ3Y3WFc0V0tqTFJSTnZhUk1LNGNLR3doVG5naWVSM0Z6SDB4L3dsMXV0eXNNMXRlS3N5N2xkNHRzZlVjSG5yejZkSzhBL2FGK0xtbmZBSDlvWHdocU5qZlNMZCtOTlVnMHZWTk1VNGl1VlpTa2R5b0tqRHFkcWxza01NQTR3RFhvM3dTK0l0LzhBdEFmQ25SZkZVV25McHNPc3dyZFFXazkwUis1ZGQ2RjhJd3lWS05qSEc3bkJHS3MvR0Q0R2Y4TFg4QzNHbTNVZG5IZk11YmE1akFhVFRaUmdwSkdTZ3pobEdSZ1pBNlZqVWhiVkZSMTNPc2c4VXhTUjRuUDdySDMxQkk5ajh2dFh5SC93V0dhM3ZmZ2Jvcy8ramZhVThRUUpHelI3WmhHYmE2SkJKQU9NZ2NlbzlhOTArRW1xZUtOWnVMZlJmRTNoSFVMSFZ0TnNvcEx2VUV1b1d0SjJJS3E2Yld6bHlrbVZHZG9BM1kzQVY0VC9BTUZjTGU1aC9adzBYenJTNmhMZUpvTW1SVlljV3QzajVsUE9jbnI2ZFQycHl1S3g2NSt6RjhEUERnL1o3K0hsOUcyc1djMG1oV0Y0eVd1clhWdkRMTEpiUnM3TkdyaEd5eEpPUi9JVjZaRDhQUERXbVdkeDVVWXUwdW1MeXJjM0VsMEpDZVNBSkdiZzhmS09PT0FLNFg5bW53SkRMK3p4OE83dVM3MWE0OHp3MXByZVFMeDBpQk5ySG43dURnWjZaeGl1MytJVDZYNE04RjZycTJvU1hUMjFwYXZLMGFYTXU5c0lma1hEQTVPY1l6MW9kckdpVmp3clFmZ2Q0VC9hYStOMG12YUxwSDlpK0dmRE15UVhOeGE3N2Q5WXZJOEh5Z29PMk5JU3NmSzRPN09PUjh2MEZaZUI3TFIyaGhpVzhqa0IzSE4vTEk0N0RjV2t5UVQ3WTlSM3I1OC9ZNXUvR1ZwOEc5UHVMNlRUN0hUTHBHWFNiS3haaEhERVdMZWRNN2ZNODdNelpQM2VNdGtrNDdUeGY0VjhUNm5wck5ENDAxcXptdUJscDQ0clllU01EN29NV1dQSGZrODg5cWRPZ3ZpUkVwSG92aS9VN0x3NjFyRjVxU2FscTBqV2xpaW45NTV4RE1YM1pJQVJWWWtrZndnRG5BcG1sL0JIUjU5ZXQ5YTFIUzlMMVR4RmEyZ3NmN1V1YmRXdkNtUG13eEdWUXRrN0FRUHJYeTk0azBiNHBhTDhRL0ROamY4QXhBajFiV0xpMXZZbWVMUmpISERwek1nZWFVb3lwdkRHSlZJQ2tzNEdRQms5MzRZK0VVMmpzaXY0eThmWGtNTXh1dHo2cVk0d3pBcXd5aUtjWnljRnNET2ZTcXB3dmR2OGhYUFg3NzRSZUV3SnBSNFc4Ti9haGxoS05PaFF5a0RISks1OXMvclh5UjhaUGhOOEtmMmpmMm10RzhCK0dmQzJoTnFtbDNYOXArS0wrd0F0RnNyU0I5a2tYeVlTU1IzYlljZ25PZW1NajFyNDArSUxId0Q4SXZFVjUvYXV1V2tpSVVqY2FuY1RYVnhLeEFVSUpIMms3dG9HQWVDY2RUVlg5aDc5a0RTL2hEOEx0UDFqVU5MVmZIV3ZXbjJyeEhmWGhNdDg4OGhNcnhzeDRRQm1JS0RBNFBVa210V3JDaWVhZjhGNE5KYTkvd0NDYnZqTHkxVzN0NFp0UGxRQWpjd0Z6R29Bd2NBQUgzNllHTVYvUFJJalFTTkdKSkN6Zkxrbk9LL29YLzRMUitCbzMvNEovd0RqcG80ZExiOXpheVJTSEJsUWZhb2h1UTRKSjVJSnlPUHJYOC83YUEwTWhEVEE1UEpDOWZ4b2p1N0drZGpCbW1rdGZsM2xtWHF6WU9LanRKcEx1Um1abG1LdGdZNkRnWnhVbXAyVWsxOUpic2lpTEdmTXowL0NwTkowMGFmQXlmdkdWVHVKSndRVFE3c29iZVdaVi9sWmp6NlZVdUo3aUVNek1IVmVlQjJxM3FsMUpFVU1TckltTXNPaEI5UGVuYUpDMThGdXBGUllXeU5qRDA0cW8zMkFiWTZaZVRSR1dTVFkwZ0d3NHlCazlEVmllejFDMGxINzZObDlkdGJhWGNhUUJkaEtqazU3VTU3dHBJdzJPQm5nMDFDMnhQTWN6cjJtYWxKWnpKOW90OENNeU1OdkxLQnVPUHdGUXc2NVBieHdnV1RTYlZ4Z3VPbGFOejRqZVc0a2loVm8xbVFveWdBczY1eWNrOUJ3UHI5S3BzcFZ2dXNoSHIycFJpdzVoSk5jMnh0NWxuT2R3L2hJSXpXWHJHcnRmMmZrcmJ6UXRJUm41YzRBNjFyd1crRWw4eGZtWUFJQU9oeVA2WnJMVkdXOWxrbUhreHJoSWcvQVByUktLQlM3bHFUVllMQ3hpV0pYVWhRZ1hIM2NWTytzUW9xcVVrbFp1U1F0VkhNYyszYTBlQWUzU25TT1dYSHlydDQ2MHJCekRyM1hyZTRpbFh6QkRKdDRSbEkvR25RYW5iUkx6Y1JsZ0JrKzlaOGtVY2VvckkwYXplWW1EK0ZXcmJSN0c1TGJ2TGpYT1Q4dWNudFRHelFsMSszZUZjeVE3Vis2ZDFVOVZraGJUcEdabzl2WDFIV3EwM2g2eGdsNjdsM0U1QU9QeXFucTFxc1Y3QmFxMGJSdXhYY293RGlrbmNFN212WnpSTWZra1VLb3hrSGlyREZSeDk3cDlLelA3S2hEZmQzci9kUEdSVGJ2UTRad3plU1lZNDJ3ckljY25tbUxtTHVzUEdOUG04eGtJMm5PZlh0UmF4VzhjSytTc1hRY3FPMkt4YnZSRWkrWldrWlFkelpQQkhldWloMU96V0FlVkpHb1lZQUJ4VThyWWMxaXVZSXdRWk5uSjROVWZFa1Zxb2hmY3JDT1JkNTI0eVBZL1d0cDdtTzRUL1dSczJNY0VISHBXSDQzc3hIcHNFZzJ0dWJISFVpcDltVWRGYTYxYTMxdHNqbWpiY0IwT01jVStLeSswekx0OHRtQTdFWng2MXpla1hsbEZBdktSc3d6eVA2MWZ0cjJ6bHUyR1kzR1BTcTVRRytJZ2xyNHFzWkVkY3pGVjNBOERuRmRsWjJBVmR6YldDOGpGY0xyMDhjc08xWVBMWlNHRGZ3NEhPUDgrbGRUSGR4M1ZwRDVhN3NnWkdUeWNldWFtTVFQMisvNElYZU5yRHdsK3hEYUxkV21vTXk2M2UzS05IdDhyUHlENWlXQkdObWVjQTQ5c1Y5ZC9FRHhYYStJcktEV3JUU2I2YlcvRDh5UVdLcmNRZmFIam5ZSmNLQ2VDQXVKTnBKTEdKQU9lRCtlUC9CSXo5b2U4OEsvc3k2SjRUaytHL2lyWExPNHZiZ3JxMm1sV2hReVNIZU1NQU1qZHo4NHpqUGJqN3hpc28vRFZoYjNrb2toc0ZEZWVsekd6dmF4TVNITENQY1FjS0czYzQvdll4aldVYkdNbTduZDZEcDJ0VHBZNmhZNmZKRFozaWVmS3NtenpjdHpnZ3Y4cFBCSzlRZU1Ea1ZwSmIrSko5TmttaXQ3VXV5bG8wYUhCR1RrWjJNY2xmcitQY2VRL3NBZkZ4dGUxbjRpZUM3dldMWFhML3dQcjhra04vR1NQdE5wZWcza09SdVBLK2E2ZTIwQ3ZwSVhWcmFiRnVHdDdkMlZtQlJsQUlYditYZjJyT1NkN01rK2N2aEw0OG0vWlYvYUV1L2g3ZldraWVGZkZFQjFqUkdqdHlzbHN3WEU4WkhKZkRMd0J5Rks5YTl0MHo5b2Z3N2Q2emRXYS8ydXNrREFIZHBWeXl2bkErUmhIZzhucG5QSHBYRS90aytEL0Uycy9EM1R2RlhnUzhYL0FJU2p3VGN0cVZ0QklSczFXRmhzdUxZbnJsa3lSZ2o1bFVlNDBQZ2w4Yk5KK052aG14MVRUUmZlZTF1alhZaHRKbWdpbDI1ZU1TaGRoSWJqQU9lS2psdWkyN0hVZVA4QTRsUTZGNFV1dkV0bkRQZXlhSEM5elBDOXRKQTBsb0NES0YzZ2ZNQkh1SHFWQTREWnI1VC9BT0NwbnhjMGo0dS9zZytHZFMwVmRTbHNMenhKYnp4M1QyN0xESVBzdDJNS3hHRHpuOGpYMC9mK1BOQlRYcE5IdnZFRnZhWDZ3aVFXNW04cVVvY241a1ByejFHYStDditDbE1XbytCTFdMd3pEcVVVL2cvVUwyMjFUU0xVUHUreEZJWjQyUWpxb3hLdXorOHVCMVEwbkJKWFlKM1BxejRLL0U3eGRvWHdDK0hkdHAvZ2xkYXM0ZkRHbUVUUTZ2RkZJdyt6UkFZU1FLT25KeS9Yam12THZqNzhRUEduN1YxNUQ0RDBQUTRkRjhQMjl5UjRrdlp0VEF5WXlHTnJISkdPZHd3U3lnNDlNOFZxNlIrMGZvL2hIOW4zNForRXRQMWpTLzhBaExkYjBQVExLMmhSMmtleXpZeHRKUEtCOTBSeHF6YlNlU3FqdlhaZUNQRHVqK0NmREZuWTZaZTZQWXJib1FXbG5qdUpybVFrdEk4ak93TzltT1RrL01TVDYxbFV1dmRScWJXbjZENGlmUmJheDAySFFiZXowNVBLdGJTSjNaWWt5Qmdnb0N1QTNVbkpJNm11YStJdmpQeEY0TDBhNDFDSFNyWHhkTmJRbHBiS3l2UExhWUwxeDVnVmRvQTR3M1VZNUp4V3ZvdW1YMDJyTjVWN3A4ZTVTc3JHUkZqQ2NGbENMa0JpT2VHQkE1cmtmR2oyUHhLMVdPd2tuMHVidzdwOFhtMzZ4eXJKSGR3c0hWWWlFK1VJWkFNNElKQ055YzRyU0ZTVXRrWjh0anpUNGJmRzM0ci9BQklzZFU4VFdmaHF3dDQ5YmtXUFJKTmNDUnlSNmZnRlYySXZtN2Q0TGZ3aGlBY3NOcE92cU91L0hTN3QyaXRiandEWXdyKzdsdUlwWlpQUC92T2Q4YnFTY0hBNEhUcDI5ZDAzVk5DbWlXTzFtMDNTN096UmJaSWxhTGFnQUNvbzRHd0hHQXVTY0wyNkdsOFF0WS80Ulh3bzE1Y1RORGEya243NDJVWVl1aEpDS3VjN205aDFKd3VHeFhaRnRJelBuLzRnK04vRTNoSDRsZkRpL3dER24vQ1A2aGIvQU51dk5CcFdrUXp5WCtxU3hXOHhqZG9vNDlyQkpRamJVMjg0T09NajJyVmYyeDlVc2JXM3UyK0cvd0FVSS9QZlpFaDBadkxZNTVZcHU4d2R6eU9nN1Y2ZDhGZmhDdmhmL2lmK0pwSXB2R1d1UlpuSmpRblQ0dXEyNllHRlZGeHVPVHZmY2NuNWNkZGM2dGE2NXBjOEZxbHhJc2NtNlB5bEcwOTkyY2NIQTQ2L2pVOHpmUUQ0ZC80S04vSGlQNGhmc0plT3JlODA3eEpiMzJvYVlER0o5RXU0NG93azZOODdQR3FSa0JPb1poejFKcjhNTG5XSVl0UWpqMnpNemt1RGpBWEh2WDlDSC9CVm03MC9TUDJNUGlNc2x4YjJxeTZMTEhGSE9Rc2hjOUIweVNUMDl5YS9uYU55ZDhqRnUyTWVuZW5GYW1rWmFDbUZtbG1rWjEzT3pPMk9lVHp4Uy9abTJNZitlZy9pT2MxQWJoWTgvdkc1NUhIVDF6U0xxQ3hmTkcvekx6a2M4MXB5b3JtSyt1MmM2V2plWEd2bU9kb0NISUdlTTQrbGJja2NjVUNLc2pmdTBBQUMvS08zU3M2RFVmdFZ6dTNmS2crWVpIek42MVlXOWJ6NC93QjJyQlRrOGZlejNOUVNYNDBXVFRYUkkxZVJpTXlGVHVVVlJkWTJIN3U0WDVPU0pNcnRxNmJ3dkN5eHgrV1dBNURkQlZPYU5kck5KSTI1UjFBNjRwdFdLNVRKMHU1VzV1TDJWdHFoV0VhNEc0WUhKTlhJL0xaSkc1Wmdvd01kRFVQZ2lWV2p2SFlmNng4REhwL25GYmtkdjV2M3NrWnp0cW83RW1MdFpuMnFweXg1OVJXVHJEeGEzcmx0WnliZ3NiYnBzOERBN1pydkh0aElUNWFsVEhnZ0ExbGEvcEExRTJxZVh0SmJjN0FmTndNa1o3VXBhZ0g5bTJseEI1Y2NkczBLSGdJQWNWUTFMdzdaM3dDckI1YmRBVlVqL3dEWFZ1eDBlR3lsWFpHeXJuT1F4L1dyRjFISkhJR1U0T00vZXpnZjU3VlhLQnpGMTRIR253U1hLM0xmTGw5cEhBOWVLdXg2U2lZV1RPVUErOXhqOE8xWGJpUnphTXJZWlc1d1QrZGMvTHI3Q1dSZm01TzFRb3lXT2NBVmxLT3VvR3hOcFNrRDVvU3JkT3Z5MVZYU0xPYTY4eVJENWlLY0VFOFZIcWQxcUdoeUt0L2EzTm03TmdHUk1LVGpKQVBUT08zYjJxdkpyVE9xbmZ3M1FranBTanl2VkZTaTFvelYwYXlndnRQdG1aV1ppbVdPZVdxeGNhYmJ0MGo2Y2ZlSno2NUdhd3RQMTVyWlBKU1JYRWZUNWM0SHBtcHBOZmtsaFhvcFU4SG9UV25JaVNieExvOFVXa1A1TE5GS2k3bUhJM0R1S3A2TXFycGtFZmx4NHdlU01rNW8xSFZwZFR0MlNSaGhoaGowSUZWYlNmekxYeXZNSThsdHB4eG4wclBsR21hejZLa2ZXTlY0NkZlMUpKb2x2ZXhHUDVjSCtJamdmaDYxVyszc0l0dTZSaEg2azB4YnRpZWk5ZWFweDdqNWk3NFUwdU9WWHRWOHZkYWtxK0I5NCt0WDBSWXJwbFpZOGVnSFd1WWFhYlRMcHBJV3cxdytjLzNmV25tN3Z2OEFscGNSc3ZQellPYW5sUVNiUjAwbHNzMFRMSXU1SlJnalBUMHFIUjVGRHlXYktzYlF2dEh6ZFI3Vm5RWHQ1TkdvODZINVJnWUJYM3B0dll6M09zVzhubGhseXFTQkRqdmpyNzVvNVNqOXdQOEFna2JxRStrZnNXK0ZJYlFxc3Q1TmRmSzBaK1pXdUpGYmF3T2QzSDA5anhYMWRwc2w5WWFsREpjUTNDcXZsczh1NEVvQmtvU3Fqa1lVakI1em5JN1Y4dS84RXQvQjF2Wi9zVWVFVGNhYlp6VzZ5WEEvMGlKV1daQmRTRW5rWmJIUVpKR1ZJN1lyNlcxbjluM3d6NDEwV1JsKzFlSHI2U1BNRnhwRjdKQ3lBYm84bU5TSTNBUEozb3d3ZWMwWHNZUzNQbjM0TitLbC9aQy80S0JlTHZDbHZIYjJIZy80blJ4YTdhWFZ5aDJ4NmkySTJUY3hCVlVKSTJnNFVZNEFyN2V2ZE52SnJWcDdteHM3bTNhM0FjTVF3MjV5d0lKN3JuR0J5Y1p4ZzE4Vndmc3Yyc3Z4eDBud3Y4VjlTdVBHMmt4d1hONW9FZ2Q3R1MzekVHM1N0RXl0OTRNdTBOak1ZSjY3YSt0dkJuaFMxOFAyR242YnBlb2FwYTI5akhISGFFekNabmpUNVFwWnd4WURhb3ozQU5UZTRqYjhNYWpwZXVRdEhGREhGQ3orWmJXYzZBUnMzTEVmUUVFNFB2d2NFVjR0OEN2RmVuL3M1ZnRlZUp2aGVMK0hTZEg4VjIwSGlMd3hhTGhiZUluZWwxQ3ZaUUhpSlZSeHRZQWRNVjZIcnZncnhCcUdzTTFwcTFsWlRTRTNHMlhTNDVwVWJnS0hPVUdNNFB5Z0huT2VtUGxEOXFENFhhcDhYdjJ6dmh6cFhqSFdsOEt0WjdZOUsxWFIvd0I0czhjczdzWVpSSXlzSER3Z0VCbTI3dHc2akdVN1JWeW94dWZvQkZwR3k5VzRaM0w3K0M3Zys0Qko5T3YvQU91dmwzL2dzam9zTXY3UG5oN1VIdDdkcnlQeEREYnBjYkFaRmphMnVXS0J1dTBzb09QWVY5VGFCNEoxSzB2N1dTVHhGL2FHbFJXNklzUXRZZ1o1QUFON09Nbm5CT0Z4eWZybjVvLzRMSndlVit6TG9hZ2JSL3dsRnZ6anFmc2wzbnJVUzJCSXRmczlmczVlQ2I3OW4vd25mYWw0ZDBxLzFEVXREczdtVzl1YlNPNHVXTDIwZVZEc0NVVURhb0E0QVVjVjJlaWZCdndONGF0b1kxOE42TGV0dVp5eGdWd3Z5NC9pOVJ4WE4vQStEV05RK0JmZ0w3TGRhYXF4K0hiRE1SdHBQT1pmczBlUG0zYmZmcHllL0hOWDQxK0w5VzhCK0RkUzFDR095Zyt4MjVhSzRlNjJ3cXg0eTdEbFZ5UU1LTStuT002UGxTNW1OTzV4Zng4VysrS1B4YjhNL0Qvd2JaNmRZMnRtVzFEeEZxc0krYlJyY2tCSTFDamE3eWtNQXBCeGdOd0Jtdm92d2JvMXJvM2hDTzFzWTVtZzhzd3dxVzNQR0Nmdk5na0gxSlBYTmVKZkE3d1Q0d3YvQUlUMlBpYlIvRE9rNjFjWDBYMnk1dUxuVXhieTMweEh6U0t4M2hvOW9WVkw3Y0JSZ0VjMTZMNGZ0ZmlINHR0ZExqdnZDOXJvSVllWkpqV0k1dkk1R0E1aU9PQng4dWNqcGc1d29TaGE2SEtKMGVwK0JZNHJwcmo3ZkRDc2haV2VNYzRBNUJZWjZZNkQrbGZHUDdhZjdRUGlENGtmRURTZmhEOE9iWnRhOFJ3NjFiWDByK2NZWTNTMmtTUmdaUDRGRzA1WWtZNE9POWZZUGp6NE4rTVBFSGdxYXp0TmUwMjJ1cFZFTUQ3Q3FxV1plNnFNTngwNTV4MTYxODhmczMrTy9oUDhLTGJXMTBXMDhVYWxyNjNiVyt2NnNkSW51cHJ1NFdWbGNNeTdoR3U3bFZVNDljdGduYUx1OUNkdHowSWZEZnhwcThsazJzL0VUVm9iaTNoV09hSFIxTUVNYWdjNVpzN2lUMWNyejNDMWp5L0NuWDdPM2VHVDRuK01vNW9wWkNBdDFFVEFTY2hIUGtuUFRrayszQXhYZWExOFEvQ2VyTEROYTMzMlczdUdLQVhGdmNLSXdTMjE4RkYrWGNqZmVKd1QyN1dQRGZobTJqMGk0dkxXOGt1TEthWGRKTGRJc2JRb1FUNWE3bFVFakhRazRBNU9jRWErMGNYWVZ1eDh0L3RKZnNSYXArMEo0VDFQUW0rSSt1WFVlb0ZJVmE1MCtHUzNZeUVZS3JHRkFQM1R1N0E1NEdhK2R2RGYvQnZwNEQwYlJMYi9BSVNyeHA0dzFMWFpjaVo5TVczczdSVzV4c1dTT1ZtQTduZHoxd09sZnA3OE05Rmg4ZGFScVdzNlhlWEdyV052SkpZV2M3c0VSL0xQbHlQRWNuZHVjT29jRTU4dGlEaGpuYmgrR1huaEk5UTAxTHlUQTh0dnREZ1E1SFBRRE9BY1k2SHVjVm0zMVE5VDhyNFArRGZQNFo2ell4elE2MThScGw4M2JJMXZxTmt6SU9GT1VhM0JYREU4Z244U0RYbTN4Si80TjRMandQbzJwZUlOTCtKRTBHbjZUYlNYai9idElWaGJLaWwvM2ppVUVjREhFWk9lM2F2MlcwTDRVLzJWY3hySkJFMm5zeHlsdzJDTU1TRVhIVTdoK0k0OWMwZkZuaEtEeEViWFFieTNoVzA4UTNrWU52bFVFeVJNSjVGZkJiZUdXSXJoVGpEODROSnlkdHc1bWZtMzRRLzRON2ZoVm8vZ1hTWmRlMVR4bnJtdVRXeVhGOWNXdC9GRkQ1aEFMN1kxaTNJaTVJd3hMREI5d05ud1Ivd1FHK0Q5NWVUWFhtL0VWdFBqUG1CNWRVaGFJS1Z5b3lJVk9CeWM4OGNISGY4QVNuVy9EZXBKYlhGdkNMeElXVVJzSTErV1JjL01NNEdNZzQ3alBxZUsxTkVlK2p1YmUwYTN0YkhTck9Jb0k0NFJLQ09pZ2piak9Pd3pTYjYzS2pJL01QNG5mOEcvSHc1OGNlSG9yZndyNHg4UldPcEFzbjJsL3MxeENTVG55OWtNTWVXeDMzRWdja0hOZkhmN1puL0JEcng5K3loOEs3cnhZUEdHajY5cDl0ZHhXaldrZHZQSGRNSk53Vng4cFZzRlJua2RRZWdPUDNTOFQ2YllhTjRodlB0Q2Y2UE5jaVVXMGxzeWgzNEE1M2ZMbkpBQUdEK0dLK2QvMjVmcy93QzBmOFovZy84QUNIVDRXZ3NkYzEzKzA5WVh5dHJMYlc2QjhMd3B4NWF5TGtEQTkrMmRTVGl2ZFpWMjl6NFovWUYvNE40YnI0dy9BN1EvR0hqM3hWcnVnTjRpUVhNZWthZFpSQ1cydDJPWW5lV1F0OHpyODJBaDJobHpucFh0aS84QUJzZDRSdkwyN1lmRlR4Tlo3bVAyZUdXeHQ1SkVISDN5ckFNZTNBWEg2VitudHo0Y210bWhqdFlGczdXeHdpQklzS0ZVQUFEMEhBSFNyUGg5Wkx1S2RyaXkyZVVNcTRYYjVoOVJnZCtNMVhNM3JjejVtZm1QbzMvQnM1NEhzUXphbDhUdkYwelRTYkxaSXJPM2lPQjF5V0IzZlFGY0VIcjI4cytPbi9CdWZxR25mdEI2Tm9mZzN4eGNId2pIbzMyL1d0VDFlMldXZlRwRE0wYVJSeHhsUE5NbTEyQUpVS0kzeTJkb2I5aTR0T0Vtc1JPM2tSenFDdmxKTDh6cjI3NUhKSEhyMTdWNVZGcG1zYXY4WWZpTnFVN1hGeFp2ZTJHaTJkdkVwd2tjTnFKV1pUMzNTM0xxVDIyTnoxTk9NbW51SzdQejQrR0gvQnZqNEpzMmtIaWZ4WjRxOFJPc1FLdnBxUTJFU3NRTTVRcktlTU4xa1RqRmF2eEMvd0NEZXo0WGF4STdlSHZFdmpUVHZzTWYra05IZVcxNUJjTnRHQ3BaQVJuT1NBU1BZWnI5RlJvdW1LMGpYZ2wwMzVnaWllVUswaURsa0JKQndmUVo0UDFySjhRNlpadkpFc0dwV3F0dEl0YlJOcXF1UXVNZzRCWG5xM2ZwMkZYek1Mcy9NZjRuZjhHMzJtYUw0ZWErc2ZpVnExbkd3R3o3WHAwRXlENWNsV1pYVGJ1UEdjRUFBNUJyNG44UC93REJNbnh4SDQwL3RMd3JheDZ0WWFUZHFKWHZMdTFXT0o4akRLN09va0t0OHgycjhvQXpnNHorL3ZpdlVkRjhMK0dKSmRVOFFXc3gwK3plVXd4WEN6UEVJOTJNSXVBU1dVTGsrdU05YStFUDJON25RZkhIZ1RYcnpUWk5RRjVOcUxYeGprVlpGaWp1WGFVK1dObzJEa0FBNUp5T2NrVmpLTXBPMXpXblV0clkrT2RWL3dDQ2FIeEsxMi9hOC80U0h3dmJXTjFJRlpiMmFWb2R6S2Zta2pXSjQyQitibHUyZllWNW5xMy9BQVJLK01kejRuVkxUVS9BZDVIZE8yK2EwdnBJb1lpR0F3WS9LREFISXdWVXIwNmRLL1hDNDhNYXBCcXNGdmNhV3pRekFUUnh6SUhFU3N3WVBzWWQrbVdPUDk3dnZId3pEYzNGbk5EWjIrazNVY3Nyekt0MTVXVEcyUVNTMk4ySENrSGpwMDZtcWRGUWVqQ3BYbFBjL0ozNFRmOEFCRnpWZEg4WWVLOUgrSW5pWk5PdXRKZ3Qzc2Y3RVl1dDAweU93ZG1sakIySUVJS2hRU2U0NjFSOFdmOEFCRmp4eHBzc3cwdnhabzE1c0N1Z3VyV1dFdVNmdWpZWk9RQ1BjbmdkaWYxQ2k4UldmeEMrTDJ2YWJvNjJMTm84ZG5ZUlhXNktYN2ZPWVRQSUV5QVFWOHduZ0FEYXg0eVJWVzVrbGE3bWprdWx2MXR6dEFray9kUWxPQVNEeHh4MHlPYzg0T05uelgzTXJzL0lMeGovQU1FdHZqUjROMHBycHROMFhWMUdOc2RqZTdwSFBjTHVWUVQ5RDlNOFZqZkJ2L2duZjhVdmlyOFJwOUd1Tk1qOEpwQmFOZHpYbXJBcmJsVllMdFRZRHZZc2VBT01ja2dZeit3MXZwVWNtcHNKRjg2NHV2blRaSzRHNDhFT09oT2VCd09wUEp4WEs2TlpXTTN4dzFKcElMaU84aDBhRWhDbkxvWjVBVGpISnluM2pqN3c0Sk9RWGxjSXl1cm53ZnBQL0JHWHhITkkzMmo0Z2VHMGpCVUZvN0dadkxKR1R1NUFYSFRyL1RPZmQvOEFCSUh4YmF4dThQaXJRWkZWZ256MjhxakJZQWNqUGJKSjZEQUhldjFDMGpRcmU4RTF2YnFJMmxjTTRYYURNMmVNa0E1d0F5NEo0UDB4V2IvWVRYY04zSGNLcUJnQ1JIQ1ZSajgyNWVnSDhPT2c1R1FPUlJyM0VwTm40MS90Ty9zUCtPdjJkckd3dXJ1UFQ5WXM3cHlubjZWSTA2UkhBWUJ3VkJYUElCeGc3VHpYRStCZjJidmloOFE5VCt4NmI0SDhSWGt4RE9DOWs4TWVBdTc3OGdWUFRBenlTQU01QXI5c3RjK0ZGdDRrdlJHMEt0RjVvTDI4QUVLeWVYenlQNFMrQXVPdnpIR1NNR3o0SzhQMi9qTFNkK2p6QjQ0bmxTTkVsOG1XRTlUdnhqYTNHQUc1T2VlcHJQbWxleHB6YUg1VmVCZitDWFh4ZzhUMjhEVFdPaTZUY1RFb3R0ZDZobVVuakF4R3JqSnozUEdPZU9hMVBFUC9BQVNtK1AzaE95a3ZZZkNkcnIxckdBM21hWmZ4U3M1d1dBV05pcnZnRCtGVDA0enhYNjZlQmZBc2kyc2RwRzB3dXBIVUVSQitUa0ZsRGNFdndDZXVCamc0cjJ5SHdmOEFaOVAwMXJlMGh0cGJORlNLTzRrNXljRnR4Ym5kdDI5ZWVLYnVpZVpuelovd1RvazhYK0hQMk9kQ3Q3ZndENDQxajdIQkp1bHRMWkk0eklrc2lsWXZPZGR5bHl4TzFTUWQyUjF4N3o4TXZqaDQvd0JadWJleDFENExlUE5KMHkwSXQvdGNpTElVUmdQK1daSUpBT1RsQ2VnRmVtZnNuZkduVExyeEI0cCtIVjJvczlZMFBVcDd5emdsY0ZyMnp1bSsxcktwQkl3RE95NHprYlBhdmNyU0FSSnVrVnZtUEdmNjFIdEd0MFRaSHk3NG8rSDJzZU1tcy9GR2srSGRlMGZYUERKZUFDYTNLeVR3TnQzb0ZZQVNLY0JnVkpJd1J5Q2N3K0Q5YThYYWxmeDZsWjZKL2FXbHpNSmhjMnMwVU1iRUhFZ1FTTUF4TEEvTUR4a2pxT2ZxS1c3ZFp3c3k3b1MzVmVpWTljOWE0Sk5NdXRBOGJONGZXei80bEY0azJvV04ycWxZb3laQVpMZVFEamhwTjY4L01Dd3g4aEpqbWV4U015UHdGcVdwUUdTVm9iaVpwZk1hTHpUbVBQVmM5R3gxQlBHUU9uQnJ5YjlxbjRDNng4VWZDTU56Sm8rcFhXdWVHZFdodjlDdWJRUnJjVzhxeTlRTi93RHFtUVliT09NRUFGUUI5QTNHblhPbVhLUXI1TVlBMnNFSjNQOEFqakhmOUtkZTZuTEZFMGw0RlcxVWJBVElkd09NRE9QdmZqamsxRTQzV2pISFE4Ky9aSCtNVjNydnduaXRkZTh6KzFMZTZlMlJFdDJ5eUJpQmhSMFVGWEdlZ0E1d01WNUovd0FGaDlWVzkvWm4wVmRsMUduL0FBbEVCVXZIaFRpMHUrbnAxNmUxZTFlUE5OUjlWMGJWTFBiRGNXTjJyVE9rakJicTNDdjVpeWV3Vm1kVk9mbUJBeHVKcnc3L0FJSytYLzhBYUg3TU9nU0twQWs4UzI3NUg4WCtpWFdEaWpsYjBZMjdIYi9BRzRqaC9aOThDdEpkZnVVOE8yQWRaQ0ZSZjlIaTZjZk43L3pyeUxVemIvdDIvdFV4K0E5UHUxaytIL3c4bGoxSHhZWVEwYTZqS0MzazJtOEg1dHpqSkdQdVJQZ2drVlErSEg3WEh3dnRQZ05wZWg2dDRxdm9iNjMwRzBzWllWczdyZEZJa0NLOGFNc2JLY0VFYmljWUk5S2IreGgrMHA4Ri93QmwzNE4zR2oydXN3MmR4cUdvejZsUEUxaGVUM0JMdXdUenBoRUJJNnB0SEh5Z2s0OVNTZDdSV3hTc2ZiOXBvUzZmWS9aTGVTM3Q5T2dqVzN0YlJZdkxoalZRQUZWVjQyZ0RBQTdBVkZMYXd3aTNqdGJpVHFRQkNvR0FlM2ZBSHRYeDM4Wi8yM3ZCZnhFYTJYVC9BSWp6NlZCYnpwS0lvTEM4K1ZSZ0hrMjQzRWc4QnM5VG5QQXJaK0dYN2ZQdzcrRzFqY1JMNDV1ZFNOeE8wN1RYdGhkdEtRM1Q3c0cwQVpHQmc0OXp6VSswOTVwb2JqWmJudHZpcjRvNjFOOGNkSjhBMituM0VGdGUyOHQ3ZTZrOGEvdWJlUHl4bUlsdnZNN2hCMUlMRnNFQ3ZWTFpZTkQwcjdQREdzVmpHb2pSSVNJMVQyQUg0REZmRS93QS9iYytGL2hyeEQ0eDFqeEI0Z2tzOVExclZKUHNUUldWM2NLdG9ya29kM2w3bDNzV2JHQVFBb0l5QlhhSC9ncGg4TWJYVVl6SDRnRnhic3pCaTJuM2lzQmpPUDhBVmR6Zzl6d2VuUWxHUFdUSVBxcVdTUFViZFZRcmNBWVAxeHlGSXhqbkhYQXJIdnJiU1RaM0xheFo2TkRhcmxabm5FWWpSV0p3ckZoam51TzVQNDE0cHEvL0FBVXcrRDkxYWZ1dkhFYXlSOG9uOWs2Z004ZERpREZlUGZIVDl2ZndCOFkvQkZ4NFluMWFLTFQ3dS9zSlpabzdlN0pTS080amFWMEpoVTVFYU1lVnljSEdUak92dWs4cDZWNFkrSEdrK01mQjluY3RiWFduZUdtQnVORDBGNW5qajArekJ6RUFvT1N6cmlVcTJRb2tDN1NGSVBYV0dvVFdscExKR3E2YnB1NWZPbGpVUXhURGhSd1ZVZ0RHTTkrM3Y1UHFmN2NId2ppWm9iWHhZWTdXRStYRkNtblhxcUVYYUY1OG5QQVgxeHgwRk0xZjl0bjRUK0lMSXJkZU90MGlnaEYvc081a1dUSmJHY3dyampyenp3ZUR6V3Z0WXhpRVl0czBmSGpYeHZQOUxsLzBjdWZLZUIzRWxxZVBMTVJSZ1ZZWXlOeHhqSFdzMzlrTCsyZmpUNFlrK0lmalMrMXJXdEwwKzl2OVA4T3JjM0pXU1NNVE5CSmRPaWxGWUVSN1ZBem41ampoU2ZNL2lIKzFoNEdrK0hPdFcvaC94SWwxcjBkazc2YkxkMmQ0a2YyZ2c3Y0hZY0ZTVHlWSFlad1RqMGI0TS90VmZCZjRNZkJMd3g0T2o4ZkpxemVHdE9TMWU1bDBlL1Q3VElGTytYWjVHQVdkbUl6bkFPT2V0TDJ5ZW5RT1d4OUplSHZIOTZaNGJXMWdWYkNORkVRa3o4eWdEZHVMSE9jNUk2OFo2MDN4RDhRN2FKNXJIVUx5V05RLyt2dDVwWWZ1Z0Z1WXlyRThrWXlSa2MxNGRjL3Q4L0I2RFRTc1BpeGJobFhvZEp2RlRQWUtyUW52M3lQb2VsTzBEOXUzNEp0TjV0ejRrZ2hreHRRdHBWNnh4akJKQWdJK1lFOU94N2RLbVVrMW9DMVBYWVBHOWpaYXRjTEhwOHNjYlJsQmUzVXp5Tklxakp5elpLNDY3VzUvcjRYK3k5ZmFYOGU1N240N1gyazd2RUY5cUYxbytnWHl6TURIcHNCYUg5Mml0c1JwSkJMdStYSkFIQXppdWIvYUYvYnI4QnplRXRScy9CM2lXTzYrM1cweWJFc0x4WEVqb1ZHMHlvaXFvTzA0NTRERHVCVy84SnYycnZnVDhHL2hONGQ4SjZONHZtanNmRGRpdG5FWnRIdkg4eVFjdklmM2ZMTklXSnlBTXNlMUtLanpKaHNlcVJYMDFwck03M0dzYWxkU1RBdmJ4bTltd0c0Nk1XWWNidUIwNEhTbDFQeEJxcWFLc2NrMTRrbHdxRzQyMzdCa2NjRUVyZ3JqazhZT0JYbGVwZnR2L0NnZ3NmSEJ1dHc4MlZVMGE4VVNObmxWekV1TWRCNkFEcldaQisyLzhKcHI3Wi9iZDM1TWg4NWpkNmJNeWxnNXd2eUpuR0FNWlU0R09jOU9yMmtMYUM1V1dmMnNMYldQZ0Y4SmRWK0lIaDNVYnFLNXNsaU41SGQzVHl5M0ViT3FrTEtXRWlNT29CSkJ4aXZwYjRhNno1L3d2OE42ZytvVFQzRjFvMXZLenRJY1R5U1JCc3RrODV5ZWV2R2ErQ1ArQ2pIN1RYaEw0Ni9zL3dBWGczd2pyUTFKdFF2NFpidVJMZTV0VnRZVWZPUDNpRGZqSjRHTWNZOXZvbjRkZnQ4L0Ivd3o4Si9ETmpONDNiKzBOTDB1MXRaYlp0TXZ5c1RwR0ViNWhBVllyazR3TUhhT2VsYzg2bDNhNCtVOWUrSUY3YVRwYmFocVdnMnVxTll0bG5hRlpwWUk4SGNWREtmbDR5UUNNa0RybmpOMWo0TC9BQTkrTkhoNzdaZmVIL0taZ0dEbTVraFYxWlJnZ0l3SElJNmpxQjF4WEUyZi9CUlg0S3hXRXFTK0xwbGxjbG1NZWxYbTVnZU1rK1NPY2ZXcy93QUpmdC8vQUFUMFdCa2s4VlJCWmZ2N05JdjhFREcwQWVWakhIK2VwWE41aU9SK0szN0Uxam9QeG44STZab1d0ejZaNFc4VDI5M1lhcEJMY0NSajVkdXpnUXF3S2xuQUM3aUN5QmM1emdIcXZCUDdKdmhEOW52UTc2VFFmQzl2REZjSnV1Wm9wcDVyaVJWVENzVEsyRmJxUGxVQVpVOEVDdWQrSzM3Ym53aDhZL0U3d2pmV3ZpVGJZYVRhNmc5eGN4V0Y3RzhNODBTUklxcjVJUEt0SnlNOGhlUlY2OS9icStFZW9XMGRxM2pSdnM4SU1pWjBxODNUdGpqZWZJNDdyd09BTW5QU2twOVd3U3VhbXBmc3FlRC9BQm5MY2FscTFyNGl1NTdpQkJjQ1h4SmRxczRaZ1VqZnk1UVdWVkNnTGs5aDJwMFg3SmZ3enVkUmowdURSZGIwbTd1dDBKbDAvVzcwdEdxcWZua1h6aW9QUTVZSGN4QU9hNHJVL3dCdUx3REplTGVSK1BJNTJ0ZjlRa21uWHU1c3NQbHo1RzBBSG5CeURnY0R0MVhoWC9nb0I4STdDK2phNjhVVzlyRDhqU3RiNlRlTjVwR1N3Zk1BT0Q3REp6MjdYN1R6SHluenA4QmYrQ2RGcjhVVzhZNnhybmlieEpZK0dkUzhRM0VYaDJ3c29GaHZiK09GUmJDZVpqbnkyTHhNdTNhUHVFOXdLOUkxL3dENEpGNmg1TUsyUHhjOFdXUDJjS2tGclBieDNTMitEakdWS0Riakh5NEJBR2E3YjRVL3QxZkIvd0FKK0c5WnQ3cnhhME1rM2lMVTlTdFZPbFhiczBNdHhKTkczRU8wWkxuQVBJR0FSbk5kUkwrMzk4Qzc2RzNFbmphNVI3UUZncTZiZjh0ejgyN3lPcDNFa2dEMkZFYWxsdUxsWjg1cit3aiswcDRNdkk0YlB4SjhOZFMwZFhjcmVYc3R4SE5oZ1ZKOG9JU0d3VGo3MkRuNWpYbkdpZnN6ZkZqV3YybHIxUEZNMm0rR3RObDArU3pqbWh1WTdtTzhkWHlmTGp6NXZscUpFT0p0dkc3a2JsRGZaOXIvQU1GQWZnVHBseEpicjRvbWVDWU1KTGc2WGVzV3ljNE82RXNlbmZJNTcxODQvdEVmdFkrR05SL2JDMC9YdkNPcVdjL2huL2hGRzB5VzdGblBDbHZkK2N4LzFUeEJ5VEhzWGNGWWRlUlV6cVN1ck11TnRibzlrK0NIN010amZlSEx1NjFieGJxVzVYeEViYTNqRUFYa2ZLR1F1ekhPUUJJMkIvRnppdFR4WjhCOVJ0OVR1THpSZFhzN2VHNmN4V2RyYzJBRVh6TmtqWUdETVd4Z0hjY0FEUFN1WjBYOXRINFUrRGRVTFdmaTBUMi9sNEFoMDY4UXVjY0Fib1I5MGtrYnNnNDdDcncvYngrRkw2akhkTjRubWtramtMK1gvWnR5VjVJQnlURjEyZ1o0d1NPM1NtcFhJYXNadHY4QUJ2NGdhZHBjOTVweWVFdFZ1WXdzekw1TTlzMTJxZGt4SXdhUmlUZ01BQ1FNSHJYQy9zUS9zN2VQUGlVbmlyV3RGbThKNlQ0WjFIV0xxWXdYS3lOTkZNMGpGaEVxcmdxbjNQbUs4Z2djRGNmWUxIOXVyNE02SHFrZW8yZmk1WkdVaDN0WnRKdkFyTjB5ckxCd0IxNUJQcGcxeEh3Wi9iQStGL2dpRHhNcmVLRXNmdG5pL1VOWXR5bW4zamVmYnl5dTBYQ3hjTGdqQ25CQUpCSGVvY201WHVQb2UxNmIrelhxWGg3VS9MR29RM0c2UWt6dGFiVEg2K1g4K08yTTRianJrWkZhT28vQUMzdjBrYVRYTmYzeC9NZnRFaXlJSkNUd09PMld3TWtaSjU1cmlyZi9BSUtHL0I2WlJIY2VKRlpGQVVGTk92VmtLNC9pUGs4a2NuOGU1cTNKL3dBRkVQZ3pNWk4zaTIzODdjU3N3MGkrM1k3RC9qMy9BTnB2OG1ucDFaSkJyME1Qd1YvYUYrRzgyb2FoWXgzV3FSVFdLNnI5bFdHYS9iQkgyZVRLa2dqTVd3YnNmUEp4a2dENlAxdnhocWxsb3duc2JHMzFlZnEwSG5pRWxmWXRrWjY0emdIMUhKSHg5OGN2MnVQZ3o4Vjcvd0NIOTVMNHZpa244SzYzL2FNcXJwZDlIR3FmWjVWd2YzT1d6SjVZd0NPQ2ZTdTluLzRLSmZCMnlFTU5qNDJpVzNrSU1yUHBOK3JwZ2tuR0lEeDBIQkhYcFV4a251YVNWdGozYlEvaVZybDNxTnZCcUhobVMxV1JOMGsxdmV4M0N4SDVUdElPMDU1YkpBd01Ecm5qaS8ydWZpMi9ndjRPYXpjUTIrcGFScXRuRVpkSzFDZUpXdGt1aC9xd3pLeDJCOGxNdGdZYzU0eWE4NDAvL2dvZDhIYk1uelBHelhBVWp5LytKWGZqY0FRT25rZWcvcmlxWHhaLzRLRi9DWHhsNEMxYlE0ZkZWcGVXK3FXc2x2SWx6cEY4NktqS1Z4Z3dqTEhQQlBSc2Roa0R0dWlWcHVleS9DbngxY2VPdmhKcEdyUjNtbDZsZlhGc3Bsdk43TGJzdzY5RjZqb1FjSFBYSFNrdi9GSGlwZk9OOW8rZ0N6dDJBKzBMcU1rWmtIYzRNV1JqNll3TTd1Z3I0by9ZVi9iMTBUNFQrQUxmd3I0d2tXMGhoZVZ4ZExGTGNSdHUvdktxWjVCT2V2UWRCWHRsdi93VUQrRXJSTEkzakNOWm0rVWdhVGUvTUFUdEpQay9kd1RrWXlTVDJ4aXZkM0RVOVE4ZGVJYmo0VytIZitFZ3NkSjF6VlpMTnpjZjJkcGpwTkk4WEt1TnJGVElwWGxSdERBNDRQU3ZqdjhBYTArSWV0ZkVIOWlEd3RmWGkyMWhhM0hpTVBIcC9rR080c1FJcnNKSEsyUjg0US9NcFFFRTg5T2ZjSmYrQ2dYd25sV0hiNHNhSHlYM3hpTFQ3MEJpQTMzdjNQSUkyOXM5UFN2Q2YyKy8ybHZoNzhYL0FJWFd1bmVFOVJTOHZwZGNpMU84ZjdIY1JieUlKb3kzN3hGR2VVempxZWZXaVZsc1VmL1pcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wcm9qZWN0LWltYWdlcy9kb3ZlbnNob2FoLmpwZ1xuICoqIG1vZHVsZSBpZCA9IDE5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==');
},function(module,exports,__webpack_require__){eval('module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAlCAYAAAAjt+tHAAADoklEQVRYhc2Xz2sbRxTHP7uSl5VQk2gPCb4Y+VqndZ1ggSik2KxLSaGoBKfHpPkbcugf0BwSyKkkpwR8CyUXUygUJBxHUBRq0tah6SGlYFRII0OWuMjr1Xq124NmlJWR9geVoQ+G2R9v5/uZmfd29ylBEACwsrKSBVRAE32WyZoH+IAL+LVazQNQgiCQ4hqgi6YJAHVC4r4AcAFHNLdWq3mKaZpSPA+cEL3O8ayAA9jAP6J35Sx1IX662qw3Jyw8ZOsVsyIOfcALL32+2qw3S6Uc+XwGXc+MHeTVqw6u20NRIAhgakplevqdSGHH6WHbParNenO9Yr6H2AaVt4GnA7Hi7XZffOW7n1j90+Pj73/m8NCn3e5EAuh6hnx+MK6MM1VGu2yR4gCu22P5YQPj/UUUNUNxboHlhw1ctxf53JGxB5oyylNF+6l3P4g8T2hqamFpb37/NfI8NUUa07QMG6sXsJ5tEfg9rGdbbKxeQNOit26cpcr1VmtvcFz7rDx0r9vt0WrtMTNz8ngAZJR/sROM9fm2pNBudzhzppAYIPEWdLs9lh5sRPosPdig243PhtQAnY4LwOnKUqSfvC/9JwZgWQfMXr4G9Jd5lMnrs5evYVkHkwN4/doGoHzrPnsvnlM8e26kX/HsOfZePKd86/7Qc/8ZYH//kPLtNQAaVy+yePPeSL/Fm/doXL3Yh729xv7+4WQAslmV2UtXALBftijOLYz0K84tYL9sATB76QrZbLL4jk1Dz/P5Y+0b/n78A8Z8OdLXmC/T+PJTpj/6BM/zJwNQKGj8decrLOuA5fWtSN/zX9/l0eeLeL9tUihoiQBi18kwcuRyU6iqwu6TzUjf3SebKIpCLjeFYeQmAyBN17Ns37g+lIZHj7dvXEfX0/3JJQYoFnOx7/mZmZMUi8lmnhrguOx/A5AsZyZrvgTwQg3HSfc1S2OhsQeaWd6WSw6Abfedon5Ox2VCnLgcW2i5gK+YpqkBBeAUEYVJqZTDMJK9XCzLZWdn9BdRFCa7wBugI1fAoV8uIYqGcGmmAlSb9R+BWAgpvl4xPxSXZHwdLc0cwE9SnA7+4avN+tOolQiJn2c4tsYXpzHluezD5dsvoyBC4gtilnKfwwCjy/MoE2A6/TgpCIjtMERIfF6Id0RzpNA4iwUYA1GQKwGEZ94hhXhigBEQJwTEU0DueYd+cCUWTwVwBCIvmgwEl/7S22nEUwOEIGRQylSVKeamEQf4F/3SnpaupimUAAAAAElFTkSuQmCC"//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy9mZW1hbGUtMl8xLnBuZz8wNzk0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiIyMDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFsQ0FZQUFBQWp0K3RIQUFBRG9rbEVRVlJZaGMyWHoyc2JSeFRIUDd1U2w1VlFrMmdQQ2I0WStWcW5kWjFnZ1NpazJLeExTYUdvQktmSHBQa2JjdWdmMEJ3U3lLa2twd1I4Q3lVWFV5Z1VKQnhIVUJScTB0YWg2U0dsWUZSSUkwT1d1TWpyMVhxMTI0Tm1sSldSOWdlVm9RK0cyUjl2NS91Wm1mZDI5eWxCRUFDd3NyS1NCVlJBRTMyV3lab0grSUFMK0xWYXpRTlFnaUNRNGhxZ2k2WUpBSFZDNHI0QWNBRkhOTGRXcTNtS2FacFNQQStjRUwzTzhheUFBOWpBUDZKMzVTeDFJWDY2MnF3M0p5dzhaT3NWc3lJT2ZjQUxMMzIrMnF3M1M2VWMrWHdHWGMrTUhlVFZxdzZ1MjBOUklBaGdha3BsZXZxZFNHSEg2V0hiUGFyTmVuTzlZcjZIMkFhVnQ0R25BN0hpN1haZmZPVzduMWo5MCtQajczL204TkNuM2U1RUF1aDZobngrTUs2TU0xVkd1MnlSNGdDdTIyUDVZUVBqL1VVVU5VTnhib0hsaHcxY3R4ZjUzSkd4QjVveXlsTkYrNmwzUDRnOFQyaHFhbUZwYjM3L05mSThOVVVhMDdRTUc2c1hzSjV0RWZnOXJHZGJiS3hlUU5PaXQyNmNwY3IxVm10dmNGejdyRHgwcjl2dDBXcnRNVE56OG5nQVpKUi9zUk9NOWZtMnBOQnVkemh6cHBBWUlQRVdkTHM5bGg1c1JQb3NQZGlnMjQzUGh0UUFuWTRMd09uS1VxU2Z2Qy85SndaZ1dRZk1YcjRHOUpkNWxNbnJzNWV2WVZrSGt3TjQvZG9Hb0h6clBuc3ZubE04ZTI2a1gvSHNPZlplUEtkODYvN1FjLzhaWUgvL2tQTHROUUFhVnkreWVQUGVTTC9GbS9kb1hMM1loNzI5eHY3KzRXUUFzbG1WMlV0WEFMQmZ0aWpPTFl6MEs4NHRZTDlzQVRCNzZRclpiTEw0amsxRHovUDVZKzBiL243OEE4WjhPZExYbUMvVCtQSlRwai82Qk0vekp3TlFLR2o4ZGVjckxPdUE1Zld0U04velg5L2wwZWVMZUw5dFVpaG9pUUJpMThrd2N1UnlVNmlxd3U2VHpVamYzU2ViS0lwQ0xqZUZZZVFtQXlCTjE3TnMzN2crbElaSGo3ZHZYRWZYMC8zSkpRWW9Gbk94Ny9tWm1aTVVpOGxtbmhyZ3VPeC9BNUFzWnlacnZnVHdRZzNIU2ZjMVMyT2hzUWVhV2Q2V1N3NkFiZmVkb241T3gyVkNuTGdjVzJpNWdLK1lwcWtCQmVBVUVZVkpxWlRETUpLOVhDekxaV2RuOUJkUkZDYTd3QnVnSTFmQW9WOHVJWXFHY0dtbUFsU2I5UitCV0FncHZsNHhQeFNYWkh3ZExjMGN3RTlTbkE3KzRhdk4rdE9vbFFpSm4yYzR0c1lYcHpIbHVlekQ1ZHN2b3lCQzRndGlsbktmd3dDankvTW9FMkE2L1RncENJanRNRVJJZkY2SWQwUnpwTkE0aXdVWUExR1FLd0dFWjk0aGhYaGlnQkVRSndURVUwRHVlWWQrY0NVV1R3VndCQ0l2bWd3RWwvN1MyMm5FVXdPRUlHUlF5bFNWS2VhbUVRZjRGLzNTbnBhdXBpbVVBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHJvamVjdC1pbWFnZXMvZmVtYWxlLTJfMS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAyMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAlCAYAAAAjt+tHAAADr0lEQVRYhc2Xz2sUZxjHPzNOdifLRMyCFS+7aW6N2DSKiaVqKWyg2EupiLdaV/8EQZCWIpVAEL0UPBlIL6Kn9tBD6S5ipSWuYn9YUoRADQtat+IY7GQ7Mxlnetj3XWfD7uyMTqAPvLwz8z7v+/3M8z7vMI8SBAEA09PTGqACGdFrpGse4AMu4FcqFQ9ACYJAimcAXbSMAFBTEvcFgAvYormVSsVTSqWSFM8Bm0WvszERsIEm8Ez0rnxLXYi/VstWF1IW7rApp/S2uPQBLxz6XC1bXRgZGSKX09D13gF49OgpruuhKBAEMDCwie3b85HCtu3RbHrUlqsLU05pJ2IbVF4kng70FW80WuLffH6LpTmPb8/8zNracxqNp5EAuq6Ry7XXlXmmymyXLVIcwHU9rp6+wZuv70FVNzFWnODq6Ru4rhc5b93abU2Z5YmyfazwVuR9TFMTC0v7o/5r5H1iiiSWyWgcmTnA3fu38f3n3L1/myMzB8hkXu7UJppVrz9uX394ZrJjzHE86vXHFApbNwag0VgB4M/5oKfP6CcKjcYK27ZtiQ0QewscZ43Lp65F+lw+dQ3HWYstHhvAsv4FYO8b70X6yXHpnxqAaVoc3l8GWmHuZvL54f1lTNNKD+DJk2cAzB6fY+nBIjuKu7r67SjuYunBIrPH5zrmvTLA6qrDuRPzABw7f5DZ8qWufrPlSxw7fxCAcyfmWV110gHQNJVD+44C8NCsM1ac6Oo3VpzgoVkH4NC+o2havPzueww9z+erypf88Pt3jI9ORvqOj05SvvAB7+58H8/z0wEwDJ2L33+KaVp8/dmtSN8vPr7IR2cnWfzrRwxDjwXQN075/BCDg1lUVeXmveuRvjfvXUdRVAYHs+TzQ+kASNP1AWaunOw4huuvZ66cRNcH4i6ZDGB42Oj7nS8UtjI8bGwMwEbZ/wYg3plJ13wJ4IUatt3/3+5lLbR2W1PjRblkAzSbLaeon9NeJ6GfuFxbaLmAr5RKpQxgAFuIKExGRobI5+N9XEzTZnn5n65jojD5G1gBLBkBm1a5hCgawqWZClBbrv4E9IWQ4lNO6R3xSObX+tLMBvw4xWn7H76Wrd6JikRIfDedudW7OO1Tnss+XL790g0iJD4h3lLucxige3keZQJMp5UnhoD4LQwREh8X4pZothTqZX0BekAYMhJA+M0tEojHBugCsVlA3AHknlu0kiu2eCKAdRA50TJiyKUV+mYS8cQAIQiZlPKoyiPmJhEH+A+nV5/BOPUFbgAAAABJRU5ErkJggg=="//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy9mZW1hbGUtMl8yLnBuZz9lMDRlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiIyMDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFsQ0FZQUFBQWp0K3RIQUFBRHIwbEVRVlJZaGMyWHoyc1VaeGpIUHpOT2RpZkxSTXlDRlMrN2FXNk4yRFNLaWFWcUtXeWcyRXVwaUxkYVYvOEVRWkNXSXBWQUVMMFVQQmxJTDZLbjl0QkQ2UzVpcFNXdVluOVlVb1JBRFF0YXQrSVk3R1E3TXhsbmV0ajNYV2ZEN3V5TVRxQVB2THd6OHo3disvM004ejd2TUk4U0JBRUEwOVBUR3FBQ0dkRnJwR3NlNEFNdTRGY3FGUTlBQ1lKQWltY0FYYlNNQUZCVEV2Y0ZnQXZZb3JtVlNzVlRTcVdTRk04Qm0wV3ZzekVSc0lFbThFejBybnhMWFlpL1ZzdFdGMUlXN3JBcHAvUzJ1UFFCTHh6NlhDMWJYUmdaR1NLWDA5RDEzZ0Y0OU9ncHJ1dWhLQkFFTURDd2llM2I4NUhDdHUzUmJIclVscXNMVTA1cEoySWJWRjRrbmc3MEZXODBXdUxmZkg2THBUbVBiOC84ek5yYWN4cU5wNUVBdXE2Unk3WFhsWG1teW15WExWSWN3SFU5cnA2K3dadXY3MEZWTnpGV25PRHE2UnU0cmhjNWI5M2FiVTJaNVlteWZhendWdVI5VEZNVEMwdjdvLzVyNUgxaWlpU1d5V2djbVRuQTNmdTM4ZjNuM0wxL215TXpCOGhrWHU3VUpwcFZyejl1WDM5NFpySmp6SEU4NnZYSEZBcGJOd2FnMFZnQjRNLzVvS2ZQNkNjS2pjWUsyN1p0aVEwUWV3c2NaNDNMcDY1RitsdytkUTNIV1lzdEhodkFzdjRGWU84YjcwWDZ5WEhwbnhxQWFWb2MzbDhHV21IdVp2TDU0ZjFsVE5OS0QrREprMmNBekI2ZlkrbkJJanVLdTdyNjdTanVZdW5CSXJQSDV6cm12VExBNnFyRHVSUHpBQnc3ZjVEWjhxV3VmclBsU3h3N2Z4Q0FjeWZtV1YxMTBnSFFOSlZEKzQ0QzhOQ3NNMWFjNk9vM1ZwemdvVmtINE5DK28yaGF2UHp1ZXd3OXorZXJ5cGY4OFB0M2pJOU9SdnFPajA1U3Z2QUI3KzU4SDgvejB3RXdESjJMMzMrS2FWcDgvZG10U044dlByN0lSMmNuV2Z6clJ3eERqd1hRTjA3NS9CQ0RnMWxVVmVYbXZldVJ2amZ2WFVkUlZBWUhzK1R6UStrQVNOUDFBV2F1bk93NGh1dXZaNjZjUk5jSDRpNlpER0I0Mk9qN25TOFV0akk4Ykd3TXdFYlovd1lnM3BsSjEzd0o0SVVhdHQzLzMrNWxMYlIyVzFQalJibGtBelNiTGFlb245TmVKNkdmdUZ4YmFMbUFyNVJLcFF4Z0FGdUlLRXhHUm9iSTUrTjlYRXpUWm5uNW42NWpvakQ1RzFnQkxCa0JtMWE1aENnYXdxV1pDbEJicnY0RTlJV1E0bE5PNlIzeFNPYlgrdExNQnZ3NHhXbjdINzZXcmQ2SmlrUklmRGVkdWRXN09PMVRuc3MrWEw3OTBnMGlKRDRoM2xMdWN4aWdlM2tlWlFKTXA1VW5ob0Q0TFF3UkVoOFg0cFpvdGhUcVpYMEJla0FZTWhKQStNMHRFb2pIQnVnQ3NWbEEzQUhrbmx1MGtpdTJlQ0tBZFJBNTBUSml5S1VWK21ZUzhjUUFJUWlabFBLb3lpUG1KaEVIK0ErblY1L0JPUFVGYmdBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wcm9qZWN0LWltYWdlcy9mZW1hbGUtMl8yLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDIwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAlCAYAAAAjt+tHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAhdEVYdENyZWF0aW9uIFRpbWUAMjAxNTowNToyMyAxMTo0MDoyME/D0q4AAAKuSURBVFhHtZfBahNRFIYnoWgIrUjEdleKuBURFyJuXCTvUXwQFz5J3yMu3Ii4KCLupXRnxSBtCTGExPNd7h9u4p2ZM5L54HBmTqfz//fMCdzbWa1WBYxGoz1LXYs7MXO/SxYWS4s5eTwec18EA1Ec4V4MrmVoFyCMIOKzGHNMdIbDocT7FvdixkQbHUB4anEd8xwDiO9b3Lc4/Hz3/SfLrfHiz/ClpSuL3xa3GECclQ9M/NvJyUHR7+8Vvd5uGzCbLYrpdFFcXNxg4omVJhbXfGMNHm1vRRx4J++OaM66mnZFK+IiefdaU1O+q2lvQtB0C19e/mwUXlwGeOHx8cPi+9lqI6hBru41UWtA4h/eXRWPTjsbQQ1yda+JSgOp+Ou3h6GmVQNiaSeUedZrorYDWrnMCITh8ZtueKbb7YR7iW7Xy3APYSqeslyuil83P0IWPJur53AbqOLBwVG82qSsnuI24Bko0eTZWgMMVO6npTowI0Kzwt80uFVUGpCophpkgqxfgdDfeJb/kZkqajuQmkAsDcjVveLgmgGZYMVqt3Ku7hUH9xA2BRMe3AZYkVoMuq6qe3AbyLVa7S6re2jUge1VqVZW9/BfM8CU5yirVyED7NtdaGW5VafZQdDEAPt1Rdi9tkXy7rUmBnRc4tAQts5tmNC2PBJORhZL98GE88JgEHbutUwms7D/z5E7mLA9rjqahTkxYx89JiRuQq9iSfPF8v89mjkOp2H/TpiJ8yoTifhzu11/Z4vyw2nN8VxZ5vpm4kvORCL+zG5Znb5zakDztnk8ryIaQ405ITDxNTWRiD+1W8RvY8wkVEatAciY2FcnIFm5hF3i4DIAWyYYVkycW9Y3R5ThcouD2wAkJvilEMwG8F1pffj2XnFoZACiCQ0l14DgerJDxUVR/AWFXPFNPrQOOgAAAABJRU5ErkJggg=="//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy9nYXktZmVtYWxlXzEucG5nP2ViYWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDIiwiZmlsZSI6IjIwMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWxDQVlBQUFBanQrdEhBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQWhkRVZZZEVOeVpXRjBhVzl1SUZScGJXVUFNakF4TlRvd05Ub3lNeUF4TVRvME1Eb3lNRS9EMHE0QUFBS3VTVVJCVkZoSHRaZkJhaE5SRklZbm9XZ0lyVWpFZGxlS3VCVVJGeUp1WENUdlVYd1FGejVKM3lNdTNJaTRLQ0x1cFhSbnhTQnRDVEdFeFBOZDdoOXU0cDJaTTVMNTRIQm1UcWZ6Ly9mTUNkemJXYTFXQll4R296MUxYWXM3TVhPL1N4WVdTNHM1ZVR3ZWMxOEVBMUVjNFY0TXJtVm9GeUNNSU9LekdITk1kSWJEb2NUN0Z2ZGl4a1FiSFVCNGFuRWQ4eHdEaU85YjNMYzQvSHozL1NmTHJmSGl6L0NscFN1TDN4YTNHRUNjbFE5TS9Odkp5VUhSNys4VnZkNXVHekNiTFlycGRGRmNYTnhnNG9tVkpoYlhmR01OSG0xdlJSeDRKKytPYU02Nm1uWkZLK0lpZWZkYVUxTytxMmx2UXRCMEMxOWUvbXdVWGx3R2VPSHg4Y1BpKzlscUk2aEJydTQxVVd0QTRoL2VYUldQVGpzYlFRMXlkYStKU2dPcCtPdTNoNkdtVlFOaWFTZVVlZFpyb3JZRFdybk1DSVRoOFp0dWVLYmI3WVI3aVc3WHkzQVBZU3Flc2x5dWlsODNQMElXUEp1cjUzQWJxT0xCd1ZHODJxU3NudUkyNEJrbzBlVFpXZ01NVk82bnBUb3dJMEt6d3Q4MHVGVlVHcENvcGhwa2dxeGZnZERmZUpiL2taa3FhanVRbWtBc0RjalZ2ZUxnbWdHWllNVnF0M0t1N2hVSDl4QTJCUk1lM0FaWWtWb011cTZxZTNBYnlMVmE3UzZyZTJqVWdlMVZxVlpXOS9CZk04Q1U1eWlyVnlFRDdOdGRhR1c1VmFmWlFkREVBUHQxUmRpOXRrWHk3clVtQm5SYzR0QVF0czV0bU5DMlBCSk9SaFpMOThHRTg4SmdFSGJ1dFV3bXM3RC96NUU3bUxBOXJqcWFoVGt4WXg4OUppUnVRcTlpU2ZQRjh2ODltamtPcDJIL1RwaUo4eW9UaWZoenUxMS9aNHZ5dzJuTjhWeFo1dnBtNGt2T1JDTCt6RzVabmI1emFrRHp0bms4cnlJYVE0MDVJVER4TlRXUmlEKzFXOFJ2WTh3a1ZFYXRBY2lZMkZjbklGbTVoRjNpNERJQVd5WVlWa3ljVzlZM1I1VGhjb3VEMndBa0p2aWxFTXdHOEYxcGZmajJYbkZvWkFDaUNRMGwxNERnZXJKRHhVVlIvQVdGWFBGTlByUU9PZ0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3Byb2plY3QtaW1hZ2VzL2dheS1mZW1hbGVfMS5wbmdcbiAqKiBtb2R1bGUgaWQgPSAyMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAlCAYAAAAjt+tHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAhdEVYdENyZWF0aW9uIFRpbWUAMjAxNTowNToyMyAxMTo0MDozNr+7RtoAAAKrSURBVFhHtZdBixNBEIUnWVliWFQi6G0J3kXEUxA8JXdv/sbFi/d4EiSnRcQ/EPamYFiXJYbgJtbX9Aud2DNTI5kPipqp9M573VOzdHe2220Bk8nknqWuxWnM3B+TPxYbizV5Op1yXwQDURzhXgyuZegYIIwg4qsYa0x0xuOxxPsWD2LGRBsrgPDS4ibmNQYQP7N4ZPHk7ezjzHJrfBiNR5Z+WFxb3GIAcWY+MPFvw+H9ot8/KXq9Eysdj9Xqrlgu74r5/DcmnltpYXHDO1bjseytiAPP5NkR9VlX3a5oRVwkz95pqsuP1e1NCJpu4aurX43Ci8sADzw/f1i8m2/3ghrk6l4TtQYkPvp0XVwMO3tBDXJ1r4lKA6n47A3/JordrAGxdCWUGes1UbsCmrnMCITh/bNuGNPtdsK9RA/rZbibMBVP2Wy2xfrn95AFY3P1HG4DVZw+fhqv9imrp7gNeBpKNBlba4CGyn1aqgM9ItQr/KbGraLSgETV1SATZH0FQr8xlr+RmSpqVyA1gVgakKt7xcHVAzLBjLXcyrm6VxzcTdgUTHhwG2BGWmLQdVXdg9tAbqm13GV1D41W4HBWqpXVPfxXD9DlOcrqVcgA+3YXmllu1ml2EDQxwH5dEXavbZE8e6eJAR2XODSErXMbJrQtj4STkcXGfTDhvDAYMLSexWId9v85cgcTtsc8uexoFvrEjH32mJC4Cb2OJfUXS/7v0cxxOA37d8JMXFaZSMRf2e3uPVuUH05rjufKMtc3E19yJhLxl3bL7PSeUwPqt/3jeRXRGOL0CYGJr6mJRPyF3SJ+G2MloTJqDUDGxJlWApKZS9glDi4DcGCCZsXEpWW9c0RpLrc4uA1AYoIvhVAj8F5Z+vDuveLQyABEE2pKrgHBXWeHioui+Atm4vFNf0eS4QAAAABJRU5ErkJggg=="//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy9nYXktZmVtYWxlXzIucG5nP2U2MjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDIiwiZmlsZSI6IjIwMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWxDQVlBQUFBanQrdEhBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQWhkRVZZZEVOeVpXRjBhVzl1SUZScGJXVUFNakF4TlRvd05Ub3lNeUF4TVRvME1Eb3pOcis3UnRvQUFBS3JTVVJCVkZoSHRaZEJpeE5CRUlVbldWbGlXRlFpNkcwSjNrWEVVeEE4Slhkdi9zYkZpL2Q0RWlTblJjUS9FUGFtWUZpWEpZYmdKdGJYOUF1ZDJETlRJNWtQaXBxcDlNNTczVk96ZEhlMjIyMEJrOG5rbnFXdXhXbk0zQitUUHhZYml6VjVPcDF5WHdRRFVSemhYZ3l1WmVnWUlJd2c0cXNZYTB4MHh1T3h4UHNXRDJMR1JCc3JnUERTNGlibU5RWVFQN040WlBIazdlemp6SEpyZkJpTlI1WitXRnhiM0dJQWNXWStNUEZ2dytIOW90OC9LWHE5RXlzZGo5WHFybGd1NzRyNS9EY21ubHRwWVhIRE8xYmpzZXl0aUFQUDVOa1I5VmxYM2E1b1JWd2t6OTVwcXN1UDFlMU5DSnB1NGF1clg0M0NpOHNBRHp3L2YxaThtMi8zZ2hyazZsNFR0UVlrUHZwMFhWd01PM3RCRFhKMXI0bEtBNm40N0EzL0pvcmRyQUd4ZENXVUdlczFVYnNDbXJuTUNJVGgvYk51R05QdGRzSzlSQS9yWmJpYk1CVlAyV3kyeGZybjk1QUZZM1AxSEc0RFZadytmaHF2OWltcnA3Z05lQnBLTkJsYmE0Q0d5bjFhcWdNOUl0UXIvS2JHcmFMU2dFVFYxU0FUWkgwRlFyOHhscitSbVNwcVZ5QTFnVmdha0t0N3hjSFZBekxCakxYY3lybTZWeHpjVGRnVVRIaHdHMkJHV21MUWRWWGRnOXRBYnFtMTNHVjFENDFXNEhCV3FwWFZQZnhYRDlEbE9jcnFWY2dBKzNZWG1sbHUxbWwyRURReHdINWRFWGF2YlpFOGU2ZUpBUjJYT0RTRXJYTWJKclF0ajRTVGtjWEdmVERodkRBWU1MU2V4V0lkOXY4NWNnY1R0c2M4dWV4b0Z2ckVqSDMybUpDNENiMk9KZlVYUy83djBjeHhPQTM3ZDhKTVhGYVpTTVJmMmUzdVBWdVVIMDVyanVmS010YzNFMTl5SmhMeGwzYkw3UFNlVXdQcXQvM2plUlhSR09MMENZR0pyNm1KUlB5RjNTSitHMk1sb1RKcURVREd4SmxXQXBLWlM5Z2xEaTREY0dDQ1pzWEVwV1c5YzBScExyYzR1QTFBWW9JdmhWQWo4RjVaK3ZEdXZlTFF5QUJFRTJwS3JnSEJYV2VIaW91aStBdG00dkZOZjBlUzRRQUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHJvamVjdC1pbWFnZXMvZ2F5LWZlbWFsZV8yLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDIwM1xuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('module.exports = "data:image/jpeg;base64,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"//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy9oZXJlbi16ZXZlbnRpZW4teHZpaS5qcGc/Yjk5MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxrQ0FBa0MiLCJmaWxlIjoiMjA0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUFTQUJJQUFELzJ3QkRBQW9IQndnSEJnb0lDQWdMQ2dvTERoZ1FEZzBORGgwVkZoRVlJeDhsSkNJZklpRW1LemN2SmlrMEtTRWlNRUV4TkRrN1BqNCtKUzVFU1VNOFNEYzlQanYvMndCREFRb0xDdzRORGh3UUVCdzdLQ0lvT3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096di93QUFSQ0FEY0FTSURBU0lBQWhFQkF4RUIvOFFBSHdBQUFRVUJBUUVCQVFFQUFBQUFBQUFBQUFFQ0F3UUZCZ2NJQ1FvTC84UUF0UkFBQWdFREF3SUVBd1VGQkFRQUFBRjlBUUlEQUFRUkJSSWhNVUVHRTFGaEJ5SnhGREtCa2FFSUkwS3h3UlZTMGZBa00ySnlnZ2tLRmhjWUdSb2xKaWNvS1NvME5UWTNPRGs2UTBSRlJrZElTVXBUVkZWV1YxaFpXbU5rWldabmFHbHFjM1IxZG5kNGVYcURoSVdHaDRpSmlwS1RsSldXbDVpWm1xS2pwS1dtcDZpcHFyS3p0TFcydDdpNXVzTER4TVhHeDhqSnl0TFQxTlhXMTlqWjJ1SGk0K1RsNXVmbzZlcng4dlAwOWZiMytQbjYvOFFBSHdFQUF3RUJBUUVCQVFFQkFRQUFBQUFBQUFFQ0F3UUZCZ2NJQ1FvTC84UUF0UkVBQWdFQ0JBUURCQWNGQkFRQUFRSjNBQUVDQXhFRUJTRXhCaEpCVVFkaGNSTWlNb0VJRkVLUm9iSEJDU016VXZBVlluTFJDaFlrTk9FbDhSY1lHUm9tSnlncEtqVTJOemc1T2tORVJVWkhTRWxLVTFSVlZsZFlXVnBqWkdWbVoyaHBhbk4wZFhaM2VIbDZnb09FaFlhSGlJbUtrcE9VbFphWG1KbWFvcU9rcGFhbnFLbXFzck8wdGJhM3VMbTZ3c1BFeGNiSHlNbkswdFBVMWRiWDJObmE0dVBrNWVibjZPbnE4dlAwOWZiMytQbjYvOW9BREFNQkFBSVJBeEVBUHdEdGZEL2diUVVzNDczK3pyUVMzRVFMQklGQUhmQXlEeDByYWc4TGFKYXplZEJwOE1jb0JBZEYya0E5ZVJWalF3Qm9sbUIwRVM0elYrZ0RQZlE5T2tBRDIrOEQrODdIK3RNUGgzU0dHR3NJU1BjRTFwMFVBWm4vQUFqbWpaQk9tMjVJR0FTbWVQOEFKTk5QaGpReU1IU3JYR01ZOHNkUFN0U2lnRExIaGpRMUdCcE5vQjZlVUtYL0FJUnZSY01QN0x0Y01NSDkyT2F2WE4xQlp3TlBjU3JGR3ZWbU9CN0Q2MXpXdWVLNTR0S3ZwOU5WWWpCQXpwTk5HWDNFSEdRZ09lL2ZuSXhpZ0RTazhPZUhvZzAwdW0yYUFENW5aUU1ESHI5S3k3Z2VFN2NlWW1td1NBdHRWaEh0VmlldUNmdmNEUEdlQlhNZUpkUW52dEl2Uk9YWW1HUGNaRkJFUnllT1JnNWIwN2RTTVlyWU5tTGlDUDhBZTRsV0pVV1VJR1pSM3huMXhRQTIvdk5MdDJmeXREc0dqS2ZLN2tmT2NaVUFIRzRIamtIcWVsVkZiUTduUXY3UUZta0Z2SkZ2ZU9GTU11QVN5NFRrbGVjNDk2eWRSMHlLMGlrRnZvODF4RmJ4ZnZuS0tSTmh3eDRZNEJDQnZtSFBPT3BxejRnMDZLK3NmdGQ1S2Z0VnNSS0xkMTQ4a2trUThkVGpna1o3NTRvQWZlNlBhSmNtT0t3SGtTN1VnYU5pU3VRdnpZTERIT0JrY0VFOXhUSk5GMHI3WnFMR0s0a1cybGVOVVIyS0xqQlAzaUFQejUvQ3JPcjJWcE5lV21vQ1Q3MTFFR0FpM0tpbFZWY2tqaGNrWUhIellOUjZrOEN5M1V0eVp4Rzk3Y3E4eXhrcWdEcmdIbkFHVkhVRVpUSngzQU5QUS9DMmczVVU4aHQzdVl2TDh4R2tta2JybjM5cTU2NXN0SXQ5UlNCTFdabFNkdk9EZWU2QUdCU3ZLOWl4Si9QTmRibzgxdllRengyOGFNSlk4QXBLRHViblBBSEgwQXdLZzB0N3VHNHZacHBvNW9KcHkwS3hsaVVYYXE0NmVvWS9qUUJpdzZIcGozcitkRklxRWhVUkxXNkc3QUhKeXB6bnJtbnJwV2xsY1RXVjJXSVVxMFZqZElWSEhERUxqZG5yaXV0TjM1c2V3eWxNcWVnNlovQ3JYOXVKRDVjZmtTT0NNQWdIakhyeGlnRGp4cE9ubU5uajBTYmErNGJYV1liZHBHQ0ZBSnczMDlhaWJ3N0NIRW9zdkxZTUZLbU9RUjdjOVFPcC9FOFpydHYrRWdnSUJDRTlqeWVENzhVNyszWSs4VEQyeWY4QUNnRGtOSjBEUzd2WHZzMXhaU3lXNjJwVWY2MUY4emVjdGduajVjYzU3MXc0UUJKbFI3dU52dGp4UmxaV1hnU2Jmdlp6anNNMTdPTmRqSi8xUng3TWY4Szg1YlFkUW1pSmpXMjJ5dExKc0xzQ0E3RnNINU91ZjFOQUdYSks4V20zY3g4Nk4wamtBamVlVHpOMndoU29CNHdjSDZIT1FNMXNUVzBjMXdvdFpwZkplZGxVL2FIUUl3a0FJSVBJUWRQUWo2NXJEdjRuczdlNmd1MUx1dHQ1RWdTYmNON3FRdTQ4Zk11ZW5Ua1p6WFQzdGxzdkd4YzNFWU03K1l4QmNBQ2M1ZHZYT2NZT1I4bzQ0b0F5OUxzNG5obG51cnkvT0x4b2tBdVpNZ2J5b0FVRWc4a2RjMWZrdXJTMzArSzh0NERxRVVyRlUzZWFqdmtrQXNVUEE0NU8zQXJKTjNGRDRaa3MvTWtnbG5sa1MzbGxHUG5YTHB2UFBIeWRSeGtkcTZXV3p0TGkxaGdrdFZlSTRBajI0SGZQMDY5UlFBeTExM3d5OXV0eHFGalBERzNCa2d2SloxWE9NRWdFT004WStYbklycGRQMDd3MXFrVFNhZk45b1ZEdGZ5cnlRN1Q2TU4zQit0Y0hyRU1kdFBCcE9tM2tkaWk3N200S3NCSnpJZHB5MkFlZVNBZVNCbmlvRTgyTUdhMk1rRnlvSVNmcWlNVEVXMnlBZzQ0QzViKzhPS0FQVHY4QWhHdE0vdVhHZWVmdGN2OEE4VlFQRE9sZ1lDWEFIdGR5L3dEeFZjZnB2amJXTk91b0xmVUkxMWUzbGlhVDdSYmxVa0FWM1VsUm5FaUVLQ0NNSG52WGQ2ZHFkbnF0c0xpeW5XV005Y2NGVDZFSGtIMk5BRlFlRzlPQUlIMnNaLzZmWnY4QTRxaHZEZW5zQUMxNE1kTVhzd0kvOGVyV3BLQU1aL0NtbXlCZzczN0s0SVpXMUNjcXdJSUlJTFl4Z25pb1p2QkdoWEtxdHhieXpLdjNWa25kZ3ZBSEFKNDRWUjlBUFN0K2xvQTVnL0QzdzRXM0xhTW5PY0s1QXByL0FBODBGdDN5VHFyZndpVGdmVGl1cHBLQVBCZFh2cHJIV3I2emp2YnNwYjNFa1M3cjlnY0t4QTdlMUZRZUpMdVpQRStxcUp3QUwyWVk4cFRqNXpSUUI3am9HUm9Wa0dKSjhsY2s5NjBheS9EZ0E4UFdJVWdnUWprVnFVQUZGRkpRQVZsNnJyYTJJZUczaGE3dTFVdDVLSDd2R2ZtUGJQWWRUa2ZXcWV2NjVMRWsxcHBqUi9hVUtyTEk1SUVXN29GNE81OGNnZEIzOUR4MnB4MnIzRWNLeXp3M0FnS3lQR1MrOE9ENWhZTnc1SXlTVDJIcUJRQkRyWGlLNmt2NEVlS2FhNldWVElaa1pJb1FSdVVMdE9GT0QzNVBISjROSlBkZWRvV3BoZ3pyOWpSMldWc3pLZ0txTjR3TU5oV3h5Y2tFbnJUbG1TTzFSTE9CSGhtZU9KSExobFNSZUdXVURoaHdSdVhQUUQzcUhVbzB0OUV1M3RHU2JUMDB1V1R5blFaMnN5UEdyS2NNQUJ1MjU5Y2NZNUFHNm5HcHNwblMrUmpFa0t4b2lBbmI1b0dlUU1nSGFTdVQ4eHowUE8vZTZ3bWo2ZTk1ZXdTQ09CbFhNZUNaQXhBK1hrRE9jNUI2WXJGdnJXMlRRN281eTVOc01MZ2hTSllpeE9QNHNiTTVQLzE1cnpTNDlOdTU1b3dFaXVJSW9WWmNEYWpzVWtkUmtmUDh5NDl1bVRRQm9TM3kzVnBGdXpkeXhnM1R3eFo1VGZtUFBHRzJnZzRCNUtqRlpGNUxMcTBiYWRjV2kzQW1rYUtTNDhzZnU0MnlVT1Jqb3V3RWM4a2duTmFrRjNwOWpDWWtXYTEyY1ROS2lncVE2eHFBQWRvNVljRGpIVG1xZHZQR21tckEycDJVVXR5N1NYRHFpSTB6dTI0eEZPcThrcms5UTNyUUFsb1JlNmRwNHZvNWhjSmN3UExzaTZ1cWdmTU1ZVVlJNi9UclZzZVcwbDlETmJ0SVhudUF4V1VodHJUTUdDQUFuRzBnc2ZRcjFxVzZoZUc1UUVSaG9ybUFsNVRuZDkwSEl6bHNuNVFPY0VaN1ZIRllTRkx1YlkwamkrbUtrRVBKek0yZHJFamFjQlQxL2h4aWdDc0xMV2JhSUdMV3BpcldSSXVDR2t4T1R3MnhVUFJRdnk5S2xlZlhaWTVvckxYWjBMUklrSDdtNC9jeWZ4TWYzUHpBK2hJQXFWZFNhMHVidTNsYTFqYUpQdGlqenRwRVpKVnk1S055R0hVREJCRldocWtjU1NOOXBzZ3NjU3pzN1h4eUVKNEpVUWNBbklvQW9tVHhKZEM2Rm5xbDVFMG9qYTIzeDNKRU9NYndTMElEN3NIR2NZejdVK2VUeFBNbDlKYmFsZFFlWUVGc0dndVQ5bUkrOGNHSE1tNzM2VnR0NGludHhLWjVyQ05rSytac3VuY0F0OTNueWVjNTdVOWZFYzhrclJKYzJwZU9SWW1WWlgrK1IwLzFOQUdEZVRlS0FKaEZmWEVXK2RKSXRzVjFKNWNZQURSbjl6ODJTQ2M5Um42VXlXNjhTeDd4RmZYamJycFpVSnQ3czdZTURNUCtwT1NlZm42ak5kQi93azB1N2I5cXRRZk5NUDhBclgrLzZmNm45ZWxOUGlpVVJzMzJtMndzUmxKRWovY0J4bi9VK3RBR0NicnhVWlNWdTVnVGVDUVJtSzYyckRqL0FGVzd5ZWNuSjNEa2RLeTc3eEo0aHQ1emEvMmxjcE1vblBFYmc3bUFNU1lrVWZjNDU2TUNjODEySjhTU0c0a2lhNHQyZUo4TXBtUHlOdExmODhQVG5QOEErcXVFOFNYeTNPdFNYMzJoRVdSWWhjdkZKNW9jNEd3Zk5HdXdoVzV3RG5mMklvQXlkVHZXdXJhOGpsWWxueEt6TXd6dFVFNTNzeHovQVBXNHJyaEpGSnFLSmVReXlONXhsSmlIeWxCY3NGY0VEQ3NkeHlNaklPQm5wWFB4VzczV25YQ1p0MWNZREswaWJBeGpKSzhqUFRrQURQZnJYVHdGMTErRnZzak9ETVpBV1VNUTdUNTJaN0ZSdVBINDRvQTUrMXNWYlQ3UkdsZUJiK2QxYmpNU3lSdVdESE9WQlpRVndlUFltcjY2WHFUR3kxR05wV3VvSTQ0Mkc4R1NQYVNDRlg3aDNEaGw3bFZJNlZXaWFFZUE0NGJ1UUVTU3JzZUE3V3g1dnl1QmpzTUhrWTljMWJ1OVhtaWg4alM3V1NhYU4yUm5sUU5tVEo5R0djakxESFVmU2dDdjU4RjdwbDROWHVJcm1LNG1rU04yZ082M0pkMUF4bk9DdUFNZDhnazlhVFRqZDN0bktsMEZpYWFGV2U0REVqYXNpaGxQWExkTWo3cHlCaW9JTlhodUpYZTgreHBOUEY5bXZJakcyd051R3dIcnVPRHlPb0J3T0FUV2hDOWhjV0U5dnAwRnNqRnNGYldSVlZaRmxpSVlTREFLamcrL0l4bWdCODhBYzZjdHRjekVyQ3dqZnpzeUtnZHdGTGduSlhqUFBPQ09hYk0yc1dWM0JKcHJ5cGNnbDBUemt6TkVHQlpBWHkyY1lQelpBNUE5UkZkaU9TOFJsdnBvbDJJMTJMYmQ4NnVUaEZ4azdUdVFrOVRrNU9hZk0waUxiTkRkeVRiYm9TQkhtMkxJRkRrSkdEazVCNEl5RGdmTmtVQWRwb3ZpcDVaNDlQMXFKTFM3a0dZcEZ5STVobkE2OG8zVDVUNmpCTmRMWGs5N2EyZXAzVFJUQVhFN3d5bzVHQ0ZEU0JndTREREVNbytiSFBBNUlyZDBQeFRObzh5NmRxMDAxellvaWhOUWw1YU1uakRrZmVHUjk3QTI4YnMvZW9BN3VscEZZTUFRUVFlUVJTMEFGSlJSUUI4L2VKQWYrRW4xWGcvOGZzMzkzKythS2Y0aHRJWDhTYW01VmlXdkpTZUQvZk5GQUh0MmdBRFE3UUFZSGxEZzFvVm0rSFNEb05udEpJOHZxZnFhMDZBQ3NYV3RWZEpQN09zM2FPNGROenpCQ1JFdWNkY0VienpnYzR4azlzM2RVdm1zclhNTWZtM0VoQ1F4L3dCNWo2K3c2aytnTmNScTlycXlyTEZhU1N1SnNPeXM4UUcvdWVWenlPLzBIYWdDdEpNaXdyYldVcE1rQVV5WVVsODdXVlMrY0Y4dGpucG5tcWZpR1MrMGZ4REViZHA1SnBrTVNLR0d4bTJSdGdkTnVTUXVjOS9lbitHZFB1cllTdGVUUExkQlF2bHJzS1JxRzJncVFPVGpkbXRUV0ZVK05JNDVVeWtrVWdEcXhCWDkzQ1RuKzZNRHFNSG52MkFLSWlqaDFpM2xXMm1saURwSEJFZ0d5SlhVbVhLREIzNzFQWG50MnhWN1piMnVuM0NXdGdMZWQ0QXlRRUtDNVVxQ0RnbkdBVjZuaFNNY1V5WlJKcWhhYWQzaGpBTWM0UWphektxNVhIVlNPQ1RqRFpOWExtUC9BSWs4NXQ0Z1p2S3dydU1sc2tZR2NuSXh4bnZnVUFaV3NLcjZUZXdSUUxHNDhreUJSdCtZU3AzR2NBbmpHTS9MbXBMcVdHNHU3ZTVmejRYZ3dvM3hoOHRnN2NLU1IxT1FRTThDbmFzMS9GcE1yTENHVlZRbUtRbGxkL01qTWVHeUNUOTRFakg4UHBTTzB0OWF2Y0pOYkdPWGRtVmlOaWZNQTZMOCtRU1JqQnp6MjdVQVVsbHU0ZFNNa1Z0UEk5MER1a2xtamFaV09RSkV6a2RnQnhqQ2dBVWEybHhkNmJQWXVxM1d3QlN6UzdwRkxLUGxPZnZMbkhKNXp4aml0S0NDNm1oZ01NQmhnMkFySDkwN2NjQWpmakl4d2NFakp4aW1xdDlaelhFWnRra2hXSkpDcnpIRVVmQ2c1SndUbU1FampHTTlXb0F2WFl1cFRhelFDZGlaWXM3ZW9JSTNjRVlBOVNjZkxudmlxd1NGN2hNTS9uUlhGeE9MZFpRTW9aR0c5OG5PTWdEcDY4WXpWcTZ0WmhmckpiM0NxZk1WbTh4Z2NMdjVia2s5V1VjZXc0cG9EbUozaml5eVhjL3p1Y21QOTZ3Qi93Q0Fnc1IxQTlLQUltUjVJSVMwZHpOOWsrYU5rbTJPVGhodExxZStleFBIWG5HSTlRdjlSMGVKNythRm9MY0lKSGsrMk81TE53QUl6SUFCbkk0YkpKSEZXNTV6RE01YTRjS3Y3eEdiTGVjeERmS01kTWZMakhQT2FnMTN3NUxENE5tbG4xcTdudFlMYU9XU0tkWTh5ZVhoc05KdHp5UUN4Nm5GQUdGYWVOdkV0MDR4YVc4UHlid1pMbVVkZWc2bi9PS21pOGIrSWc4UWx0SU1Nd0RGYmhzWXoySlBjVlF1dE0relRSNmxIS0JITmJydEtra3RoOERPUUJqQnh4L2hVRVZ2ZGVYaFoxZU9SUUFoUlN3S3NlZXRBR3pQNHo4U0tKVEhhVzRLWVlvMHprcXB6am5keWNqR0tiYStNL0V0MXFLV1J0N1pDNUlWL01mNzNZZmU5ZTlVMHQ1a3VTQTUrWUtxYmdNT1BtR091ZUNlZndxMzRjU081OFNXME1ra1VoWlhZRGJrTGdEbkgxRkFHcmJhL3E5M2FXbDVoVnM1WTNlYWZjNThzSXJFa2dIQVhLa1p5VDdWeU4zY1NhbWo2aGRabW5ZZnZBRVpTTW5jRitZQmpnTUFNOVJqNjExR3FhQjRodC9EbDVEcGQzR2tFRXN6eHMwcFZ6R1dMTVBsR083WUhIWHJYTG1XYTh0bzU0bEtXVThJQ01yTnZWQ0FVM1pQVVlJM1p6MG9BMHRQUVJhYnFWdk1pTXlBek9rcWtoOTBaQ2xUakFKUFlkSzFzWGN1c1F5eHpoVWFadkpJSlU3ak1DY3J1R2NMZ0hodWhHQm1zdlRyQzVUUkxtYUNJMlpBWUMyV1ZaRkNiVDkwRVlSZ2U0R2UxWGxDZjJsWVp1RUR2cUV6dEpnNFFNek53TSsrQVQ2WnhrVUFWTk11N0FlRzB0OVZoWmJkd3lPQ3JTQXB2T09WNTV3S3FSNnRIcDZXVUV1azNsMmZLUzNuYmFwRXFScTIyUUx1em4yT09HNjVBQlNHOVMyMHByTlltZ21YQlZXYU9NN2l4R2NNYzdoMUdCM0I1cTliUlRQTGJTUjJqc2lJcXMxcTBZRFlHVnhua0FZOVR3eEJ6UUJYMXJaYjJoUnhJM20vdmo5bGpjT0gzQi9tYnFQbUNuazlRT01pcXVtU0lzZHpielFPMGFpRUlKSkNENWozRVk1SUFiSUpRbmsvZEdNVmNqdHlrczFxYlM0aGFmN083UW84U2tIek40SXlPcEtNZU05ODFKWjI5OWFYTWtseThzQllxdm1TYlpUSm1XRkZKendHSklKT01kTTR3YUFIQytoM3ZCY3JOQ3BqRVZ4SkpFV09IY2NzajU1SUlYR0RqUG9PSklZWnJtQnJhV040b0R1WHpTd1BtcXhaV1BBRERLQWtIcWV0VjdKdzMyUVJnSk1JZkxqRWllVVcrZmZoMHo5L0c0a0RuQTdacVY1NzFwUE1ZbVM0UjkwWWExYkVoK2JBUmhuQVBiTGNad2M1b0FmcWlRUTZiZTZmSHRpalRTYnQyUUtRM3loUG5iUHpLUU1jSFBlc2kzdkgyUlFhbkk0RnpicUlIYzRZbkczRFkvNWFBWlBIQkE0NkVWZDFmVVpicHRRakxXODhSMHJVVDV5RHFWUkF5a2c4Z0U0eU03dTNTdVpoWmIyQzB0TnlNbm5ScHY4QXZqY0N2SXo5U1BYMjcwQWVpNlpyUC9DSXl4YWZlU1owY0lpckpKSUMxa1dPMVI2bUluZ0hrb2VwMm5qdXdjOGprVjR3ZkE4UkJqUzZoSWZMQ1UyNUJERVk3Tmo3djRkNjdud2xlemFYS25oN1VMbFpkeUY3QjhFWlFkWXVTVGxSZ2pKNVUvN0pOQUhYMGhwYVEwQWVLNnRwNGsxaTlmeVZPNjRrUE01SDhSOXFLMTdxT0o3dVp5Z3kwakU1QjlhS0FQUVBEdVJvTm9DTUhaL1UxcGtnREpPQVBXczN3NnhiUXJVbk9kcHpuNm1wZFJkblVXeWRaQVMvc282ajhlbjUwQVlkMWYzODE3SmR4V21VWEtRYm5DbmJ4emp0dTY1OU1aSFdvWlovdEp5WTJqS3N5bFdQZFRnL3FEVm1XN3Q1TGw3ZU81SG5JQXpKbmtBLzA5L2FzVzQxT0RTTkplNXZvNUVWSjVTVmpqTGVXalROOHhJNktBUWZ4b0FzMm9BdVpCa0RBZFFCamdlWWZ5SDlheFBHTnVrbmlkOTBNcm5ZY0ZQUXh4RGoxT2ZYMHJlc3RyTkpJcFV3dnVrVjBmY0czSGRuOWF6L0FCVEhjdjRqdFhna2RFVVNibTJqQStTSEFHUnp4bnIwN2MwQU5nbFc4bldXWTNvZVlMS1lqdVJrd2dFaUtWd0NCdEFLZ0RxVHpuTmFDM0prdDV6a2hSQ2lveTdDQTVjZ0JTdkJBQlg4eFdQcCtvM2E2dE5ESWpsdzVaRkRncjFJQjVQQVpRdVFPaDk4MWR2cnlaYkkyOTFOYlBJelJxekJoR1NwbUFQeUVrOERHY2RjbkFGQUM2Z2tzR2d6K1NWWmN3cWhRWkw1bFFjS09nSE9QcWVsUjJkazFxVXNWRWNTM0V6dEVzQ0xoVjNicFc5MTZBQWpJTEhrNEJwTlZNRGVHYmlhUGY4QU9ZWFZSZ2tabWp6MFBKSEdhWmFUTGE2YnE5NWMyVHZlMisrS1NDMUxmT3VRL3dBbURrSytkeEE1QVlqdFFCWWgxV2ViWEFFbVVhYzByd1JvVUEzc0ZBQVhqSitZTzJlbTByak9hMDVyV0M2dXJoWllnK1lVUWs4aGwzRWdFZlgrdFllaDNNVFJHT05aWmJxQzRXTGVyREFSZ1hERFAvTE1BN2NET01BRHBXeGJYcXlpUzRrdHA0cENWaWNmZkFLdG5ranRsc1p4UUE2NkZsL2FpdkxtSzRRRFpKdFhqNXVpTWVRU001SGNBK2xWWUo1WW1rRG9ZeTk1SXcvZDdzcVoyWDFIK3orZGFGN3Rra0pNZThCOHF3YkE0NXllY2tlMzQxaldXcFd1cXp6V01MWFVjN3ZOUEZNRitTYUUzREg1VzU1UEdDZW9KeDdBRTF3MXdFaUorenpYRXJrb09xd0hCQlB5NDRDNEhYT2ZVbXQzeFFCL3dnT3BCaGtmMmMrZisrS3lvNUpSNXNrWVc2WEdZNGJkVjNHUUp5QzVia2tudjBxSFh2RmNjbmhMVUxTNTA2N3NKSmJTYUNLU2Z5M2phVUlSc3lyTmdrZzQzQVp4NjhVQWM3SXNxeko1dUpZVWlqWUtWNHo1bWM0K29IUHNLNlh3ckN4MGVRWWxFdjJsUVhXSldHQStRT1IyL3dBK3RjcTkxYnk2Z0VSU2grekJqZ0hLNGsrN242bk9EWFgrR25XVFNwc0pFV04yQTRNeFhCM0QvUEZBR3pIRzZYQjgwek1QTmsyLzZPdmY4UHJVU3dvOTFZamJJUWtUci9xL0tJR0Y0NmRQcDdWTmJSNG1SeEdBV21kRHN1R1ByMlAwcFZaNHA3VHpFSlJVTzU1SlFUMEhhZ0I5MUZ1OE9YMFVlMFpobVVjNUE0WVY1WEJkU3hlRjdVSElqVzJUZHR4dHh0QUc3K1hIUE5lclhDQTZGZW94Y2hvNWdTbUEyRHU2ZTllVjJheEpvVnZPOFB5UGJSaVJtd0FDQU1aSHAxeWUyS0FOalRXRWxqY2VVQkhPOXJLVjJLSkYyamNWSlBiakIyNUdjNTVxZElMY1gwQy9aNVRHdHpNemxVQkJHODhjZzRHZDNjZGZlb3JLeWhHajNXNnpFemlGbFZnKzN6bDJIbHlPdlRQekRyMHFLZlhKN085MjJ1bVNYSnNiMS90TXJ6c3FydVAvQUMwSUJDcmtxZHpjZkxuQTROQUMyVnM4Mm13S3lvWlN6N1RLdkl4SVR4amdIazg0SjlNR2sxa3c2Wm9WdHBrYnRGSmVrUmhvdjNMbmdzN2dJT01rWUlHUHY0RldOTTgyNDBqRnZINU4xWm1hM0p1Rno1RXVUdzJNYmgwT1IxNHJNdXY3UWoxV0s4MUNhSzArMVhVVm5GYnNkNlN4ZzVMcVI5eklDKzVPZWxBRTlwOW9mUXRNYU83a045QTBkdXFTZko1dk9jTUR5cmJGTFlKL2h3ZldySDJ4L0xlRklycEpVS0orK2liN3IzRUliR1JnaFFXNDVBQUI2R3Bvcks1L3RHM2FXMWxtanQyVlk1bWtQWEdYY3IwSEoycjF5cE5QU0M0RjdkZlpVa0RRZVZDQzUrZVRNa1RGdDNYQUJZZW93ZmFnQ2hiVHE5OUZFMXVrVHhKaTA4cUlmZUpaaVN5L0x3RGc0OSs5V1BKYTBsaGh0eWtrYnpCWTBoSlNLQlZERm1QSno4KzNIWlN3eDZWYml0YnFTN2grMXZMQkkxcU9JVzJrWVlrNHp6dHp1eG5xT3RKTmIrWWsvd0RvenliNUZDeWJsY2tLK1kyQndGVUQ3MkFEZ2p1YUFNSytaUzdoblI1RTBtOVFlV3A4aU5QS1hqcjE3a2ZUcFhNeDJLSkpheTc4Q0dTTU1pbmNVQlpTTUU5UjA1Njg5YTZuVWJWTEtTVmxab1dPbTZnd0pZQkZZcEh1YkE1eVNSengwRlkwTVJhZTNpV1JzR1NOUy9BWWZNbkpCQkdjNHorRkFIWlEyYWZaNUkxYVdNSUZSUkhNeTR4RGoxcGJxenVOUjArM2tEdEJlcUZuaGtPQjVjd1VsVHgyeWNISFVFanZUTGF4dTRQTVo5YWxXTkFDN3ZERnlCR1J5MkJpcjhpbWUzUklwV2lKVWZ2WWlyQlJ0Nmc4ZytsQUhUNk5xSjFQVElyaVNQeXArVW5pem55NUZPSFhQZkJCd2U0d2U5WHE1WFNaWjlQOFFzc2hZMm1vb29EdndmUFVISDVvdi9qb3JxcUFQTjNpTHV6YlorVG43d29yVHRmTmt0SVh6R2QwYW43bnRSUUIwUGh2alFiWHAwYnAvdkdxOTVQNWtGMWNvUzVJMm9xSEJJQndBRDJ5Yy9uVE5Pbmt0L0I4YnB4S1ZLSm5qNW1jcXY2a1ZVMUc4dHJPQ08zbWtLeHdLQ1Qzd0I4cW4vYU9EL2swQVl1bVRSUDRnazJSUks4b2RYeWRqN1F3MllUODhqcndUME5RNnBxRXNGNU1sdTl0ZXZHSlRQRElONk4vR2lFajdyWWQrUnp3dVJXYnFTaFRiNmN5eXdUSzRmekZYcklaQTJWWVo1VWJlZnIyclN1NG12dFVmUXdVdUxZazNhWHNLWS9mQWpJUEcwc1NUeDBBb0FuOEhKSEY0ZWhpU1JYV0JXanlvSVVmTm5BejFBempQdFNlS3J1YUR4VFp4eFcwTW9hR1l1U21XQ2hJam42WkErdVFLdWFDQWtkOHNTZ2o3YmNFOWNrK1lRTTU5c1ZtZUxwdko4WTI4cWZOSkRieWIxWTRVSWZJeWMrZ0c0L2hRQldlUXRlQndIdHlYQ0o1VUlZRml1NEV0emtBODVIR1RnMWV0N2lHNTArYTRsdGxrbmo4b1M3V0REekJJTXFQUitBU09nM0Flb3JOdVlXbXZabnVCR0lQbFhJTGN4NXlyazhkODVPQnljY2dacDl0ZS82TWlwS2p3QW9EdFhKRENUdUNCNkxqQjdtZ0RSdkpXbThPekZVZVNacFkwU000Q3BpV1BJNktNWndOM1U0cVI3S0NUVGRUaUdJVGMzN2plQVNXR1ZidHlmbFVqanNLYk51aTBhNVVXN0lNUWgyWlNyRi9OVVpISkcwL2VBN2ZqV3ZOYjJCc21TZVdLSUtkdytmREk0NUJ3RG5PZnhvQXp0TGdoTVgyeTFueVlwVUhtdEh3RmRJMkNrRHFEdlUvcDJwTklqMU9UVGhGSmNxaUpLMGJrYmd5a09jNE9TUDg5S3kvRGR4YnlYaHNHMCtWVDVranhzMHpQRXJqREhBUGNrQnNjN2ZsSFVZSFVXcWZZN0ZzTDg3U05zVlVKRE9YNEdCempQWDBGQUdmNGsxZVhTSVhudGZzM21XeXZJeG5Ma0FBY0tGVGtzVG5IcGdub0twcG9vMHpVTEM2dHpLWHY5UFpiaU9HRXFqTjEzR1RQeUhKVUFmbGpGWFl2QnlTV2NOenJjOGozYVMvYXJoaXcvZnNBMjBGUjhxaGM5dWVvemhqbkllemcweldMeTkwVFU3S1N3dW1WMnNFWmRtM2F1Ty9Ra3RqR09XQTdZb0Exb0ZZK2RjUndGbzFDa3NDVmttWlJ5RHVVWSs3Z0FIQnd0WTJvNlhwMnJ6eitIYkc4bWhudG1pdm80V0daYnBpdVpOKzRqZTRJM2RSOHpjbjAyN29nWFNLSVhsU1NWV1Y1c3liVjJra3JrNS9peHdPTytPS3NhN3FkbENiUzE4OHhYdHhOSEVnV0lNeGo0RERMY1lPN3JuK1J3QWNFWjdsdFhSNyt3dWJPYWFMRnUwdUFrNkZnd3lRY2JzRUhBSkE2WnpYY2VGY0xwVHgzRXNJQnVBVlJreU1idU9jKzFVdkVDMkdxYU5OSUVuaGZ3M2NvSGlLWVo0dHFuQkhZWUlPZUJsTTlLdTZQTU5QMHVWRGVpTjdlZmZMR0F1RGdGc0E4NXp4akhxS0FOeTBFUmNrdFo3elBJUnRUR1J6anY2VUFuN1hZSjVVTEVxeExwakNqQS96K0ZjM3AveEFzWkdXRFVZcmpUTHZ6QnVnbXNuZGdHRzRNZG80WEoyNVBjZW5OZEdzb2E5c1ZSRm55aFl0RUFvVGp2ejNvQXNYSkkwTytiemNrUnpIZjJIQnJ5KzJkSlBEb2VRczZ2YWZOR0VHWDlSanBrODhWNlBxMXhMQm8wa0Z2SkJiWEZ3enhSUEttNktNa2tBa2NmUWU1SFd2TnhZWE9uTGN4WEY3YXl4eHcrZEJORk1Tc1NCaXBVc2NiaGxUaGo3OWFBTCtpSnQ4UHU5amVzWTJpbGRHbWZQeWdzQ3JBOVNBVkhQSU9lUlc5RkRGdXV2T3RqTGFzOXo5clZXT0NHeWdMb0IrOEdBUjZqakdlMkphMzAwdWxYU1RXdyswcGFUTkcyMGVYNXFLMmNoanVWc0VOMXhnOTYyTHU4dDlOaVcrdUN5Ukc0S2JvbzNrSU11NGhnb3lTY2UyZWFBT0MwL1dyelI3SmJsTGk2ZlVXVUs4TThKZExsQUFxTTQ0S3NvRzBOL0hqSDhKeG8zRjgvaTYwMHlXRzFLeTI5Mkk3bU5KQm1NbGVHR1JraHNIR09jakhOZFBwTTh0M3A5M3JhVzVtU1V6U1c4RTZLc3p4Z2dzaFBRQWtNUjZGcXo5U1RUTEs2c2ZFbGxid20wMURhckV4K1Z1Wnp1L2VBakFPT2UyV0E1NW9Bdlc5d3NPdlMyZ2VWWWlzU3JFVnlvL2RnNzFQWmVDQ1BYQjcxV3NaSjdwOVJTY2lLUXpra1NuWU5pU1E5ZU9oVTR6MDljODFHbXM2WDRlaHQwbHM1VUZ5NFZaclpBOFVtemF1UWM1SUFZYzQvbFdsS2JYN1ZMcUgydUthQkZXQm8xa0RoU1pZaUd3RHg3blBRZTFBRlNNeUcvTm9qbGtoZ2oyZ3VyQmwzTUdCMllDbHRweUJ3T3ZmRlgyZTdmYjl0aE1keExPVmlkTnJpTDVUZ25IR01mWG1zVjc1TFRXVlNmVVlZbFd5aktQS3l4cWRyRlNDenRra2pCeVR6eDZWb080dEdzZFBrdjFNOTU4dHNQSkpZN0NDb1VyZ2RlVzNZM0RwakZBRkhVQk5POGd1b1oxSzJNOFcyYkFNckZvc3NGVW5nREE3Wno3Y2M1Y045bGxndVUzTkw5cEdFQkRidm5VWTZkUU8zYjhLNnU2VXgyanNIMlFQYVNpTmJaOGdreVJLZGc0Sy9ubjV2WVZ6MTVjSkJORkpJV2loaXVvdk9jeGtpTTdnUmtnY0hHZnJRQko0azh2VXJqUzdjWExiSkVrVlFUbU16ZklFOHpQVG9lQ005Y1ZxK0dyZTV0OUZsVk15Q081bEViU053d0F3eFhBNkYxT005dWU5WnI2eC9hVWp0S2x6TllscEltdDdaQVpGQVhDU01EakxaWW5KNEEyajNPVFo2cHFHajNLelFreUpLV1FRU2IxU1U5Q3dVREc0Y2NoY0FuSGVnQk5ZbmUwOFUzTXpSVEM5aHZGbCsweXVUSEV2eXRFQVJ5QVJsZWg0T01ZTmUxNlJxVU9zYVJhNmpibk1WekdzaSsyZTFlSzZ4OXMxM1dJU0lsdDV5ZkxXSUt5aU9OUUdSbnoxVUJ6bHVoSmJIR0JYb0h3c21BOE5DM2FVT3pNYnBNWjRqa1pnT3YrMGpmcFFCUHA4RXAwNjJPRy93QlNucDZEM29wK2pxUDdGc2VQK1hhUHQvc2lpZ0NhMU9kRDB5RlNvSG1TU0hLazhMdTZmaVZyTzFCWURjS0pRcXR0TENZY255d3BMUHgwSVlqSDZkeFY3VG5OeFp4d1J2dGxpdDIydjFHV2tZWXovd0FBcXEwVFhtc3lTWElPeXpBalpBT0hmRzdQdXVDdlh2UUJrYVRNcTYvR2w4cXl5ckc1M0pHWlNTVkM4SDBQSlA0ZE1WbFRTM2VseXozVnZLbHRPK29pTUp0R05waVlnN09oQjNJUWM1T0FUazVGYU1rYXgrSlk3YU5WbjgvOXpKdUFDczIzekZPZmNyZy9YMnJOMURSOVJmU1lwMVdCWi9QZTZqVEJ4bG5WRnhqaFNNamprWUE5NkFOL3diSVpkRDg5bUprYVNSbU9EbkpjazU5d2VEVmJ4ZlBISDR3dEhYY1hTMnVBd1BJSjJ3RWRNa2NkZUtzZURrTVdnR05HTElzc29CWURQK3NiUFQzcXRxMGtWNzRqdU5Ramxoak5tczhVZ2QxVitCRU9wNllJNm5qbWdDbmNYMGxuZWxiaEpaSlhhRkh2bVE3ZVFRT25JK2dBSFBXcWVvYXZNMnEzdHJib0xpMnQ3ZnpJNDdoQkJJamJsK2JKeU52djZkT2xkVEN0eGRyRFBwVXJUK2E2d3gzRVM1amo1SWVVc1NDMkYzQmR1UmtnNDcxeW1yM054ZStJa1M2aUZsQ2plUkRFcjVUYW1kdVd4aGlRUng3SHJRQjBxU1BQbzgwakdFVEh5Vmxpam4zN21ESjBQcGpQT09md3FlYURTOURnbXZXdG9vMFdRM0R2SGJqZG5jT2dBNWJPMEEvajJyajlhL3RPenY4QVM1TjRTUUFTeHRrRExxY0hqSHpjTndQclhjYURvMm8zV2hNbXRYMHNqWFIzU0JnTXhBa1lqWGpHQU1BKzlBR1M4Mm4zZXNhSGFhUmRMY20wVnJpZVdPY3VrYXJIc01lMGNjc3dQUElPZld0blRwcHJiVmIrM3RMRmJ1OWhqRHM1azJMR1h5d1J6eWM0Q2s0QjRaUU9sWi9pV1BTSTRMZTZndUlySFVZcmxybTFsaGo1a08xZ0FjS2NyZ2c0NzFsZUd2RjVzTFBVMjFPNFJwSnJuejdpUUtSNVNQdEc0ZW9HYysyQ08xQUhRK0RyRzN0VXZMaS91WlgxY1JBYWdaV2JxSGM3a0o2cDFBSTR3bU9vTlp1dHpSV1NyUHBsakJjYWhxazBzc0Z5a3VIR0RsQmh2dmdoZUJuQXhrRGdVWG45cTZ0YVRYVmpiUXdmYUpHZ2l2SlZ5SjdNQTRBNTNaSlk0NmZlejJ3ZWQxQzdNY2h2TkxuRU52WWFUQ29RT0pXajNQdGJxT0cyY0Vqa1o3ZGFBT3JzclM4MDBSV1F1eGNFS1hna25HNWxTWExMNW1NSEN0dkJ4akkyK2hwamFsYjNMV2tPbzR0cjNUVEg5b3QyajJzN3N4VmRqUDhBZVFQakRLU1RuSEdTS3FhRHFPcDN1cW02MUMzYUVRd1FvMXVZanRhM3pLdVZKKzlrTUdQWDd1SzUrM3Y3c1hkam9haFpCYVhrUSsyeUV2S21aZUNTMlF3Ykt1T0FRR0NrY1pvQTdqV3J5eDB6eEQ5bXZCSEVtcHhSMmJ5NEEzakQ4Titad2NjY0R2VkMxYit6VW44TDZtOHoyZHE2eVdrc2NuelBhTHM1eU1rbU5zYmh4OHJaSEZaR21wNGw4U2FpbXB5WEZ2R3J3bEdsbWpEbU1BNHpDb3g1YkVNVG5KT1F1VDJyZmkwQXRxcVMzRjlkM2tzVXJ6cE04Z0RaZEFoVENBQURaempIcjcwQWN4YjZqYWVIOVVUWElMbTRSWmJxVVhNYnF4RWxwSXhFSkxuS3FVK1U0eUR0SXpnbXUwWFZiSzgxT3dWTDJDNDJSeUVrM0tiUVZ3RG5hY2ZuMHhUdE52VEcxeWx6RHUwNmU4K3oyN05Ec1Z0K1RsZ3dIQWI1QWNmTnhqT2E1U2N4YUg0eTFHd1JmT3RybVJJL0k4c1kzeUFNQXE5TTdtNTlRY25PQ2FBTjdVZFZsVjUwL3M2ZG9yY3licEJGbEMzbVpSRnhrc1hPRjRHUjFQYXVSdlBFVWV2ZUo1bmV6YTJqbmcremVUTmNEQVpOeHpqb3ZPNGRPbzY1T0s5RGI3Vlk2YnB3WlZsbkRxa29EQVpCWUF1TzNCQTQvRE5jOWQ2SEJyMGVyNllsaWx2TEpFbHhCZHlwc2NTQkJoZ1J6dy9VOThuRkFDVzBOdXZoNjVFOGkzS3VrZ1FtYnpkNUNzb0dRZVNRTVk3OSt0UmF2ZjhBOW9wbzAwOWhjV1ZyRGZOTGRLckV5TEltRTQyZGxMWlp1MjBpc0N5bjFTYnhCWVJUemVZSlczUU95a2VXKzJVWkF3T1F3SXp3VGtacDdYVFRhRHFPck5MYnROOWlBdDVGSmRrRWtqeGtjNVhETjh4eHljNVBhZ0RwOUsxa1BMcndoTUlnZ2xJdHB2TURSbnplV2JjZmxJREJ6NkQ3dmF1YXY5VWdqdVBzTmpMY0d5YlQyMG8rWXF0R1dqVWxIV1JDVmRzdG5zVndSalBUTTA2MHVKb3JYVG9DNlc4OXVyU1JyR0NoYnpKUVRrcmtjRDYrMWRMTHBVVXRuYjZaY1R5TmJScVRHSlNGamlJQk80aFFQdXFXSko2NDY4MEFaZDVhYUQ5cHNyZHJ4a2ZVQUpyaC9OWGJaeU1WQ2JZczdRSkRuY3A3WTZZcmUwWFRiQzR0SkpiUFFvTk8xdTBDMjE3RkVvS2d0c0xFYlNkd3dNam5QR0tqdTdiUUxyVUlySzRrdFdpUTNkck9oVGI1RVFnQlVEUEs3VkFPNzFMZXRZdGxveW0ydHZGK3BhZGFRMjE2TVNMNXhpTUxrQUxJcE9BQkl3SEhHTndQSUp3QWJNYVdGeHJhc0NaTFkyalJUeXRDcEc0TSs1bTdZR3dldTNBQkE2Vm5hdllhTS9pUFEwaG1sdVRPNVc2Z2xsVnZKUitRcjQrWUU3d09UMHdLbTArRzd2dEQwK0FUd0d3dVlacm1TRVpFdHdQTytlRU5qYUViekl3ZU1uR1BXdWxrMFdmVnRVc2ZQdHpwMXJDODBqeHhTSzNua2dMR2NvZU5xanYwK1hIU2dDa3Ryb2xsRjludEliR0swbWhtRWlvUXE4N0ZZa0E1OVB5cm4xc3JIL2hGN2dhalBKSFpXbmt5VFJtQU9TMGpxUE1SaWR3WUFzdU1rZWxTejJja2NsOTRldlowdUpScUVVQmwvaU1MZnZ3N0RIQndwUSt1RCtONnkwS3oxQ3p1Yi9WRysyV3RuQWpvc1VqTDVqb0NTQ2M0SUlLakh0UUJnNlpiNlhhMzg2SmUydC9jTEUwbGhMRk1HREtFWWplUDRjWXd5bm9DY0RtcmVzMjAwTWNYbHVrVnhiM2pKYnpna2dia1Vxd09NTGpJWEJHTWo4YTJkUjhJNmRwWGhkbHRydFYxRFQwU2RybTZRT3FIdnVVZDJVc29VZjNoeDByUGZUdzlwWjNsNWErUkJBeGxKa0RTSXNXekFkOXB5VGhRY1k2bnJ4UUJIQUxCOWF2aXJBK1hmVzBFaW93eXNjU2tJT3VmbWxSZXVBVGdWcitGOVJqMC9YZEwwMThlZmMyOHlUYm5CWUZXM0lmb1R2eCtOYzdxTmxxMEdnM0YzSjVralh5d1hFMDVURWtMNFE3V0ErYkNGZmZyejBOUDAzV2JlZlZ0TXVVaUl1NDdkRExLaUVaQ1labElQUmZjZER4UUI2Qm8wZTdRN0JpQmsyMFpPRngvQ08xRlkxb2RZanM0WTdOTlNhMldOUkMwY1ZrVktZK1VndklHeGpIM2dENjgwVUFTYU5LSVZaVVJJMXRzcVdKeVg1TFp4N1p4MzcxWDA4UnpTM0Uwc1VwV2E0Zk8xZ3pJRklBSWI2ZlhpcE5KL3dCS3M5UVdOai94OXp3NTdBNTJrZm5VV2p6c2toZ1FySUF4YU5ZWkFNN3VlRlBZY2QrS0FLTmtwR3JMTG5jWTdwV0pIcHVWZS9zNXAybFN6dHA5cEdGU1EvWTRpdVR0d1ZsWUVaOXVLejdwcDRibTJuUUZFYTZqdWl6SERJU3k1WGs4akJCNHo3VTI1dTRkRTEyN2lnanVYdGJRSjVxbFM2amUyK1RrRWJWQUlPVG5uanZtZ0RWOEV2T05MdWxtS2d4M2NnSElPTW5jYzQ2bkpQNjFIcmR0TXZqbWE1aWhaL0tza0k4dGM3QnZrM095OTBCNUk1em5nWnJIOE0rSjlOMFBUN2lPL0VyU3l5dE9mS1FzUXBQSXgwQlVkaitkZFk4ZGhkM1dsMzJyWEVSL3RSMWEydEJ2VVNZeTZGbExmUHNMRGpnWjVvQXhYMDdYOVYxN1FiNjcwcGtuRHBKdVdZd3hxbUM1WFlTeFFnZ1pQZklGTjhRNlRxMXhkMnlha2RPTTBXMmFIN0lHVWhSSVBNUmd6SE9GNUI3NElHS3Y2WmVUYWY0enM3UnRYdWRRam1zd1drdUNOOFk4MDdoNmpMTW5IVURqb3RRZU1aMXNQRTFoZWFydFMyalNhZFZnekxJV0M0d01jcXBKWDVpTUFqazgwQVU5U0wzdmpidytMaWJ6cktPWm9ta2xBNGRBU3c5Z1FBd0o3TURYVytJOVYxQ2JTVXM5QmllTzZ2NDkzbm5nV2NKLzVha2RReHp3QnpuSi9ocnp1eDgzVWJUVnB2TGx1aSs0NzBWRUVidGh5dUNRQ1RqQnh5RUF3ZTFkTm9OM2QzOGR4TnFxUTZndXA2b3NBamppQlNNSXVkM0JPWTBLWUh1Y2s4MEFXdkV1bENId3ZwMG1uUXhBMnNrTnN5U0ViVUtueStUOWZsUGJuT09LeTMwcTIwVzBtTnpKQ2RWZ0t3U3gzRDdvTG1LVmxHMStNYmNFQW5HVklCemdqUFR5TEkrbG5UTkVram1FZDJyWFNTVEF5TEU3bDMrOTBQekFnSHNhNUczMDZTMThNMnpwYk1MbUc1L2UrWEV2bVhUUXpNQnU3bk8wWngzSTY0b0EzSnA0ci9SN2V6dGRsckRxdGxleDJnZDlvV1RLK1dnendQbEIvQUhGY0xmMlNqUWROdTRvVmphNXRYaGJZU3dLcEpnREk0NVZzSFA5MGVsZDFiZUl2RCtqZUY0dEh0cjlicWVCR0M3Y1NtSWdrbG54akFIT1FPY0E0SEJ4eU1XMjQ4SS9abzdLN2VSWjNsalNPQ1YxTWNpN2ZsZmJncmx3Y1o1MkdnRHNwSTRsdkxlS1NSWW80TGNSUnlTUmphTjNES3BQZkFYaitmYmw5V2ZiNGwrMFJEY2l5MjBEQXBrb0VrajcrdVd6eDYvV3VxdGlGMDNUU3kzQnVZN2RZQkdJcE9ISUdTL0dNREhVL3dBNnhwZEF1UHRtdVRLdDBUTGVSVDJ3K3p5WU9HaWNrRWprY01NSEhJK2xBR2g0S2JibzJXYmJzbWtVNVFqQUJ3TWY0aXRVM05xbXNhWTZTdUxxYzNFSWlVNVFrb0crYkhSaDVhZ2QrVDYxZzI4VjdaMkUya01iMk80Z0JrVVcwQW1NMjltMjUvdXB3T3VDY25HTVZidmRXbHU0bWpTMG10N215dm9aYlpaTE9VTTZvRTNEb2V1NlJRM3A5RFFCdHp5RFZmQjF3OWxNZ2VSUXNVa2lrQlhYQUdSMXlHR1BxS3pOYXZUYWFvMnRXK2xpK1JiT0tSekdDV1dUOTVzZmJqa0FFaGpuSURBNDRySm52YjZ4aFRRRkVwaTJTeVhDckV5K2R1a2RpdTdqa2dERzNQM2oxT0syN2U2a3RiZS8xZTlqbHQ3ZjdXaU5hellVUVJNaUpsZG82a2JTUm5BT2FBS3VtYXY1dmhhd25menBUOXRLenlpTVNDTXNkeDNucW95Mk1nSG5IUWMxUEkxL2QrSW83MnkxSFQ3dTFzdHNaamhjTEpraGdFY1p3RHZ3ZTNBeGpQSjVEVGRWajB2U3RSOEtsN2lEVWx2UnRWbFdQekNwVXhnRW5DN3RpQTVQTzc1YzF1NnAvd0FKRGN4eVhGcG85NmJrYmZtdUlWM0FLMjRMaFd3L0JZWko0eHg5NmdDaHFjT25QNGdzYk81TnFaWkpEUE9sc3AyZWF3WVBIenl1V0NPTW43MjcrOEtUeFRwOXNiQ0xUYkhlaVNNMDJ5TmM1Q0xuREhISkxNby9YdFVPb3c2cE5jWE44K2xhbGFTUzJ5RGZMQmlHT1hJeTdjbkdBaThqc0t1Njc0Z3RMR1MzdmtsanVJN2xSYWlGSlFQTFlydUVuSDhJQjJuT0RuYjZHZ0ROMEdHYTN2cllURWtMQTBXRy9oWVN6WUk3SDYrOWRMSGRXbWxURjdxR1c2L3RCMnQ0Vkh6b0ZHUE5MRUhBR0FmeTk2eGRPM3pDMW1oODE1cElEc3QwTWEzREVNN050VXNPb2JCWWphTUhyV3BOcFhpdVc1Ti9EREpIRTFvWWhGSzZzeU9YSTNDTE8xY29FeW9QYmp2a0EyZEwwU3lpMWlTK2tzWVBPV05udWJsdnZ2Tkp5VndSMENuR1FmYkhGY3dOVmsxelFtMEJOUGdzVm1tZ2p0MVFmS1lneExNQVJ4dHdNRHZnWTYxYzhTNmswZW53YUpieXk2VE8weVMvYXJoR1h6Sldaanp0VmhsbURIcldWWTZyUFoyTnZaTFp2YXl2R0huSDJhUnltSk5tMEFmNm9yOTlXSUFJT2VPNEJzYWJCOW9UVDMwNjNNS1hjYzZ3SGRueW8wZEZqWTllVGp6RDdnOWMxMEQ2amF3N25zbE0wZHFFaVJrWWJjQUJqeWVPUVY1NzRyejd4TFBxZWo2WGFhZWlhbEhEQnVUN1ZNcUdPZUU4S3UxVGhnYzU1Q3QweUsyZEIxSVhIaDJidytJSjFsbk13bGttVlFHVm00d0Zja2ZJUjhweHdNVUFaRTl6S2ZHUDI5QkhjYlpuOGhJZHNjMXhMdUs0S3N4eHd4VU1SOTNQNGErbjZDTlhuaWoxUFJyZTBNSldDMnNSUDVxMjZ4OHZNM1FNeEpDampzTTV4VE5XMHJUcjdSTFdON2RkTGV5dlkwTXFGWWpKdUJYZUc1T1M0eXZjRUtTSzQrNnZkUTBDNXVicVQrMEVsdUFYWVhCRDd3Q3IvZVU1VTdnY2prZHVsQUhiWEt3NmhINHkzUWlHM04xYmJBcS9LN0FyKzh5T3VTQmtucGpub2FyUzJIMlh3RnJPdEFQNTl6Ym0xdE1nQjBRa0lEbGV1U1NmWWRLWmQ2aDlqMGU5RU42a21zM2h4TGFXcitaRkZHUVNBeW51VUpHNzErbUtyUjYwbW9mQ2R0TnR6NWsxcmVXMXNxdGdNd01xbGNqOENPZXVLQU9udWJZMm5oU2NXOFRUZVhzdDQ0M09TeTdsWDVzKzNVL1d1UTBtYVNDK3ZyWnd6TGN0UEZsUVdCYkVvNjl1RlhIYmdZem10ZlZmRkZnbWxtRDdkTkluMjNFbmxSc3VNU1pZNTI4Z2JXVXIzL25XMExUcDd4L052Ymk3WDdOemJHNVFLNzVCZmJnSERLTWtjNTVKOXFBT2NiNHY2M283SFMxMDdUSkJaSDdPSGZ6TnpiUGx5Y05qUEhhaXZQOEFVd3AxVzhJQng1NzR6L3ZHaWdENkUwQzI4djdZQmsvNlZJUi9zNWJjZnpKelQ5U3NveGZ3TkVpaWVXVll3VnlDcWdGaU1qMkI0cXBISEhiUE5MY05PeXM0bFJJb21mbjVsUEF6engzOXFTVzFRYXRhcmJUWGNqejI1ZjhBZk1jb1JqYVFUME9NOGR2eG9BSTdCVThSeXl5eEt5eVI3MFJ3R1ZVd21PdlREaHVsWitxMkVWNzR0dUk0UURjeVcweG1BWEcwZVJ0Qzd1aEJMQS9VZDhWYjFPd2xGOWIzYjJHb3lnTTRtYUtaV3doeGdMOHdQM3NuR0tnMHpSMHVMMmJVWklMcUt6bWEzK3pPWm04MzVYeHRkZXVDR09jNTZuNjBBY3Q0V3NMTFc5UXQ3YTZRU2hvdDUrZnFBRkxaT2VoNUgvQXEyUEVYMnJWTEdYWDJlUzF2Ykc5OGkwdEdsMmZZbFdJc2hIQlVzemJYUFVNTm9GUmZESFI3ZSsxdVNTNWlESFR2blVFTU1NU1ZHUjA2QW5CNTZWZXVycTI4UitJYmpVTEdSVXNvdFRpVzRHM2NMbFlZeXdtem5JQ25qcGdqYWUrS0FNciswRGE2a2srbnl6Vzl6YnpYRng1TjBxRWVTVVZTckVINXp2WGRqUEF5ZlN0UFNqY3BKY2EzSnB4U0svdDJhUzRraGVTTlF4QUN4TDk3WTI4OGNIUFBDakppc29vYjJLV3dBVTIwTXEzVndYZ1lPa3htM054Z2tBd2NEcU1QenhYZXorSk5IMC9TcFo1SlFzTnN1TnE0UE9NaFJqak9LQVBPdkQrbnZhNkZxa1VNemZiWVp6QkdWSXdKMUdJMURaNkVrQnZZa2RxMVkyMVNlU0cya3ZibTdudEpoSUdoZzJSdVA0bElVZ051NTV5Y0E5QWVhZGRYT3BhZWRJMURVbmhRYWs1WmtWZ1lZcnJER0hMZGVRUXBKeU9PMkJTYTdyVDZycjFuYVFTeVdFd0IrMFN1eGpnRnFIUXR1SkFQek5HeVpHTTlNa0hrQTM3UFNkTXVZQmJ5ZUhVV0oxNmhjWXpqUFBQb004ODRvdXBOSTBqUjVkSTBlMXR0d0loa2lqYjVVZHlCdFpzSDV6bk9PdU9UeFd6ZTM2UzJwdHRNbWltdVpjUm9JNUIrN0I2dWNkQW81OStCM3JBdlBEcmFkWnBiNlRGZDNsd2pJUE5ra0dldVRrbkhCd3UvR0N3R01pZ0RsdkYxeEF3ZTNVUWhOT2VPMkJnbURCR0liOTJWUFVqQVpzY2s3UndCejZEY2E3cCtqUWkzOHZpQUtqSkcwYStXRGdENVN3eDE2ZmxYRjZORkN2eFJ1THZVdm5GN0kzMktlSnN3dk1pN0dVNEdONEN0d2VoejFydHJqd3ZwRjNjeXpQRktKSkgzeWJMbVJRVzlTQTJLQUo5UDF1MTFHVjRZOThjaU13MlNZQllLY2JoZ25LbmpCNzVyUnJJLzRSalR6ZExjczF5MGtZeEdUY1A4bWNaeHozd1B5RmE0NEdPdEFDYlFHTEFESjZuMXJNbTFHS3prU1FlYjVEdmlRZVdUczNkRzlobnI2WnpXbElna1JrSk9HQkJ3Y0huM3JKZzhOVzF0YUxiUlhWejVhb0UrWW94SUF4eVN2UEE3NW9Bc1cwK2xhNGtGNUNJTHRZOFBES1ZEWXowWlQrSGIwck84V1d0bFBhUlJTMmtFMXpjeWJJUE9Vc29jSXpaWUFna1lVampua1V0dDRKMG0ydjVMOGVlYmlUWnVaWk5nd293UGxYQTZkK3RWL0dvTUsyTjVGZCtWZFFPNjI4VEp1Vm1ZQlM1SEdkb3pqSndTUUQxRkFISCtLZE10cnF6dS9FRWd1VEFySmJ4UndnWmpXSjJRTXdPQzRMNDVKM0tEeDZWdStDUEZyUHBzMm1hdGVSeTMxaXhBa2xsVWVaRndWTE4wSkFPQ2ZZWjY4MnZEZW8yZHphV3RqTlBIY1hWeDlvbGtLRDVWYklNZ2JhY0Q1bitoSU9LNDdVSVc4SjYvQ2tkakpmV2tZYVdLTHl3RDVETjg4Zllsa2RSajhQV2dEMEtEeGRvdDJnUzVtZ2lTVURIbVRSc3I1Qk9PRC9zOVBjZXRjUDRpdGJJM091ckxhVzF0Tll5UlRpNVpYV0thM2MvS3Z5QWZNRHdPVGxpZWVnSGF5MlhodjdOYWFpbGtMcFdUZmFlWHVjTnVYakhPMEZod0NjZldzaU9GUEdOc1h1bmpnajArZGtOdStHaWVZSU1rWkFQN3NzVUhiSUo1NG9Bci9EWFhOT2lpazhQeitWQnFNVTBoanpqTTZFa2o1djRtQTRJUE9BQ2U5ZDVlU05GWlRTSjk1STJaZU04Z2VsZUwzMmlhdnA5M0xjeVhWdjhBMmxCT0pyWm9JbUs3aTNHTmc0SjdqR0RsdnJYb3ZoVHhkY2E1OXBqMUN5U3lrdFlJNUpQbWNFRWx3d0t1cWtBYk1nakl3UnptZ0Mxb2V1alZmc2tNL3dCbWtlZTBGeEhKRElyaVRhUUdZRHFCbGx4d01Fa2RxaDEvWDdVU3k2UEJKSTE3TEdXRVVNQmtkd092VWJWSEJHNWpqcldIQmZlZHEwTDZCWWkwOCs4WXZlU3dJc0VnYkt1cW5POW55TWpnREt0MUZVTER4cHArbnp5V25oK3h1ZFRrbHVHTjdxTjA2eCtjUU9YempCQUhQYkhISE9hQU9ldmIrd2o4VlJEVUxxZTYwcTFuQm1sY3NSTmovbHB0SDNzbFJuam5hU09PSzc3eG5xR2o2ZTlzTG5TN1IxbUFsZTduaUlSVkRBWURyeUgrZkk5QUdOZVpYMHpYc2JlYmQyaU02YkZoaEJtTWE1T0F2bGdyeGtjNUhRK3RkdjhBRHZWUHQybjN1bi9ibnVWRWtLN2JtTnYzYW1QQitWaWVDeUZjQTQ5aHpRQTZlM3RqcGx0ck45ZDdJWGFOdEx0TG00WlM3a2pZemtEYzVVZmRIT1JuSnl4eGo2eFozRjlwTU4vcU4xYldDend5ckc5eG1ObkJmRER5aDg1TzNCMjQ0eitOV1JvZXEzbXF0cTJ0emlXOWcxS0pZN2RSaElvdnRDcXJJUFRLNHllY1o3MXhPbTNPNkdmVWJ0emNUeVNNUzg3TWNzU1N2SjV3VGordEFHMUlIbjB4NzJ6bHVKSTRwa3NmTWxJQklNUmN1Rkh6SVMrU0FTY2J1Z3p3M1QxVzN0NHRqRlV2ZFN0NHhFemZNVWprRFlKUFhCMy9BRUp4V3Y0Y3M1THZ3WGVRTk03TjlzZWQzM1ljRkZWZG51U3hZWkhvYXpiQ2VLOGkwMUpaTGY3T2RVTjNFemJsTzZRbGdEbjd4eW8vRTQ3VUFIaUdKYmZ4SHZsbVZwNWI1MnVBc3V4aEdKTW9HeDJDNHhucmdEMXJ1cHBWaGphWk5vMjVja25IeTRZL2ptdVQxdlRyYlZGOFhTMnpzZkpNYS9meC9xVURFTm5wODRZYyszWGlyWGlCb2w4UFBkMmQ1Y3I1bHVKUXlUdXlmTXVGNEpJNzR4NzVvQThoMWhjYTNmQTlybVQvQU5DTkZMNGlKaThTNnBHL3lzbDVNcFhIUWh6eFJRQjlGd3hPQWczQkZkSEliNXM1V1ZzOVBacWttdElubFdWZ3J1QmdPUnlLbXRMU1AreGJWRmpWVmptZEZVQUFLcFpnQUFPbmFwL3N5OEVuUHRnMEFaYzF1Z2JKbGNNdm9UVkMvaGpqdDdtNWlkNWJtSlBOaVRlY3M2Zk1vOWVTQUQ2NXJvV3Q0aDFpVTU2L0tmOEFHcWwxYlFSMjB6VEpIR2lvek80VEcxUUNTZXZvS0FPTDhPMld0L1pQRUVXbm9ndWRSWEU2S0dIMktSbXl5NUpJWTRrYkFCeU52T00xYmw4T1gyaFh2OW42WkxiMjlwUHByd3kzRWNSTGJrUmQ3TWNZRG5nRGtqQXpqSTV0ZUgvRUZ4RjRpMXpCelplV2IrR0xIek1aSTRTQjE1SFh0MUo2OXBycS91cmVXNW11bkVzVU9sUk0wZU1CNTU1R1p1ZlFMR0I5S0FNYndta2twa3ZKWlMwOTliaDN3TUlXUjlueTRHQU1BREZkemFXbG5mYVpjUlhOckROSEpGaGxrVU1HQlVjSFAwSDVWdzNoTy92cGJsYk8ramloa2h0UzZxb1lGeThoa0xjOGRXeGdkSzdqdzRrOGVtU3dUd3FubG9xQmtZbFgrVHFNOGpyakJvQTgvd0REVDJOejRjdmRQMWUzZWJUTHN0Kzl6dVdDVUtDR3dNN003d09PaFVldFZiL1VCTDRpMS83REo5alZJN2V5aTJaVWhFblNOK1FPQWN0ajBxUFE5bHJaNmZjK1dFUzdzQ1daemtTVENUQ2xsUERZMkhPTUhhVGswa1dtdi93anVzYWhxQ1F3emFwZkFxbm01S3hpUXVWei9FQ2Z6QW9BNlR3cmNYMWpCTEZidkM2eCtYR0dZa09WRWFrWlloc2pEY1ZPL2lqVjdQeGpvcVhadC9zdCtqUXlLanNmbVVaTERnQURPTURHVGs4OUtxK0dKa25nbWxWZ1ZuWkhSdW5Calhid2VueXFEK2RZM2o5SGViUmxoWUJ6TElpYlR5U1NuSS9IR0tBTG12M050cTNoZE5iMFNhVzNodGRZVlkzalF4K1Vyc0M4ampIVXVRYzQ0NEhybVdXMzhZSFhiSy9OekRHVm5aWVVnM05icXBqNnlGY2JzblBKQjU2R25lR0xZYXo0Y24wM1Q3V1MxUnJKN2FXRjNLRnBVbEpKM01yY0hlMmNybkp4Z1lyWTBDN2xpdExEVGRSaWEydXZzYVNSSzdsekxHdnlnazdRQTNHU282QWpyelFCdjJlcTN5Ull1NDQ1bUNqL0FGUTJuZDN5YzQvbFV4MStMN1dsdDlsbkxNR080YmRvd0FjRTU2blBBOXF6SGtFVXF1eHhDcXR1eitCei9QOEFNVkZZTE15eXZjT0E3U09kd0dNZ0hDZHZURkFHeVBFTm15cTY3bVFxemxsK2JDZ0ZzNEhQSUE0OTZ6N3p4cmEyMS9IWnBCdmQ0MmRnMG14bHdRQnhqdms4KzFKQkJGQmZMUEVCRWh0OGxWUEJ5aS80ZnJXVHI5b3FhckM3Unh2QjVaVHkyUHpGM1plUGZoVCtkQUdsYitPSTcyZG83ZXlkRVFEZGNUTVJFQ3hLcU55ZzlXR1ByanZ4WE9EeFZmYTFjdEpwMm4yMDl6ZXhLa2NjOExFeHhuY0hSZ1R5Rkl5VHhua0FFaXRQUWswM3hIWmFmWjZocDhja0NpNVNHSmlTam9ySU54Qnh6ODN2ZzU1NzFrWHQvcDJreVM2VG9PbnJIUEpxSWFGVEtkcy9sbGtsVWc4a2ZLVklHZnZaeHhRQm9wb3VsZUNqL2JrbXBNYldlSllWUlZVSklXWEFSVkF5QXhBSXgwT2M4ZE0zV3RRazF2d0pZNnExb3I2bGF6Q0dRb1d6dktZTEtWN0hDdHorUElyS2wxYTQxancxcEdqWERoNVh2QWZQbWJmZ015c3BQeWpuNXlNREhDdFd4cGVudFk2ZjRpMENDTkhtczQ0cmlONU9rc2gzTGtqb3ZLWTQ2WW9BcStDZFdnMCsybmx1NzI1dHJmVGxCYUJuL2NIT1FvNUdjbHdjQUhIcDFybTlMbXZwYmExa09vM2tjVEtTSTdlZGxVSE9HSUFQQi9yazk2dEVzSjlYWFloUzUwcTRqS0ZnMjRlVXN5U2JlK04zWWRhYklrZHRmTENraVpVaFcyeUZTQ1FUL0NlL0g4NkFHR1hVNFpvdkwxWFUxd2M0RjFLdWVlTy9lbzlHOFF5NkY0cHRiKzd1WjU3V09CcmVYZkkwcmVVMlNjSHFRR3dmcG1ycXh0R0l0dkxEUEhtT09lb0dlY2M0OWVSV1RyRnRMSEhxVHJGdnRZWW9Va0tNU1lnUTVYanB0TERIUFROQUhaZUtaWnJLRHd6NGUwL1VQSWdsaGFTYTdjNWNLK0VMWnhuSkVqNE9NN2lLeC9FTmhIRjRMOE5RVzhTUjcyRE9pcjFJaFlIMy9FL2pXbmZhVWJxeVhVNzY2bHhhNklMWlpsaTR5U1ZES2VwYjV2VEhUSFBUSTEveldqK3pQZHl0SGE2emR3d21SZHhXTllWeHdPdzNNMmZmM29Bem9VRnRJelBHMGdRNDJzL1lFY01lM1BVWm84T1hONURyQ1dWak1WbW50ejlud3hBTXFJWkkxNi8zbDZISTU1NjAxMDJia2E0aUxzM0VYbVpaL202NEdUMHJwZkFPazZmcUd0UlgxeGN5dGQyRXNTUXdqQVFnUkE3amdlcjhEakdLQU5IVE5haTFhRWFwQzBobHVyMjB0M0JIeUxnQ1o4Y2ZlREJnZlN2T05MRnVkS2plUmxMQll5NExZNUpIWC9DdTNzN3krZTNqTFNiWXJUVUpqRHYrWUJYaWFkRXoxNk1QbXoxWEgxNGkxdnhEWXJKYXJIRk1xSUlybVVDUnkyTjNVZ3FwMmc0R0MyVFFCMTJsU1E2VjRKaHUybDJ6elNYZDdzQUJWQkdqeEltRDZ2SW1BZjRqNzFWT2hhbkhaUmFmSmJabVNPR0NER0FHWVIrWWRvM2ZLYzV5dzUrUVlycFBBbW1RVDZCOXNsVlpwM3U1bWNUTVhNVGwrVjU3OTg5eWM4VmZlMzh2eGpBcGtXVldlUm1WVHQyN1lrSFFqNXVXR0QyeWM1elFCV3V2RExYdHZMYlQzTHRETmp6RWpZZ3luak8vbjVpVHorVlVvL0RrbG9OTTB4cnk3ZTFrdklrTUJadGhWRWFRNUdjQUhZTWpIVTExazFqREtOMGx4T08zN3R5Z0lQcmpHZjhBT0tvV05rMHZpV1Z3RDVWbFl2S1NiaHBDWlplQmtFa0RDSWVuWjZBUG4veFVTL2k3V1dia3RmemtucC95MGFpbDhVa0w0dDFoZlMvbkgva1JxS0FQcHpTYlJXOE9yYUlTQXBrUkNYTEVZYzdUdVBKUEE1UEpxd0Q1cUsrU053ejlEM3BOQ0t0cFNzckJsTXNwQkJCQi9lTjB4VGloUzRraHllZjNzWUI2Zy9lSDRIbjhhQUl5d1VqbkxEcHhWTFVMZE5RdEpiZVI1WTFsUXF4aklVNFBYOCtsVzUxWEkrUmlSME84Y2ZwVlowTEU0UUw2WmNtZ0RoNzFiUFF0Y3YxM29rbHphV2NOdkZMSUNUR3VkNVhwbkFRY2Z6eUJWdnhmY3JKTUxPellrYWs4cTdnd0ttT0NFcnNCSDNjdTdjOXRwNHJSWnlmRzBnQ1FCaHBjTWlzMGUvanpYSEhlbWFyYnhwcXVrWEN3d200bnUzU2Q0N2JKOHNRT1dHRDF5QUJuMkFvQTVpeTBaMmdpdlZ1a2lrdUk0ZkxZUk1KVUVraFhPN2Q5NEEvZUgzdG96V3piK0l2RlduK0drMUw3TXQ1YlhNS0ZSY0FKT2haUU43RmVDdUNweHRKNXhtcVJqamo4TTZXR3QwazNXK25Bd3lPU0dVWEVlVko5QmtkTTllbFNhM3E3NnBjNjFkb3pScFkvWXJPSzJiamJtZUl5TnRPUDRpRkJ4ZzdPRFFCbVdURzYrSGVyYUUxdjVkeG8wVWtqdTQrUXNsd1crVTl3QWhCK3RRZUh0VHU0dEN2VHFFMHkybHZiL2FoUEsyU2pid0UyY2JzTm52MEk0NE5iQ1hzZHBxR3BMZFBEOWl2bDFDMVl6U2hWM203bXdvSk9GTEJzODlkdFVmRDVoMDFZWXRTdEV1Sjd2VUdzSm9zQmtoQmNyczU0S2h0K1ZIWHRRQmUwRzZ0N08yanRMKzVXS2VHT05IV1ViQUcySG9UNmdBOEU5YWg4Y2ViYWpUcjZCSTVQc3JTeVI3c0VFankySGJrY0g4RFZtMTBDMGswWFRZMkxXMGY5cXp4WGNpUGdHQkZtWmdlY2JmM2E0NDRGYzdyZWtRSUlYdHBKWTFsdElaamF5eHg0VHp5NEdTby9oVlBRL3dBTkFFVDZsYXk2WmR3MlY5TGFSWGtnT2JZdEU4TEhDdEV5NzhGWEJ5RG5yMkFydHZFV3N3M21sd1d5dk5IZTI5cGJ6VzdRQlNFdUpKREV1QVNNOGhseC9kWSt0Yzk0YjBlTFc3eUxScjMvQUpaSzZoc0FpZUtKekc2RnVDR1NRaDBQVUsrT2FsdTdadEs4YXkyZHhkUEt4RVN4T3VGeksyUExVZ2NIWmpjTVl5WE5BSFFIVWplNnREWXhuN0pMRkN6U3hTTXBaSE9SdFlET01iY2pCd2Z3clJzZ1VpZVF1ek41dVpYYlBYR0QxN1pIRmNacFVqWG1zNjNlUHFVSmVQVWpFUmdzeFZaV0lRRTlnbTcxNmNWMEk4UVcxdmR0YU96ZzNsNHNLeDlNTm5uQTY1ejEraDlLQU9pbElXQ3p6bFFZWXdRdzVIc2ZTc1RXc3g2clpOZkV4Mmt3UWJ0NENSTXJETzdQK3l4T2M5RlBwV3BlWFFPcTNscXBDbERHQ004N0NvSi9xUHhyQThUVDNEYWNyeUZna1Y3SWprNFVzcFlLcWoxempqMW9BbThKWGx2ZitNQ3VuUmVWcGRoWU5CWkRQK3NWblV0SUI2TVIrU2c5NjdHNzA2eit6bVQ3TEZ2aGQ3aU03UU5zaFZzdDlUdVBQdlhuV2k2M0JvV3FMcVYzRTdRblQzRGVUQ3gyNGxHVDBPQnpqazlhNks4K0l2aHliVGJpTDdaSkJNOERoRmxoZGZtd1JqZGpHY2pIMXhRQnhlZ1dFRDJ1bTc5VmExdWJWR2ZZVlhBWGMyR0dlQU41QTJqT1d4bnJ6czZGRHFUWDJzQzZ0SkxLWCt5ekNobFhKbENPK3h5ZWpIQncyZTQ2QUVaNC9ROWZOaHI3M2h0b3Jrd3dFUlJTb0cyNEdRY25rWVlrNTlBYTY1OWZ1UDhBaFlsMXBzZ1R5R3Q1RVYwUFFsZzJEemc0SlBQdUtBT1Y4TFh2bWVMbzVwTFV0RzlrQXNjQXlXWHlndnlrNDQrWHZ4K1ZXeEpmNmhkWEdvTGJHTXp6TEs5b3pzREU3QmdGSThzOHNxQTV6amtkQmcxeitsMzAxcnEybDNwd1JMRWl1NUdBQTBqb1ZQdmptdlU5R1lKZWVKYmFWSTFranNyWUJXUDMxOHBobnJucmxmd29BNHVTNld6d1oyVzI4dHlHU1Z0b0JBVnRwY3hoYzRZSEdlY2oxcW5wM2lLYUFhZ0xXMGFHQ2ExZ2FWcEczTkVxdmdNd3hqWVdjYmdmNGQyTzJPdzFpeUY1b0dxWENoVkpXMDFCY2pKQ0dOVWFUNmhWZi92a1ZRMCtXeWdzSmJQV3I2SzJjYUxiSktzckFMTnNudVVkZWV1YzRBSFBJeFFBbmcrV2U0dUxxMDFpVkxpR0t4aGhqTy9QN3VLNGZCUHVEa2V2eTFnWFVkOXNzOU9mZGQzVU9yUzIwaGt5dm1zSTRrWGtlcXJ1R2V2R2MxUG9MeDJVVnpHOTRndEFqV1RYanFFR1NubW81RFlJSitjRUgrTGJqcldoY3l4dE91cFF5TE5hUzY3YVNpYUJnUWRzVVljakgrMENQekZBR0ZmMmVxMmlvcXRDRm1kb1BMVXFQTFlQem5BQXpuZ2pCeGcxc2VEcjJXeDFMVFk0Sjh3NmhkeVNOTWNJTUtQTE1lM2IxeUVPZURrR3F1bzZqYTNmaHU3M3VxWE05N2MzVVZ0Skc2bVpHbTRHY2REa2M1N1VrbDA4OXZwRFh4V0h6OVRtWUxQSmxvZ2tpZENCL3NubjJvQW44NlkrR1VtbGhBVTJsdzhicnlWZGJURzhIc1I4eTRQVUVIdFVHcDJibG9wTFdHS0FXeHNKN2lYY28zZVpHNkZzRVk1SlVkaDBwMnA2aEpaK0g3cTFoaWlTME1Na1MyNHhsSTNCeWY4QWV6MzU5S2ZlMjYyOWswcnl6U1NJb2J6SGtHVHluM3NjRURhdUIwK1VBZTRCWjhLNmgvWlVsM0pmWEY1SlozYksxdEpIYk5JSkFDd01qQlI4dVNRTWtjNDRKeFd4cCtyeFhIaVcxbmgycGJHMnZKWkFWQUlDeUpHR0k2Z2ZJMlAxenhYTDJHb1hFT2syNGU5bFdOclpJakY1MzNoakEzREk3WXdQZmpBeVZoanVMNlBWR3VZN2h4SkhHMGVkM3pvR0lZS2NZQklZY0FENmdrTnRBUFRXMVMwTHhyNWhZeWZ3a0ZTT21CZzQ1NUJ4MkhKeGtWYzhPeHRjYURjYWtVSWZVeTg2S1Z3d2pJMnhBKyt3TCtKTmVhMmF5YS9lMnVranpadnR4QUlsZFc4dEJ5Ny9BQ3R6Z0ZzSGtaSXlXT2E5bVpGaHRDa2FoVlNQQ2dkZ0J4UUI4bmVKNVlMbnhYcTl4Qk1IaWx2cG5SZ0Q4eWx5UWZ5b3FscUl4cWQwRG5pWit2MU5GQUgxSjRGVUw0SjBwVllNRnR3RllBZ0VEb1FDQVFQcUFhMXIyTnpFSlkxM1N4Zk1xLzNoM1g4Ui9Tc2p3SC95SkdsZjllNDdZcm9LQU1XWE1rS09uem80eXBCUFNvVWlacEIrNkhKSGNtcms2bTF1eENGUGxYQkxSdDJTVHFWLzRGMUh1RDdWRTNtWjVRZm5tZ0RqR251b2ZIOTRkS2dpdTdnYVpDR2haaEh0RzhGaXpkZnVuSXhucmlsdUxyVXRUZTFlOTAyV3dtaG5NanhTT0pRcE1VcWxPZHZHQ3JmS0d6bnRXeGQrSGJLNzFoZFR1TFZaNVJBSWRyZ2tjSElPQVByMTlhaGJ3OWIyaWVkWTZQQkJJakdVTkdTV0RiU01oVGtaSU9LQU9WMVc2dTRORDBHSXhlVmJ4VzltMHJDVkNEaWFMQUdCbmdqbklwMnB0SGNlTkhsa0VjaS8yZThpUG5JRzBLUXdJR0RqMUg1OUt4YjYwYlRkUDBhTzF0N2kxbGtXSDdWdnMzaEJrQlJ4dllvdS9EYzhFa2MxMHVxM0dweGp6OVMwSzM4eXhXUlk1RW5aNFdCWExPbVZKUTlCaHdWUHFEelFCeHV1NGkxZStsbXQxbGprdnI1U1FtN0tic2x5Yy93N3dSMHh6VzU0WXQ3eHIzUUlMdFVqdGlReVJScGpJUW1SSFluak9TdlFnODg1NXFlNWxqUWVJTkhhVzREVDNjNkxIYjZZMXhzRG9vTGdyamFjNUdOM0lPY0RyVWtGemJYZmluVHdtbm15dURlTEt4TThvM0h5bURLSVhRQURnZEdPTURIRkFEck8vd0RJOE1heHBMUjNGM0xKYlhzbHVZN2QzUXM1WkF1NGZlSnc1eU9PVDNySThSem1UKzMxam4yL1pyZXo4c0xIaG93dTdLanZqQTYraFByV3JwOXRkUWFMOXB0ZFlzdEtTVy91RkwzbXhRRldSbENvV09PQUIvRDYxSEtEZGVEMGwxR2RaWWh1UnBZbUxLMGJ5SnV3T3FnTHVDcjJ6Mm9BbWpzN3FIWExyVTdDNmpCc0w5NXZLRW0xNUlwWVluY0tBTzRQWG9DT25OWTBkdkpxT3AyazExY3lYV29TWHpTTmNnaFhieTAzY2tjRGFGWGpIQnp4eldxc0Z0cU03YTBrbHhicUdlT0Nib2hoallDTUh2aGdxam5yeVRqaXNPVzFsYlU3bTJVeXhtVjRJbFFNQXlGd3J1Unpqb3UzOERRQnBXRFNXVmw5cWxqaFc1ZTZOeEhadGx2SmNLNHc1NnJsbmM0OU1EM3JIdGRXdTJ1dE12M2xZWFNYY2JGcFNvSkJrSVlaemprczJTZWVhaGt1MmtZM2NWN2NQOXlSbDRCRzdqQkF3Q2M3YzhjYzRwNzJjcXJhRzE4MVpWS0xCdFlCcEhIekhieDdaOXo2VUFlbStLZGRmVE5ha2wvcytTN2plemc4a1Fna3ZJN3lBajZBS1B6ckYxVFdKZFVnWWF6Y3hhSFlQZE1zVHJiZWEvbVJzY2hqbkhWWEhIUEdNZHpidE5YdjVidlFMMDMwNnd6c2lDTjRFSllOMURZR1JnRThqMHFIUWtqbHNJMHZrRWl5M1Z3MDhZK1lmNjkxWnNkY0RCeDZkK2xBRmFXdzBFMmx6THAvaTNUM2UvalRjSjQySVpGWkdPQUd5TWxBRHh4bW1YbXVHWGZiWE1FV3ByUE84bS9TbGFUeXp0SUNsWEFJSWJCemsvUVlySnM5T3RZdkROamMzRnMwOTJuMlNaM01iTmxaWmcyTURnNFVPdUIyYjNycjU3RFJycTNSNGJXMW1RaENKSW8wT2NPaHprZTNOQUhtaHM3aTF0V3Vsczd0N2VTRmh2VS9NSDNGRHl2VGxTRHh4K05YbzlTblc5aWwwdFg4d3UyTHJhb1FLeHdjWjRKNDRQSTVIV3VqMGxNK0JMV096dDVwRmoyeXN5SXdWUjVqYnNrYzVDNEp3RG5HS3k3YXppdW9MMTdhM2pua2h1ZkxGdGc3eUFvVm5RTjEydnlPbUF6WjVJRkFITlhTdXVoUElOeWhJVkcwNXprc3dHY2RUeng2Y2l1OG5obHZkWTFHQW1SV2pXMERFT1ZNZzhsZHlOenlwQjVVOWMxVjBYVDdTNjB4THA3TkpiaU8yZFk3amtNa3NiT0E3cm5rNUlKSGRsSngwcDk1ZW9mRnV0MllPcHg3N2xYU1cwZGp0L2NCWEpYQkJHY0VmUTlPS0FKUERhWGM0MWVXNWxhYTNubmFHSmQ1MkNOTXFJd004S04yM0hUaXFGNUJPOWxIREd6WEYzSnBWcmJJV2w1a2Q3bWNOa25xU0F4NTlLMU5NdXJtSDdNWTdDUkxOcGpNWmJSWnBUTVdmTGdLeEcwRTVQSU9NY2UyWnFWbGFUZUpkTit6bDdlMGV6UzNpVzRqWm1Vc3R5Y25jQ053T0JnODVZSEhXZ0N4NGQ4UmFVa0dxVFhvdUF0enFKa2pQMlY1Vks3VkM4S0d3UUFPRCtIcFZ6eEJlVzk3YVdrc2tvbnNybThFOGNzVWJyd054WEE2a2o1Y2NjbjByaGROZ3VvR2ltZ04xYlNiUjVaQ2JtZU1qa25HTVl6akJ6bm5pdHpVTldudXJQVEZpRG5VdnRmbU5CS3dNYWhYUFBRS1F3SzV3QjlLQU55L2JRcEpZcDF1WmJpYjdPd0VFVUxPVlFjdGxlb0hDayt1QjZHcy9TbzRyN3dSbzg4MTE1VDJtNlhiNXFOMFlnc1l5d3p3M3J4Z2Vwck5tMURWWlBNdUdudHJkaEZ3bG5Fc2FJbjhXQ0J6a0FqSnpqZzB0aHRrMGkwTXRyR1VYY0ZWaXJnRU8zR1QwQXlSNzhqb0RRQm9YME9vejZEcVp2TEpFaGp0MkVFcU1pdTMrckNncUhjTG5jYzRZODR4anBWSFY5UmE5MW1hUmJ3dGFXdit2OHdiVVhBNVFiUmg4YmNZNkJnY1o2MG1vSVZ0N3NRUnJGTEpBNk9VQU80WkQ3U0IxQmJKejJKSjduQ2d5L1pDVEdZRkkrZEZZL0wwSlVyOWR3eDFQMTIwQU4weGpKWldlWVFzWVFZK2NBWTlja2pCeHpra0RrSElVa2lSbjJRYlRDQXEvZGpLOVFlQ0FEZyszellKKzYyMzVjdWpobVdJUnFza2NVZVNpTmNrc2V2SmJQSUc5Y2RzRlNlR3JWOE9hSmRlSU5jZUtUelVnVGE5eEl3SUR4RVkycUQwM0ZTT21jQStnSkFPcStIZWtOSGFTNnpPbUd1Zmt0dDJjaUVmeGM4L01SbnR3RjRGZGxjSEZ2SWZSRC9Lbklpb2dSVkNxb3dBQndCVExuL2oybHgxMkgrVkFIeUZxbi9JV3ZPTWZ2My9BUFFqUlR0WUdOYXZnZTF6Si82RWFLQVBwN3dDQ1BCR2w1R0Q1SS9uWFJWei9nUVk4RjZXUCttQTdZcm9LQUlMeTBodnJXUzJ1RkxSeURCd2NFZWhCN0VIa0hzUldOYVhFeGxmVDlRYk45QW00dnRJRndtY0NSZTNvR0g4SjlpQ2VncWpxdW1McVZ1cXJNOXZjUk52Z3VJL3ZSTjB6ZzhFSG9RZUNLQU0rVUVQeElOdm9RVFNBZk5rU0wrVlY3UzhlU2M2YmZ4cGI2bkd1NW9sSHlUcVArV2tSUFZmVWRWNkhzVGFkTm1NUk9TVHp1QW9BeTliOE5hZHI0UnIwTnZSZzI5SEFZNDdaN0RucFdYZGVBdkR4dHBRdGtvZGdjRXlET2VlaDdkYTZqbkgrb0tqUFRDMDdqYmt4SDZIYlFCNW5aSFQ3TFd0YXNkWXQ3b3VManprUzNMRkZUYmpKS0VEdUJ6enlNOUsybzczVDdxM3NqRFpYVWFXMTJqWmtDaHNCU00vZnpnWkdUNmV0ZHBzQWt4NWV3ZHNCZWFyM0ZsQmNMS2swQWVLUmRyb3pZeUQxNUI0b0E0WFJiUzl1OUt1MmkxTnJXQjd5N2hNVFdjVXFNcGxiSVk3TjVCeWY0dlRwVkRWdE1mVGRGdjdlNEZpRDlrdDQwa3N3d01zZm1sVjNEL25vTy9YdG11cGw4TTZyYXJLbWo2N01rY2tqdXR2S0VDeDdpU1R1QVlzZHh6ejE1ckwxL1FmRkYxYXhSeTV2VmRZdDVXN0FHOVhKWWhkaTdRd09BTThmZ0tBTXc2VkhxR2x0THBmaGFXeTA5WXlQdFYzTnVtZVBHU1ZUc1RqdWU5Vm9FdkxNNmpjMjl1dHpaYlFrc0FLNzFrRVVaM2tzRGpBeU1IZ2dEdlhRMzhIamU2YVcydGRQaXRMTnlVQW1samZNWkczNWxHY0hIdjI2MWpTK0NQRk0xMEdlMUd3VENUQ1hpQlJrQlcyL0x3Y0RnNDZDZ0RBamFGZ1piZTB1SUdpQ3U3QjlqYnM3czRCSndPVGoyejZnTmdJaGtEMk5uSUhqQ3l2NU15N2Nrc09Ubkl6d2ZxeEhldXh0UEFWKzgzbTZwRk5NeUlJUXNGNEVEcU8rNEFIcms5QjI3NXp2MlBoSFI3Vkk1QnBiQjQrUDM4N1NaL0F0ajlLQVBQdFB1OVVnMVhUWXBXaWtpdkd0OWlxVlovS0xoUVIwOUNEei9DQWVSWFFhRlo2UGQ2V2JiVmRPbnRycWRwSmx1cFUycmREekdJSWNkR1BIeXRnbjBOZGtiQ3d0WVdObFkyd21EaVZSZ1JxNUJ5QWNlNDYxenlhZnFXaitHSTBuV3kreFc5djVzNGVVa0l5dHViSk9RNHoyeDFIZWdET3NtUWVIL0Q5dmIzTnRHNjI5amRTcmRFUUViQ0dMSXpBQmlja0RCUFExMDF4RUxtMmxoaU1aM2dZVlhIUXNCa1k0eHoxOTY0WFRySHdqQnA5dERmZmJieTRNS0J2M1VqeHN4VWZkL2g0R004OFlOYkVVUGg4bUpiVFE3Mktjc2l4U2l5T1VLa0VOaFRrQVl5VDN4M29BbThQM2h0L0Fkam0za3VsUU5INUlPMW1ReU1yWXp4a0RKeG50anZWblFMbTNpME1wY255cFpibTQ4NVpFS3lGaks1YlBvZnpyQTBtNDhOU2VIZE1oMWZVTGxwNFl5REFrczNscDg1SXdxOFo2SFBVOGMxcVJhdjRSc3JQN0RHMjZHSDVQS2EyZVE1Sjc3bDY1T2NuNjBBU284ZHZyN3FRTG0zMWVIZnZoakVuK2tJQkh6eGhkNmhUeWVvYW83T3p1dFBHdDNOMnYyQkpid0dONVdSRmRBbU40em5QVG9LZ3VKYk80djRiZlRMUzcxRklKWGxpaWpoZU8xU1Z0Z0RFQlFTQUVMWlVZeXpkZWMxN3p3ejRuMTY1YTh1NFZFd0cxVExLWVVVRE9BRks4ZGNlMmVwSW9BZlBydHZIYk5kUTNzVW84M01vODBHVGpBNEdEd01qbjJQdlhPM0Z3ODgxdzEzc1NPWlZSZk1ZcXJCUy93QjNrOGtNQm5QOTcwNTZHRDRZYW41Z2FiVW9MVENqUGw1WWtuNzNwanFRZld0V3crR2tFWUF2cjk1ZW9BaUJWU3BQb2VoL0gxb0E0Z3pSQ0I1bGp0amhsWWlLUGFGL2hBWG5PQmpIcmdIdVFWcktMcVdhQlhRUnh3TXdQa2dZWGRnbFJqbkJ3Q2NuMUFHQml2Vm9mQVdnUkJsTnM4b2M1WU5JL0p6blBYMTVyV1RTTENEQmh0NFlpQmdGWXhrSDF6aWdEeWEydDVMc3pScHAxL09NN21XT0lqZGtFakJPT08zMU9hdjJYaFdkN2VXSzNzWkxJTVRJMHQ0eEozZ0RCVlVKSnhqOGNkK01lbkxhSEEzVEt4OVF1UDYxSUxkRkhNaWtaNmxjL3dCYUFQTmJYd1ZxU0dOSnRSWlF5L2ZDcnZBeDF6enlPMmVoK3B6dXA0UWdqVUY3aFZPM0ErZGNBZTNQSHB4MDJyL2RGZGNiV0lzQVhpem5qOTJLVzRXMnNVVm1RU1NTSGJGR2lEYzdZNkQrZWV3NjBBY2xjK0dkUHQwZ2dTUHpiaWFiRVVTTnhLMkNXeng4cUFNMlc3QTRISkFyclBEMmhRYUJwdjJhTi9ObWtjeTNNNVVBelN0OTVpQjA5aDJGV3JTME1STTh4RDNEakJJNklQN3ErMzgrdFdoUUF0UTNmRnBOL3dCYzIvbFUxUVhwMjJVN0h0RzNYNlVBZkkrdERHdTZnUDhBcDZrLzlDTkZMcnZIaURVZit2dVgvd0JETkZBSDA5NEYvd0NSTjA0SHFJcTZDdWY4RERIZzdUdU1mdXE2Q2dBb29vb0F6OVkwZTIxbTBFTTVlT1NOdDhGeEVjU1FPT2pJZXgvUWpJT1FheDdhL250Ym1MVGZFM2x4WFVqZVhiM3NRS3dYbjkwZGZra1A5dzlmNFNlZzZpb2JtMmd2TGQ3ZTVoU2FLUVlkSFhJWWZTZ0NpTGVOSDVKejZGcUdpaExmZVA0TWF5ci9BRVM3c3JieTRKTlF2clRlR0N4M2pMY1FBZEFweVBNWC9aWTV4M2JnVkJZYUZZNm9qU1dYaUxWSEtuRG8xM0tIaVBveU0yVlBzUlFCdWxZV09OM0o5ei9oVWZrMnZCQ3FmUTQvK3RXWGQrSG85S3NMaTh1TmExSm9Zbzk3NXVISkFBUFQ1dUtaY1dlbjJxb3VvWCtwMjgwaWd0SEZmeU1JZ1NFVmlRZW00ajhTZmMwQWJJaHQ5dU9Eei9keC9TbkNLSHRqQTlGLyt0V0Q5bTA1YnJ5L3RtdThTbU1zMXpKczNieEgxTGNqY1IrZjFxQjlNMDZPNXVJSk5iMXhEYnM1bGxlOVpVVFlpc1FTV3dCaHdjbmpyelFCMHdnajdqL3gzLzYxUENoZW00ZW5ILzFxNUMzMDZ3dnBMV08zdmZFTW91RlpodHYzMjRWbURITzdIQkFCNS9pWDFxMDJsNlZiWEUwTTF6ckRHSGZ2ZDdxUWdiWWxjak8vbjVXSHRrSHBRQjBwTDlRWEo5Q01mMG9PL0dQbng2ZjVGWUZ0bytpeVBiMlRHNHVaSklWY241enNEWlpTNTNFak8wNHlmYXBOUThQNlRZbTFXTzFqRytkVWVWMWFVcUdJQXlOd09DY0RQSUJQSTVKQUJ0N1R0SU84NU9Ubi93RFZVTnhhUTNUYnJpMFNYUFhlZ1lIOHhXREJwT2d6T3pJa2lxRlFxelJrS3l1eFZXSFBxRDF3UjZZeFVFbWphSjh0d0pyNk9HYTJNNlRKS3lJWXljc1I4NEkyZ2duam9lUFNnRHBwYkszbjJtUzEzRk03ZU9sTU9uVzdLVk5zZGg3TVRYTXdhSnBNMFVPeVhXUWswY2tpczg4aUJVVGJsanVmb2R3SS9HcElkTDhOeXd3dmQyYzRkbWRBSGtMc2NTTEhrbFdJNUxxZmJKOURRQnR3K0hkTGh5ME9sVzBSOVZpVUg5S3N3NmZCYjRhSzNTTXJ5Q0FCaXNPTHd2NFcxTmtqaXNIM0lDR1ljbE1kQXh5ZWNkUFdyTWZoRHc5b3F4eWZaVmY5NG9UZkdqTXpFOERjUjYrOUFHdnN5ZnYvQUlCaFFiZGR4K1k4OVRuL0FPdlhKMlNhWGNhVUdtc2pLeTJxM053SW9ZWTRnNVVIWmtuZzRZZTNYblBGYWxwNE0wYVNHRzV0K0F5NzFZSWpaeU01NVg5YUFOZ1FFZmREWTlRZi9yMGlRYlB1b1FSNzF4OXhvV2hONXM5NVpNeGlrbmlWSVFuS3hESkxiZ09UZ24wNTl4VVRhRDRadGRRZGx0bk50YXh5Qjl5STdTT0hqVVlHTWdBc2VUZ2ZObk9PYUFPMmZmZ3F4NmRpMU5XTkQ4d01mcjk0Vnpsam9YaDY3MUZiV0RUa3RaMXRsbWtSa2hMUmduQVVnS1Iyem5QY2V2R3VQQnVqZVo1aHQxWnoxSmpqNTRBL3Urd29BdkFLU1FIajQ2Z01QMXAvbE4yQy93RGZPUDZWbVhXaGVIckpBYmkzZ1VTWUNwNUNNejQ3QlFwSitncXYvd0FJMWI2a0lrazB5M3RyU1BsZlBnamttUHNveGlQNjhuMkZBR2xQZGVSY0MwaVZwN3B4a1F4TnQycm43ekhIeXIvUHNEVnV6czNpSm51WkJOY3NDQzRYQVVmM1ZIWWZxZTlHbWFWWWFQWnJaNmRheDIwQzlFalhHVDZuMVB1YXVVQUptaWxvb0FLcjN2OEF4NVQvQVBYTnY1VllxdmZuRmhjSDBpYitWQUh5VnI0SThSYWtEMSsxeS84QW9ab3FIVXBJcHRUdTVZQUJFOHpzZ1Zpd0NsampCSUJQSHFBYUtBUHFQd0tjK0RkTzV6KzZyb0s4djBEeFZxRmhZd2FiQ2tIbFF4cUZaa0pZNVVIbm4xTmRKRjRnMUNWVkpkRjNEc2dvQTZ5aXVXZlU5UWNFaThaUDkxRS9xdE0rMWFtMmYrSnRjRGp0SEQvOFJRQjFsSlhKbTQxUWova00zUXo2UlEvL0FCdW1tNjFWZitZeGNubnZGRC84Ym9BNjZzL1VORXNkUms4K1NNeFhhb1VTN2hPeWFNSDBjYzQ5dW50WFB0cUdxcXhBMVdmci93QThvdjhBNGlvLzdUMWJLLzhBRTBtNUgvUEtMLzRpZ0RYMitJZE8rUnhEcmRwZ2duNVlibjhSL3EzL0FQSFB4cVNMVk5HTEpIY3dDeGtpT1ZTN2c4cllUL2RZamFmK0FrMWhEVnRXMjUvdE9YcmovVlJmL0VVZjJwcXJrbzJwU0ZjOGd4UmMvd0RqbEFIV0paV01pNzF0NFhWeVczQlFRY25jVCtZQnBMZlRiZTNsdTVBQTV1NVBNazNxRG5nREhUa1lVZGE0cHBya1lWYmw0eWVqUklrWlg2YlZINjA2SjladFYrWHhMcVRxRDkyUkxkdjFNV2Yxb0E2dlVORlMvWUtadkxnMkZUR2lBRUVubGxZWUt0L2dEak5XeFlXblUyOGJIQkJabEJKeU1ISlBYSUFCcmptMW5WMGJiL2FjcHdPcGlpei9BT2dWSC93a0dzQnNmYjJPZldLUGoveDJnRGUxeThuMCs0alMwdDRvRDlsY3hYTFFHUmQ2a2JZY0RCR1FUOWNjYzBrbXN5N0x5ZWJSejUxZ0VYSU81bVprUnNKOHVlQ3hCUDhBcy9sejU4UmF5cmY4aEJqMjVpai9BUGlhVlBFZXNsaXB2MjRIL1BLUC93Q0pvQTNVMTVnZFZIOWlPaTJjNFNNSGhyZzdnQzIzYndNbklQT1J6eHppWCsycEk0SXBHc2hGRWpUcE1xbzdsZGgyamFGWGtIZzlPbGM4L2lUV0Z4aTlQL2ZwUC9pYXFTK01kY2oza1hTbmFjY3hML2hRQjBNdXJ6Z3d5cHAweHphb1JER0NxQmpMZ2plVkFIQU9RY2NkUnpXenA3SmRSU2g3QmJkSTVXUkZaTWJsR1BtQXgwTmNEL3dtdXVqL0FKZVVQL2JKZjhLZWZHV3RoUS8ybE9lM2xML2hRQjZPa0VNYmIwaVJXeGpJVUE0OUtjUXJncXdERHVEelhsa25qN1hsVXNKb2VwLzVaQ25RK1A4QVhDcEphM0p3VC9xcUFQVGpid2tFR0pNRWJTTm82ZWxTREFHQlhsamVQTmVrNUUwVWZPUGxpSDljMDMvaEpmRU14WnpyZHdvR1BrV0dFRC8wRFA2MEFlcUZWUFZRZndxdmRYZGhaakYzY1c4Ry9qOTY2cnU5dWV0ZVhYSGlQVUkxMlR5ZmF4MVBuc3h6bnNRQ0JpbXcrTWIrMSthM3M5UGhLamp5N1lERkFIb3lhcERJeGZUZE5udVdaY2VZc1BsTGdkQnVmR1I5TTFOSEhxbHlNM01rVm9wLzVaMjVMc1ArQmtBZmt0ZWNTZkVmWGxKd0xYakgvTEkvNDA0L0ViWFFwT0xYL3YwZjhhQVBUcmV4dDdaaThjZjd3OE5JeDNPMzFZODFQWGs1K0pXdkFBN2JUci96eVA4QWpTUDhUZGVYT0k3TTg5NGovd0RGVUFldFVsZVJOOFVkZlY4ZVZaZjkrbS8rS29QeFExL2RqeTdMcC96eVAveFZBSHJ0TFhrSStLV3ZqanliRS84QWJKdi9BSXFtbjRxK0lNdVBJc2ZsNmZ1bS93RGlxQVBZS3JhaWNhYmNuL3BpMzhqWGxnK0tldlpBOGl4NS93Q21UZW4rOVJCOFNkYjFLN3R0UG1nc2xpdTNXS1FwRzI3REhCeGx1dk5BSGg5RkZGQUgvOWs9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHJvamVjdC1pbWFnZXMvaGVyZW4temV2ZW50aWVuLXh2aWkuanBnXG4gKiogbW9kdWxlIGlkID0gMjA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9');
},function(module,exports,__webpack_require__){eval('module.exports = "data:image/png;base64,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"//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy9zbWlsZXlfaGFwcHlfMS5wbmc/OWM5ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQ0FBaUMiLCJmaWxlIjoiMjA1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBREFBQUFBNENBWUFBQUM3VVh2cUFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBWWRFVllkRk52Wm5SM1lYSmxBSEJoYVc1MExtNWxkQ0EwTGpBdU5XV0ZNbVVBQUE2Q1NVUkJWR2hEelZvSlhKVFZGditHblprQkJrVlpaSmNkQldRWnRobW1FUkIzY3lreUphMThtZnF5UmZ0WmxxR201YlAzWG1WbWxPV1NxYW1JS0Nnb21DSm9pMnRsaS9iTFBhM01MVkFEbFBQTy8vS040RGhvQnVrN3Y5L1I0UzduL3ovM25udnV2ZC8zU1daaXhXb2RGeGRuNitucHFZeUlpRkFiREFZMS8rM0MvMnZ1cE1xWWFuQUFGM0FDTjVtalJWR3cyZ1FGQmRsblptYXFvcU9qTmVucDZlMTc5dXpaZ1ExNVpHVmxlV1prWkhqZENRVVdNSUVORHVBQ1Rsem1BSTR5MSt0RXdaVTJTVWxKamxxdDFwbC91eVd3QVgyUEhqNzZ6TXlBSklNaFNKZWVIcEppTkliZUNRVVdNSUVORHVBQ1R1eWNDemlDS3pnM1VtK2NrbXZrRXhNVDNkR3AzVU1QZGZKNFpLeWY5L0JIZzd5R0RBdjFHem9pN0U0cU1JRU5EdUFTejV5WXVBZENDMXpCV2VZdVdTTnNVTkdkeWFzZWZkUmRwOU5GVFhGVlRaM2xvbndqMTFVOVo0cXJldTdkVUdDRHcxUlgxVFJqYW1xMDlPaDRkME5DZ25EQ3o4OFA0V1F0WVhIMDdkdFhpU2xLemNqdzFmYnNHVEUrMkgvRVhDZkZoYVZPRW4zZ0xORUNxTXNkVnNZRU5qaTg3YVNvZmpMSTc1RUVZMVprc3RIb0I2NVlFMkpoZTN0N084SWp4Rm1uWWFPOHA3UnpmbW0raTlYUmxmNjJEUnZDN1dsamxDTnRpVlBSbG5qMW5WWEdCRFk0ckdJdTc3bFlIWHZKVlRYVEszc2tyNG5lSGxqWTRDNUZSVVdwRWhJUzJzZnI5VDd1STBiN3YrenNNUDlqOXJ3azBvRzJKcXBwdTg2WlBqTzQwT2YzYUZyVUw0elg2ODd1bHRXOG5TVmJKZ1Vtc01FQlhNQnBoclBkRXZmaG93TGk5UU44ZU5EZHdGM2k2VkFqWFdIRkJ3NGRHVHhObzV5M2lLZHdZN1NTcWxLZGFZZmV4YUxDZUhPdFNuV2lxaFFucW9RbXF5MHIxNkVOMnByM3Q0UUJCWWROekdVeGM1cXVjVndRbHAwVG9zL3NGOEFoMUJIY3NRYXdZWGdnYmZrTkdobzJWYU44Qnc1c2lWZnhLTnphZ1cxTXJEeldnVFpFV0ZGaG9FU3J2Q1ZhNFNIUjhvNnNIV1RsM3loREhkcWdMZnBVSkRYTzhNMGNBSWN0Q1dwYXJKRm9tc1p4WWZDOTJlRkpoaDVCZXIzZUU5d3hBeHBzSE1pOXdkazU0YmthVmQ0aWJseWhWZk5VV2pZS3dJb2tGWlYzczZmMTRVd3F4SXFLdFIycEpDT015Z2FsMEpZUnZhbHliRGJ0ZUdhRTBNcXhENGd5MUpWa2huTmJkKzVqVGNWaGtyQUJXeTA1QVE0VmlVNzBvU3M3NE9LNEtHTElzSWkwakQ3QjJQREFYVGlBUDdDQkJISGx6Und3amRiV1JGNWdNZmEwTnR5VzhrUHNhRTFDSjZwOGZBanRmMk02SFYyL2tzNTh2WWN1bi9tVnJsNjVJdlR5MmROMFp2OWVybHRGKytmTW9Lb3g5OU1hclEvM1pSc1JkaHl1OXNLbXlYNXpUSE1Id2djL0VLbEw3eFhTdlh2M1RuL0pBUUJoNVBJN1MxU3M4NmVxMFlQcHdJSTVkTzY3citqU3p6OVI3WVZ6ZE9XUHk5VFFjSlZNMHREUUlNcFFkK21YazNUdSsvMTBZT0ZidEgzcy9WU3NENkRWSEZiRm9kSTFKNXBqdHRLQkptTlZJSzlWY2NoWTA1cHdCeW8yaHRLdUtlUG9hUEVxcWpsK1dLYjY1NlhteEJFNlZyS2FkcjMwQkszdkhrWnJJaHlFYldBQXE0MGNhQW9iTExpTjBYYVVINkFRZ0x1blAwTy83ZnVjNmk3VnlKUnVYK292WDZUZnZ0eEplMlpNcEEyWlhZUnRZSmpXQkJTRDJDWU9sUEZpV3hkcEw4Sm0xMHZqNmRmZE82aTIrb0lJajc4cTZGbGI4enVkM3ZNcDdYbDVBdHNPb0hXOEpzcGliTnZHZ2M4TUdwR3prU3FMUXhXME9vS25kOHdRbnZvQ3FydFkzY2lpRFFTemVLSnNuVmdUQlpGcUtncVJCQ2IyQUd4b3JaZ0JqZGg4eXVNY3FJQVg3WnBFYnpxNGFDNVYvNFdZdjVYVS9IU1VmbGp5RGhVbSs0bEZqWDBDMk9EUWFnYzJSRnBSVVVKSHFoeHpINTMvNFZ1NlVsc3J3N2FkWEsycnBRdUhEbERWdUd3cTBub0lUT3plclhJQTV4Vk1aU0dQZm1sV1Y5by9kK1pOUStmOGdmMTBLSCtaMEhQZmZpbVh0bHh1THZXWEx0STM4MTZsVFgxaUJPWTJYc3pnMENvSEtoS1Z0SktQQUo4OFlCU2JWUDFOSE5qLzVuUmFwSlpvb1VxaWZiTW15YVV0bDV0TFBhK0ZZeVg1dENVblMyQUN1dzBjVU5GeVQwbUVEM2JUSzdWL3lIQTN5cjVYSjFHZUpORTdyTHVtL0ZNdWJibmNYQkNhWjcvZFI5dWZIQzR3VyswQWpzQmJ0VXBheG9leHp5YjlnNDhIcDhYUm9DVTV0aUdmdGo0MG1FZHdNQjBwWENxWHRseHVMckQ5eDluZmFDZW5hV0J1MVRxMjNvR0tSRWRheWlmSzNkT2VsbUgrZnRuM3I4a0NzeUtoRFdiZ21nUFRKOGptLzM3Wk4vdkZ0blBBRkVJN1h4ekhXLzhsYXJoNjQ4NTd0YjZPcW8vK1NMWG56OG9sTFV2dGhmT2k3ZFc2T3Jta1NXQWJHTHY1YU5HR0ljU0xtQzhqTzU3S29kK1BNSEI5dlF6WEpEaGxmdlAySy9UVDVpSzVwR1U1VmJHUnZ1RjAvTWU1TTNKSms4QjI5YkZEWXIwQnM0MnlrSkpXZVBGb2pPeERwNnJLeFFITVhDNmVQTTZIc1VncTdSTkxCeGZQNWFQempaa0tzL1REaC9Ob1UzOHRyVThQNTkzOGlGelRKQmo5bjNkc3BtMlBEUlNZclhZQXV5QTJrOVgrRXBVTjBOTEJKZk1zYm1TNEI1UVAwVkZCakJ0dEhkR0xUdS8rbEM3LzlndnZHVFZDOFJzbjE0cUgrNG8yWlFOVHFPYmtNYmwzazJBZitHRnBIcFVQVGhHWWJiS1JZU2N1NHN2R2hyUUFjUXJGVGN0YzZwZ2tEbU83YzU4UUR1eWRNWUYzM2NYMDZ4ZVZRZzhYTEtHOU15ZUt1cDB2anFVVG05WlNYYzJOQTRHdzJqMzFLU3E1cDdQQWJMVURwck1RenVpRjRZNVUwaWVPVHBRWDNiQllUZmtiUndaY1Vvb05RYlM2cXc5dFNJOFF1anJhbDRyMGdYU3NlQ1hmeHI0U2JSdk05aE9zbzVOYlNxaTBuNVl2VEk0Q3M5V0h1Y2JqdEROdDRVeUVzMGwrRnhmYXkrZjIwM3MrRXpGdFNSQUdsYU1IMG5wakFtM2tOUUZkM3oyQnRvMGFRSFcvL3k2M3VsNWc2d3hmYlBhOThpeXRqbktsTlh3YUJXYXJqOU9tK3dDMHRLc05yWWwwcEUzOUV1amJkLzh0WXRoU1JzSUZCK1ZJa3lBbVZQeXV0M2o1dVhxbG5tMGRwKzhYdkVtYmVKMFZNa1pwRit0cnVLMjhEelRleUhibzhXeEdTZXU3MmxGQmhKbytHWlpKQnovS0UvZmFsbWJpendpY0V2ZUFaZS94VWFNWDIrYWpleGM3eG5JVW1LMitrVFcvMUZlbU9OTm12bVFVQkVoVTJLMjlBUHh4eGZ0VWZlS29UT2YyNWVLcDQvVGp5Z1ZVd1NsNmJheWJzRzI2eUxUUnBiN0pBWXdHREpmSE9WSmhpSUx5UTNtaDlZdW53NFhMWlRxM0w3aWFZbCtBclVLK1JzSTJNQnBudlkyZVNwZ01OWGVpTE1hTzFvVlowVW9HTHVtanBTOG1qNkh2M24rZGptOHNwRE5mNzZaTHY1d1NzVzBTWktsTHY1NFNEN3lPY3dyOTdvTTNSSi9TL3NtMEtsUkphME90aEUxejh0QS81Y0R0UGxwRWR0Z2M3eWp1eWRqeVYvanhqYTFISkZXTkhpVHlQUjVhSFYyZlR5Y3J5NFFlNWVQMEFiNUw3NTM1ckhnb2dOdmRTdTZ6M0YyaUF0eC9lZVJoMHhLV3VRTVdIeTNDZ2JTTWpPRGJlVGJhK0xUQ2lUN2hCVmNTWlU5RlhleXBJTXlPVm9YWTBjb1FCMW9Sd2plNU1KVlE4WnZMVUljMmFJcytHQVRZZ0MzemtUZnBMUjFJU1VseHdxTnFub0ZBL3lIRFFrMVBwOHRqbFd6QXN0RkdiYXpEeU9GQjFDZHg5bFFXYlVPbGtRb3FDZWVkRzd0M00wVVo2c3FpYkVSYjlHa2E5WnZqYkk1VmljZnJlRG9kTW1ob21DNjlUeUNIa0R1NGl4Y2M3SWtiWHQzNFpEL1VlYnFMd3pzZjRnVkgxOGJSTVkzTXAyazNhbk9ncG5LOG5MQ3NxTHQ1M3laRk9iREJvWlM1TEdGT0x6czdMT3c4WkhoUXNyRzNuMDZuNnlCZWNPQWYvc00xaGFmRWRlUVluK2xPRHZNKzRzWkZvVHlpY1VyeFNCR2owTnc0TmhjVFNGdG9jNXNtQlNhd3dRRmN3R21tMm02QmE4NWp2aWtaL2IyU2twTGFDUWZ3aHBKblFKMmNuTnd4cm05ZjM4YzcrL2QvemQwcGIwRUhxNnRyUGF5b29KTTFyZlcxdVU0TGZXeG9uYjh0YllwUjBqYk9IQ1pudHV1dUoyWkpUVzNRUjJTMGJrcGhxOUQ3ZWd5b3dHWU96SVZtdXp2Tkh4M29ON0JiNzk1K3ljbVpIUkUrNEk3WHJEYnNnQU04UW1xU0p1WjY5RXBLU3AydHNxcDQyMEh4L1g4Y0ZRZGVjMVFjYks2ejdCWGZ2NjVTSEZybWE5dFFGbTNLSUkyaGRqTW5tdXFRQkp5cG5BZGdPZHY0cjhycThDeGJ4WGZtT01BR2g5ZFVWbFVEdEZxOTlQeE1kK2JxRGE3TjNoVkwxaEVSRVhaNGJZbUtiaWtwWG1scGFjSDN4M1pOeW9tSk1XUjM2NVkrT0RxNngvMnhzVm5ac2JIaS83U1VGRDNQVk02YlN1bjhtazVXdEpHSklGNHhxcmR5b0xHTk0yM2lrUy8wdGlhMlVUMHUwSCtFSVRWVjF4d0RtTUFHQjNCSjErbENrbmlBOFVJU1hNRVozT0VBWHRrTEp4QlRjQ0xCWVBCUURYKzhZL3RIeG5rRmNzejVEaGtlRVB6Z3c0RkJ2TWdEN3MwT3NSODFLb0NOeFU1cTcvemNQRmZybld0NXFzdllDWVNFcFhBeS9SWmh3eWxUaEEzM3lYTzEzamVwbmZOa25kRVlCNXV3RFF5ZjdPek93QVEyT0lBTE9DSFo0T01QbVR6ZTBsLzN6WVFWS3VMaTRwU2NZL0hpencwdjBoQldxYW1wdmtiT1VyellBeE1URTRNTnljbGg4Vmxab1ZMdWJBODRrYWRXSFBsWWhKUHB6V1pUT0RVNXdtSERJMS9PNUZmNDJUYTh5MzBtYTlTNXNBRmJhWW1KNGJBTkRLMVdHd0JNWUlNRHVJQlRzNUZ2OFlzVmEyNXMwN05uVDN0NEtuLzRvY0cwd1FnV2VteHNyQ2VYZS9QZi9yRkdZMmVBancvMGZtQ09TanFQa0RBUEoraDFZZU5qVGR5Mitxa0E3MkZkalZtaHNBRmJzQW5id0lpSmlla2dZMnJBQVZ6QWlmOUd6SXV3YVVrd0pWRHhBUWpQaGkwVVhzc0dIQkJtZUwySlBHeGdVSHhia1ppUkVmNmNSdjA4aDhRdWhCTVdweW1jb05ocE1mTHIyTUc4ZHRaZjhzaS9rR28wUnVMYkIzMTh2QTlzd1Nac0F3UFpSWTRHZ1E4dU1pY1R2MVlKRE1BNXBad05PaVZ6YXBOZVdkeGVPS0ZXSEVlSXdBbUVESFF6d3NaZmhNM3hGMXhVVTZYY2Q5MlFEcG1zTjBZYXRtQlR0bjFIUkh4ZlpGcjBuSk85NEVTY29VZlkwd0dlRDc2bGtpNnM0MUJCT0pXeXJ2TzFKaTZybWVEdmtaUE1iUkt6c3Z6aE9QcktNNHBSdm1Qa1RRSkFXNU1UM1prUVFpS0JRK081ZHM2NTg5MnM5eFo2OGtiRXlyKy9udXlxbXBac01IUlI0Wk1aRGoyTVBQckNobXpycmdqaVVqZ0JRbGlJMnN6TUFHbmliSThwN1ZWVDgreWxFKyt5NXJaVHpVSlpGTDdBMHV0OVRDT1B2cktOdXlvS0xEalRUSEJvZWVEcnFvRXhrZEZqZzRQVG9QZEZSOFNZdnJneWpUejZvRytqaWJzdllpYXdHSm1rSnBOVG9XZmZvVzVTYnE0RzZuVnZUbnVVb1U1ZXNQOFhJMjh1MTV4Z2RjRklJejFDNVV6ajB2YmtKZWwvWDcvaXJRWE44bU1BQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3Byb2plY3QtaW1hZ2VzL3NtaWxleV9oYXBweV8xLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDIwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('module.exports = "data:image/png;base64,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"//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy9zbWlsZXlfaGFwcHlfMi5wbmc/ODY1OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQ0FBaUMiLCJmaWxlIjoiMjA2LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBREFBQUFBNENBWUFBQUM3VVh2cUFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBWWRFVllkRk52Wm5SM1lYSmxBSEJoYVc1MExtNWxkQ0EwTGpBdU5XV0ZNbVVBQUE1Z1NVUkJWR2hEelZvSmVGVFZGWDVEOXBsSk1rbUdMSkI5a1dSQ1NESmhNak9aSk9Oc1NkZzBrRWhFQ0VzU0lBdGJXQ1FnbUlEaTNxOHFDRnFyaUxqVnBWWDU2Z2EwZGErbGlndGEwYW9nTHA4b3NxTnNPVDMvelh0a2NhTFNwS0huKzA0eWM5OTk1Ly9QdWVlZWUrOTdJL1dRUWF3K2VYbDVmakV4TVdxRHdhQzEyKzFhL2g3Sy8zVURxVEttRmh6QUJaekFUZWJvVlZTc3ZxbXBxUUVlajBlVG5aMnRjN2xjRVdWbFpZUFpVSFJwYVdtTTIrMGVNaEFLTEdBQ0d4ekFCWnk0TFJBY1phN2RSTVVYZlMwV1MxQitmbjRJZjliRFFFbEpTUnpmbU1TZlU5blFSUTZIWTloQUtMQ0FDV3h3QUJkd1l1ZEN3WkUvZDNNQ1EzS092TmxzamlvcEtvbWJhcGs2dE1iUm1EREZYcHRhV1RCNTJDVDd0UFNCVkdBQ0d4ekFCWnpnQ0ZJTFhNRlo1aTc1SUcxd3dldzBSOVdhYTZNS0N3dEhSSGcwYldGbDZsc2ozT3JidzEzcWRlRnU3Y0FxWXdKYmNQQm9WdGxzdHV4YTg3d29rOTBrbkVoSVNFQTYrVWlZSEdQSGpsWExReFJmVmxobVNQY2tUZ3NkcXpvY1dpR1JicnhFWVJOVUYwU0JEUTdNNWVpd2tvU2FVbHRwSnFkWUFyaGlUb2lKSFJzYkd3U1BNRHlUN1hXeGVyZjJhdDJsZy9ZbXp3aHN6MnpTVU03OFlESXQxbEgra3JBQlZXQUNHeHpBUlZjKzZITWVpVFZWUmRNNWxVWkhZMktEdXpSaXhBaU55V1NLS0NvcWlwdG1ucDJvOC9qZnJidE1vcXk1V3JJdURhZmlGUkhrYUIxTXpyYklYdFcxQ2hwMVR0MnJ2V3ZYUHJqSG15MUZnUWxzY01pYW95WGRSQjRKdC8vbUtVVjFTVVZGbDhaeDBQWGdMbkhrdFNoWG1QR1RpcWVuaFh2VTZ6Rjh1UXRDcU9ncVBkbFhEdmFxeFN2MHJNcC9QZmVOb01MbDBIQ3k5YUs0aGo3b3E5eW4yT2hwWDFGd0FKZndDazRyVCtDOVZhN3FpenllY1VuTU54TGNNUWRFK3JDbVRyQk9TbWNITnNBQkRDT2k0TTBvVkFHM0xRdWprUXUxTkh5T0g2WFdTUlEvVGFJaFV5U0t2cUtMVHVwb3d6WDBRZCtSQzRPcG9DWHNGeDBBQi9PVllSME91QU0zbGhkWFpkanRKYW1jTVRIZ2poSFFZZUZBN2EwcXJzNElkNnZ2UkdjTER4MkcwcHRSQUFJOGI2R0dNaHQ5S1gyV0wxbWFvNmhrZVFaVnJDNmc2YmVNb3FaMVZiVG9ybWxDOFhuR0xhT3A0cG9DS2wxdTRMN1JsRDdiand3TlBzSkdoeVBlblFBSGEwczRSVlRDZ2FEN0twMlREVzczbURRc2VPQXVITUFYTENDVmhaTU5QK2RBUjlUMW5KYzZNaTdRVW1aREFLWFhCWkI1M2hCcVhGdEp0eis1bXA1NTQxSGE5ZGxiZE9ESWZqcHo5b3pRNzQ5K1MrL3YyVW5QL09NeFd2ZlV0ZXpRUkxMTUgwcnBNd05vT052SVpWdXdxZGp2aXRuVGdRckg1Wmt1MTZpTG5FN24wUC9LQVFBaGNtbTFLaXBlbkVRTmF5dG80d3UzMDRmNzNxVnZEbjVKaDQ4ZHBCOVAvVUR0N1dkSmtmYjJkdEYyK1BoQjd2TVY3ZDczSHQyM2RhMXd4TDRrbVZKckIxRUcyMVNjNklyWmJ3NFU4MlN5TUVCbWt4OWx6ZzRpNTlKaGRQWDlUZlJuanZpK2J6K1RxZjU2K2VLN1BmVHNqaWVvZGZOY2NyV2swL0I2TmFlakgxbXU3TzVFbngxUUpobnlOSGVCaGxKcVZBTHdtb2NXMGp1ZnZFRW5mandtVXpwLytlSEg0L1R1cHp0b3pjT0xlVzVrVXNvTXJuN3pPK2NFc1B2TmdieG1EV1UxQmxIeG9rUnEyenlQM3ZyNE5UcDY0ckJJajc3SXNSTkhhT2ZIcjlPYWh4YUpsTXhxQ0NKanM3cC9IRUFKUXgyMkxRc1hPVHA4dG9ZYTExWFNjenYreUpFL0tsUG91MkFVdDczMU5NMjVZeUpsMVFkVGV2MGdnUWxzY09qVENHRGhNUzBLcHJRNkZWbm54OUttYmV0bzMvN3p6L2xma2krLzIwc1BiTjlBQmMzeFlxM0FPZ0hzUHFjUVZzK3NPZjVrYm83a1Vua1pmZnpWQjNUeTlFa1p0di9rRk52ODlPdmRQQXBWWXAzSWFnb1FxM2VmSE1DZUJTdHQya3dWalZxWlJYYzh2WWFPLzlCNzZuejB4UzU2NHVXSDZISFdEL2ErSTdmMjN0NVRUdkNrM3JEbGVoclhtc3NqUG9nS0dCc2MrdVNBdFVVbnRnQlhYTy9naGVqUm4zVUFDMWtJYjRHRHl5VzY4UTlMNWRiZTIzc0s1c0t6T3g2bmFUZVhVdnhVaWRlRjBQNXhZQ2p2WTVBK1dFMVBudnBSaHZ1cDNNRGtKS2RFa2tQaU5XS08zTnA3ZTA4NWVlb2tqOURiMUx4aENnMmQzQThPWUF0c1lTUFlqTFhjTTVPK1AvS3QyQnIwSnMrSTZGWFFWTlluWDN0UWJ1Mjl2YWQwYkR1K285Yjc1NGxOb09YS2tMNDdnQkdJdWx5aTFRODJ5ekQvZTducHNlVUMwOXdmSTZBNGNBMHZOQU1sTnorK292OGNVRkpvNWFZbSt1SGtDVHJyWmVVOWZlWVVmYjcvRXpwMDdIdTVwWGM1Y3Z3UTdmM21FeTZicCtTV1RvRnRZR0JyQWN4K1M2RWhQS0dhNzZ3V3dLZlBuSmJoT2dXN3pQVmJycVB0TzdmSUxiM0xTKzg5TDhyeHdhTUg1SlpPZ2UzUDkzOHE1aHN3KzYwS3hWWkxWSFBMR0hwMTF6YXhBZXNwWHgzWUp6WmpZMVlhYWRQV2RWNHIxV21PK09adDY2bThMWjg4TFJtOGc5MGpYK2tVUlArMTk3ZFQvVzNqQldhZkhYQzJSWW5GSkpsM29PTlhtWG1wWCs5MUhmam0reTlwNHBwQ3ltM1VpOVBZem4rL1R0OGQvb2FPYzEySEh1RFAyTG5XL0dZc0dadjA0bVQyMVlIUDViczdCZXZBUTMrNWt5Njcxa2JKTXlUZWxlcjZQZ0pZaVRQcWZlbmlwY204ZDU4blRsbzlSZG1NdGQwL1Z6aUFuZVVUcjJ5aUhidGZGdnFuVnpmVGRZOHNGdGRXM3RkSVc5OTh5bXNna0ZhckgxaEF6cFpVeHZUcCswcXNiT1p5Ri9CaG96Nkl4bDJkUjl2ZjN2S1R5WHFXNi9kQnJ0Kzc5KzBTaDVTTHIweWw3SVk0OGl3ekNNMXBqT2V0Y3JJNC9PRGtocjQ5MXhQTW83Kzk4eXhkMG1yaW8yb1Fud3ZVZmQvTUtkdHBuSkxTWmtxVVhSL0tGV0lScDhqZlJlWHhKaGlOK3R2SGsydXBpUjAyQ25XMW1Ham1yWmZ5K2VHSTNLdTd3QllPTnRjL3NvU3lHOFBFYnRTeVJOZjM3YlRpQUo3alpNOEw1TDI2bWk1dE05SGR6OXdpY3RoYlJjSUJCKzJubUJTSVFUcytuL1o2K0RuRDdWOXpFYmp2K2R0NG51VXpob1pHekEwUW1QMXlIc0NweUw1U1QrWWxvWlE5VjgxblZ5MU51ZEZERC9Kays0SXJTVzhqOFdzRVR1RWM4UEJmZnlmbXgvRFpXaG94UjgxWUlRS3pYNDZVeXVFYStUaHlVUWlsMUVwa25CTWhBQjk5OGZmc3hGNlp6dmtMSXYvWVMvZHlkUnBESStjTzV2TTJIMlQ0OEFTc2ZqdlVLNFp3Um9WaG5NN1NaL2xReHF3Z1RxZVI5TlRyRDh0MHpsOXdOQzNudERITVVndWJzQTBNWVBXN0F4MU9kSXlFa1EvNGhnWmZ5cGlKeXBSUFYyMnNwM3VlK3kyOThPYVR0T3V6TjJuL3dhKzV5blRPRDFTYy9ZZStGZys4VUVMdmZmNVdXckd4Z1JjMUsyWFVxYmxrK29tRGZBZjVUanpvcjNMZ2ZCOHRZbkxsTHc0UjUyUXMrVW5USlNwYk1ad2ExazZnNjNrZnMrbUZ0ZUlwM0N1N3RnckZJUVVyTktwTTA3cEtHclVpaTVMNW5oamVNcWZXcWpqeWVKRGNtVFpkdGFjRFhoOHR5aS93MHM3bjJTZ0E4ZVFBRXk1bkhsZU9KalVaWmdlS1I0M0RhdmwvYlJBWlpuSWJLejZubzQydm9jK0lwaUMrUnkyQzBQSDBvWHZhZE5WZmRLQ2dvQ0FZajZwNUJKTHhYa3A1T2oxeVVhaFhnejBWNEhnUVpWcXM1UVdQUysxY1A4cHM0am5TcU9xbWFNTzFITzZEdnRnbTlCYjFuZ291Q0NxZVRrK3dUMHAzdWNZa2N3cEZnYnQ0d2NHZTZIa09KRlFWVEUzUmVRSTM2Q3A0MFpvWHpOSHBqTXpGVi85VXU0SjB0RVVLZGJSNlYrVzY5M3U3SzlxQkRRN2dFbFlwa2M3dHY3SFNQaVhWNFJpZFVGaFlPRmk4NE1BZi9oS0dJWmxlMUJBWDZ2RmZEd2N5NnRWa1doZ3Fvb3VhM05VNEZoY0ZwRCswcTAxRmdTbEdsamxrOE9LbVl3ZENQUDczVnR0bXhidmRsd3l4V0N6aHdnRzhvZVFSMEZxdDFzaXh0ckh4S1k3RVMyTEdhTzZNcXZRNU8zUzZMOFZOOTZQRW1nQktyTzNVQlA2ZVVoZklsU09VQ2psQ2lqTTlLNGczVmZyZ0hsU2RQTFlCVy9FenVtTUFFOWpnRUhXWkwwV1AwOXlkN0V3WVA5bzZPc0ZxOVVRaWZjQWRyMWw5MllGQWVJVFN0TmpVR20wcHROaUNTd2U5cUI2dCtsQlRvdHF0TGxGOXhQL1BhWkJMOVdId0tOV25pZFVCN2JuTjNTdkl6em5SOVJydU1TNE1vY1NwQWUxczY3TkFwK3BmWFRGa3pOM2d3RnhleVMvT0wxcG1YaFBGWEdQQnRjdTdZc25IWURENDQ3VWxMckJuUTRxTGk5T003aXhMamp2SG51dk9kV1U3c2t1TWJtT3AwV01VL3d2WVdJbzdzVm83U25Vb2ppTmtYQkFxOGhWUi9TVUhPdnJnWVhFb1I5MlB0S09rbzhtZXVHazJ1N213S3dZd2dRME80TUpwTG1vL1hraUNLemlET3h6QUszdmhCSElLVHJDWDBWT3M5WkUxQlUxRHF0Mno0aXVMcGlSZDRacVJYT1dZbWxKZVdIVlJYWDVka3JQSWFSenNDR25SbC92c2lHTWlJcDA0SmJ5bGsvSVoxeEQ1UE03cnVCby9paWozZVZ2djFDNTNGQmJtd1Nac0E2T3FvQ29GbU1BR0IzQUJKMVk5ZnZ3aGs4ZGIrbTYvbVJpRUMzbDVlV3FlMEhqeHA4ZUxOSGh0czluaVVhVTRDc2xtc3puTmFyZW1seGFVRGx0c3VpbDZzRDJrSldTY3RDZHhtcEpPbmZVY3hMczd3cEhudEVtYUh0QWVjb20wSjl5cGJZVU4yRElYbXpOZ0d4ajUrZmxKd0FRMk9JQUxPSFdKZksrL1dQSGh6cjVsWldVQjhGVCs0WWNPd3dZam1PaEdvekdHMjJQNWU2S2p3SkVDOEdSUDdPWEJvNlZEU0ltZTZRVHRtallKSEhudWV6U3BKSGF5ZysrRkRkaUNUZGdHUms1T3ptQVpVd2NPNEFKTy9CMDVMOUttTjhHUVFNVVBRSGcwL0tEd1dqWVFpRFRENjAzVTRYeDdmaXgrVzFGYzdNNElkMm1YNmNmNy9GTTR3U21pcEZQWHRJbnZTSnQzT1BKWDJXeU9UUHoyWVdUUnlEallnazNZQmdhcWk1d05BaDljWkU0S3Z6NEpETUE1dFZ3TmhxSzBYV2ZhRkJIdTBDN2pkTnFYeE9sa2xLdFRCL2tRM3Z1SXROa1g1dEMwdGViZHBjYzlURFlXa1lZdDJKUnRENGlJM3hjcGt4NlZhelN2am5aclNYcFNTY3dWd1dPa3d3azEvcHhPSVVJVGEvMkoyNDRsbGtaWG8wK3B2VFFSanVOZWVVUVI1UUVqcndnQS9SUW5MRTdMVUtRRVVvTXJTMnZrQk4rZHNid1FRU01yZk4rTGNHbFdXYTMyNGVpRDFFUGtjUzlzeUxZdWlDQXZoUk1naElub0tmSWtpZXJrMHJScHhrcGZRUFVlelExb3d6WDhxRVNKUE82VmJWeFFVV0hDS1NQQnFSV05YMWZsT0RLek16eUp4ZEJzdXlGSCtjV1ZFbm5jZzNzN1RGeDRFU09CeWNna2RXSmZsVGRKUHorN1ZRY3ROMVZIb0EzWDVBbjdmeEg1bm5MT0NkWlFSQnJsRVNwWG10RCtKeTlKL3dGWi84VXRTVDVZamdBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wcm9qZWN0LWltYWdlcy9zbWlsZXlfaGFwcHlfMi5wbmdcbiAqKiBtb2R1bGUgaWQgPSAyMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAlCAYAAAAjt+tHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAhdEVYdENyZWF0aW9uIFRpbWUAMjAxNTowNToyMyAxMToyODo0MFNtqGcAAAN8SURBVFhHtZfBaxNBFMZnk2BjiEZCaE+W3kVEPEVBrKR3PVWv/gM9ePJSLR4ED0IFr+JJ8KT3SgVBempFRcRbaU+VEppaahqaxPeb7gvTZDa7CckHj5eZnez3zXtvZmeCdrttwNzcXEZcSuxM6GmPEsdiLbEGfmVlhbaxAkJyiLOh8VsFjQIQQwh5PbQGIoJKpaLkObHzoUfEOCIA8aHYfugbCIA8L3ZBbPLO2sc18WPDh3KlLO6P2J7YAQIgZ+ZFIf8xM3PW5HJpk82mpWt0qNeb5vCwaTY3/yHisnRVxfbJsRYeYR8LOeCdvDuE1lmKCBTlB1Yi/KWSMYXChKnVjqRrtJieLpiNjZqmYVesqoXWqXYGlT/vme3Xz8zFB4/C3mgkHbd2kxI7BcupEZB52xqwEQDzm23zbiY4afRB0nGgKwLUwG7POmdQNyYm0iYQDjzmG0NfnPnQI0BByJgdhNffrJhbb1etB1tbNftCnruhpX9QeAXwcl7Gy4+OmiZIBWayPGuf0QbUCc9VDG39387OgdnePvFYP0RGQENGBFbnZ22eEcGsdeY6YzzPEeGLWD9EClBMTbFPnRSbAjIl11SoKI2QRiwOsQKioBFi1ghSUel0YD7dv22f4Y+PW7Kn8AnwY2gBPiDq0sJjsUXz6+WS9bQLhWykiMQCdJaYC8JO+CE/d3fB/H71VJZsYJrNlvU/l5dM6d7DcHQvEgvQPGMKSAk7IkjF3/fLNuQpWTUA32y25TuQidzaB0pB9+yBKwKfz58xmUxKaiFlPauCrZrviw8jqQEtSDwz3Xi+aL6/eGI9qwJxI4lAUkSly4exCAC+dPkQK0A3nHEhVgChI5S63PCjRKIIaIWrj8rnMFABnNu9cCvc9T4MmC7LiQDO62r29DosNF3AXQEK590dTgTodclu1hydhxVBBNwt210JeiwPYW9GYq3EFxPuC8UiQ+NRrTbs+d8H38Uk7mpm60SEfUkiQsmF6EbYpfVFyHuvZgkup3hrImK9nwiH/Jo0O3kWi76cxlzP1au4nIj46hPhkF+VJrPTPLsCtN5OX8/7IRQGOXWCIeKbK8IhvyJNyDmJYnUlikKsAOARkddIAGfmSpyIHCQSALpEUKyIWBevOYeU4kpMDhILAI4IVgqmhUBeCb3NfVJyMJAAEIrQouQ3gLBT2bYnEYz5D46f9qXQC6MwAAAAAElFTkSuQmCC"//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy90b3J0dXJlXzEucG5nPzQyZTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDIiwiZmlsZSI6IjIwNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWxDQVlBQUFBanQrdEhBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQWhkRVZZZEVOeVpXRjBhVzl1SUZScGJXVUFNakF4TlRvd05Ub3lNeUF4TVRveU9EbzBNRk50cUdjQUFBTjhTVVJCVkZoSHRaZkJheE5CRk1abmsyQmppRVpDYUUrVzNrVkVQRVZCcktSM1BWV3YvZ005ZVBKU0xSNEVEMElGcitKSjhLVDNTZ1ZCZW1wRlJjUmJhVStWRXBwYWFocWF4UGViN2d2VFpEYTdDY2tIajVlWm5lejN6WHR2Wm1lQ2RydHR3TnpjWEVaY1N1eE02R21QRXNkaUxiRUdmbVZsaGJheEFrSnlpTE9oOFZzRmpRSVFRd2g1UGJRR0lvSktwYUxrT2JIem9VZkVPQ0lBOGFIWWZ1Z2JDSUE4TDNaQmJQTE8yc2MxOFdQRGgzS2xMTzZQMko3WUFRSWdaK1pGSWY4eE0zUFc1SEpwazgybXBXdDBxTmViNXZDd2FUWTMveUhpc25SVnhmYkpzUlllWVI4TE9lQ2R2RHVFMWxtS0NCVGxCMVlpL0tXU01ZWENoS25WanFScnRKaWVMcGlOalpxbVlWZXNxb1hXcVhZR2xUL3ZtZTNYejh6RkI0L0MzbWdrSGJkMmt4STdCY3VwRVpCNTJ4cXdFUUR6bTIzemJpWTRhZlJCMG5HZ0t3TFV3RzdQT21kUU55WW0waVlRRGp6bUcwTmZuUG5RSTBCQnlKZ2RoTmZmckpoYmIxZXRCMXRiTmZ0Q25ydWhwWDlRZUFYd2NsN0d5NCtPbWlaSUJXYXlQR3VmMFFiVUNjOVZERzM5Mzg3T2dkbmVQdkZZUDBSR1FFTkdCRmJuWjIyZUVjR3NkZVk2WXp6UEVlR0xXRDlFQ2xCTVRiRlBuUlNiQWpJbDExU29LSTJRUml3T3NRS2lvQkZpMWdoU1VlbDBZRDdkdjIyZjRZK1BXN0tuOEFud1kyZ0JQaURxMHNKanNVWHo2K1dTOWJRTGhXeWtpTVFDZEphWUM4Sk8rQ0UvZDNmQi9INzFWSlpzWUpyTmx2VS9sNWRNNmQ3RGNIUXZFZ3ZRUEdNS1NBazdJa2pGMy9mTE51UXBXVFVBMzJ5MjVUdVFpZHphQjBwQjkreUJLd0tmejU4eG1VeEthaUZsUGF1Q3JacnZpdzhqcVFFdFNEd3ozWGkrYUw2L2VHSTlxd0p4STRsQVVrU2x5NGV4Q0FDK2RQa1FLMEEzbkhFaFZnQ2hJNVM2M1BDalJLSUlhSVdyajhybk1GQUJuTnU5Y0N2YzlUNE1tQzdMaVFETzYycjI5RG9zTkYzQVhRRUs1OTBkVGdUb2RjbHUxaHlkaHhWQkJOd3QyMTBKZWl3UFlXOUdZcTNFRnhQdUM4VWlRK05SclRicytkOEgzOFVrN21wbTYwU0VmVWtpUXNtRjZFYllwZlZGeUh1dlpna3VwM2hySW1LOW53aUgvSm8wTzNrV2k3NmN4bHpQMWF1NG5JajQ2aFBoa0YrVkpyUFRQTHNDdE41T1g4LzdJUlFHT1hXQ0llS2JLOElodnlKTnlEbUpZblVsaWtLc0FPQVJrZGRJQUdmbVNweUlIQ1FTQUxwRVVLeUlXQmV2T1llVTRrcE1EaElMQUk0SVZncW1oVUJlQ2IzTmZWSnlNSkFBRUlyUW91UTNnTEJUMmJZbkVZejVENDZmOXFYUUM2TXdBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHJvamVjdC1pbWFnZXMvdG9ydHVyZV8xLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDIwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAlCAYAAAAjt+tHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAhdEVYdENyZWF0aW9uIFRpbWUAMjAxNTowNToyMyAxMTozMjowOGsHLIUAAAOKSURBVFhHtZc/TNNBFMevpUJTqzUNwkaIG4Mx4CDGhZASR91MnGQyLsSJTYjERR00muiIi4uDURMHgyEuxjgAMe6GwMSfNIBIChbq+xz3mrP9tb9fm/abvLzf/X7X+37vvXfXu1ipVDJgbGwsIS4u1uk87VaiKHYkdoCfm5ujbawARw5x0hnPKqgVgBhCyAvODhARy+VySp4SO+08ItoRAYj3xHacP0AA5GmxM2I937s+fxPfNlzaz10Wty62JbaLAMiZeVbIf/b3nzKpVMIkk60NQKFQNHt7RbO8/BsR5+VVXmyHHGvhEfa2kAPGZGwHrbM4EcjKA9ZN+Lu7jclkUmZ7mxS1Fn19Z83i4oamYVMsr5LK1U6nLzPrZnb+kRkfnXRvayNqv5GpHvdUhuXUCMi8bQ3YCIBfr0rm3K3YcaMOovYDFRGgBjar1jmdKtHVdcLEYjHrsaA+vAuzIFQJUBAyZgfh7N1P5vXkvPVgZWXDDsh3P7S8bxSBAhicwRh8f/+vicXjZnhgxH6jDagTvqsY2vq7tbUts7q6aT1WD1U1MDT0f6gYQEmZsULJffB94HanixR1UTLjT6+a3l72uGOE1kAl9Mc+OUWn5JoKTYeK1YiFIVRALUAMCD2CVFRHR9zcfDhqv+GLxUPZU/7YdhCaFhAERE1cmxabMs8/zFhPO5M5WVNEZAE6S8wHYSf8kF8fvGNefHxgl+zh4ZH1z97fNzeGJ1zvakQWoHnGFFr1iCAV75Ze2pDHZdUAPEKSyc6aW3tDKaicPfBF4NPppEkk4rYW8OwjbNX8vwShJTWgBYlnpo/f3DNP3k5bz6pAXEsiEBW10hWEtggAQekKQqgA3XDahVABhI5Q6nLDtxKRIqAVrr5WPpuBCuDcHgi/wn0fhAbTZTkRwHldzZ5em4WmC/grQOGNXeZEgF6XuDTYo3OzIoiAv2X7K0GP5Q72ZiR2FPliwn0hm7Un91Dk8wV7/g9C0MWEk3G9q5mtExH2NYoIJReiK+6V1hfTr76aRbic4q2JiIV6Ijzyi9Is51ms9uU05HquXsWlRMRSkAiPfFCazE7z7AvQevv/el4PThhs1AmGiB++CI/8gjQh33VWUKJaCBUAAkSkNRLAm7kSRyIHkQSAChEUKyIWxGvOIaW4IpODyAKAJ4KVglEbgLwSepv7qOSgIQHAidCi5BlAWK5s+yYSjPkHieT9Xo2XTwQAAAAASUVORK5CYII="//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy90b3J0dXJlXzIucG5nP2IwNDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDIiwiZmlsZSI6IjIwOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWxDQVlBQUFBanQrdEhBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQWhkRVZZZEVOeVpXRjBhVzl1SUZScGJXVUFNakF4TlRvd05Ub3lNeUF4TVRvek1qb3dPR3NITElVQUFBT0tTVVJCVkZoSHRaYy9UTk5CRk1ldnBVSlRxelVOd2thSUc0TXg0Q0RHaFpBU1I5MU1uR1F5THNTSlRZakVSUjAwbXVpSWk0dURVUk1IZ3lFdXhqZ0FNZTZHd01TZk5JQklDaGJxK3h6M21yUDl0YjlmbS9hYnZMemYvWDdYKzM3dnZYZlh1MWlwVkRKZ2JHd3NJUzR1MXVrODdWYWlLSFlrZG9DZm01dWpiYXdBUnc1eDBoblBLcWdWZ0JoQ3lBdk9EaEFSeStWeVNwNFNPKzA4SXRvUkFZajN4SGFjUDBBQTVHbXhNMkk5MzdzK2Z4UGZObHphejEwV3R5NjJKYmFMQU1pWmVWYklmL2IzbnpLcFZNSWtrNjBOUUtGUU5IdDdSYk84L0JzUjUrVlZYbXlISEd2aEVmYTJrQVBHWkd3SHJiTTRFY2pLQTlaTitMdTdqY2xrVW1aN214UzFGbjE5WjgzaTRvYW1ZVk1zcjVMSzFVNm5MelByWm5iK2tSa2ZuWFJ2YXlOcXY1R3BIdmRVaHVYVUNNaThiUTNZQ0lCZnIwcm0zSzNZY2FNT292WURGUkdnQmphcjFqbWRLdEhWZGNMRVlqSHJzYUErdkF1eklGUUpVQkF5WmdmaDdOMVA1dlhrdlBWZ1pXWEREc2gzUDdTOGJ4U0JBaGljd1JoOGYvK3ZpY1hqWm5oZ3hINmpEYWdUdnFzWTJ2cTd0YlV0czdxNmFUMVdEMVUxTURUMGY2Z1lRRW1ac1VMSmZmQjk0SGFuaXhSMVVUTGpUNithM2w3MnVHT0Uxa0FsOU1jK09VV241Sm9LVFllSzFZaUZJVlJBTFVBTUNEMkNWRlJIUjl6Y2ZEaHF2K0dMeFVQWlUvN1lkaENhRmhBRVJFMWNteGFiTXM4L3pGaFBPNU01V1ZORVpBRTZTOHdIWVNmOGtGOGZ2R05lZkh4Z2wremg0Wkgxejk3Zk56ZUdKMXp2YWtRV29IbkdGRnIxaUNBVjc1WmUycERIWmRVQVBFS1N5YzZhVzN0REthaWNQZkJGNE5QcHBFa2s0cllXOE93amJOWDh2d1NoSlRXZ0JZbG5wby9mM0ROUDNrNWJ6NnBBWEVzaUVCVzEwaFdFdGdnQVFla0tRcWdBM1hEYWhWQUJoSTVRNm5MRHR4S1JJcUFWcnI1V1BwdUJDdURjSGdpL3duMGZoQWJUWlRrUndIbGR6WjVlbTRXbUMvZ3JRT0dOWGVaRWdGNlh1RFRZbzNPeklvaUF2Mlg3SzBHUDVRNzJaaVIyRlBsaXduMGhtN1VuOTFEazh3VjcvZzlDME1XRWszRzlxNW10RXhIMk5Zb0lKUmVpSys2VjFoZlRyNzZhUmJpYzRxMkppSVY2SWp6eWk5SXM1MW1zOXVVMDVIcXVYc1dsUk1SU2tBaVBmRkNhekU3ejdBdlFldnYvZWw0UFRoaHMxQW1HaUIrK0NJLzhnalFoMzNWV1VLSmFDQlVBQWtTa05STEFtN2tTUnlJSGtRU0FDaEVVS3lJV3hHdk9JYVc0SXBPRHlBS0FKNEtWZ2xFYmdMd1NlcHY3cU9TZ0lRSEFpZENpNUJsQVdLNXMreVlTalBrSGllVDlYbzJYVHdRQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wcm9qZWN0LWltYWdlcy90b3J0dXJlXzIucG5nXG4gKiogbW9kdWxlIGlkID0gMjA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9');
},function(module,exports,__webpack_require__){eval('module.exports = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAMAAAExAAIAAAAQAAAATgAAAAAAAJOjAAAD6AAAk6MAAAPocGFpbnQubmV0IDQuMC41AP/bAEMAAgEBAgEBAgICAgICAgIDBQMDAwMDBgQEAwUHBgcHBwYHBwgJCwkICAoIBwcKDQoKCwwMDAwHCQ4PDQwOCwwMDP/bAEMBAgICAwMDBgMDBgwIBwgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDP/AABEIASQBdwMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APxEsrl0lmVV8zaxB78c1OLvf92Nd36mqdhP5F3Mu1eHJz7/AOTVqGFgYzzuU5zjp7V5Z2Fm0mHmKWTO4+vStCBsuSrMeeRnpWfGONys/wAwB47GpLRXXLbm68djUMC+IlWZeI0+bld3erSW8Lv8zScngjtVa2txJG33cgH8TUtmWYDeeh5y3I/CsgLcFjEWDMrSY/vnbnJ9qtzW0IkVvL6DoWzj3qvHgOobZ0HVutaNtGqXB37dq+/XvQAsdhCYlZQTnjAOKkgsFAwy7fbPepvktouMtG3IBPzL+PpUkciyYZsIrL0x0oAhvLSFrde698nGDUsFlHIyoEYsR/DmpYYfOt/m2Ff1zVmxsckZYp0PHegCJLFYZwzeZkDpv4BqZLWOdMr5jMoxjJI//XV4abFL8+cnHTNSJZIihdrH1560ANstLVIs+W6sTycnv+NPTQkW5fIfDDb/AKw8/rVmNNo+6MN03deKlty5O7DYU5+tADItGVIljVnUZyVEmBjvTn0JvJYG1Ybun77I+v1qwD5jbRuDf7uR+dTNJJtUljlRjpUsDIk0VowR5M2MA9+v4U/+zo44tzK/yj+POCa2LWXefmL9egNTShAm3ax3DHHpSuwObjgitt3lqx3DJIOaiksAsyt5LeoB71r3FqrS7lk246YHFTQkwDzI2YsOmecf1p6gZthoySo07KyheT8x2n8aItPELFvLZuOoPTv1xU07XMhLMylP4tvcf5/Sm3d600OFb5mXJJXbj2ouwM/UJnKfKjKqnhiPvVXkZ5FxnDJ1z2NaVzKt0sEcix4j+ZQT90ev86p3cflS7dv3sDOcU7gUgrXatuwdvXANOisI/vKdzE8YWp7aFYYG+VW7AVGytDL93Hrg9KLgR3YREXy8bu/HNRiX5VLDIPGQKdFO5Vtp2Mw6E/M2TUN/eAyMPlj7DjNJMCRuTwfoD3p4nklC4VQO/PX9agijEtvvZVyoAGD96mq5bcFWMIOME/8A16oCe8djCA0avuPIHT/CqE+nwwv+8Taw4wDj/wCtUnntHIrKy7s54qO3km1Cd2ZlwvQFupoAY2l20nzN5q56AdqRNIt2+Xc2FPU4Bx71YupIzEfm2r7Hmq/9o8DG4lvlABzmgAk0KGbasOd3GcsB+PWlGmRh1H3lVvLU5+92z/SrmmXkgYwqUjY8TzMeUHoPetcpY34ZZGWNNgVSvbHT9alysBzV/o8MUe9o2TkDk49ffFRDT7VY2ZtzY4wG/wDr1qeKYWsNM4YyKsmA3973rDWfCfO3Oc8nrVJgOg063ldvl3Y7A/8A1+1WJPCscYVgvmblyNu41DbzmDc23crHoecVqW+tzWzbY2UA4O30+n060XYFceHLMR5McySDtuPP0qjqGlQo/wC5Vjk4wzdP17irhvZ0lkZpPlbrtPei5njW1VcIy5Bxn168Ci7AxXDKPuqRnpjJNQzyqm0bVJxyeeKuXk/n4VPXOBgDNZsx+7lec5PFXGQFG7lZJ93DA9qKsSRBpPm3MPQUVRLOQSTfqVxj5iQDx68GtN4y7EMSZFwT78VnSfutYk24+cKBjvwK09yxDO7buYEn2x/9erkUWYV2QD+62MAjvVmwiDkBt26qVrIqoPm4xgg9O9WrEtGV7sP1FRLYDRVo7YNncNx7jpU1oiyruHzHuPUU37Os8ik7XZ6sNtjlCr/+qsgHG38+MN8q+mRj61cggOfn27QMYB5qLdtlHJb2HSlacRDd5hXnGAOaALymGSJv7w44+lTWkTYA3Z28YJzVOyjYkyMuVXgCtK13bMkN/vY6UAWLSFok6Lx39DWhawNIy/WqEUDXVvIqL95doPrT9P8AMs49rSNEytgIetAG3BY+WobGe1SiBs/df65/+tWE2t3QPyzFuuVH+NE3iK4iMflzM3yAnpwe4/D1oA3BHJvwwJ29varA/cx7dv3h1OTj8KwLbX7yRtzTL+PpVw6vINu64+v7sYxQBtrMo6ofYjtU8Qj2ZV/mHrVG0m80+W14qqoy3A4qePy1JVb0Kw6goKAFCZDbRu/CneeMKrL64x0qM2skp2/apMtwPlAoj0OfYv8ApjDdwOBmlZANlYeZ8wYJ69DUkm14l7Z4yaL/AEi5WJs3DHaP7o5qLw9pU9pLMtwo2sQfu8dMUwJ7RB5/zKu0ds5HFRz6V/aQYou5156dDWpLErq21flU+lNt0Kx/u22t3Ax0oA5uXSLixXc4VlUfMQPmH1FUby1W5VW+WTOCTg/jXXuPPm2svDdDVS70JXlZkARgvfv/AJ9aQHL/AGZYyf4VJ+9nr9BRM6mHO3bvYda17iyM+5eI2j4ZCP1HrUEtjjnbu2nqTigDCng8hW2bm2t6dutUpTtjZtu5umSP09q6G8tIQxwy7TnIU81QvLNYxujMTcjKj6UogZ6zOluq7cKOev8A9eoJl8p9pZgcgnvn/PSr1zwnK9sZNUn2pchlXPTg1QEds6G6PmRrgDADE/0q1NIsSnbjHXAB4qFZsL8qfOTkY/xpr3+I/m3FuScjjNACTXqSZ3KvTPAA5qvFIWIKq2/PGO30pgGcsxx7AZqaDWBaBV8snHG4UAWLOaOMtIw2LtwCerH1/wA+lOk1Gaa6/d/u+c4I6dxTZ7sSxbVVmLZAA5qG7Mkdj52WaPdtZSOR1AyfwpAO1bV5L2x2ySLMockoFwVI9PbnvVBomkj/ANaUGCRu70+/Jgk2MWOOue/fp+FNXZc3+x3WEBclulMCOCRo2QoW4NW0uld5JCkm5uCyinARww+ZuUycfKpySc9/w/nUTX8kdufK/d7TgKMEOck/yoAWSWOOZl24bGDuHOfpUU86yRbViGQeeDwfantqMkmFdsngkAZOeaDdfuOHOV/hI4Y80AZ1y7INqIy49qpM7Fm4br/jWrcahGk68MxZcHI2iqd39391H/DuOT/9ammBVik/0ht457Giq0skqz7iu1fUHr+FFahY55tj6u25TtVQR78Vctk81F27mY9M1l6dcyTXMz/xbccDj0rU0t/Lu1LZ+UVU9AJLdVPykd+PatKKIShVXdv5IOcYrJz5Vxlfu5yRW5YxSTM3lozbhjPXHHf61nIAt5nBX5tuDz+daSWm59zMzDrk96zxCpk+8vmjoMda0rW4WAru6D26VmBajiVUO5mUZwBn+VO0+yF1MzMG+U8Co8vcsu3nJ4A9a3NLsthVjhRwMetAEcMZjh2gbV64NXLKDefL5981LDZ+bPt659R2rRgjjs/m27mHCLjrQA61sI7SH7vzN04rL1jaLmSRm2ovJINa203g3tnaecCsHXLlGnaFcBsjt0wTVRjdik7DNIiuPEDMkCssIzz/ABGpNfsptHsY7hY5m+cIw2k7u3HH6V99/sPfs8+HtA+FWl6xNp9tfatqtuJZJZoxJsDZwADwOMV6P498EeH7vRri3Ok2KquThbdRsPr0615NTOKcanIlpc9enk85U+dy1PzA0u9jvINy/KfusG6qa1tN0fzwjblbyvU9T/kUvxe8Lf8ACD/FnVFiiZbRpZN6j5RweoH05qG1u/7n3WAPSvU0aUo7M8nVPle5ZOh3UjtIpK7jn2qzH4bnknjMkyurHLAen51Ui1JgNo3cnsa1tI1Rp7hYjGfl5znpQA6zsttw5b5V3bR6sB3/AB/pVsafcfaxJ53y7lIAG0KuckHvz0q26tInyx98cZ4z1oLmPaphZsk9EJqeYAsoJhaSedIszfMQQCMDOcc88dPoKtXBZHXaM+vHSnWtj5cRZRgt2K47VYlgEbruxuPINHMBRmt2Rvu/iDUNxDJFyg6HkitwwC4h2/xdQaxbxTArA8+xo5gI7dtkuDzjuO9WJ4BJbiTK8nsapw3JYhdm1ugx3pzX25xjjHBFAFW8tlkLSN94HAIHIqmNFku43ZpPlB4AHer11Nksq/MMdqjsp/IGcH5hhsd6AMebTpo/lbZtBwS3eq50/Ib5o1Oc5x/SujkgWcKzr365qhqOnAyfL8itjpU82o7HOalsCMT95eR6AD1rMJWV9xb5j7cV0WqWcMEYDN823hATzWFeWbLEqruXjHTk1URFK6P2fPzY4qqZd/zYUjtntV17fG1WbucY9qqTbI4SE+Vuhx396oCvLKzttRsqx4HvVm30v/RsluWYAAAcCodOg8x2k+ZVHA4/OppJXRgNxH9KAFtpZLJWXeVU53D+96f0qW+nLWVzHIzMWdD69/X8ahjHnW8jMu5geOev+etKyGQMWywYI2PTBx/KgCHVp47q/Zo9255Tjj1ZjUESKmpTb922MMMVLqUJjuLdowU3nIA7HNV7aN3e4Y9VDM2TQAWRbcPmO4/pS7vKJh8vcVOcDqKZbzNby7l+ZiMLnoD60ss0luWMW5t3Vh1NAFi2gFwGaSZI2XjaR29zUVtcia4VE2jaWHHO4AH1/CiMrayxu3IIAbn61JbQpJcKsZwxbIyfXI/+tQBSV2vLQeZtV4329eemaW2lDXUe4lfOG1tp/wA9jTpNsF1cxSOEfocngOvf6GmG3+zqvnIsnnNlfKbLKT6j05oArS2wlsl3N83IIHsRj+tFSXiR2tuqpdRmbcVK46Dv+v6UVUW0FjiNJGbgtxguOG4zWrZxFJ8thflJ554rJ0xdk2G5B6AVrWk8kUo2t/s5xwM1tMB08SlVbG0HjmtzRHkt45JE3L+7JU+vBx/OseYtKAWYOqn6flWymo/6FDsXhlCseeoHQVjLYCCYqjLuIB4A4q/D88UfG5twB96z9RRnjVuMnHNatiGYrt6g5OePWpAuaSuLqNeN+cEbu1dJp9tuI6f0rH0G3Wa7MzL8yjaM+tdBp4zIvG7GfqaANK1t1UDOPMYdcVHd6fJ9qEi7dmABjt9at2cWZfmVuR+IrStgqArt5YenFS2BmWkDNkfn71yccG3W3gWNppmlxsYfe5zXo40wQxF92Nw4x2qlc6Qv9sWV9CwjubOQSK23cr46gj0NPm0aDqmfdPwp0nUviN8BtM/sPUodNmW1SCRVQsY3XAI+8pHQ854P0wec/aF0y78I/C7SGbW7+CSO9SDUZ7aXLbWVlVst2VypwevQ15b+zr+0OfDniC/t5GEMNwTOIDJgBicnB9+aufGD4g/8JxoV1b3H9vWdndTCVoYoWaKXBGMlu3fK4zXx0uenWUJLqfaUZUqtByjq7fl+R4j+1d4IbQdb0eFdQXUr6/SRpSwHK5GCfQ44z7VyNhp7W0EcfG5VAJHINdR481X+3viXDCysy6XaGMM3J5K4/QevrTJ7dSNwDbhxwK+qw8pKjFSPkcVy+2k4mZDp7XDLzsK85xniultNDitbVJIw3mMMM27G7NV7aykuIPlBx3yP6ZFbdtZ7reJQN20jrx2rTm6GVtDPk/dfLub5j97dTlsWeLarHcT1JNazWowdyK3YZqG6uIVjKsEXAP8AF70eQ+UWytwsS5ZVYDrmi4tmuLS3kVT88Ybisa4vGlu87sqnCDdwtP03WpI7KNS5+VQAOuMUah5GzBbNDbndnbnuOay9Qh8xWOG9M4qSfxOtpYySXDLHCoyZHO1cVgz/ABQ0e4nMMd1H5hOMAE849cURu9iXZDpXaBtv8WemKZBwxJbHGRx0q1KPteGH3ZACCO9RTWPlSfd+U0wK8U5i/gLbugPamq/nsAPoe1OuEZRuOP8AGm2q+YFxjFUgG2ju975LZXdwMjvVoWEjnpUEB/02MAL5m8AelbUuY4CyxxkY+8/Qfh3rKpJp6FROb1fT4VUNnc+flIUncfQev8q57U4THK0bhlKn5s47+p/pXWXoS23OcdvMkfn8B9PTpzWJexQXMJeP527nd0weM04sGjmJAGlkLMwPOQOCOP8A61UbyTyLaQspUY4z/Or2tS7NQYgNulXBx3IH+FZOoFriLG7duOc9Sf8AOK1JLFrcLHa5z8rZz6ihHRl3bl69c1H5Sq6D5o26gkfpTWm2ttPzevHWgC0zqkTcr024I6H1qq1x+8bduG0EMN3DcYFNjl3fwlQGOFI4HpUd24O1TlNxP3e9AFjWb2OaK1EfXIDYB+X2qq22K3b5WGe4ycimTT+bFj7wVjtB7ADPNRXFyzoEVt3cj60AODqZ18vLcdO9SrGz/KPlY89cAVXtpfs0hZflZTzzx+FLPIxf5txPegCY3Cb2VwrMvy+x7UtjP9nli3Yb5uHAyQPQioPIV5A2Cqlh196bGuJs7uEGMgYoAfPGl5fSGYsP7pP48f0qWy0uSOQLF8pYbi7jaAoPQZ5PbpTLSSOHMm1WZedzUv2oS3BDSLJtUl89AeuBQBVu1t/t5DRlWydznB59gaKc4jN421WbfwhxjIAop3A4nRv9bJ9QB7c1sW8e6NWP8TA5+meKxtCGC3c7sHHQ81txjfaRr93kj9a2nuA+1C53dRnge/vVuyi2ytD/AAsMg/5/GqUcWPl9ySOxq7ErQzDLfdGcnvWcgHXB3QjHrwK17WRY42wOVxz+dZV2hD7R8wyBj+Vammx/K27o4A+uOv8AOoA6LRYttlu2/ebsevSt7Rot3XNZemrss41Hua3tIhMYO760AbFhCAqqPmPqOtaFpZbpfusGz064qvpiiKHI+82OvetaF0tYNxwN3OPWswGz2++Hy/mVc1Xj05rydYbeNppJDhEQbmJ9hVPxF4qt9FRWvJGVJGIjULkk/wCfWvpr4VeCtHsdGsbzTreI/bLdJjMfmZgygg5989BWkIczJlKx5Cv7NXiG58PtqUXk2+ow4aFC/wA6r1IbHrxx1FdFp3jC+i8O2NrqyzWd1DGUniZcZboR7ivoDSNM86aP5dyLhifU9h/I1uQeEtLu7r7RNZ2sk0LFQ7RgsOmetcuMy+NWzvqdeFxcqafZnx7+z/8Asnal458d6l4g16G8t9HklP2AFyizLnPPfA/WvYPFX7KGhrFut/Ptgv8AdkLYrO+O/wDwUN0H4d65d6LoGl/21eWD+RPcytstYnHG1QvzNg8Z4HHevIde/b+1Dx3Etvd2tnZ2ucslizB/+Bb85xjoCBXRK6VmYKF9UUPE1vb+HPE11ZwyPNbwttDOoViPX/6//wCqppNVjTQ1kj3lkOMg9TyOa801D40f2t4ouf7Ut1gt5SRDLHk7QOm4d8+vb09Ox0m6XU9FVreaOaNh99Dlf/11Lj1YarQdNJJeRMWeTceyuRVNsW0QWR9q545q0sTJ8u4884xmug+Fnwyb4i/EPTtPbEkckgeUbTgIvJ6UeRJi6HoOpeIpdun2NxebeSY0LAD3NMlj/sqBluFa3kXIcSfKU+oNfpR8MvhPo/hvwl9ht7G3ihZMDbHtNfF//BQz4I6toPiC2urG1kmguw0MaICVDk8MP/r9Me9XyaXYO/Q8r8M+A1+NuqWmmQXEktxc3It7WFR8uOhbHtgnPTAr2HxV/wAE8vFnwzSRdP0v+1LebLm6fbJ5S4zjA5zn2xUP/BMb4Za54Y+MF5rWtaT9ltbW2KiaV92GJxwMnHfjtzX3V4w+OvhrTdSjsV1rT2vyg/0RZlZ+SByBXi4zHzpVfZ0XdHt4HLadak51tH0Pyb+LfhDXPgl432zW9z9m2hpwuVjySOVwOMZ/HFWJ9Y82NWZm2kZODX0//wAFBPGej+JPCdxFayWE08eWlETruRTxgjr3r488JXq6xpFvL8zFQFbI7jqf616OHrOrDmkjy8TQVKfKnodNaX32oFcqvoD+FQ3F/GGbnhcZOeKoNe+S77QvzE9qpOJbrc/O7OcEYyK6UYGkPEn2e+gZV/iGSe/OBXWa1qUUZzgSMp+QYwT1rz+2s5JdQt1bLbSBkDpzmtH4keMI/AelJOy+ddXB2Qxk/ePUk+w/qPWs6kXJpIIy0uYmv+JbnU9XkiB+WKQgKO7Z5z6+lWLG9hkSLdJ5bH74Pf1A9686g8a3y6k10Y4d7SeZ8uVwc565PStPTvGtveKqTf6O79A/3T+P+Nb+wkkSpo6DxXpSx3kLxk5bg45zwa59SOFG3Cgj8a1rm/kvI44/mWSMfKQfvCseE+XBLkc7+cjrUIosDy5V2su1s8c4FRXUG2TLc/TvSu++ZU+XJXPtUaT/AGmLDfeXpTAbbyeZF8y85zj8aj1FlEkXLfKrH8hUnysyyE/N3OOlV7s73Xvw4x+dAEJeNbDdz80jn9BVWKXE+T8vAII+lEocWar/AAgsetQSORKuP4U/LimgLcsyyW67tzbeBk9BUlqyyKO7LwwPeqa+YUX5h83YHmrEX7mPcjbWY4PPakBIXSRmXnb1IHanQJuTbk/LnjHX61XhwQfu7uuT2ojumR0ZFz19OaAEnl2OFBO7PI9aYEKtuO31B9acX82X7rbs9unvQysxjk+9gdc+lADWdo5dyyY3E/Kw4B74oqO9maQljtAByB09qKrQDl9DCqP726VQPzresAW+U/8ALM7hn0zWJ4ej+Uq3QSqcjvzXS2dsLgKjFl68rxWlTcBI7VXkU9VOcEVM8YieMHB2rk/WlhTy1G37uemKdchpJVVm27his73ALmLbbxuf4sZH4VqWgC26KOPmPX3UVSuspZRjaG24ycVp2yRyiPb95cZGP9mpA6nSlXyofQIB+PFbNkfMfZg7RyMVm6dblbSOT/ZGBWxaOqR7j1wM0mBoW8rRIv8ACvQe9GseI10uy+0XDFkHEcQPMreg/qe1Ubq6SKB55pCkMY6+3t7muK13XG1jUFdyY12/KueI0HX8aVioxuVPH3iGbVhFHK26ab5iF+7GnYD9f519K/ssfteaPpng620PxNILG5sVEUFwRtjnQcAFugYDA5wK+ThcNfapJJj733Bn7o7VcdJPL2rGzMelbx91BOPMfo/o/wC0z4NtNMW4l1WxhXbvXdcxjcPUEtXmXxZ/batvEbHw94PnH2jUC0UmoqQ0cAYEEr6tjgH8e1fIPhXwI2oSNJKoVR1JHGfT3NejWPw+urPwtdXmmabNcS2oVmkVC3ljOeSPu9CfwrCtXSia0cO5NdvzPYPgh/wTy1fx/wCF9U1ZVjmVSdixjLT7eeB6+9efa7+xb4qnvWjs9AvY5o5vmYQvGqnPIBYCvuv/AIJn/EC81P4dTW80apbwsuy47liBlTX0F8RtWt7tTG09tuYqjAMBsyQMn9K+SlmGIpycr3Z9bSy2hVpqyPxZ+NXwG1L4X61Z2V3FLcLeMYo1jBLRybQSvHUntXG2moa38J9bU+RdQRuu54LqNkEq+uDz+NfYX7e/iq08EeN9L1PTpIru60nVIb1V3cO0ZDducfKBWfd/td+Ef2jNFutD+Inh2ztrecf6LcRkmS1YjG5X6ow45HB6EEZr6PA1HVoqUj5fGRVKq4HmmgalDr+h2t9Gfluow+3IO32/A11/wY+J0fwo+IlnqksBnt1JjmUHDBD1I+nWvD9E1Fvg948vvD91eLeaV5pa3u1HyFTkq49mGMjsfxq9qvxR+1ysmlxxt1Jnm4X8B/jj6V2Rpt7HHJpH65/DjxzZ+J9It7yxmhubSZcxvGcqwIpfiV4MsfiDoj2l0rYX5o3A5iIIPH5dK/Nn9h79sW8+EHjmfS9cvLi40fVHQxkfdtJc9QOm0g849Aeea/RfTPGMPiTTllWRpI5BnKnjBrolTvHkZVOpZ8y6HEeF/DNr8OGWzFr/AKOrN56kf67cSS3vyxp1j8MPB1n41/tVNKsdPur/AAscYjWPLcDeeMAnCgd+tQ/HTxQuneF2nt2X7crFmI+YRrg9fbOPpmvkvxP8V/GnjeW8mm1KPybWbyRaJN5UbbeM8gk98Hgj2r4/F4X2NTli9D67C5hCvC9SKvqcF8WNH0O38TeK7La1vqtnqU9qojcsso8xirH6KccentXIaV4Xi0PSFht2b5QSSx5yeTVjQbeTVdfupmtzHtcmZnbLO5OcZ7nPfvW1fac4tjhfm9utezhrxjZs+bxjjKfunlvxH8cXXg3VLOK3aNvMQyOGTduGcAeo/CoIvjRavbp5lpOsxHzqpBT8CTn9K0fjN4GuNd0eG4tY/MurEkmMfekQ9ce4wDj615GJV2FcbWXIx6GvXpQhKJ58pNM9Em+OkNldq0WmySMrA4eYL/IGsHxf4xuPiBrbahcBY12iOKFWyIlHYZx1OTmtz9lj9mbWv2svil/wjWk3ENm0ds11PcSJuVACFAwD1JYD869k8Yf8EgfjN4SiuntdLsNWt7ZsLJa3YVnGM52t+VYVMXhaNTknJKXn/Vjop4PE1aftIRbXkfOe8LEoXHp8wxk/1qvrR2aasm35lHp05rW8b/DjxT8JNWmtPEGk6hps0LAN50fyEnpg9DWal3Df6cUljwrDgqOtdsKkZrmi7o5ZRlF2krM1PAWpTX/h1jIzbreQrGxPYAYrXvUJVm5UFwBjrmub8Laha6FZyW8hby2csJB0GfXvXXtaLLaxspLK2HJByMAcEVy1FaRpF6GbICLtmzjauB+VQMGtzHt+bBBbFXb2z8qFWb70mW47CqMfPytt3NyM1mUWZYdhdeflOev41QmYx3acdmOT+NaM6hVZifmYYAxWdI26dW54Q5J7YzQBTnkDRL83dutV5AfO4/u8n8KnlG6BegB3H8arGRorj5j74/CqiA9dyKvf3qZAz8ZA565qJC0kIK9OacXZFyrbstjB4zQBKhxL83XHUmmRqJC3yp83Ayf5VXnBA2bgrMefp3oaTy5gN2GUZ69KVgJppWx5axoOe3U01d3kBvlbPG3JqETtG24Dd/SpEk+VSq/N+eKdmBDc5Ex+XbxnA79qKbOWuLrA/hGBzj3ooAyfCu5oJDnrKoxXUaRJmYBsbQDz2rmfCdv5yhV6mYZ9q6axVY4YWXGHJOO55xVVfiAZCMW4/wB4596lu2zMrKqjGMflThHhc7du3pii5G+ZBu7gE1mBJOu60Xpj5a1dNJS5j2nbuC8/VBWZcxhLY+2MVpaT88kbA9AOP+A0AdpF81hFzztAz71ajfZHzwkYyT6YqG2ZTpsOA3I7jk1T8QaqtlprRqvzTck46KP8f6Uioxu7Gfrest4hv44FG23h5A24z7n6/pR4c+G2tfFTVX03w/YvfX10OcuEWOMdWJYgAf41Qs90emzTYxJMOM9s/wD1q+gf+Ce19a2vjPWvOKrdLYr5IPoZMMR+Oz8658VWlSpSqR6Hdh6MalSNJ9Ty/VP2MvHXgrT5L6+0+GSGP73kzglR6nOBXM/Z2sdUSza2mikhGXjGdzHoAfY8mv0u1GS2uIljk2tHjBDAMj8cof8AP518k/tYeCdF8GafFrNjbMyXEyi1kgXPlNk7oJO4XqVJ6HI6YrysDnE60+SotXtY9XH5PCjH2lN6Le5wvww8FX3jXxZpekwr5c2oXMVpAgPAZ2CjOPc1+l3ib9iLTpf2b/8AhE9Fgj8yx2XpZ1y+oTIDuLerNk4HQHA4FfnD8HPipa/Dv4seEdVnTzI7fVbWedP+ecYkUuT6YXNftZ4fMdxEkiDbuUEHn8K+ioYWNWlNTW+h4n1p0qsZU/s6nxD+zhbr4H07xB4RjuptNUTrcJdQ9YxIvBH0OR+FWvCP7M11p/xT1HVtW8ZatqGnzR7NPsmnIzJ5ZV5SAefmIIz698V2H/BRbw1qfwt8c+H/AIjaTaeZpM0Q0zWkhj4VgzNFI2Ozb2UsehVR3FfO3jr9rG7PnSaCbuLUIo1MbwqJJFAOdgByACevrgV8PjsPVw1T2Td79f62Ps8vxNCvH2nLazva/wCHmeBeP/hbpcPhLWdYvtY1Bte0e5lsru3lkLm5fzSVY5PAKnsOwrzGR2RV3Ivzfd45ArpPiFqMmoeIL661ZNVt7nWn8+V58KHbvtUDHrWHLH9rjVUVsKcZI7V9Plc5ctpHyecU4c94afmcz8X5JLKXQ5A21jAwLA+4IH61j2Xi4Ku2aP5mIy6Hr9RW18cBtXRVxjbHJn/x3/CuDNwsbd26jPpXtx2PGO01PXo7u2jmt2UcYGDyCB/Wvrz9hH9p6+17wp/Zup6lJLfae5jUysOUP3fc9xnHavhK2v2BLIcDHzKe9dL8LPG03gb4g2Wo20zRpvCSYOA6n1/z2qmB+lnxE8XDxVo11ZvtkF9AysocquD7jnrzn2r4jm1jU/DCXFvi487zdhjyWJf1PrkdDXr9h+0JJJpJJkWNVxIWIznPY8d8V5brOutqnjdb+GNGdir5xkHGMfl0rjxFFTjqa0a8oSujs9M0j+zNPj83aJtu6Taernk07d+83f8ALPGTj6VYm/1LbiNzLnHpVN5VVWX7oP4155v5kdxosd8m5W+ftXmPxT+Cw1x5L3T1WDUk5dOiXH19G9/z9R6cuoKkBO8DaRj1/KqNzdLcS7tzBmPGa2ozcXoRJI1v+CUvwZ8SeM/iJ4mjtbe2sxpclnJey3SOs0EZaUkxFSCHwpIbPBUdjmv0c8Y6d4t8bapY6Xpdws1lpr2oud1zNC10pBE77ozlip6KeuOvOR8K/s1/tMt+zGut3o+zS/2xCkEayvtAkDNtLHB4wx+vSvUP2bP+Cidr4d+KesWfjzUns3vGMdncxCNtPjVmJy+zLBg2AGyQAT0r5vNKlSeKbitFb8kfc5HRoLBx55Wber6LV2v+lzv/ANt39mWb4gfAbUodTdLO4kQTW5kPnSQsvO3cQCR2yefevyZHh+48+e1WOX/RZGSR8fKNvcfzr9h/jh8TrD4hfDGS8h1CO6h1BWS2kjYmOQE8EE9R796/Oj44+I/BfgjwZr1vp8rSeJWvJIYIVi3RmFlXdKTjHJLjrngY6k1pkeOqQboxje7VvLu2c/EGXYdzU1OySd337WPn7c0h7HsCK1vCnie40+8Fq0jLC4OwZ4jPp/un9PasLR7gtCVz8yndzUt7hRzwfpX2kopqzPhr2eh095r11HcZmdWXkc0mnTSXVzHI3CqQeO/1pfDtj/wkllDIxO7lX9ivX88VqfZlgXaM8cc1xNWdjcW+cJGzdWxkH04rKdikrNux8nc9K1r9GIY+gwfesxpFJ5GDtxmkBTklzbx9M4YkVR8zzZxnHCn37VYuSPs0fbhjz254qim0T44+UetVEDW0+FGh3feYDIxxVdRmcLtGcnjNRxStGqsoPTJ54xTEnJk3d2HB9KOUB12QLr/gPY/hUTSDZvyc5x1606R83PGNzAZz3ORTbr5m2/d9eMVUewCJdGMfc3Z/Cnwyts+6cY6ZqFSpYcqOCcntUsU6llyFx3NF+wEA8w3EjhW6flRTJbny/Mwzbj3B69KKeoEXgd1jEfmIsiJOGZM7Sw9M10+i2bal5ccPl+ZkkZfaq4Pqa5bwZaTX90tvCVVZp1G5u3rXq3g3wVe6beQ/Y7Wa7hkVsMwH5+3r1qK0km2xxi27HO6lol3otgk1x5DRyNtBifcM++RUF7pktmIZJl2rNwjKQwPB7ivtr9jb9m7TPi5balFfWTJPC3kyJIm5emcgnv7j3qz+0x/wTW0+38Pvc6LqS6fdWY80RPHmOYj154z0rghjoN8slY65YKpy88dUfD9wN1pn2rT0Yq91CvIBGf0NUtU0ubS7i5s7ldtxayGJwOmV4/pUlpcLZhZCeVAIGfrXbucZ6BamOG2tTOzR2+3DNnp1rk/EOu2dzdzj7TCY9oQEtxnvSeE9Luvjb4pt9FW6NrYxgtnovuT79fwr63+B/wDwTb0HxhpM8czzXkksDMdh+dNoJ4B98fUGsMViKWHV6l/kdWDw9WtK1K3zPlGEwanpzGGaJmIyAJBxzjOPp6UzQtb1TwtrNpfaRdzW2obtsLxn73YqexGOoNfZOsf8ETtSv9Gujaa0unsilrVLgFmbI4DYr5f8W/ADxL+zz8QJNC8TfY55FiM9ncwHKsAwB7A56damjicPWi+R38mbVsPXpSXtFbzR6jrn7RfiTWfCQtYFt1umQCZhkLKwxhsdQf515n8QPHPjbV9AvP7UvbVdPvHhM8axqolkRgVYcEhs4JwRnHtWjpcUlzPH5bf6w8n+7XJ/GPxF/aM0Gk28m5IWIbacgv0/SoweGgp2jFdysZip8msmc7BcFNrSOxYSb9wHzDsfx5z7kV+yn/BOz9o+3+On7Pel+ddLJrGgqum34LjcXRRtkP8Avrznpnd6V+OWr6FPocVqWbcsyh0K8FgOue24f/X716L+yD+1jrP7JvxMj1a1b7Rpd4BHqNiX2rdw57HoGU8q3bpyCQfejKzPGTs7n7QfFXwXY/FHw1JpOpzTHTZlKzQRnHng9mJ6Ae1fmv8AtHfDn/hnH4xazYabDJHpEmJLNmO4opUd+p59fSvuj4G/tP8AhH4+eEF1PQdZt7gSAeZbSMEntW/uOvY+44PYmvn3/golqXhPSbJ7rVNWhTV5LUBLJVMkrDcdpAHQcEZPpXk5thYzg3BXb/I9XA4hxknLZHw78QNZXxfZvNfbvMtWfys5OT/+s1i+H9Fado9q7RIMn2rS8RawfEMUcWkaPLNIo3OzsWVsDpwMA0vhW4ubbR7+41IW8DWqkm2V9kg4zjPrjtUYOjKlDlZjjqirSvE4Dxxodx8SfiPHpliQsVmm15W+5Co6tx+Ax3NfRfwA/ZB0fxTpqxw6CuoIrbDd3CF2dgBk8ggdR2FYf7EdjpMl1rOqSWe59UuxbnzFEiwKMsSCeud3XHb3r9bfgtomj+EvBFhZaPBZxW7QrIZEUfvMjljj8R+ArgzbGVFL2NN8p6WT5fCp709T8sf2hP8Agl34gkFxdeHdHNs0SGQ4UJGwPbAOPXkCvjPU/D994S8QXGk6nbyWt9ZyGKWNxhkYf56+9f0EfFK+DvHb/LumyI1YfKa/IH/gpN4IhsfjVNqFnDH90C4ZB8rd859jkUsmzOpOfsKmvZlZ1lMaEfbU++x5x8Mbm88U6xFpHnqrSRkoXz1UZP44z+Ve0+Gvhnb+HI1kmY3Eg6EgFa+Z/A3i6Twp4mtL+NlSS3ckFxleQQQfYjj8a9a1z9rCLakWn6W00jL8zyylUD+wAyQPwr3a8aj0gfPQ5d2ekazfw2spV5Il9mcLzXQ+AvhfceM7VbqZvs9m3Q4wZPp7V89aVrGs/EfXftTRRxtIwIwNkcY4+pPH1r6++HGqXCeE7K1n8s/IEyV2oD34/l615OOo1YpRpvffyPRwNSjdyqq9tkVbP4CaTrFzFayQm0jI5vEmJUD+WfrXM/tJ/B22+HUdhfaXGyaex+zTjcWZJAPlZj/tD9fqK9k0WVo7tbeMRzRgBi7jJ5IPI9unJ/lipfip/Yo8C6p/wkNxZWelyQMtxPcOEWL+62T/ABA4x3yBiowcJwVpvmZpjKlOo06ceU+KvFviE+FI7XVo4I5m0y5injDruXcrDBIrS+Kn7S+m/Ga3tdPvtFsZr6WSGE3KoBIYcgueBkHGfXtXu37N/wAE/A/xN/ZU8ReKPFmq29jpGrJNbQ6jIAv2WKJipkjB53M6twQGwo7E5+Tvi94q8B6F4t07Q/A9ouoeG9HLR3OpXsY+06pM0hDylhz5exV2KMBQT3JJ755bCpKNSputjCjmNajTlSpvSW59V/Av4VfEH9qC2t/DXgsTyaFo/wC4n1a9O2x0pegVn/jcL0jXLHjOBzXrfxH/AOCUPhHwx8N7zTV+1atrFxHm41i4Qea8nP8Aq1H3EB6KDyOpJ5r6b/Yz+MvgH4g/AHRbb4fLZ2ej6XbCJ7OBArQuBzvA/wCWjDDFSSw3DPWuo+I/jfSvDHhW41TWrq1sNPtAXmmmkWOPaM5yzYC9sk8CuzBZbRpK63fUyxOMqVVaWx+C/wAav2cvEn7P3iOa11Wxn+yq2YrlVJjdecHNcY7/AGv5QrMx6ADv+FfSP7f/AO3u/wC1J40+x+HbFdO0HT2KxNKgWSYcdcEjbkNzn5gw4BFeH6f8QfsyhbrT41Y5/eW5AB/D/wCvW0m1tqcit1ND4aWM2k6bKJ4yvnTFlVuoUgD+YrWu4lBOF/ixj1qtovivT9ck8qC423GOYpF2ufw7/hWvLYLIic7mYgMfU1xzve7N0UtRASBtvpWBNtR2O3LHA6V02tr9mgkyuCTiuduCgK7s7sqODUoDKmkxbrtVV5bB9OTVeJ445DuJ347D2qzcyqttyo4LDn8aqoyyXaqvpj9KqOwEyyqSq7fxPpUTNhm2qM5OMd6kCqke7I3dh6Ux90r/AO1gDk+3WhAQed529m/hGPqMillnwvy84YH0470ydfLhH3cMQP8AP5Uk6mIrj+LnPrWgEpMLsoDDjk5Oe9SSLHLNGFVVVyQSP6CoI5lB6KD1qwduxcfLkEqSMgDFZ9QKbwp03Hac8Gii6IjSNw27d1yc0VQEngKc2t1wdm35sjsa978BfE9rPTRFI0VrbWozJM/G4HoBXhXhK1EE0yyqzMwVgVPbnP8ASvTvgdpUfxI+J2j6D5PmWtw7DGwyBX2naWHs2KxxkU4cz6ammGu6vKutkfb37Avx7tPHPjO60HSNsgSMXLMi7SpHbPf3r2b9rbx/ovwv+H9xqWsSb5GXYlurYeRiOB/nn+nPfsUfAjT/AILWNxq0cEK69JF9nu5wg+fjgr3xj160/wDau8A6b8RNHuY7jduuITG0rRiTyVGCSN3APHXr0r5ic6ad9bM+njTqRg4PdH5sfHS+bVNdj1RdPaxXU4xKoRTsmGSNwJ78YOPT3rlJ4Gv/AN2mFaRdvzdBX05+3Zr3hP8A4Vd4c8O2NjqUOpeH44o7OeSDy45oGXLYJ68qOTjJ6ZGa+YdpaPb0O3A9q+hwVTmpJnz2Mo+zquNztPh1rGk/C2wjNxHDd6gx8xix4Bz/AIHFfbH/AATv/ajtbj4sw217Nb2y3EWyODkF89ByecYx/wDqr4l/Y5+FWi/HL4/2+heJ5phbeRJJFEsjRm4mDKApYHOAGLcEfd9M5+qP2Qv+CfviGb9qHTfFljqNvdeCdHvPNW6lk2zuiEjZswMnOQG4BHPHSufMKtBylRk7Stdefod2X4XEqMMRBXi3bzVu5+nXjXxRpOjeFbnWNSvLXT9PgTdJczSBVX2ycV+Xn/BQn4h+G/iNrvh6+0iaO5uftk6x3Kq2LiHhWwfQEjn2HrX3D+1n+zbe/HnwFFYw+JPsGmQOrSWwQfvsfwZIOAeOVGfQ1538X/2K/DXxE/ZF0zwnpNpbjxb4XgabTdQRNm+6VQZVZh1V8EMOeQCOQK8DB1IUqinN+p9PjMFWxEXTprbVP9D80fG/ieTwppa21rJ/pN4M+8adP16Vzng/QrjUtSa4kX7gDAnK5+h6cirureBte8Q+MdSjmtZIm0mc205kHywFDtKk/UGvSvDXwnjvNIVJNQkEBONsKhAv584/+tX2UalOjBXe58JKjVrTaS/Q5bw74K8RftGfEjR/CHhSw+361qEhjtrQFVCMqFmJZjgKFViSTgY9q9J13/gjT+0kH3R+Bbe6B+YGHW7A49sGYH9K+lf+CSfwZ034fftYafrM1ru8yyuIYp5/3gBIBOPQlQ3oSMjPOD+tcUNmI18uGNs9GVVwP5mqjilNXhsX9ScdKh/PjZ/8E1f2mvhqWvrbwR4m0RrUBpL60vIf9FUcs++KUkAAZJHpWTeRal428U6bJ401jUtYu7VhZ+fK+4yDnqx5PzE4zX76ftEeGLzxj8AvGOm6ezW17eaVPHA0eA27aT/kfUV+Oui/CiwubLULbW1b+0LaR4pI0j3LGwwoJb8OO351z1sVy6z2Kjhb+7A7j9jX9mHR/ivd6S9vYtI0sshYlvlQqD8x9xgV3H7UH/BG9vGczXuh6tpOnTeWfNjLybWOPvcL16flXoP/AATd8FxfDy51a3iLtCsKTq0pB2MTgqPQHk4r2348fHLw78KtLiutevmhSY7FWKJpGJPQHHT8favmcZm1enJui0+x9Hgsmp1qcfaq3c/M34W/sueIvgp/wmPh2a+s1uraIXsbKcxyw8qxQHuCqg/Uda+5PglPqXgv4Laa1xbzahqFrAD9nXiRsjKg5PHPrjHfFeS3/jTQPjX+1z4K8N6PavDJfG6+0TzxNB51m8EhGMgbsMNwB6lBXqXjLTta+EniC3026vrdLtoC8MkLFkmh3EAfMBllwOMfzrjrTrVYe3qLT9f62PUy+jhqUvZKVpL8u/y1TPO4vDfj/wCOx8eah4ivpPD99pEc0fhuG1ZWAmGSr5X7wKL9fnxwRXwX+0f8OtS1/wCH0mqWerXmvSTXKj7PKubwSHJli2jk7cEk9/0r74+InxcHwq8MTXGoa7Ja6zO5ubVLaJJvMY8LvUqSeg4UZwMA85r4N8Ra59s8aXzG6vpJJbmS5lkuYPILO3JYJ/Dn0961yurJ1eaKtqn/AF/w5z57h6UKO/M9dendf1Y+XSslrcyRSxtDIh2uki7SCOxB711Xw90y11u9ZZVbzox/qycAj1Hr1H516x4r8L6b8Qhs1SFWusYW5T5JgP8Ae6Nj0avHfsbeAviXDbzSSR29vcBDK6bSYzwWx9D+lfeRnzLQ/Pz3z4W6AWlXcI44XwAwIGDxX0J4b0v/AIlEZmdbaNdrxqflYOpPBB7cfjzXzfp3x0s/ChjjsdPWaQNuE065wcY+UA4GPz55rL8UfHrVNcW4a4uGi53HaSABjg1wzw85O5tGooo+iPiZ8dtB+E+mXGoXmos6LmVLe3kBeaQdYwMcZ9eg618QfGX49+JP2hdfFxrF40enwv8A6NZRsRb246Z255b1Y5J+lYnxD8b3HjfW2kkZvKj+VV9vf+tYtvOtujc7m+vSuqhQVNX6kSqOR2viz41eKNZ+GOj+CpNZk/4RfRVP2exhRYomLOZC77QN7bjnLZPJ5ru/iP4Q8J+EvAVq7NqX+nxI+mW4jjDI/kxzFpDuJXdHcW79TnJHGOPJfAV3p2m+ONHuNXt/7S0qG8je8thz58QYF1A3LnjPG4Z9R1r3f9tb9onwX8eNKs7zQbK6s9UXVJJikkWzy4DY2Vvh8ZXdvtSQFJwp564Gkr8yFHZnKfsxftW+I/2XviJDq2h3ExsTKi6hZK64u4BIrOgLKwRmC4Dgbhk9iQes/bQ/4KR+Lf2uPsmnrHP4a0S3i2S2UFzu81jkOCyqmY2G0lGB+Zc5r5ye48l22yZLckjgE1Ekis+1snaM5DdTWupJtaZDbiwm5YMFIBx0ORULt5YwGHynn3AqTTdpsLmbO5W4TB6c5P8AWs8z+Z8zY+b9KQEkt3GLqOaORoZoyCrL1UjuP8PrXoHw48d/8JEJLO6VVvo8MCOkwH8Q/wAK8vumXzw35e1PtL+bTtTjuLaVllh+eIj19PpUzpqasVGVj2zX/wB9asfl68frXN3iABfTeBjHSptF8Rp4g0VZlO4SffX+6w6iq19NsMeP4pVx7CuHla0ZsZ1xFm1O7LNl+MdeDVBE3XBCtjC98c8Vo3rKID7M3foNtZiLmTPzblXgD8quIFkr/o6r1yfTqTT4LRTjGGwDk9KhlkYlV3L0/AVYh+VWHmHbu7AUmBSvYPKePcN5Z/rkUs0bTqD8oUZxUd/IzhT8vytnPf0puGNvu4UknGDV9AGyRyBiFZN3XhaTMkT7WUttPYVLE+ZPvY7cCnSy7Su7PTGP8/SlqBn3VxJDNuXn29KKjm3CVsZ60VXKB01jpn2i1jWNmkmkwoRMliTxgd+emK/QL/gmL+wp4r+FHii48VeJtHija4tx9lt5JB9otieclSMDI7ZyDniud/4JUfsKXWr65Z/ELxfYvFa2YE2jWlwn+sbqLllPYD7me/zdlNfphpml5tlbbiTBAHcgf5NZzipxcG9zWjFqSkeY63Dpvgd7j9x9hfUJDK6uNoZ9oHGfYDgcV41+0L4zWDQ5o7Vo5pZY8AE/KQBnFfT/AI68K2vifS5tPv7ZbiJ15jI6HrkHqD7iviv9o79nPWPhNrkmraff3mq6HMMKk3zPa57E917ev1rwcbljguZao9ihmDk+V7nyD+1b421fxUmn/wBobMLHtZBHjbk5H5dK8nhlVbZf72MV7f8AHsW2uQIsu3ONpwBkMK90/wCCW3/BMJvjfqFr478dWTr4Tt5N+mafKhH9rsp/1jj/AJ4jsP4z/s/e9LAcropR0PMxXM6zvueSfsCfsJfET4ufGfw74stPDOsQ+Fbe4859U8xbZCAp+4WYFwTwSuRgnPev1W8G+DNW+HmuTWd5pa22k+QDFdKxYPIW+ZWxlR2PB5JNe+eFtAt9DsYbW1hht7W3CQRxRKFSMcDAA6ADHHpVy6tY451hmjj23KEBWAIYE4x+fHvn2rLG4ONeam3ZrQ9TLcZPC03TWqk7s+Y/ireX0+nyQ6fcLb7gxWVhkRAc5xX54/HX9qnxH4q0uHRdHv8AWtHu/tyxCaxvJbdC7tjLMDtIJ5GR3r9M/wBpj4Eaq+h3OpeFcz5Qk6fwpmyORGxOAWHRTxnuOlfln+0B43tbaX7Hd6FqGialYXKzwLe2zW80bxEBchgDwQOCK8H6hUhiFKcXZPdbHvSzVVKTjGXT5nrXwY/Zhu4fBOn6fqVwLq43k3d8QG3M7lmAzyevUj9a9A8L/ATQPCHixbe4h+1w3RBjRiF8iTBLRuOhU7WYEdMN1yK9DufEVj/wiGlTIsMIurOK5jKsQi7owzZOMfxP19K8h+MPxYt7Dw6zQzYv7ZI7m22nLM8Y6t36jr3zW8pznK8V1No0KNOHvdjvvCnjnS/g74xuI7W4tYUtSJoY4myzKjq23J54KhcjHBJ74P6IfDH4iWHxH8E6bqWjsk1rf26XETocoEbPJI4BBBBHXINfhN8Sfjz5vxPt51hzY3CK4cvgiNx0x7rgHOc4+lfpX/wS5/aP0XxH8BbXS4biBZtFnngkhQ/MyNI8iOR7biM+xr28LRlTVpbPU+ZxmIhVfu/Zdj6y8ZeMo9B0mV2k+6BuPTOSAB+J/rXxZ8SvhF4X8Tatql5Bp8sd1HfXH22K0by2I89nXAwRu2sh6cjivb/jv4pmKaPp+5lm1rVYI8HjCBwxP4Bf1r4T+MP7Udx8HP2jPGkEguH0/WmSaEA8JKo2nj3UD/vkV5fENGVShaC1TOzIcZGhirz2aPo34dazb+DYIZbNXW1ulWRldcSbSBww9Rmsj48/CTQPi1HbmXUr7TdNhnF7qLrcyhbqIdYyN233HGBjPXr4D8M/2t4fEuvxrfSJG6n7u7nH94j3/pXWfFv9o7T9I0VxHbyahcycwwxx7kUDByV6Hp3zXyPs6sGoLtdP8z7T69hKtFuS1TtY9m8ZeENI8Rfte/B/xJYNb20tgt7aOdgVpIVs5mRcegww+jmvRPjT4K074z+FprW6kNnPCzPp16P9ZbuBy/8AutwCOhBHfFfmT8P/AI3+ItP+N3/CSLJNpDabeC/ERldYmVwUkUxcL867geOhr6F8cf8ABSJLmy/0BIopmj2lNu7aeSefc8/gK+zy2i3hnTqq6bPhM3xtN4lVaPu2S9br/gGB4r0a8+F/jJn8UR2sjx7oY7iJVkSdP7wz0J7g8181/HKKy1XxIl9p7KsJaRFRUEaooPoMDqf51F8SP2ptY+LHjXXIpZmNvA1uigfwsA5Len8WPwrl9Q1p9ThCNjcrfMce2KdHJ/q9ZVIPQ4sRnDrUXTmiraXCtM2AWXuh7V5D8cbyO68bqsTbvKhCsM5xnJx+Fd34v8ax+EdNumbDXUOAoJ+8G6H/ABFeMXN9Jq11NdXEmZJGLNgetfR049TwUb+m6ouoRwxLI3mKnKng8d6r+OtXkgiW3QMrSDc+fSsG21eSz1FJoWCtb5IJGevH61Fia9naaaRjnlnY9/8A69bFEaW5Rd3p0yeWqJImV8su7Pb1q4qhx2Xb+Qp1tBDdTxmeRoYGkVJGRdzIvGSF4yfbIzQBVsmU3inLKw/SrTXCG4VZGbu/Hv0r9J/hF/wTu+DfwxkWLVrr+3tSvSt5b2/iS2k0+dkCD5FjbbuAySRgkZweleB/tifA7wn8QPCNx4k+H/hm08NTeHriW1vre2m3RXwB4ZRng8EjgZHHWvCp8QYedb2STS7vRf57+R9DW4bxNKj7WTTfZO7/AA0213Pki/IEp2ru9c1WBVx3DdxVvKtFu7n1qOCx8xvTA6178ZWR88WNKvzYCJRtw0mxiT0HANSXCLb3u3d8nTis+QeUki/3iMkjpWnqV2J2ilC/6xQ2cdaGBR1O0ydyt+HpVQDydr/3Tg4rXnUXMa/3sEYqrcW32aJ8jbngjFOMugHQ/DUN9puMMqwyBdyZ/iz19uM1uaiF3Kv8KyAjJ6CuF8L6z/YOrKzt+6c+XJ9OxruLq6VyG3LtGDXJiItSubQehUu/9IU/LhWLDOO+BVDzBDOepVenvSXF4FUBWZsnOPSoobhRP/Evykj61iii4g4yCOucHvipkdY5WbDFSeT0quk4k2r/AHupAqxER5g27m3DHNSBV1EZljUAbMkgemcHFQpB5kAX5fv5Ge/erWqlpJ12sAFJH6Cq6QblbqzEjrWi2AsQRRqrFvlb17VDqR/0ndnqMjNOZygYbcr/ABd6gnnBdQwZcjG41MQK00art+bquT7UU6eXy7jyyoJCjvRVa9APurwn/wAFlbnwn4fhstP0W6vLq3tlXfLKiRs4VRk/KeM5PTP9JdO/4LeeNoL6Bp/Ddm1nGBmOK+kV/wDvogj9PX8PhPw8WGoLhNzMQuCcZzx/9f8ACtu9Sa21AKxgywGAGzkV0KjBGftJ9z9CfBP/AAXA0/WNfsl1/wAPXmm27kiaWO5F0sZI65IDEbu2DgYr6H8EftK+Df2hfCVzHHqOmyLJEJQfNHl7W+8uT/EM9PqMCvxbug0jNujK+69Km8NeLtU8G3bXGlX01qxILBG+V8dMjv3/ADNTOjfYqNZo/Tz4Z/sAaD8VP2ovL8QanGvhnS9t9LpynEl+S3yru7QnncRz0XjOR+mnh7Q7Lw5pUNraLaWsFvGscUUe1EhjAwAFHYAY44AFfgR8Af25Na+HHi+11ZrxvtEUXlXEc43RzruBx1zxgHnGDjFev+M/+C4njR7S507RtKt1ZkMaXJYoFPODjv179cCs40eVciRccRZ3Z+ynjD4y+EPhTawz6/rumabBvIXz50jEhwehYgH8M9q8r8af8FAvg+6W80fxA8L7bd/mK6lE2BtbAY54+YA/hX4ieNtd8VfHQT+JvG3iGXULiNC5W4fdHbIfQdj9Bk8dTXkl7FBLeyNbbxb5+TcecVX1eL3H9bl0P6HPBf7dXwv8dW1xb2fizRL5Z3JhiiuQzSRtkkAdRtYEj0DDHIBrgvj38APAv7VFlmOSxvr58/ZpGGx7jA6HHfHG4eh7Yr8FHla2lEkcjIyHO5WKlffNe2fs9ft/+OPgdcR251W6vrCM/I0r75rf0IJzuA/HjpU1KPu2SuVTxcoyufZn7Wfi+/8Ag9Zw6bNEdNn0fbCltLnaIl4U4xj7ucex9hXx744+NN54jkVVvH3xyMcs3JU8465PpzXp37UP7XOqftJ/DhW1Ca3umt4ottyFDSN0Dc9QDnOOme1fK9zJNq1xmFkaNODL0UfU1z4XDw1dup0YzMKlWyT0saOoeIW1Hd5lwZGtjsRmb0PHH5flXo/7Kv7VetfswfFmy8QW8s02m7THqForjFxAcFsZ43AqGHqRivFXuf3jxo2W3Z3joadeXT+SsW5pFUYIHbua9BxTVmebzNan7oeAPjZD+1FeeCfENirfY7e3kviGG1lV4lWMkH/eA/DNfFv7f2mxx/FO6ZlG5UQfiSQf1rG/4J0/t6Xnhfwta6Hqs3mvpUYsVkmlZi8H/LMHOfuqAox0CgVt/tk+NLX4i+LrnVLURMkkUbsYySrHdk8Hnvj8K8mtC0uV9zqVS6uj4r8feKdT8E65a6ppd5cWdzA5jDI5w4PPI6Hv+dbPw6/bF8Q+HfFFjdX0gmhEoFw5y37skZwvT8qwf2h9PNtcW0kZ/dLIysuerHkH9GFecwt5u0Y68fWu54WjUgueKfyMaeIqwd4yaPo/9oP9oSC98TafqFjJ5tpfIeUPReCfryWrnfDnxQtdQjUyT/Mxzye/X+leY3PhW+MVttaO4ij+ZUDYIz1FHjfRWtrkXkf+ruMBkH3kb3+tTSpU4RVNE1Oabc5HcfDa/wDO1bxBNJIo82YAc/e+Xn+db/iDxjY+H0a4kuI1EkeQN3Rh7fia8Usb2WOWSOKSSPjDYPWo7uOSU/vWaTo3zHOPpXS6abMrGj488ZN4z1USqHWKMcBuC59cCsW5k+zW+0dxk+1WoYEYbu6g+2fSsy+kEo/mRVrQZ9dfsaf8Ew5Pjx4GtfEni6+1LSdN1AebZWdjsFxcRnlZWZgwRT2G0kjnjjNP9s79gOx/Z70GPUNB164u4MssllqAUTYXklZFAV8D+EqvTgk8V9tf8E5/FT+Ov2RPCepRNNC8NqLSST7pZ4MwnB9Pkzx3J9K+bv8Agrvq2oeF/FOj29359xp95CZYJ3G4O5PzJu/ixgHnke4wB5Mc1pyxX1VXv36XXQ9ipk9WGCWMdraaddep8NRQRzXCQg7V3cnPamT23kw8fdycAjnrj86s2djHJesVfy1GCSozt9f6066hk+1vuVVxzj72PTmvWPHPvj4C/HbxVYfBfQWXXNJ+LXg+4s47TV7LUo0h1LwxOVA+ZmJMkSNn5ic7RkcV5L43X+y/EV1FbL5f2xfnEU+5ZlJzkgcf4gA+9eA/DrxbefD/AMSWOoWshOnSSCDULeO4VXuoMr5ilM55DcMRjIOOhx66gR7SO+tZlvLO6JNtLGQwZe/uCO4OCK+NzHLZUavOrWfZW++2l13tr6n2GDzRVqSpu913d+ltL62fa+nTQ8B+IGgnwx4zvbMIywmTzIgR/C3I/LkfhWVay+TJ94fMOcV6X4g1G913VJo44PtKM3ywNH5i/wDfJGM8dcVb+N/wwtvBPgDwvqd1pcOm6lqTOJkgzGrKACMrnAPXoB1r62hzOnHn3sj5OtbnfLtc8qmsWljk288bjSwjOkxPy3ll0Pt0P9a2IZbdl3eXGqsCMdcf5xWHdzKttPHGfl37wueAenH51utdDMmtJ98HzfNnoe9F0zPCwYbuODWfa3LI+7dV83ImDK3p69aJRsBmzx+YrseMdB/n8K09K8RXVxbx27zBY4xtHy84HTNUbmFtpZWOD1NVbdhHPuJ4yBVuKktQN6LU1klMcirnGVf1/CnJcNHPvXb6Y9qyWQifY2ctwM/pV3SpGaBlY9OFz0+lYVaaWqNIy6M3LJ/Ok+VsbuD6Vcjl2AL8u7OfqKwrK5a2ZlK/L2z2q9DP86/LuX7pyOBXHKJoTXEvn36rt78cZ54ptzI3mqsbbhn5sDoRUTqBdZDbfTHAHXtTILxogT/FnB4quUB0RacSEsMr156+lHl+Z5fp9O9Ms5y27aOe+Kv2Nn9rvmi+6wV3BH+ypOMfhRsBk31uZLrcdx28UU75ltGml2NtODxjk0VpysnmRZ0Y4nbn7p8vcfXFal1qNt9os5pJocsuXAO5l46Y5Oc1n2mnNb2K7eOdx9812PwpnjW1vk2R7o5vvEAMA3zdfqTXQYnJDU7e3u2Ejv5ZU8mMrz+OKo3qeS+Y/mjbnI9a7Pxpp6pN96Jtwz0HNcZer9jdvlVVI2kDp+FAD7eNZcZX7uOamsLgPM3yqdr9fX/PNVbeTbbFvUgU6wLeazL8qlxyR0H+c0AdRr3i+bWLEWMcrLZRkFlHAkYcD8qw0ZivOOuOO1PUiFSoA2/yqJTsm2E/eORx+f8AjQBIBx/s1UvrFWj3K2yTsR3q391ctUNxIrblbay4yRQBJ4Q+IFz4at7rTrhXuNNuhiWFW2sh/vKfrzg8H261HIsSy7rd3aF87cjDAds1m3NriVZFVn47DrS6fdAttUsvOQD/AA0WS2AvhVQHa24v+n4U8yx26MZC3yr37mtXwR4TufHGqfZ4nEcacvIR9wfT1r2DRvg7ofhvTDNJaJeTOdu+4USseDgAN8o4BOeKxqYiMNHuXGm5HiHhHx5P4S1mO6tC0ZXAZd2BKPQ16beftLC9syrQ3Ss4+ZBgqB9c19X/AAK/ZQ8F/Eb4PX3ifxnokky6HJIRZo32dbgRpvwduGPTgAjJNfLn7Rv7MfiD4eanceIz4dtdA8P6gsc9vYteL5luGQNs2M2/Iyc5HH6VjGtSqStJalypSirnlPxG8b3HjXVVkmj8mFcYUnJOO5rntOkWHVI2H94Dita4WHUrdWyI8DBrNnt1jK7f4entXXaysjE7uE/aPm3MWUY4Tbn2P8q0oNCXXLKQTNtRhtZSP5Vl/CfwL4++Lmptb+FfD+qeIpocCT7PatJHF6b34Vf+BEV6xF+x58cdHjZdQ+HmoLDIA26CaCRovqquT+HWuGpBp7o6o1E0fPviTTodH1ee3sz5qxYBZ2yWPfH0qnc3jeQu5WUrnPpXoN7+y98ULW5uZpfh/wCMCvnMGkGkTsuck9QuK4jXNNudDvJLO+srizuYTteKeMxuh9wcEV2xknszlt3KkEvm2J2RvNNIT8qKWYD6Cs+XSL7G02V2pxxmFs/yr1X4Wahpul+FGZrJZrrDsx28sRnH8gKz7ye8s7aS7vo7u1iLZBKsijPQDj+Vc8sVaTjY6oYbmjzXP0S/4J7a/wD23+wRouk6dMtrq2jrMs9vBh54S1zKfmjYZBZTuAIwQ3X0q/G/wLD8a/hivgjxxJNeaj4Nthq41JGjWOUM5EInPHlEoH437nVlYAY5+Hf2avE3ivQ/F8/iTQLzWNJ0nTQBdS2zN5mokbnW2VRnczeWxx2Cscg4B574xftgfED4yaZdaTr2rMttNeSXNyqReTLMzNkrIRgsq9lPAxgAAAV87LJassTKpTmk27+au7/8DdH1UM+pRwsaNam2kreUrLT9H1/EqfFXV/D9z8Vtcbw3G0ehmfFspUKCAAMgL0UkEgc8HrWLp0qPeO0qufLikcbWAOQjYJ9gf0BrB07fbHcu1+Oeeoo1G2lZF/i3Hc20/l+Q/nX1VOHLFRvsfG1Jc0nLub32eGJ5JGk+SK3jCOsZ5ZkDBBwOeTknjCnGeAdDwN411X4P66upWcccs81qyL9pj8yE5+UOFyFbBU4zkZz1rj5NUmkb5/mKhVBAxwFAH6AVebWG1S7WOPc7eUsYTHAwoB/lmnKKkrPYUZNO6Ppz4O/t3+G4ttv4u8L6XpV9xjUtPs/3Mnu0agsp7/JkE/wrXC/t0fHDTfjB4j0Gw0G9XUNN0mGSd503bTLLt+UAgH5URe3BcjqDXlupalYaWdoginl2KHO0bOBjAH9e9ZEupWsjborfyOcgqen5/wBMU1psIqyyeXD/ABLg1UD/AL5R2ZSMVZu7hpZWZgu3PHFVtQTc+5V29O9XEBuAW/Ej6VNEyqSpHbGc0jOsjrjA3Dn6/wCc1FdDy5Plb056U3roBNM2239dpGeOgzVFl3g44q5If9GOemMCm6ZAv21Bu3DO4j9acdEA0s2yNm+8o29eta1qfti/Z0C7pDkVFc2n2ePzPvITn5k4z6UaVPHywAXn+HP6elTLUCfzPNbyWXbJEMGrlpOxRlbcdvT3rLvbnbdfLnduzkn+dXra4Mku7y9u0AsQa5akUjaMrlhZc3uGG3C55qeXTYpvmUtHzgnNRW7LfXjEr92Ibe2Rn/69XIk+TduxtbJFYSZRDFEbZlWFfq3bNanhxmOvxb1H7xXz7nY1ZsPmRyMyuNucgCtDQJjJ4itz95grZx/uGplsyqfxIwWgWWxkb7vQY/EUVYghItpJCrFVbDFRnHT/AOtRXYc/Ky9GNlocDapPX0qbwjqDaVr0i7sJPED1wCQf/r1TjvPOgG33yKhnH2e9tZlY7N20+q5rQk7zXbaKfT1kVvNI5yB0NcHq8f2mVgfl9K7rR79Fs1SRY2478lvwrlfEtiY7pi0X2c54BGM/hQBiWv7638tux5Pp1qe0kVYtqg+WvQgexqu0nlrIA3XkkfoKLNmzCu4/UD/PrQBd8/cFPPyqDnGeoFR3l59msd2A0ynK/wBaSVvJhOG9B09qzppd8jc/L0IzQBck1Pz4Fba3zcj2qKe+QxbdvbG4Dp/nmqcW6OQxdfL+7xTkmUBh1X1J9cUAWre7YW7KncdSOopuzz18wNtdWHbrTIiEDbcZ4xTt7eYPzFJgei/AjW4bDVryGSZI2lTKBv4j35r64/Zl+DLfHfxFZ27OIbGxkE88g7jpj618Exy7ZBIv7uRD95Tiv0I/YHvn8NeH7O4/tiext9UtkkgimWMz3i4ILRgHJVSDk4yMHNeZjI8vvnZhve91n3NoXgjRfDuhR6VpMSW8Fqd4weWbrkn1r598Sfs6+H/iN438Vax48vI9T1EOkOmq67o7RABhtnRiSSPTp1OMevWviOa2ezg05Y9QvNQOyJYjnfxkk5OAAMkntWxpn7OVvc6rJq2szDUL6YfPCOLdPbb/ABfVuD1wK8+NVt+4j0JQVtT879H/AOCUmofF7xNdXGi3sPh/w3HdETahdozKV9IYhy7cgYLKOozX1n8MP+CLHwf8G+GYW1ez1PxRqEkYZri+upIecfwxxFVA9juI9TX1X4Ye10y2jhiihjjjAVVCjamK6TT7hdZmZQ263hHJ2j5ia0eNny25jJYSKd7HnHw1+Elr8N/D0ekaPbWmmaTaKEht7W2SFFHsFA/E9TWj4i8HwjTfMmkZtwyPmNegR20c8MjIv3eg9qxfHWkjzbeM4USYwue/WuGpOb1bOuEY2tY+ffE1xqvhzUFtBCLzTG+8G+8o+tcLdeD/AA//AMJOurR2enXN7BlTDfWyTqAe2GGV9cgg19R+IvA1vf2+1oxuA7V5R40+Dn2u5aaCPyrjGA4HPtnHWs41LaxZFSjc808W+HPA3jKW2vG0y10XWtLJPkRAwx3kbccFNu/BIO1ugz16jwf47+AdW1SzktYfC+l65Io8yK3k+SO6XqNpIYbvY45719Z6b4NurGMx6rpcUyp92SMbvbkdRV2Xwd4ZsNZtbS+Xyby8XMaRqd464Bwe/pXk4zAzqV/rMZa6XWtnbrdarzse/lebfVqPsZwUl0el1fyaafzPzg8EfH+38K3d1Y+KvAOsaXFZp9mhgSKaFbF85lYMBjc2EySv3YkA4GTR8a+A/hr+0BG1xZ6vb2eodFkdkhuVJ/hJx+9H+8AeOCK/Rb4g/ss6ZqmppqEUyxXSqBu2KWK/3X/vfjn2ryLxf+y39rjvrv8AsHSbxdPcB7iXT/JhXd0Pnx8Kf+uiDnueDWFatOhJVY05Ra2cHf8AC17d7nuYXG08TF0as4y5t1NW+5p2T7WPgzUf+CdPjo2jXegS6X4js1+75Ehjn9fmRhhT0yM8ZFcKP2XviM3iL+yx4S1Y3jfdJj/dsPaT7h/Amv0KttM1X4bXVvJdeGdZ023kKqt3YTLqNqqnvldjJ14yCvfHGa9K8cDSL3wKNS1C20vWLdNpWRhtcP2UsxGQDxjIHqc8V6OF4qryi0rSdt/+GPMxfCuE9rFx5oxb1Ss7ffv5PT0PyL8VfCTxR4NvWs9U0G+hlGM+XH5q5PumR+Ga5+7gvvDEo+0Wd1ZtMuV86Noy6+2QMj6V+gHjn4fa1Pp95qGi6i/hOKCUuXntmmhTPAzhUaPGMfvABx36188/tGeA/il4o8OW8d3Y2viPR7eX7Quo6UhuZJm2kZfDMVwM5CgL6k4r3MszyWIko1VFfNp/JNW/E8LOOH6eFTlScpLpomvm09PuPAoj9pQsfmPUkmtnwx8Orzxfpslzb+UsULmPLscsQMnH51kwCSxmkhkjeGSMlHR12sp75Fdz8NfHNr4X024trtWEEsgkjdRnDYwwx+Fe5iJTUL09WfN0Yw57VNjmtc+HWqeGLf7RdRx/Z9wG5X3c/wCf5Vk3Xl3Yk2oqyL6elem/ETVo/Enh1IbeXekb7ypbnpjpXl0MSvqbAsyoozkDnpnFGHqSlG8twrwjGVo7DYlxpytt/iKg/gKhuPmG0/8A1zVi4lxCkSk7YySeO5/yKjuuVHtzW63uYlcriML71Y0eEDUI26fMB+dRH5U3DBaiE4lHNXzXQGrq8n2OEQ5VmbPA/nWYYpFf5TxjmpY91xOW3bmzx/SrsnhXUHuBGIGaRlL7c8qB61HNYLNlAQ7pwNxbJ61bW4YNx3GT7Uy3LoSu4mXPQDkHvU0Ue51LL970rKo+5rDY0tPAd1xnlfz5FXpIliYfe2vweM81StIPKmVfu5BxxWi0jHbu/CuWW5ZDPOsQX5sbfavVPhz8B2vf7JuL2Sdb+8XzTaJgGGM42FuDyw+bHGAR+HG/C/wx/wAJz8R9Ls3je4hWQTTp2ZE+Yr/wI4X6sK+rvAWl3mmeJb2WS1heSFBNI6nLSk7tqIOAoyvc9MevHHiariuWJ0UYJ+8z5++Puhx/CLw5P4X0+3+znfC9xO4Bkui3z7s49eMcYwfxK6T9uoPeaV4d1SWL7LfXcWJoN27btJx+e4/lRXVgXeld7mOIsp2PGtVgU6VvC7ZFYYOPzrK1Ig2sci98Ej0x1rX0vUW1OwRWA+bcHXsDxWbr1t9gszHznOfpXoLY5TSh1P7EUdWVm2gg+lU9b1ITl5pG8w7SMnr/APqrPkv/ANykfO6FcLkdR1qhLIzlwTuLDB/rQAkMqry3IbJyD0qa3miiffuVW3YKk8gf5NZcluGG3cRzg4q1YxrH95Ruzkk85+n+e1AFu9vFFn/fZmPIHT29Ky2uGkZto+Zjn8K03kjdlSRkWNOWbb39/wDPpVex8trjaYVaKViI2Pt/X/GlKVlcqMblWCORJOSynqc9TUyzb22qv3fXp7fnTL2H7Pc7T9yT7jZ+77VHcu8Mn97cPvA5Bpxd1dEtNOzLMOUy2FK885p3mbhlfqapwyb4x9eamEnnHgYx1x0pWAsQTsX+b9a9w/Zr/bT8afs4aTJa6Ouk6lZoc28epW5may3HLiFlYFQxOSuSucnGSc+H2kRkkG7O3rmrr3gkgSOPcqKP++qicU9GVGTTuj9Y/wDgk1+0B4V+M2nahYsDaeOLGJpLqCZ8tcRPIWeSDnBQMVBUAFQF6jmvti70/wAo+X2YcMBiv57vgX8ZdW+AnxZ0HxdosjR6hod0tygZjtlXo8bY/hdSVI7hjX71/s5/Hrw7+0/8K7fxX4Zvo7yxbEc8J+WexlwCYpF6hhkc9CORkV42Mo+yfNHY9PCVOfSW55p4l8b6/wCDPjRb6bcRBPD+pRlDeBTtSXPybuyt1HofY9fc9EvYtM0xRE2ZCMEDrWX4w0zS9bs7m11Dy/3ydGXJb6Y615J4B+L0/gbx03hHxIZoo1ONH1KZWWO9T/nkzH+NQQATyQPUc+LKLTtE9Pm01PoWPVPsVnCzH52AGO5NV/EMbataRylm8yE5C+lczc+KBC0c0bCSdR+7B+ZR71X0/wAXzbpo+JppDl8EYSh3S1DR7HSC5YqEkbbIF3HntVcQ291L821m6djms3UbiOO2juDIWm/jXOeKfbaYLm2jm82SIt0Ujr+Fc/N0Rpy9Wbf/AAi1rqMQ8ws+4YwR0rP1rwBasI32K7RNhfl+YH61f0+/ayiZT+877t2CKsWH2rXb9beCLzpHzhQw6dyfQfWq1eiJ21PP/FWnJFp8v3l2/MOOlaX7NQTVNM1ZLyR4dt4uHPy4Hl/qfb3rv9S+F0Ol2DXWorLdRxjcUjfyISfRnPzH6AA46ZrKstD8S6vcxquqP4d0CNP3VppkfkzTH0Un7o7l2BJ/ujk16NGlKLvI5qlRNWRkaz+ztpPig3DNa31vd3BKpdWRe2CcEbiP9WxIJ+8rfpXx/wDtjfCuT4T6KH0vUpbqxjuyz273G5mccF92cHIGN2OhxggjH3I/gqG4SaeW8uI7WFWZ7m8vJLjIAy27LBNoxyTleuRxx5PJ8YF8YmeLwLo2tapYwSNENVvbyLT9MkYEgtEgjLOvXBVMH1qcRg8NNN1IrXr1OnC5hi6MlKjN6fd9x8P+B/EOn/EjRo9H0LWZLXVLRcm0tXEdzbHofKywUoSDlJAqkZwRnAteJ/h1r+lat5a6eqi3Q3F9feH5be1njQg5EtvMSF4GTsBznq3SvpT4yfs+3Pxct/O1zT/BN7drGSssmjxNMrf7NwFEo+oOa8n+Fv7E/hewu7+/8ZWdqNWjv0bT44b6bEEMeCD5vBZmfcfmJIAUcVwxy+ilvddmr/5HdLOK8nzNWfdO3+f4HzD8TP8Agnn4w/aZvbrxpo2u2FxYz7YNO/tCCO2muIkHO/yFIDB9w5XPAya8D8c/sS/FDwDqMdveeEdSulMmxJbBBdoff93kqP8AeAr9nr/XP7RThYvK6gKQV+orl9b1WK3Dv8qsvQ4r3MLjnFKCSstD53FYdSk5t6s/Ifxp8I7jQ5Gjura80y9J/wBVPG0W/n0Yfyryy/sRbXkm3BKnqK/Wr4s+FtG+KOlz2F1Db72+8zY2/wCRXx98av2DLO41GSbw1qDW8hOGjmJkhb8fvL+o9q7MLW5Xab0OfERUkuWNmfJc8WT/AJFQyQ8f55r07xV+yr448KlmbTYr1F6m2mVv0bBP4CvPr7S72w1JbG4s7q1vJGCCKWMxsSTgcGvShUi/hZxuLW4nhjwtN4muGUMsEMYy0zg7M9lB9eelb3iLw1ZR6OVt4FgurQ7X+bJfjqfr+lajCPwroK6fbyOzvn7VFKAR5hUZI9sjj2rHhSS4WQeZzJH5e5jnHGKXM36GnLZGP4OtvN8TafGi+ZunUuAP4Qcn8sZruPEETnVI2hH3WJyD0GOlN+Cfh5rBLvUrqEL5gMNuzDrjO4j2yAPwNaWt3KpcKwH8PNZSq3qcqKjG0LnB+JbHy7iOZY1jfOJMdTnpTdHgWSQtxhecCtPxreiFo02/fG4/h0qppcDRWat90ynfzVVH7hmvi0Jw6sYx/Ecj609z5cfp2HrUFxiC5jYHpzg17H+zd+zDqHxT1C11fVIWg0GOT93G+Q1+RzgeierenTuRxzkormZtGLk7I7L9l34bHwh4Il8S30LLdaoCYTs5gtwCQ3rluSO2Ap9K9al1pU0LUZmWOHaRET5ZOF8tduQvJA3dPSuw1Twrb6foUMPylCygoRtAPrx9GOO/SuXudOjfQ9Fhhhkb+0pz5m5SrMiqTlhkdEA65zjpk15bkpycpHZyuKsj5l/bpvJLfxBothuVktbJThBtUHLDgdhweOaK539p/wAQt4w+K+pCSTEdnIbaPb6ISP1IJ/GivcwkeWkkzgrazucrocqxRKq9WfHTr0o8byRm1KrzI0gViD1wOn4cVQ0q5+xzl92dmSo96mvRshink4EYyoPVnJ6/h/QV1GBQ1OLy28mTJuABgdlGBwfes8nyImZupO0VavZWjdXZjmYk5J7f5JqjczknOMDnHtQA1cp8y/e71LbXG5lOF3L6d6oyXQjj6ckjPFJb3JEn6c5p8rtcC5fT+ZDsXHzNu6dB2qupZRGQVVoyCATjP+cUyWVS7dPlGOe1MXazHeC24EZDd6fLpqC3NO/g+2PGH4XdziqgbB8lh36Eda0LGM6hYoc87cbh6jjj8MVk3c266b94CE4HHJrGjezj2NKncdKFR1XotTIdjq3yrzz7VW8/f8v3lx0xSLP5edpIB6cVtYzLqztH8pyd2QcVPDMAu31GPwrNiu2+YKueMnPOKsC8Xylbbt9SKmUe4Gksp+Yjb044r6N/4Jk/te6l+zJ+0jo8jTSt4d8RTR6VrFp5m2OSKRgqy46b42IYHrgMMgMa+YobsOm4N79enNXrC62PvZeFHr1rOpTUouMtioScZKSP6UtFGn+I4BNbNHeRqcb4sOBVXxR4L0vxDZG3vLNLqGQYKSxhga/nf+H3xR1r4Z+MLK8s766hutLvorqHErBd8bBlPBHoB9K/X74Gf8FT7H4ha/Z6f4g0mDS5L5/L+228pe3Rj/eRhuVfU7mxnpxXy+YU44aS5no/0PosDz4lNwW3S57lq/wxvNMj8nSrqS1hUcRyYkCj2zz+prjp9G8TeG7uRd1rdwzN8zqTG49eCOfwNdb4h/ah8L+HbaR5tc0VfL6os25s/QAmuV8JftIeF/i3fyQ6TcEXdqN8oaMorDOOM4yK53FSRV1eyOi0rxBZaTpQWaRmuMDdvRlA45xkDP4ZroPDfjCwurvdHdW00/3jGJB5mB1O3rxXNarNb3vOEaRV3EIACwHofxrzbXp4bnWJI7W4+0Mrqy6df+ZA75GQbeXgBxyeN2BnIHWs/YJaIt1HbU+koPF9pfsymOBmB5H3Qwr0rwfpVn4c03zIY40uJlEk7Lzx/dHtnP1618Q/DD9pfw34V1+O38U3NxaaP9t+ytqE0Z8y1l5/cXIGSuTjEg4IY9xk/Wmk+JYPHEG7T7+z1CxuuIZbaQSRiLPOGBOTg/rXXhYOL5pHPWlfRHUXM3/CQstzJ/rpMi3LDcsMfIDBTxk8HPuBWR4jtFukEk0m2GRliSPnOxc8Zzx0yabr121lertO2PZ1A4GCRXnf7Svxu0/4P/BfXtauryI3kNhKlnFkZ3su3cR+IrrnLTUyjHU4Txf8Q4/2lPihq3hO3maH4e+DxFDqyw/L/bl8fmW2LD/ljEuCyjAJK59ugvza2MEcNusMMMKhI40TasYA4AA9K8J/ZL8V22hfBHSVWZGvNU36pey53NPPOd7MT3wML/wGtPx58b4fD24ybmCk5I7V41WpKc7HfaMI6M7/AF7XFtlbM4Zlz36D6V5/4p8fLvaPy435+9Xkvif9paK7Ltb7iB1571w+ofHi41O7aONZtvupOK6adJnHUrX2PUNR1q+innaG/vLWGQ7ikUzKv1wK4vVvibrfhzU/MmkXVLTpJHK2HH0IHX65qlaeLLe9tz/pTRuR824/0rA1mVYw7LcLMrEE5Peu2K7nJzM1vFHxjt9bDRQp5bAcxsQjVzJ1e/jDP9l/dt0+bdVO6js58tMI3bGOlc/rlxa2zsYXeH0KOVx+Va6E3NK98SzfMJY2Ax3Hy15x8ZL3Tb3QJPOs4prjP7rKg7H7MD2x1z7CrepeIbyB223ayr6SjP8ALFcr4zum1fTy83lh0GQEBA5+ua0hvczlK55P4k0wRXplDGRpsMS3Y+grNhtzJdrHGN0kjBVAHUnitnxHcZkKjkRin/DWzim1W6uZG+e2iAjU+rcE/gB+tenz8sOZmfLeVjoddZNN0mOKHCraxBV9yP61yMd00g3P8xHJJrd8S6grKRy248+9cnqKyXFvJbpJ5TSnGe4rLCxajdmlaWpz/iTU/wC1tXbDZWMbF9DXTeDfBt34sO2PdHDGv32GBgdfwFUfBPwyvNR1VWaNpojIEUIP9YT2H9fSveLPSLHwZoDG427bVMzOG+SQ4xswP4R6f44pYqslaMTOjTb1Z5HoHhrR7Dxrar4g1KOPS4Zd04iH711H8IB45PGQe9fYPw8/a7+GemeFbC3OqNafY0YFTbP8pORxtUqOPQ9DivjDxxbjUZXvph5TNwkHl84POWx0PPTt06jnBuo7hwxW1Mi54wm3H1/ColhFWiuZs0jWdN+6j7U8eftneCtUsmtbTUDcRiRmLeUwByDlcEcjnH0rS8FftB+DvEmjabbw6tayaha24jVZMRujFQr4yBnp249q+EXudo8too1VeoUc/wBKhjdg+5fMVsZBGan+y4Wsmyfrkr3aO2+NOnNpPxJ1iL7x+0uVY/xgng/iOaK5u88SNqUZbUHlmZFCK5bL8YwMntjNFd0ItRsznk03cZIfJjC/eOck/pUOqak964V24HAHoKllXzIOves2clH/AL3WtjMl1GTz7ksPljhUIgqhPKZERd3Yg1ecstkGZWG77pI4P+RVC4A3YCj61UdwKkrbgvP/ANekhO58HgKO1JKDupyxGFNv8R68dP8AP9K2AdjAy3zZbHXkU0Pt2tnuD2pU/e7l98nHSoJBtLemewoA3NEuWthLbkqxjfOQeoIrP8QxGK+ZlGI5CWXjinaNerFdKq5VpBsPPQ9jWhrVgLnSvmOZIuQfrXK/cq37m3xQMWzk8s7juxnoKtRStJAW+8y8sG7VRtlyQufmyBUhmbzOrDtXQ43MQjLbzH83zHGKdcSyMFXcdoGBxjHenMrErtGNw6kc01VYJvHzbDjn/P4VQFqK23RjHy8cE/dY1btJ5Lp4Yc88knoFwO5/xqgbkyRcr977voPSnfaBEG6rt44zznjGM/rWNgNi1kabWodzZ3tljydvrXrXwx8fS6f4psN1yZPLkDcc5we9eQ+HtiFpAzebtwA5P5g5rY0m9aO+jkVtrDLlweMd68/HYWNeDg+x6GCxMqE1OJ+wn7KfwB+G/wAcfg7Dq3jbw9pN9dXlw32aecvHJPEoC5JVhkbgQM+h7Yr0DRP2G/hP4O1f+0vCdr/wj+pbvkmstUn2n/ZaN5GjZfYr9McGvyM+Dn/BQX4kfA/T5tN0XWoZdMknMq2l3CtxHCT12FuVB44BxnnvXvvgf/gsRPc6Pt8SeG4vtkZI8ywmZEkH+427Dfjz7V+W47hvPsPJyw0uaN9FGTTS803b8z7KlnmWYh3rR5X5xVvvWp9+eNPht4+0qeFdJtdF1WzU5klF5JazEcYITYyk8f3xmvNfFtl4g8MauRr13G3h24P+k6Zqtv5c8DE43WtxFkPzjK4cjIwQeK8H8H/8FOPDfiZWaP8AtCzk6vFxuA+nVvriuo03/go9o9s3l2/ivVLPB+6wlAH4cg1nHMs4w83HEUG/lr960/Ar6pgKsb0an4/5/wCZ1n7UHwK8TfE/QJvD+i6Lrl5rv2Qi2vmtvLjdFdAsF5MxWN1ALMCpd/l9eW9a/ZFvNN/ZM8Dw+G9b8c2V9JDCkzRX9hJYXKSEAMi73IkHbIwSQMA9a8DP/BQl7qNnh8YW7qxzsYIGJ9wQDXOaz/wUJ1qBZJLfVIZtvK4X73/fNdFDiLMOa0qGnzTv66mNTKcLup6/Jn3N4u/au8O+ItMhsfCd8viHWr5vLgh0/e+wd2klb5IwO+TnBPHFfLn7bfgnxJ4x8B3R1/XdLtIZAfs1npRn1G6vmGRh3KoRj0Ckc+1fNvin/goD4jnvriSBYYXnB81reeW383tlgjqCe2TzXN3P7c3ie00ZdPtrhYbWIcKVE4jzycGQMeuTjPUmvpsPjJ1LOdNxfyf9fceXWwqjflkn+H9feS+D/jB8QPhP5Hh/+xdVkZIjLbRttVhDnuCQeNw//VVbxN+0n4suJCt9p2qQrzn9ysmP++WNcHq/xxu7vX5NY3TTahIrIJ2csUQ4JCrnao4HQDoKydR+Ksl46yTNcMerEgYJzW0qlRz9yC5fxuZLDx5bylr+B33/AA1XqGm2phWK4Qr1BtGUt+OOa5u6/bD1DSLrctvNIvUqYyAPzrmpPiBHMfvNu9GSox4ls7ofvvLbjoa6qdS29N/f/wAAwlQXSaOptv20I728j+1Qbcn5spjFeiaN8d9B8Q2S+U8azYztbvXguoWGkajuBjiXP90isVtHXTpdtncMq5yFbnH+FdkfZTWl0zllTnHsz6Q1f4k2cCZ2hcj7wbaBXJ6t8QLeUM63SqvpuyTXjv2rVkU5j86P2m6fhWff/wBpXRXZDDCvQkknH6VtHDR6yMJSfY9S1HxpHNHujmYBTjI6flWdq/jq1ksH8uZpJBwUIxmvOL+DVEmWOKaPI6+Wu7NZrQ6pFMxaRn9A69a6I4eC6kXO51W2W+01rlf1rF0+4/swPMsnlcYY9OD/APqqjD46kisRby2zfKOcfdOKzNQ1yXVIWijjVI2+9mt4x0syb63Orm1Fr23+Y7iOcg9c1S0fTRrmqjcZDBCd0pQfMc9FHuTx+Z7Vz+lWF1dTx2tssm+RsKocj6k/qc9q+gvhH8Mo9B0OC+uY9rL88CscF2I5lb68BQegHckGufEVo0o2NIRc2WPC2iL4F8OTX1wkaTxxebMxHy2kfQRr/wBNGJC4Hcn0NYfjDW4AY/OXMIwI4F5aV+McHrz3PGfUDFbnxIvWvb6GFVWPR7WQMkKENJdy4OC394jHA6Dn615b4z8TTWGpFYV+0a1dKRsU/Jar2A+nPNefTi6krnRJ8isV/FPiGysLdrWRZL7Ur5iPKX7i49CegBzzjPB5zk1xl7NiWWNxajr2Llfxzg/lVvV4B4cgZpZftGoXQ/eyE/dHTA/lWSIfM+ZtpP6ivXppRWhySi5bkiCPcGB3hepx1qRriIS/KvzfWmpbRmJt2SO+DVm00aGO4X5fmY8FucUSqWF7OJHHN5v+rhUNj7w5P4ZorbeyjaDbt2kcZWisfaM0jBdEYlxOBbqq/wB4mq0nMg6dOatOI23FtzN0AA4FUXl3Ma7DjJkmxCsZJIUYHsOapzqQF3Ebj/Kp0yyfLncQf5VWd2V1Zvu9j7VUdQK7x/efdzmg7gyuSuWOc1YtlMizI6MW27sA9B15qi0UgLZ5Vh1rRATR/up/vKeeB600psH+r+bleT15ppGC2d3c9OnFRyjkfxcAmqAkERSPMf3Tg4PUEf8A663LmffaGbPyuDkZwOaw4LcvgB9u4buh7Vp2sTHTFR/9XyuQOQc1z4haJmtJ62Mu5TY+75l3ZJ/M0xX3KGXk1oalAqpE33eCFI5zj/8AXVExD7wQso9zW0JXjciSsx32pgvB9sZ/zxSj5FZiRjjIzng1Ao82UgBsZOB6CrDos0jZXCr09qokdtMrK3Hl4x7VI0oH97nB59OKhSLEDDKhB6Hn/PFOQqVYM7fMMYC4zj1qbIDYjvI5EWaHj5SpBHYdBTIdWkS1cbVWR+pI7Htj/PWqcY+zy7vunowIA29v8aV51ZmVl2bxj6D/APXWKhYqTuQG73nkBiepzz+dTiaW2jDLhlb5Tht2G9/1qrBD9mmfaysnv/PFS38i23l7ZFk3HnHTjpWnKrkmrperyWEkd1D8k0I3A+hyMd69S1hV1mwh1C3FufMjVj5RBXdjkDFeL+axkVW+VQvODz3rovCXiq40e38kPJt3fMrZ5/ziuDG4ZzSnHdfkdmDrckmn1O0mvN8ALYG0Z+vtXN6xyHMbMpz2OMVfmvvPt1mjbhs7s9j9KztRn+VuMlB29a4qNPlOqtUbMddUulRSlxKvy5OHPFWLPxBqMJUzXMkmRnHXP1zVGVEErL9w43cHqKTYrQpukY7hwF+g/wA/hXdyRa2OfmktmdG3iHUJoB8zFOwIX+lVZ9duo1GVhfjn5QP5VQtZ2ggZNrKrEhT3P4fjUtvBvLM33eCSRWfsoroP2kn1Lltql1Mv+pi47YNU9Q8bfYpNqwmT1Ycc+1VvtpS3kdeGLbOD0zVSdI3haLKuzcnjpWkaavqhOUu5qQ/EBZE5hkx3IPJqa28ZWbyHfHMd3HABrmTpotjuZ+3AAzirGl6W8twPL+Zj07Ae+a0lThuieZvc6hfEtrF91ZF65LAZHP1qE+M7OWNdzvnOB8vH6H/OKylVrSWQScqeOlIlityzDEZjYZx6GoUI9Q1Okk1GCRopoS5DDd0P5f1px12Jz94rz1I4FYWnS+VZxq7fNESuPbt+dI0ySDduG0n0pcvYVjcF7pcrjzbiFvfY1SRXGkzXflWu25mk4VUhJOareBPhprXxO1FbfRbMyjdteY/LEg75PfA5OM19O/CX9mrRfg5Zfbbwpf6oUy8sgG1G9AOwH1z+OK48ViadJWbd+yN6NFz227nL/CP4Nvp1v9vvbXmQLthdAoP+03fGeg6sR6cVteL9eW1maOEs3O1gG2gnuPw7kcAnAya6LVfE8cks0cfmbFBZnPA4GOvb/D0GceG/Fr4vMl22k6ay3l1MNh8tePp9Pb+mQfNpRnWmdE+WnEw/iT4vmsLqK1tdkt5LnYsbfdUn8wM5/wB7Axxisi1tF8M2E01wfOvJvnuJt3Lf7I/H+VWdN0ZPDSyXl45m1KbLTSsfuewrjfF/iJtZm2qzeWp9fvV7NGKa5Y7d+5xzund7/l/wSG5vjrGpvNKerdAegp6lkkZVibbjHSqekOpuGCqWyMfL1FaplIh+aZVbOMB8dfaumWmhJVtotzYZdrcjn/PetKIrFKm5h83OM/nVe3tzKc/6xcZOME1dtbGK4l2vac9eXb/4qs5SXUC3Fc7Wx8qrgc4opt1pUSjaPMUKcYEh49uc0VjoUpNHP+c0f55ou7byhHIOVfj6EUz77e+eBVub57Ha2OOnPINegcJVhJVwyjkelVZbfzB82QnPFWEO2HIY7s1BcyeXhcMzYJPtTV+gEEbvD5meC4IA61AHbfyw/wAKlGZXHbNVs5bn8K1QE8jME6e2MdqjjLA+u3npTo5Aw/HvT5cOuB164HQjNUA/+Jf7uMc9q2bQR21phSG5zyMViQblXcy7lz6YOavWi7bUSMu9WO3J7cev4f56VhWjeNiqbtIqXBZticsVywC/wng1A0ka7lXcq4GMc/WrU1ixBb+HBZf4Tt56f571VmXZ5Z+Yt1981dP4QnuOij2yZGWTnHHIp10MspyvXHWnMrb8quwY3HI4pny4Yvu+9uBPf8qrrckRS7Lt2+uPz4/z700KDGHbg+w6ipHuI/MVlxtAALfeP4U1mMyKckb84HT8c/nRygOhkKfMGKlhnI4zUbMw2srL7g4FAuMhFZty4OP8/nUIVbeZt3zeu3kUcvcCZVwpLfKc8n0p8jb/ACyi/N94g9KLm6M1vlVY5Pp6VHFO0irHhVBJJxwaaAVxvn5x5m7APYVat9QZGU7TuYklie/1qqHUj/V/Nyeeeeg4qQTDv/CeSF9QB/jQwOm0HUJXikj3BVAzjGakvLxkiEi7SynqRnv6VT8KzMgk3bl3KMEDgD64+lWbu4jiibbufIwDtIxzzXmTjaeiOyM20jM1C5klG7+8MrtOAe9RafczSxceWFB4yeRVuDb5p3bY224wUz/ntRFMIZNseJGJz0wMf55rTpZALEwcHdsYDt3/AConcom5ZPkUEAe/pjvV+6svLQfKqvI3T0zyM1XO7btmRQytxkZH4VNwKus2ot7BcfLIzjcQPb/61Z6sWhXG7IP93NaWohp7Rn/hVhuOPw9apGz3r1wM5PHatKe2oEpG/A2jgY69B0/yKntEaJnRlVehG1s9/SqDlUiLMzHjOB61a09NhZuOgJ56US2AfqEMk1xHKWOJOCCc8j/IpC3lysu7a3pjHSpL0M9mpXn5l465qF7VmuN3Tnkn3zUrVagS3M23PoowDXufw9/ZGsrvULOXUr6S74V2gdfJjOe2ASzYORtJQnHrxXg0cUmo3MdvDG80srbQqjljX1np/j7T9B0i1t7y4MK2sYjSLygFEYUbiuTucHPVht4yFHSuLGTnFJQerN6MY7yOw0m1tfBtmtrbLBawq5gRIBtLqOmcDoMHhc44ORgiuT+I/wAULHSLGYzlXWIZEXmbYY+2XYe3YZz0GQcV5748+O1/q981n4at5r0SFgq2hZkAPTzJs4J74Bx9OlcrZfBnUNbJvvFd58qncLOF/kTP95xx6cLnp1rz/q8Ie9XdvLq/kdHPOfu01/kR+Ivi3rXxHupLHQWkFrnE1267Y4/93+nfvgHNTeFfAMHhKxe4muAZm+aW4k+83sP7o96tXWu6ZoKf2fpYt5pbcEqkZ2xxD1Pp9eSa47xv4hk1O3+zzXG5WIf5B8gx6iuuPPUXJBcsfxZHLTp+9N80vwKPjXxWPEGoyW9s3+jo3LAff+ntWDdaQ8lvuj5FadgsI+ZFhaQ9FJ+99Pf2qRNVV4pF2hNqjaMcCvQj7itFHHKV3dlLR7P7LASGG70PWpRMHk3GNvl9OcU+T7RIA3ysrNnKrVa5tQj7/M6kggjnH+c1S11YFy0njClmRR2y/U/hV7SXjll2tIqbsHgYrPttKkuIlImfsAeu3HXtVux0uRlc+dHuQY2kc5OOM/4VnK3cC/fwwxk7bqQtkZBPHT/P50VnyWs0camRt3OORRUWAypYgvPtmpLaPecc0UV3nGK2IpOFX7tVdRhX5Wx82OvrRRVR3Az1JM2c/d5FQCPEn+6c0UVsA6JRISpA+XpgVNfsYb3j+HCgn0ooqeoEsUv2lUDJH8q44UDIznmrUDeRC23+EhR7ZzRRWYEkFqr7WOd2Sdx57e9UZoFVuPl4zgcUUVTYDrizjSGPAxvbBPc1DcKrWsZ2/eJyMnB6UUVUQHPbLBJIF/vEVH5CpGsmPmk+U+1FFNARrGDDsb5gASM/w49KbC/ksMKp57jPqKKKYDpTsaP0YAEZ4PNEDeaZFOMZxwP60UUASBdyRyfxZz+tFvGGX/eGKKKxk3cDe8ORhGK9mGD+ZNbbqIVWNRtWUZb3yKKK4a3xnVS+Eg14LbaUvlxQq0xXLiNdwz1wcZrJ0Zc6hH7k598UUVVP4Sixe3jXl8skgUnl8Y4J7VHnzZm3etFFKWwDtRnYWATtIQT+HNRyRLPbMzLysZYck4P4/SiinHYCvGqm2ztXO4jOPSo9O/1jfQHr39aKKqWzAnvl2bVHRiSfelESyQZb+DgfnRRUx2Av+GcaZ4jRo1Vtm7G7vwa6G5+Kl3MCraboJJYsXOnoXZs5ySeSfeiiubERT3NISaehR1T4za+dqx3MVuFxjy4VGP0OPwrndc8X6r4glP2zUbyZR/CZTt/KiitqFGnFXUV9wTqSl8TKdtH5NxJtLDAI4Y80Mm6WPlstk5JoorpMmWFhVZmbaMx/Mv1zQsuNwCqOB26UUVPQXUUXUkM0qLI23I/z+gqW0uWuIMNt/wBZt6dqKKUtijStrlrfcY8R7SQNoxSbyYmk/iY4P50UVzoBl/Kxflmb6miiilcD/9k="//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy90dWxwLmpwZz81N2E2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGtDQUFrQyIsImZpbGUiOiIyMDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQVlBQmdBQUQvNFFCbVJYaHBaZ0FBVFUwQUtnQUFBQWdBQkFFYUFBVUFBQUFCQUFBQVBnRWJBQVVBQUFBQkFBQUFSZ0VvQUFNQUFBQUJBQU1BQUFFeEFBSUFBQUFRQUFBQVRnQUFBQUFBQUpPakFBQUQ2QUFBazZNQUFBUG9jR0ZwYm5RdWJtVjBJRFF1TUM0MUFQL2JBRU1BQWdFQkFnRUJBZ0lDQWdJQ0FnSURCUU1EQXdNREJnUUVBd1VIQmdjSEJ3WUhCd2dKQ3drSUNBb0lCd2NLRFFvS0N3d01EQXdIQ1E0UERRd09Dd3dNRFAvYkFFTUJBZ0lDQXdNREJnTURCZ3dJQndnTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EUC9BQUJFSUFTUUJkd01CSWdBQ0VRRURFUUgveEFBZkFBQUJCUUVCQVFFQkFRQUFBQUFBQUFBQUFRSURCQVVHQndnSkNndi94QUMxRUFBQ0FRTURBZ1FEQlFVRUJBQUFBWDBCQWdNQUJCRUZFaUV4UVFZVFVXRUhJbkVVTW9HUm9RZ2pRckhCRlZMUjhDUXpZbktDQ1FvV0Z4Z1pHaVVtSnlncEtqUTFOamM0T1RwRFJFVkdSMGhKU2xOVVZWWlhXRmxhWTJSbFptZG9hV3B6ZEhWMmQzaDVlb09FaFlhSGlJbUtrcE9VbFphWG1KbWFvcU9rcGFhbnFLbXFzck8wdGJhM3VMbTZ3c1BFeGNiSHlNbkswdFBVMWRiWDJObmE0ZUxqNU9YbTUranA2dkh5OC9UMTl2ZjQrZnIveEFBZkFRQURBUUVCQVFFQkFRRUJBQUFBQUFBQUFRSURCQVVHQndnSkNndi94QUMxRVFBQ0FRSUVCQU1FQndVRUJBQUJBbmNBQVFJREVRUUZJVEVHRWtGUkIyRnhFeUl5Z1FnVVFwR2hzY0VKSXpOUzhCVmljdEVLRmlRMDRTWHhGeGdaR2lZbktDa3FOVFkzT0RrNlEwUkZSa2RJU1VwVFZGVldWMWhaV21Oa1pXWm5hR2xxYzNSMWRuZDRlWHFDZzRTRmhvZUlpWXFTazVTVmxwZVltWnFpbzZTbHBxZW9xYXF5czdTMXRyZTR1YnJDdzhURnhzZkl5Y3JTMDlUVjF0ZlkyZHJpNCtUbDV1Zm82ZXJ5OC9UMTl2ZjQrZnIvMmdBTUF3RUFBaEVERVFBL0FQeEVzcmwwbG1WVjh6YXhCNzhjMU9MdmY5Mk5kMzZtcWRoUDVGM011MWVISno3L0FPVFZxR0ZnWXp6dVU1empwN1Y1WjJGbTBtSG1LV1RPNCt2U3RDQnN1U3JNZWVSbnBXZkdPTnlzL3dBd0I0N0dwTFJYWExibTY4ZGpVTUMrSWxXWmVJMCtibGQzZXJTVzhMdjh6U2NuZ2p0VmEydHhKRzMzY2dIOFRVdG1XWURlZWg1eTNJL0NzZ0xjRmpFV0RNclNZL3ZuYm5KOXF0elcwSWtWdkw2RG9XemozcXZIZ09vYlowSFZ1dGFOdEdxWEIzN2RxKy9YdlFBc2RoQ1lsWlFUbmpBT0trZ3NGQXd5N2ZiUGVwdmt0b3VNdEczSUJQekwrUHBVa2NpeVlac0lyTDB4MG9BaHZMU0ZyZGU2OThuR0RVc0ZsSEl5b0VZc1IvRG1wWVlmT3QvbTJGZjF6Vm14c2NrWllwMFBIZWdDSkxGWVp3emVaa0RwdjRCcVpMV09kTXI1ak1veGpKSS8vWFY0YWJGTDgrY25IVE5TSlpJaWhkckgxNTYwQU5zdExWSXMrVzZzVHljbnYrTlBUUWtXNWZJZkREYi9BS3c4L3JWbU5Obys2TU4wM2RlS2x0eTVPN0RZVTUrdEFESXRHVklsalZuVVp5VkVtQmp2VG4wSnZKWUcxWWJ1bjc3SSt2MXF3RDVqYlJ1RGY3dVIrZFROSkp0VWxqbFJqcFVzRElrMFZvd1I1TTJNQTkrdjRVLyt6bzQ0dHpLL3lqK1BPQ2EyTFdYZWZtTDllZ05UU2hBbTNheDNESEhwU3V3T2JqZ2l0dDNscXgzREpJT2Fpa3NBc3l0NUxlb0I3MXIzRnFyUzdsazI0NllIRlRRa3dEekkyWXNPbWVjZjFwNmdadGhveVNvMDdLeWhlVDh4Mm44YUl0UEVMRnZMWnVPb1BUdjF4VTA3WE1oTE15bFA0dHZjZjUvU20zZDYwME9GYjVtWEpKWGJqMm91d00vVUpuS2ZLaktxbmhpUHZWWGtaNUZ4bkRKMXoyTmFWekt0MHNFY2l4NGorWlFUOTBldjg2cDNjZmxTN2R2M3NET2NVN2dVZ3JYYXR1d2R2WEFOT2lzSS92S2R6RThZV3A3YUZZWUcrVlc3QVZHeXRETDkzSHJnOUtMZ1IzWVJFWHk4YnUvSE5SaVg1VkxESVBHUUtkRk81VnRwMk13NkUvTTJUVU4vZUF5TVBsajdEak5KTUNSdVR3Zm9EM3A0bmtsQzRWUU8vUFg5YWdpakV0dnZaVnlvQUdEOTZtcTViY0ZXTUlPTUUvOEExNm9DZThkakNBMGF2dVBJSFQvQ3FFK253d3YrOFRhdzR3RGovd0N0VW5udEhJckt5N3M1NHFPM2ttMUNkMlpsd3ZRRnVwb0FZMmwyMG56TjVxNTZBZHFSTkl0MitYYzJGUFU0Qng3MVl1cEl6RWZtMnI3SG1xLzlvOERHNGx2bEFCem1nQWswS0diYXNPZDNHY3NCK1BXbEdtUmgxSDNsVnZMVTUrOTJ6L1NybW1Ya2dZd3FValk4VHpNZVVIb1BldGNwWTM0WlpHV05OZ1ZTdmJIVDlhbHlzQnpWL284TVVlOW8yVGtEazQ5ZmZGUkRUN1ZZMlp0elk0d0cvd0RyMXFlS1lXc05NNFl5S3NtQTM5NzNyRFdmQ2ZPM09jOG5yVkpnT2cwNjNsZHZsM1k3QS84QTErMVdKUENzY1lWZ3ZtYmx5TnU0MURiem1EYzIzY3JIb2VjVnFXK3R6V3piWTJVQTRPMzArbjA2MFhZRmNlSExNUjVNY3lTRHR1UFAwcWpxR2xRby93QzVWams0d3pkUDE3aXJodlowbGtacFBsYnJ0UGVpNW5qVzFWY0l5NUJ4bjE2OENpN0F4WERLUHVxUm5wakpOUXp5cW0wYlZKeHllZUt1WGsvbjRWUFhPQmdETlpzeCs3bGVjNVBGWEdRRkc3bFpKOTNEQTlxS3NTUkJwUG0zTVBRVVZSTE9RU1RmcVZ4ajVpUUR4NjhHdE40eTdFTVNaRndUNzhWblNmdXRZazI0K2NLQmp2d0swOXl4RE83YnVZRW4yeC85ZXJrVVdZVjJRRCs2Mk1BanZWbXdpRGtCdDI2cVZySXFvUG00eGdnOU85V3JFdEdWN3NQMUZSTFlEUlZvN1lObmNOeDdqcFUxb2l5cnVIekh1UFVVMzdPczhpazdYWjZzTnRqbENyLytxc2dIRzM4K01OOHErbVJqNjFjZ2dPZm4yN1FNWUI1cUxkdGxISmIySFNsYWNSRGQ1aFhuR0FPYUFMeW1HU0p2N3c0NCtsVFdrVFlBM1oyOFlKelZPeWpZa3lNdVZYZ0N0SzEzYk1rTi92WTZVQVdMU0ZvazZMeDM5RFdoYXdOSXkvV3FFVURYVnZJcUw5NWRvUHJUOVA4QU1zNDlyU05FeXRnSWV0QUczQlkrV29iR2UxU2lCcy9kZjY1Lyt0V0UydDNRUHl6RnV1VkgrTkUzaUs0aU1mbHpNM3lBbnB3ZTQvRDFvQTNCSEp2d3dKMjl2YXJBL2N4N2R2M2gxT1RqOEt3TGJYN3lSdHpUTCtQcFZ3NnZJTnU2NCt2N3NZeFFCdHJNbzZvZllqdFU4UWoyWlYvbUhyVkcwbTgwK1cxNHFxb3kzQTRxZVB5MUpWYjBLdzZnb0tBRkNaRGJSdS9DbmVlTUtyTDY0eDBxTTJza3AyL2FwTXR3UGxBb2owT2ZZdjhBcGpEZHdPQm1sWkFObFllWjh3WUo2OURVa20xNGw3WjR5YUwvQUVpNVdKczNESGFQN281cUx3OXBVOXBMTXR3bzJzUWZ1OGRNVXdKN1JCNS96S3UwZHM1SEZSejZWL2FRWW91NTE1NmREV3BMRXJxMjFmbFUrbE50MEt4L3UyMnQzQXgwb0E1dVhTTGl4WGM0VmxVZk1RUG1IMUZVYnkxVzVWVytXVE9DVGcvalhYdVBQbTJzdkRkRFZTNzBKWGxaa0FSZ3Zmdi9BSjlhUUhML0FHWll5ZjRWSis5bnI5QlJNNm1ITzNidllkYTE3aXlNKzVlSTJqNFpDUDFIclVFdGpqbmJ1Mm5xVGlnRENuZzhoVzJibTJ0NmR1dFVwVHRqWnR1NXVtU1AwOXE2Rzh0SVF4d3k3VG5JVTgxUXZMTll4dWpNVGNqS2o2VW9nWjZ6T2x1cTdjS09ldjhBOWVvSmw4cDlwWmdjZ252bi9QU3IxenduSzlzWk5VbjJwY2hsWFBUZzFRRWRzNkc2UG1ScmdEQURFLzBxMU5Jc1NuYmpIWEFCNHFGWnNMOHFmT1RrWS94cHIzK0kvbTNGdVNjampOQUNUWHFTWjNLdlRQQUE1cXZGSVdJS3EyL1BHTzMwcGdHY3N4eDdBWnFhRFdCYUJWOHNuSEc0VUFXTE9hT010SXcyTHR3Q2VySDEvd0ErbE9rMUdhYTYvZC91K2M0STZkeFRaN3NTeGJWVm1MWkFBNXFHN01rZGo1MldhUGR0WlNPUjFBeWZ3cEFPMWJWNUwyeDJ5U0xNb2Nrb0Z3Vkk5UGJudlZCb21rai9BTmFVR0NSdTcwKy9KZ2syTVdPT3VlL2ZwK0ZOWFpjMyt4M1dFQmNsdWxNQ09DUm8yUW9XNE5XMHVsZDVKQ2ttNXVDeWluQVJ3dytadVV5Y2ZLcHlTYzkvdy9uVVRYOGtkdWZLL2Q3VGdLTUVPY2sveW9BV1NXT09abDI0YkdEdUhPZnBVVTg2eVJiVmlHUWVlRHdmYW50cU1rbUZkc25na0FaT2VhRGRmdU9IT1YvaEk0WTgwQVoxeTdJTnFJeTQ5cXBNN0ZtNGJyL2pXcmNhaEdrNjhNeFpjSEkyaXFkMzkzOTFIL0R1T1QvOWFtbUJWaWsvMGh0NDU3R2lxMHNrcXo3aXUxZlVIcitGRmFoWTU1dGo2dTI1VHRWUVI3OFZjdGs4MUYyN21ZOU0xbDZkY3lUWE16L3hiY2NEajByVTB0L0x1MUxaK1VWVTlBSkxkVlB5a2QrUGF0S0tJU2hWWGR2NUlPY1lySno1VnhsZnU1eVJXNVl4U1RNM2xvemJoalBYSEhmNjFuSUF0NW5CWDV0dUR6K2RhU1dtNTl6TXpEcms5Nnp4Q3BrKzh2bWpvTWRhMHJXNFdBcnU2RDI2Vm1CYWppVlVPNW1VWndCbitWTzAreUYxTXpNRytVOENvOHZjc3Uzbko0QTlhM05Mc3RoVmpoUndNZXRBRWNNWmpoMmdiVjY0TlhMS0RlZkw1OTgxTERaK2JQdDY1OVIyclJnampzL20yN21IQ0xqclFBNjFzSTdTSDd2ek4wNHJMMWphTG1TUm0yb3ZKSU5hMjAzZzN0bmFlY0NzSFhMbEduYUZjQnNqdDB3VFZSamRpazdETklpdVBFRE1rQ3NzSXp6L0FCR3BOZnNwdEhzWTdoWTVtK2NJdzJrN3UzSEg2Vjk5L3NQZnM4K0h0QStGV2w2eE5wOXRmYXRxdHVKWkpab3hKc0Rad0FEd09NVjZQNDk4RWVIN3ZScmkzT2syS3F1VGhiZFJzUHIwNjE1TlRPS2NhbklscGM5ZW5rODVVK2R5MVB6QTB1OWp2SU55L0tmdXNHNnFhMXROMGZ6d2pibGJ5dlU5VC9rVXZ4ZThMZjhBQ0QvRm5WRmlpWmJScFpONmo1Undlb0gwNXFHMXUvN24zV0FQU3ZVMGFVbzdNOG5WUGxlNVpPaDNVanRJcEs3am4ycXpINGJua25qTWt5dXJITEFlbjUxVWkxSmdObzNjbnNhMXRJMVJwN2hZakdmbDV6bnBRQTZ6c3R0dzViNVYzYlI2c0IzL0FCL3BWc2FmY2ZheEo1M3k3bElBRzBLdWNrSHZ6MHEyNnRJbnl4OThjWjR6MW9MbVBhcGhac2s5RUpxZVlBc29KaGFTZWRJc3pmTVFRQ01ET2NjODhkUG9LdFhCWkhYYU0rdkhTbld0ajVjUlpSZ3QySzQ3VllsZ0VicnV4dVBJTkhNQlJtdDJSdnUvaURVTnhESkZ5ZzZIa2l0d3dDNGgyL3hkUWF4YnhUQXJBOCt4bzVnSTdkdGt1RHpqdU85V0o0QkpiaVRLOG5zYXB3M0pZaGRtMXVneDNwelgyNXhqakhCRkFGVzh0bGtMU045NEhBSUhJcW1ORmt1NDNacFBsQjRBSGVyMTFOa3NxL01NZHFqc3AvSUdjSDVoaHNkNkFNZWJUcG8vbGJadEJ3UzNlcTUwL0liNW8xT2M1eC9TdWprZ1djS3pyMzY1cWhxT25BeWZMOGl0anBVODJvN0hPYWxzQ01UOTVlUjZBRDFyTUpXVjl4YjVqN2NWMFdxV2NNRVlETjgyM2hBVHpXRmVXYkxFcXJ1WGpIVGsxVVJGSzZQMmZQelk0cXFaZC96WVVqdG50VjE3ZkcxV2J1Y1k5cXFUYkk0U0UrVnVoeDM5Nm9DdkxLenR0UnNxeDRIdlZtMzB2L1JzbHVXWUFBQWNDb2RPZzh4MmsrWlZIQTQvT3BwSlhSZ054SDlLQUZ0cFpMSldYZVZVNTNEKzk2ZjBxVytuTFdWekhJek1XZEQ2OS9YOGFoakhuVzhqTXU1Z2VPZXYrZXRLeUdRTVd5d1lJMlBUQngvS2dDSFZwNDdxL1pvOTI1NVRqajFaalVFU0ttcFRiOTIyTU1NVkxxVUpqdUxkb3dVM25JQTdITlY3YU4zZTRZOVZETTJUUUFXUmJjUG1PNC9wUzd2S0poOHZjVk9jRHFLWmJ6TmJ5N2wrWmlNTG5vRDYwc3MwbHVXTVc1dDNWaDFOQUZpMmdGd0dhU1pJMlhqYVIyOXpVVnRjaWE0VkUyamFXSEhPNEFIMS9DaU1yYXl4dTNJSUFibjYxSmJRcEpjS3Nad3hiSXlmWEkvK3RRQlNWMnZMUWVadFY0MzI5ZWVtYVcybERYVWU0bGZPRzF0cC93QTlqVHBOc0YxY3hTT0Vmb2NuZ092ZjZHbUczK3pxdm5Jc25uTmxmS2JMS1Q2ajA1b0FyUzJ3bHNsM044M0lJSHNSait0RlNYaVIydHVxcGRSbWJjVks0NkR2K3Y2VVZVVzBGamlOSkdiZ3R4Z3VPRzR6V3JaeEZKOHRoZmxKNTU0ckoweGRrMkc1QjZBVnJXazhrVW8ydC9zNXh3TTF0TUIwOFNsVmJHMEhqbXR6UkhrdDQ1SkUzTCs3SlUrdkJ4L09zZVl0S0FXWU9xbjZmbFd5bW8vNkZEc1hobENzZWVvSFFWakxZQ0NZcWpMdUlCNEE0cS9EODhVZkc1dHdCOTZ6OVJSbmpWdU1uSE5hdGlHWXJ0Nmc1T2VQV3BBdWFTdUxxTmVOK2NFYnUxZEpwOXR1STZmMHJIMEczV2E3TXpMOHlqYU0rdGRCcDR6SXZHN0dmcWFBTksxdDFVRE9QTVlkY1ZIZDZmSjlxRWk3ZG1BQmp0OWF0MmNXWmZtVnVSK0lyU3RncUFydDVZZW5GUzJCbVdrRE5rZm43MXljY0czVzNnV05wcG1seHNZZmU1elhvNDB3UXhGOTJOdzR4MnFsYzZRdjlzV1Y5Q3dqdWJPUVNLMjNjcjQ2Z2owTlBtMGFEcW1mZFB3cDBuVXZpTjhCdE0vc1BVb2RObVcxU0NSVlFzWTNYQUkrOHBIUTg1NFAwd2VjL2FGMHk3OEkvQzdTR2JXNytDU085U0RVWjdhWExiV1ZsVnN0MlZ5cHdldlExNWIrenIrME9mRG5pQy90NUdFTU53VE9JREpnQmljbkI5K2F1ZkdENGcvOEp4b1YxYjNIOXZXZG5kVENWb1lvV2FLWEJHTWx1M2ZLNHpYeDB1ZW5XVUpMcWZhVVpVcXRCeWpxN2ZsK1I0aisxZDRJYlFkYjBlRmRRWFVyNi9TUnBTd0hLNUdDZlE0NHo3VnlOaHA3VzBFY2ZHNVZBSkhJTmRSNDgxWCszdmlYREN5c3k2WGFHTU0zSjVLNC9RZXZyVEo3ZFNOd0RiaHh3SytxdzhwS2pGU1BrY1Z5KzJrNG1aRHA3WERMenNLODV4bml1bHRORGl0YlZKSXczbU1NTTI3RzdOVjdheWt1SVBsQngzeVA2WkZiZHRaN3JlSlFOMjBqcngyclRtNkdWdERQay9kZkx1YjVqOTdkVGxzV2VMYXJIY1QxSk5heldvd2R5SzNZWnFHNnVJVmpLc0VYQVA4QUY3MGVRK1VXeXR3c1M1WlZZRHJtaTR0bXVMUzNrVlQ4OFliaXNhNHZHbHU4N3NxbkNEZHd0UDAzV3BJN0tOUzUrVlFBT3VNVWFoNUd6QmJORGJuZG5ibnVPYXk5UWg4eFdPRzlNNHFTZnhPdHBZeVNYRExIQ295WkhPMWNWZ3ovQUJRMGU0bk1NZDFINWhPTUFFODQ5Y1VSdTlpWFpEcFhhQnR2OFdlbUtaQnd4SmJIR1J4MHExS1B0ZUdIM1pBQ0NPOVJUV1BsU2ZkK1Uwd0s4VTVpL2dMYnVnUGFtcS9uc0FQb2UxT3VFWlJ1T1A4QUdtMnErWUZ4akZVZ0cyanU5NzVMWlhkd01qdlZvV0VqbnBVRUIvMDJNQUw1bThBZWxiVXVZNEN5eHhrWSs4L1FmaDNyS3BKcDZGUk9iMWZUNFZVTm5jK2ZsSVVuY2ZRZXY4cTU3VTRUSEswYmhsS241czQ3K3AvcFhXWG9TMjNPY2R2TWtmbjhCOVBUcHpXSmV4UVhNSmVQNTI3bmQwd2VNMDRzR2ptSkFHbGtMTXdQT1FPQ09QOEE2MVVieVR5TGFRc3BVWTR6L09yMnRTN05RWWdOdWxYQngzSUgrRlpPb0ZyaUxHN2R1T2M5U2Y4QU9LMUpMRnJjTEhhNXo4clp6NmloSFJsM2JsNjljMUg1U3E2RDVvMjZna2ZwVFdtMnR0UHpldkhXZ0MwenFrVGNyMDI0STZIMXFxMXgrOGJkdUcwRU1OM0RjWUZOamwzZndsUUdPRkk0SHBVZDI0TzFUbE54UDNlOUFGaldiMk9hSzFFZlhJRFlCK1gycXEyMkszYjVXR2U0eWNpbVRUK2JGajd3Vmp0QjdBRFBOUlhGeXpvRVZ0M2NqNjBBT0RxWjE4dkxjZE85U3JHei9LUGxZODljQVZYdHBmczBoWmZsWlR6engrRkxQSXhmNXR4UGVnQ1kzQ2IyVndyTXZ5K3g3VXRqUDlubGkzWWI1dUhBeVFQUWlvUElWNUEyQ3FsaDE5NmJHdUpzN3VFR01nWW9BZlBHbDVmU0dZc1A3cFA0OGYwcVd5MHVTT1FMRjhwWWJpN2phQW9QUVo1UGJwVExTU09ITW0xV1plZHpVdjJvUzNCRFNMSnRVbDg5QWV1QlFCVnUxdC90NURSbFd5ZHpuQjU5Z2FLYzRqTjQyMVdiZndoeGpJQW9wM0E0blJ2OWJKOVFCN2Mxc1c4ZTZOV1A4VEE1K21lS3h0Q0dDM2M3c0hIUTgxdHhqZmFScjkza2o5YTJudUErMUM1M2RSbmdlL3ZWdXlpMnl0RC9BQXNNZy81L0dxVWNXUGw5eVNPeHE3RXJRekRMZmRHY252V2NnSFhCM1FqSHJ3SzE3V1JZNDJ3T1Z4eitkWlYyaEQ3Ujh3eUJqK1ZhbW14L0syN280QSt1T3Y4QU9vQTZMUll0dGx1Mi9lYnNldlN0N1JvdDNYTlplbXJzczQxSHVhM3RJaE1ZTzc2MEFiRmhDQXFxUG1QcU90YUZwWmJwZnVzR3owNjRxdnBpaUtISSs4Mk92ZXRhRjB0WU54d04zT1BXc3dHejIrK0h5L21WYzFYajA1cnlkWWJlTnBwSkRoRVFibUo5aFZQeEY0cXQ5RlJXdkpHVkpHSWpVTGtrL3dDZld2cHI0VmVDdEhzZEdzYnpUcmVJL2JMZEpqTWZtWmd5Z2c1OTg5QldrSWN6SmxLeDVDdjdOWGlHNThQdHFVWGsyK293NGFGQy93QTZyMUliSHJ4eDFGZEZwM2pDK2k4TzJOcnF5eldkMURHVW5pWmNaYm9SN2l2b0RTTk04NmFQNWR5TGhpZlU5aC9JMXVRZUV0THU3cjdSTloyc2swTEZRN1Jnc09tZXRjdU15K05XenZxZGVGeGNxYWZabng3K3ovOEFzbmFsNDU4ZDZsNGcxNkc4dDlIa2xQMkFGeWl6TG5QUGZBL1d2WVBGWDdLR2hyRnV0L1B0Z3Y4QWRrTFlyTytPL3dEd1VOMEg0ZDY1ZDZMb0dsLzIxZVdEK1JQY3l0c3RZbkhHMVF2ek5nOFo0SEhldklkZS9iKzFEeDNFdHZkMnRuWjJ1Y3NsaXpCLytCYjg1eGpvQ0JYUks2Vm1ZS0Y5VVVQRTF2YitIUEUxMVp3eVBOYnd0dERPb1ZpUFgvNi8vd0NxcHBOVmpUUTFrajNsa09NZzlUeU9hODAxRDQwZjJ0NG91ZjdVdDFndDVTUkRMSGs3UU9tNGQ4K3ZiMDlPeDBtNlhVOUZWcmVhT2FOaDk5RGxmLzExTGoxWWFyUWROSkplUk1XZVRjZXl1UlZOc1cwUVdSOXE1NDVxMHNUSjh1NDg4NHhtdWcrRm53eWI0aS9FUFR0UGJFa2NrZ2VVYlRnSXZKNlVlUkppNkhvT3BlSXBkdW4yTnhlYmVTWTBMQUQzTk1sai9zcUJsdUZhM2tYSWNTZktVK29OZnBSOE12aFBvL2h2d2w5aHQ3RzNpaFpNRGJIdE5mRi8vQlF6NEk2dG9QaUMydXJHMWttZ3V3ME1hSUNWRGs4TVAvcjlNZTlYeWFYWU8vUThyOE0rQTErTnVxV21tUVhFa3R4YzNJdDdXRlI4dU9oYkh0Z25QVEFyMkh4Vi93QUU4dkZud3pTUmRQMHYrMUxlYkxtNmZiSjVTNHpqQTV6bjJ4VVAvQk1iNFphNTRZK01GNXJXdGFUOWx0YlcyS2lhVjkyR0p4d01uSGZqdHpYM1Y0dytPdmhyVGRTanNWMXJUMnZ5Zy8wUlpsWitTQnlCWGk0ekh6cFZmWjBYZEh0NEhMYWRhazUxdEgwUHliK0xmaERYUGdsNDMyelc5ejltMmhwd3VWanlTT1Z3T01aL0hGV0o5WTgyTldabTJrWk9EWDAvL3dBRkJQR2VqK0pQQ2R4RmF5V0UwOGVXbEVUcnVSVHhnanIzcjQ4OEpYcTZ4cEZ2TDh6RlFGYkk3anFmNjE2T0hyT3JEbWtqeThUUVZLZktub2ROYVgzMm9GY3F2b0QrRlEzRi9HR2JuaGNaT2VLb05lK1M3N1F2ekU5cXBPSmJyYy9PN09jRVl5SzZVWUdrUEVuMmUrZ1pWL2lHU2UvT0JYV2ExcVVVWnpnU01wK1FZd1QxcnorMnM1SmRRdDFiTGJTQmtEcHptdEg0a2VNSS9BZWxKT3krZGRYQjJReGsvZVBVayt3L3FQV3M2a1hKcElJeTB1WW12K0piblU5WGtpQitXS1FnS083WjV6NitsV0xHOWhrU0xkSjViSDc0UGYxQTk2ODZnOGEzeTZrMTBZNGQ3U2VaOHVWd2M1NjVQU3RQVHZHdHZlS3FUZjZPNzlBLzNUK1ArTmIrd2trU3BvNkR4WHBTeDNrTHhrNWJnNDV6d2E1OVNPRkczQ2dqOGExcm0va3ZJNDQvbVdTTWZLUWZ2Q3NlRStYQkxrYzcrY2pyVUlvc0R5NVYyc3UxczhjNEZSWFVHMlRMYy9UdlN1KytaVStYSlhQdFVhVC9BR21MRGZlWHBUQWJieWVaRjh5ODV6ajhhajFGbEVrWExmS3JIOGhVbnlzeXlFL04zT09sVjdzNzNYdnc0eCtkQUVKZU5iRGR6ODBqbjlCVldLWEUrVDh2QUlJK2xFb2NXYXIvQUFnc2V0UVNPUkt1UDRVL0xpbWdMY3N5eVc2N3R6YmVCazlCVWxxeXlLTzdMd3dQZXFhK1lVWDVoODNZSG1yRVg3bVBjamJXWTRQUGFrQklYU1JtWG5iMUlIYW5RSnVUYmsvTG5qSFg2MVhod1FmdTd1dVQyb2p1bVIwWkZ6MTlPYUFFbmwyT0ZCTzdQSTlhWUVLdHVPMzFCOWFjWDgyWDdyYnM5dW52UXlzeGprKzlnZGMrbEFEV2RvNWR5eVkzRS9LdzRCNzRvcU85bWFRbGp0QUJ5QjA5cUtyUURsOURDcVA3MjZWUVB6cmVzQVcrVS84QUxNN2huMHpXSjRlaitVcTNRU3FjanZ6WFMyZHNMZ0tqRmw2OHJ4V2xUY0JJN1ZYa1U5Vk9jRVZNOFlpZU1IQjJyay9XbGhUeTFHMzd1ZW1LZGNocEpWVm0yN2hpczczQUxtTGJieHVmNHNaSDRWcVdnQzI2S09QbVBYM1VWU3VzcFpSamFHMjR5Y1ZwMnlSeWlQYjk1Y1pHUDltcEE2blNsWHlvZlFJQitQRmJOa2ZNZlpnN1J5TVZtNmRibGJTT1QvWkdCV3hhT3FSN2oxd00wbUJvVzhyUkl2OEFDdlFlOUdzZUkxMHV5KzBYREZrSEVjUVBNcmVnL3FlMVVicTZTS0I1NXBDa01ZNiszdDdtdUsxM1hHMWpVRmR5WTEyL0t1ZUkwSFg4YVZpb3h1VlBIM2lHYlZoRkhLMjZhYjVpRis3R25ZRDlmNTE5Sy9zc2Z0ZWFQcG5nNjIwUHhOSUxHNXNWRVVGd1J0am5RY0FGdWdZREE1d0srVGhjTmZhcEpKajczM0JuN283VmNkSlBMMnJHek1lbGJ4OTFCT1BNZm8vby93QzB6NE50Tk1XNGwxV3hoWGJ2WGRjeGpjUFVFdFhtWHhaL2JhdHZFYkh3OTRQbkgyalVDMFVtb3FRMGNBWUVFcjZ0amdIOGUxZklQaFh3STJvU05KS29WUjFKSEdmVDNOZWpXUHcrdXJQd3RkWG1tYWJOY1Myb1Zta1ZDM2xqT2VTUHU5Q2Z3ckN0WFNpYTBjTzVOZHZ6UFlQZ2gvd1R5MWZ4L3dDRjlVMVpWam1WU2RpeGpMVDdlZUI2KzllZmE3K3hiNHFudldqczlBdlk1bzV2bVlRdkdxblBJQllDdnV2L0FJSm4vRUM4MVA0ZFRXODBhcGJ3c3V5NDdsaUJsVFgwRjhSdFd0N3RURzA5dHVZcWpBTUJzeVFNbjlLK1NsbUdJcHljcjNaOWJTeTJoVnBxeVB4WitOWHdHMUw0WDYxWjJWM0ZMY0xlTVlvMWpCTFJ5YlFTdkhVbnRYRzJtb2EzOEo5YlUrUmRRUnV1NTRMcU5rRXErdUR6K05mWVg3ZS9pcTA4RWVOOUwxUFRwSXJ1NjBuVkliMVYzY08wWkRkdWNmS0JXZmQvdGQrRWYyak5GdXREK0luaDJ6dHJlY2Y2TGNSa21TMVlqRzVYNm93NDVIQjZFRVpyNlBBMUhWb3FVajVmR1JWS3E0SG1tZ2FsRHIraDJ0OUdmbHVvdyszSU8zMi9BMTEvd1krSjBmd28rSWxucWtzQm50MUpqbVVIREJEMUkrbld2RDlFMUZ2Zzk0OHZ2RDkxZUxlYVY1cGEzdTFIeUZUa3E0OW1HTWpzZnhxOXF2eFIrMXlzbWx4eHQxSm5tNFg4Qi9qajZWMlJwdDdISEpwSDY1L0RqeHpaK0o5SXQ3eXhtaHViU1pjeHZHY3F3SXBmaVY0TXNmaURvajJsMHJZWDVvM0E1aUlJUEg1ZEsvTm45aDc5c1c4K0VIam1mUzljdkxpNDBmVkhReGtmZHRKYzlRT20wZzg0OUFlZWEvUmZUUEdNUGlUVGxsV1JwSTVCbktuakJyb2xUdkhrWlZPcFo4eTZIRWVGL0ROcjhPR1d6RnIvQUtPck41NmtmNjdjU1Mzdnl4cDFqOE1QQjFuNDEvdFZOS3NkUHVyL0FBc2NZaldQTGNEZWVNQW5DZ2QrdFEvSFR4UXVuZUYybnQyWDdjckZtSStZUnJnOWZiT1BwbXZrdnhQOFYvR25qZVc4bW0xS1B5YldieVJhSk41VWJiZU04Z2s5OEhnajJyNC9GNFgyTlRsaTlENjdDNWhDdkM5U0t2cWNGOFdOSDBPMzhUZUs3TGExdnF0bnFVOXFvamNzc284eGlySDZLY2NlbnRYSWFWNFhpMFBTRmh0MmI1UVNTeDV5ZVRWalFiZVRWZGZ1cG10ekh0Y21abmJMTzVPY1o3blBmdlcxZmFjNHRqaGZtOXV0ZXpocnhqWnMrYnhqaktmdW5sdnhIOGNYWGczVkxPSzNhTnZNUXlPR1RkdUdjQWVvL0NvSXZqUmF2YnA1bHBPc3hIenFwQlQ4Q1RuOUswZmpONEd1TmQwZUc0dFkvTXVyRWttTWZla1E5Y2U0d0RqNjE1R0pWMkZjYldYSXg2R3ZYcFFoS0o1OHBOTTlFbStPa05sZHEwV215U01yQTRlWUwvSUdzSHhmNHh1UGlCcmJhaGNCWTEyaU9LRld5SWxIWVp4MU9UbXR6OWxqOW1iV3Yyc3ZpbC93aldrM0VObTBkczExUGNTSnVWQUNGQXdEMUpZRDg2OWs4WWY4RWdmak40U2l1bnRkTHNOV3Q3WnNMSmEzWVZuR001MnQrVllWTVhoYU5Ua25KS1huL1Zqb3A0UEUxYWZ0SVJiWGtmT2U4TEVvWEhwOHd4ay8xcXZyUjJhYXNtMzVsSHAwNXJXOGIvRGp4VDhKTldtdFBFR2s2aHBzMExBTjUwZnlFbnBnOURXYWwzRGY2Y1VsandyRGdxT3Rkc0trWnJtaTdvNVpSbEYya3JNMVBBV3BUWC9oMWpJemJyZVFyR3hQWUFZclh2VUpWbTVVRndCanJtdWI4TGFoYTZGWnlXOGhieTJjc0pCMEdmWHZYWHRhTExheHNwTEsySEpCeU1BY0VWeTFGYVJwRjZHYklDTHRtemphdUIrVlFNR3R6SHQrYkJCYkZYYjJ6OHFGV2I3MG1XNDdDcU1mUHl0dDNOeU0xbVVXWllkaGRlZmxPZXY0MVFtWXgzYWNkbU9UK05hTTZoVlppZm1ZWUF4V2RJMjZkVzU0UTVKN1l6UUJUbmtEUkw4M2R1dFY1QWZPNC91OG44S25sRzZCZWdCM0g4YXJHUm9yajVqNzQvQ3FpQTlkeUt2ZjNxWkF6OFpBNTY1cUpDMGtJSzlPYWNYWkZ5cmJzdGpCNHpRQktoeEw4M1hIVW1tUnFKQzN5cDgzQXlmNVZYbkJBMmJnck1lZnAzb2FUeTVnTjJHVVo2OUtWZ0pwcFd4NWF4b09lM1UwMWQza0J2bGJQRzNKcUVUdEcyNERkL1NwRWsrVlNxL04rZUtkbUJEYzVFeCtYYnhuQTc5cUtiT1d1THJBL2hHQnpqM29vQXlmQ3U1b0pEbnJLb3hYVWFSSm1ZQnNiUUR6MnJtZkNkdjV5aFY2bVlaOXE2YXhWWTRZV1hHSEpPTzU1eFZWZmlBWkNNVzQvd0I0NTk2bHUyek1yS3FqR01mbFRoSGhjN2R1M3BpaTVHK1pCdTdnRTFtQkpPdTYwWHBqNWExZE5KUzVqMm5idUM4L1ZCV1pjeGhMWSsyTVZwYVQ4OGtiQTlBT1ArQTBBZHBGODFoRnp6dEF6NzFhamZaSHp3a1l5VDZZcUcyWlRwc09BM0k3amsxVDhRYXF0bHByUnF2elRjazQ2S1A4ZjZVaW94dTdHZnJlc3Q0aHY0NEZHMjNoNUEyNHo3bjYvcFI0YytHMnRmRlRWWDAzdy9ZdmZYMTBPY3VFV09NZFdKWWdBZjQxUXM5MGVtelRZeEpNT005cy93RDFxK2dmK0NlMTlhMnZqUFd2T0tyZExZcjVJUG9aTU1SK096ODY1OFZXbFNwU3FSNkhkaDZNYWxTTko5VHkvVlAyTXZIWGdyVDVMNiswK0dTR1A3M2t6Z2xSNm5PQlhNL1oyc2RVU3phMm1pa2hHWGpHZHpIb0FmWThtdjB1MUdTMnVJbGprMnRIakJEQU1qOGNvZjhBUDUxOGsvdFllQ2RGOEdhZkZyTmpiTXlYRXlpMWtnWFBsTms3b0pPNFhxVko2SEk2WXJ5c0RuRTYwK1NvdFh0WTlYSDVQQ2pIMmxONkxlNXd2d3c4Rlgzalh4WnBla3dyNWMyb1hNVnBBZ1BBWjJDak9QYzErbDNpYjlpTFRwZjJiLzhBaEU5RmdqOHl4MlhwWjF5K29USUR1TGVyTms0SFFIQTRGZm5EOEhQaXBhL0R2NHNlRWRWblR6STdmVmJXZWRQK2VjWWtVdVQ2WVhOZnRaNGZNZHhFa2lEYnVVRUhuOEsraW9ZV05XbE5UVytoNG4xcDBxc1pVL3M2bnhEK3poYnI0SDA3eEI0Ump1cHROVVRyY0pkUTlZeEl2QkgwT1IrRld2Q1A3TTExcC94VDFIVnRXOFphdHFHbnpSN05Qc21uSXpKNVpWNVNBZWZtSUl6Njk4VjJIL0JSYncxcWZ3dDhjK0gvQUlqYVRhZVpwTTBRMHpXa2hqNFZnek5GSTJPemIyVXNlaFZSM0ZmTzNqcjlyRzdQblNhQ2J1TFVJbzFNYndxSkpGQU9kZ0J5QUNldnJnVjhQanNQVncxVDJUZDc5ZjYyUHM4dnhOQ3ZIMm5MYXp2YS93Q0htZUJlUC9oYnBjUGhMV2RZdnRZMUJ0ZTBlNWxzcnUzbGtMbTVmelNWWTVQQUtuc093cnpHUjJSVjNJdnpmZDQ1QXJwUGlGcU1tb2VJTDY2MVpOVnQ3blduOCtWNThLSGJ2dFVESHJXSExIOXJqVlVWc0tjWkk3VjlQbGM1Y3RwSHllY1U0Yzk0YWZtY3o4WDVKTEtYUTVBMjFqQXdMQSs0SUg2MWoyWGk0S3UyYVA1bUl5NkhyOVJXMThjQnRYUlZ4amJISm4veDMvQ3VETndzYmQyNmpQcFh0eDJQR08wMVBYbzd1MmptdDJVY1lHRHlDQi9XdnJ6OWhIOXA2KzE3d3AvWnVwNmxKTGZhZTVqVXlzT1VQM2ZjOXhuSGF2aEsydjJCTEljREh6S2U5ZEw4TFBHMDNnYjRnMldvMjB6UnB2Q1NZT0E2bjEvejJxbUIrbG54RThYRHhWbzExWnZ0a0Y5QXlzb2NxdUQ3am5yem4ycjRqbTFqVS9EQ1hGdmk0ODd6ZGhqeVdKZjFQcmtkRFhyOWgrMEpKSnBKSmtXTlZ4SVdJem5QWThkOFY1YnJPdXRxbmpkYitHTkdkaXI1eGtIR01mbDByanhGRlRqcWEwYThvU3VqczlNMGorek5QajgzYUp0dTZUYWVybmswN2QrODNmOEFMUEdUajZWWW0vMUxiaU56TG5IcFZONVZWV1g3b1A0MTU1djVrZHhvc2Q4bTVXK2Z0WG1QeFQrQ3cxeDVMM1QxV0RVazVkT2lYSDE5RzkvejlSNmN1b0trQk84RGFSajEvS3FOemRMY1M3dHpCbVBHYTJvemNYb1JKSTF2K0NVdndaOFNlTS9pSjRtanRiZTJzeHBjbG5KZXkzU09zMEVaYVVreEZTQ0h3cEliUEJVZGptdjBjOFk2ZDR0OGJhcFk2WHBkd3MxbHByMm91ZDF6TkMxMHBCRTc3b3psaXA2S2V1T3ZPUjhLL3MxL3RNdCt6R3V0M28relMvMnhDa0VheXZ0QWtETnRMSEI0d3grdlN2VVAyYlArQ2lkcjRkK0tlc1dmanpVbnMzdkdNZG5jeENOdFBqVm1KeSt6TEJnMkFHeVFBVDByNXZOS2xTZUtiaXRGYjhrZmM1SFJvTEJ4NTVXYmVyNkxWMnYrbHp2L0FOdDM5bVdiNGdmQWJVb2RUZExPNGtRVFc1a1BuU1Fzdk8zY1FDUjJ5ZWZldnlaSGgrNDgrZTFXT1gvUlpHU1I4ZktOdmNmenI5aC9qaDhUckQ0aGZER1M4aDFDTzZoMUJXUzJralltT1FFOEVFOVI3OTYvT2o0NCtJL0JmZ2p3WnIxdnA4clNlSld2SklZSVZpM1JtRmxYZEtUakhKTGpybmdZNmsxcGtlT3FRYm94amU3VnZMdTJjL0VHWFlkelUxT3lTZDMzN1dQbjdjMGg3SHNDSzF2Q25pZTQwKzhGcTBqTEM0T3daNGpQcC91bjlQYXNMUjdndENWejh5bmR6VXQ3aFJ6d2ZwWDJrb3BxelBocjJlaDA5NXIxMUhjWm1kV1hrYzBtblRTWFZ6SEkzQ3FRZU8vMXBmRHRqL3drbGxESXhPN2xYOWl2WDg4VnFmWmxnWGFNOGNjMXhOV2RqY1crY0pHemRXeGtIMDRyS2Rpa3JOdXg4bmM5SzFyOUdJWStnd2Zlc3hwRko1R0R0eG1rQlRrbHpieDlNNFlrVlI4enpaeG5IQ24zN1ZZdVNQczBmYmhqejI1NHFpbTBUNDQrVWV0VkVEVzArRkdoM2ZlWURJeHhWZFJtY0x0R2Nuak5SeFN0R3Fzb1BUSjU0eFRFbkprM2QySEI5S09VQjEyUUxyL2dQWS9oVVRTRFp2eWM1eDE2MDZSODNQR056QVp6M09SVGJyNW0yL2Q5ZU1WVWV3Q0pkR01mYzNaL0Nud3l0cys2Y1k2WnFGU3BZY3FPQ2NudFVzVTZsbHlGeDNORit3RUE4dzNFamhXNmZsUlRKYm55L013emJqM0I2OUtLZW9FWGdkMWpFZm1Jc2lKT0daTTdTdzlNMTAraTJiYWw1Y2NQbCtaa2taZmFxNFBxYTVid1phVFg5MHR2Q1ZWWnAxRzV1M3JYcTNnM3dWZTZiZVEvWTdXYTdoa1ZzTXdINSszcjFxSzBrbTJ4eGkyN0hPNmxvbDNvdGdrMXg1RFJ5TnRCaWZjTSsrUlVGN3BrdG1JWkpsMnJOd2pLUXdQQjdpdnRyOWpiOW03VFBpNWJhbEZmV1RKUEMza3lKSW01ZW1jZ252N2ozcXorMHgvd1RXMCszOFB2YzZMcVM2ZmRXWTgwUlBIbU9ZajE1NHowcmdoam9OOHNsWTY1WUtweTg4ZFVmRDl3TjFwbjJyVDBZcTkxQ3ZJQkdmME5VdFUwdWJTN2k1czdsZHR4YXlHSndPbVY0L3BVbHBjTFpoWkNlVkFJR2ZyWGJ1Y1o2QmFtT0cydFRPelIyKzNETm5wMXJrL0VPdTJkemR6ajdUQ1k5b1FFdHhudlNlRTlMdXZqYjRwdDlGVzZOcll4Z3Rub3Z1VDc5ZndyNjMrQi93RHdUYjBIeGhwTThjenpYa2tzRE1kaCtkTm9KNEI5OGZVR3NNVmlLV0hWNmwva2RXRHc5V3RLMUszelBsR0V3YW5wekdHYUptSXlBSkJ4empPUHA2VXpRdGIxVHd0ck5wZmFSZHpXMm9idHNMeG43M1lxZXhHT29OZlpPc2Y4RVR0U3Y5R3VqYWEwdW5zaWxyVkxnRm1iSTREWXI1ZjhXL0FEeEwreno4UUpOQzhUZlk1NUZpTTluY3dIS3NBd0I3QTU2ZGFtamljUFdpK1IzOG1iVnNQWHBTWHRGYnpSNmpybjdSZmlUV2ZDUXRZRnQxdW1RQ1poa0xLd3hoc2RRZjUxNW44UVBIUGpiVjlBdlA3VXZiVmRQdkhoTThheHFvbGtSZ1ZZY0VoczRKd1JuSHRXanBjVWx6UEg1YmY2dzhuKzdYSi9HUHhGL2FNMEdrMjhtNUlXSWJhY2d2MC9Tb3dlR2dwMmpGZHlzWmlwOG1zbWM3QmNGTnJTT3hZU2I5d0h6RHNmeDV6N2tWK3luL0JPejlvKzMrT243UGVsK2RkTEpyR2dxdW0zNExqY1hSUnRrUDhBdnJ6bnBuZDZWK09XcjZGUG9jVnFXYmNzeWgwSzhGZ091ZTI0Zi9YNzE2TCt5RCsxanJQN0p2eE1qMWExYjdScGQ0QkhxTmlYMnJkdzU3SG9HVThxM2JweUNRZmVqS3pQR1RzN243UWZGWHdYWS9GSHcxSnBPcHpUSFRabEt6UVJuSG5nOW1KNkFlMWZtdjhBdEhmRG4vaG5INHhhellhYkRKSHBFbUpMTm1PNG9wVWQrcDU5ZlN2dWo0Ry90UDhBaEg0K2VFRjFQUWRadDdnU0FlWmJTTUVudFcvdU92WSs0NFBZbXZuMy9nb2xxWGhQU2JKN3JWTldoVFY1TFVCTEpWTWtyRGNkcEFIUWNFWlBwWGs1dGhZemczQlhiL0k5WEE0aHhrbkxaSHc3OFFOWlh4Zlp2TmZidk10V2Z5czVPVC8rczFpK0g5RmFkbzlxN1JJTW4yclM4UmF3ZkVNVWNXa2FQTE5JbzNPenNXVnNEcHdNQTB2aFc0dWJiUjcrNDFJVzhEV3FrbTJWOWtnNHpqUHJqdFVZT2pLbERsWmpqcWlyU3ZFNER4eG9keDhTZmlQSHBsaVFzVm1tMTVXKzVDbzZ0eCtBeDNOZlJmd0EvWkIwZnhUcHF4dzZDdW9JcmJEZDNDRjJkZ0JrOGdnZFIyRllmN0VkanBNbDFyT3FTV2U1OVV1eGJuekZFaXdLTXNTQ2V1ZDNYSGIzcjliZmd0b21qK0V2QkZoWmFQQlp4VzdRcklaRVVmdk1qbGpqOFIrQXJnemJHVkZMMk5OOHA2V1Q1ZkNwNzA5VDhzZjJoUDhBZ2wzNGdrRnhkZUhkSE5zMFNHUTRVSkd3UGJBT1BYa0N2alBVL0Q5OTRTOFFYR2s2bmJ5V3Q5WnlHS1dOeGhrWWY1Nis5ZjBFZkZLK0R2SGIvTHVteUkxWWZLYS9JSC9ncE40SWhzZmpWTnFGbkRIOTBDNFpCOHJkODU5amtVc216T3BPZnNLbXZabFoxbE1hRWZiVSsreDV4OE1ibTg4VTZ4RnBIbnFyU1Jrb1h6MVVaUDQ0eitWZTArR3ZobmIrSEkxa21ZM0VnNkVnRmErWi9BM2k2VHdwNG10TCtObFNTM2NrRnhsZVFRUWZZamo4YTlhMXo5ckNMYWtXbjZXMDBqTDh6eXlsVUQrd0F5UVB3cjNhOGFqMGdmUFE1ZDJla2F6Zncyc3BWNUlsOW1jTHpYUStBdmhmY2VNN1ZicVp2czltM1E0d1pQcDdWODlhVnJHcy9FZlhmdFRSUnh0SXdJd05rY1k0K3BQSDFyNisrSEdxWENlRTdLMW44cy9JRXlWMm9EMzQvbDYxNU9PbzFZcFJwdmZmeVBSd05TamR5cXE5dGtWYlA0Q2FUckZ6RmF5UW0wakk1dkVtSlVEK1dmclhNL3RKL0IyMitIVWRoZmFYR3lhZXgrelRqY1daSkFQbFpqL3REOWZxSzlrMFdWbzd0YmVNUnpSZ0JpN2pKNUlQSTl1bkovbGlwZmlwL1lvOEM2cC93a054WldlbHlRTXR4UGNPRVdMKzYyVC9BQkE0eDN5Qmlvd2NKd1Zwdm1acGpLbE9vMDZjZVUrS3ZGdmlFK0ZJN1hWbzRJNW0weTVpbmpEcnVYY3JEQklyUytLbjdTK20vR2EzdGRQdnRGc1pyNldTR0UzS29CSVljZ3VlQmtIR2ZYdFh1MzdOL3dBRS9BL3hOL1pVOFJlS1BGbXEyOWpwR3JKTmJRNmpJQXYyV0tKaXBrakI1M002dHdRR3dvN0U1K1R2aTk0cThCNkY0dDA3US9BOW91b2VHOUhMUjNPcFhzWSswNnBNMGhEeWxoejVleFYyS01CUVQzSko3NTViQ3BLTlNwdXRqQ2ptTmFqVGxTcHZTVzU5Vi9BdjRWZkVIOXFDMnQvRFhnc1R5YUZvL3dDNG4xYTlPMngwcGVnVm4vamNMMGpYTEhqT0J6WHJmeEgvQU9DVVBoSHd4OE43elRWKzFhdHJGeEhtNDFpNFFlYThuUDhBcTFIM0VCNktEeU9wSjVyNmIvWXorTXZnSDRnL0FIUmJiNGZMWjJlajZYYkNKN09CQXJRdUJ6dkEvd0NXakRERlNTdzNEUFd1bytJL2pmU3ZESGhXNDFUV3JxMXNOUHRBWG1tbWtXT1BhTTV5ellDOXNrOEN1ekJaYlJwSzYzZlV5eE9NcVZWYVd4K0Mvd0FhdjJjdkVuN1AzaU9hMTFXeG4reXEyWXJsVkpqZGVjSE5jWTcvQUd2NVFyTXg2QUR2K0ZmU1A3Zi9BTzN1L3dDMUo0MCt4K0hiRmRPMEhUMkt4TktnV1NZY2RjRWpia056bjVndzRCRmVINmY4UWZzeWhiclQ0MVk1L2VXNUFCL0Qvd0N2VzBtMXRxY2l0MU5ENGFXTTJrNmJLSjR5dm5URmxWdW9VZ0QrWXJXdTRsQk9GL2l4ajFxdG92aXZUOWNrOHFDNDIzR09ZcEYydWZ3Ny9oV3ZMWUxJaWM3bVlnTWZVMXh6dmU3TjBVdFJBU0J0dnBXQk50UjJPM0xIQTZWMDJ0cjltZ2t5dUNUaXVkdUNnSzdzN3NxT0RVb0RLbWt4YnJ0VlY1YkI5T1RWZUo0NDVEdUozNDdEMnF6Y3lxdHR5bzRMRG44YXFveXlYYXF2cGo5S3FPd0V5eXFTcTdmeFBwVVROaG0ycU01T01kNmtDcWtlN0kzZGg2VXg5MHIvQU8xZ0RrKzNXaEFRZWQ1MjltL2hHUHFNaWxsbnd2eTg0WUgwNDcweWRmTGhIM2NNUVA4QVA1VWs2bUlyaitMblByV2dFcE1Mc29ERGprNU9lOVNTTEhMTkdGVlZWeVFTUDZDb0k1bEI2S0QxcXdkdXhjZkxrRXFTTWdERlo5UUtid3AwM0hhYzhHaWk2SWpTTncyN2QxeWMwVlFFbmdLYzJ0MXdkbTM1c2pzYTk3OEJmRTlyUFRSRkkwVnJiV296Sk0vRzRIb0JYaFhoSzFFRTB5eXF6TXdWZ1ZQYm5QOEFTdlR2Z2RwVWZ4SStKMmo2RDVQbVd0dzdER3d5QlgybmFXSHMyS3h4a1U0Y3o2YW1tR3U2dkt1dGtmYjM3QXZ4N3RQSFBqTzYwSFNOc2dTTVhMTWk3U3BIYlBmM3IyYjlyYngvb3Z3ditIOXhxV3NTYjVHWFlsdXJZZVJpT0Ivbm4rblBmc1VmQWpUL0FJTFdOeHEwY0VLNjlKRjludTV3ZytmamdyM3hqMTYwL3dEYXU4QTZiOFJOSHVZN2pkdXVJVEcwclJpVHlWR0NTTjNBUEhYcjByNWljNmFkOWJNK25qVHFSZzRQZEg1c2ZIUytiVk5kajFSZFBheFhVNHhLb1JUc21HU053Sjc4WU9QVDNybEo0R3YvQU4ybUZhUmR2emRCWDA1KzNacjNoUDhBNFZkNGM4TzJOanFVT3BlSDQ0bzdPZVNEeTQ1b0dYTFlKNjhxT1RqSjZaR2ErWWRwYVBiME8zQTlxK2h3VlRtcEpuejJNbyt6cXVOenRQaDFyR2svQzJ3ak54SERkNmd4OHhpeDRCei9BSUhGZmJIL0FBVHYvYWp0Ymo0c3cyMTdOYjJ5M0VXeU9Ea0Y4OUJ5ZWNZeC93RHFyNGwvWTUrRldpL0hMNC8yK2hlSjVwaGJlUkpKRkVzalJtNG1ES0FwWUhPQUdMY0VmZDlNNStxUDJRditDZnZpR2I5cUhUZkZsanFOdmRlQ2RIdlBOVzZsazJ6dWlFalpzd01uT1FHNEJIUEhTdWZNS3RCeWxSazdTdGRlZm9kMlg0WEVxTU1SQlhpM2J6VnU1K25Yalh4UnBPamVGYm5XTlN2TFhUOVBnVGRKY3pTQlZYMnljVitYbi9CUW40aCtHL2lOcnZoNiswaWFPNXVmdGs2eDNLcTJMaUhoV3dmUUVqbjJIclgzRCsxbit6YmUvSG53RkZZdytKUHNHbVFPclNXd1FmdnNmd1pJT0FlT1ZHZlExNTM4WC8ySy9EWHhFL1pGMHp3bnBOcGJqeGI0WGdhYlRkUVJObSs2VlFaVlpoMVY4RU1PZVFDT1FLOERCMUlVcWluTitwOVBqTUZXeEVYVHByYlZQOUQ4MGZHL2llVHdwcGEyMXJKL3BONE0rOGFkUDE2VnpuZy9RcmpVdFNhNGtYN2dEQW5LNStoNmNpcnVyZUJ0ZThRK01kU2ptdFpJbTBtYzIwNWtIeXdGRHRLay9VR3ZTdkRYd25qdk5JVkpOUWtFQk9Oc0toQXY1ODQvK3RYMlVhbE9qQlhlNThKS2pWclRhUy9RNWJ3NzRLOFJmdEdmRWpSL0NIaFN3KzM2MXFFaGp0clFGVkNNcUZtSlpqZ0tGVmlTVGdZOXE5SjEzL2dqVCswa0gzUitCYmU2QitZR0hXN0E0OXNHWUg5SytsZitDU2Z3WjAzNGZmdFlhZnJNMXJ1OHl5dUlZcDUvM2dCSUJPUFFsUTNvU01qUE9EK3RjVU5tSTE4dUdOczlHVlZ3UDVtcWppbE5YaHNYOVNjZEtoL1BqWi84RTFmMm12aHFXdnJid1I0bTBSclVCcEw2MHZJZjlGVWNzKytLVWtBQVpKSHBXVGVSYWw0MjhVNmJKNDAxalV0WXU3VmhaK2ZLKzR5RG5xeDVQekU0elg3NmZ0RWVHTHp4ajhBdkdPbTZlelcxN2VhVlBIQTBlQTI3YVQva2ZVVitPdWkvQ2l3dWJMVUxiVzFiKzBMYVI0cEkwajNMR3d3b0piOE9PMzUxejFzVnk2ejJLamhiKzdBN2o5alg5bUhSL2l2ZDZTOXZZdEkwc3NoWWx2bFFxRDh4OXhnVjNIN1VIL0JHOXZHY3pYdWg2dHBPblRlV2ZOakx5YldPUHZjTDE2ZmxYb1AvQUFUZDhGeGZEeTUxYTNpTHRDc0tUcTBwQjJNVGdxUFFIazRyMjM0OGZITHc3OEt0TGl1dGV2bWhTWTdGV0tKcEdKUFFISFQ4ZmF2bWNabTFlbkp1aTAreDlIZ3NtcDFxY2ZhcTNjL00zNFcvc3VlSXZncC93bVBoMmErczF1cmFJWHNiS2N4eXc4cXhRSHVDcWcvVWRhKzVQZ2xQcVhndjRMYWExeGJ6YWhxRnJBRDluWGlSc2pLZzVQSFByakhmRmVTMy9qVFFQalgrMXo0SzhONlBhdkRKZkc2KzBUenhOQjUxbThFaEdNZ2JzTU53QjZsQlhxWGpMVHRhK0VuaUMzMDI2dnJkTHRvQzhNa0xGa21oM0VBZk1CbGx3T01menJqclRyVlllM3FMVDlmNjJQVXkramhxVXZaS1ZwTDh1L3kxVFBPNHZEZmovd0NPeDhlYWg0aXZwUEQ5OXBFYzBmaHVHMVpXQW1HU3I1WDd3S0w5Zm54d1JYd1grMGY4T3RTMS93Q0gwbXFXZXJYbXZTVFhLajdQS3Vid1NISmxpMmprN2NFazkvMHI3NCtJbnhjSHdxOE1UWEdvYTdKYTZ6TzV1YlZMYUpKdk1ZOEx2VXFTZWc0VVp3TUE4NXI0TjhSYTU5czhhWHpHNnZwSkpibVM1bGt1WVBJTE8zSllKL0RuMDk2MXl1ckoxZWFLdHFuL0FGL3c1ejU3aDZVS08vTTlkZW5kZjFZK1hTc2xyY3lSU3h0REloMnVraTdTQ094QjcxMVh3OTB5MTF1OVpaVmJ6b3gvcXljQWoxSHIxSDUxNng0cjhMNmI4UWhzMVNGV3VzWVc1VDVKZ1A4QWU2TmowYXZIZnNiZUF2aVhEYnpTU1IyOXZjQkRLNmJTWXp3V3g5RCtsZmVSbnpMUS9QejN6NFc2QVdsWGNJNDRYd0F3SUdEeFgwSjRiMHYvQUlsRVptZGJhTmRyeHFmbFlPcFBCQjdjZmp6WHpmcDN4MHMvQ2hqanNkUFdhUU51RTA2NXdjWStVQTRHUHo1NXJMOFVmSHJWTmNXNGE0dUdpNTNIYVNBQmpnMXd6dzg1TzV0R29vbytpUGlaOGR0QitFK21YR29YbW9zNkxtVkxlM2tCZWFRZFl3TWNaOWVnNjE4UWZHWDQ5K0pQMmhkZkZ4ckY0MGVud3Y4QTZOWlJzUmIyNDZaMjU1YjFZNUorbFlueEQ4YjNIamZXMmtrWnZLaitWVjl2Zit0WXR2T3R1amM3bSt2U3VxaFFWTlg2a1NxT1Iydml6NDFlS05aK0dPaitDcE5aay80UmZSVlAyZXhoUllvbUxPWkM3N1FON2JqbkxaUEo1cnUvaVA0UThKK0V2QVZxN05xWCtueEkrbVc0ampESS9reHpGcER1SlhkSGNXNzlUbkpIR09QSmZBVjNwMm0rT05IdU5YdC83UzBxRzhqZTh0aHo1OFFZRjFBM0xualBHNFo5UjFyM2Y5dGI5b253WDhlTktzN3pRYks2czlVWFZKSmlra1d6eTREWTJWdmg4WlhkdnRTUUZKd3A1NjRHa3I4eUZIWm5LZnN4ZnRXK0kvMlh2aUpEcTJoM0V4c1RLaTZoWks2NHU0QklyT2dMS3dSbUM0RGdiaGs5aVFlcy9iUS80S1IrTGYydVBzbW5ySFA0YTBTM2kyUzJVRnp1ODFqa09DeXFtWTJHMGxHQitaYzVyNXllNDhsMjJ5Wkxja2pnRTFFa2lzKzFzbmFNNURkVFd1cEp0YVpEYml3bTVZTUZJQngwT1JVTHQ1WXdHSHlubjNBcVRUZHBzTG1iTzVXNFRCNmM1UDhBV3M4eitaOHpZK2I5S1FFa3QzR0xxT2FPUm9ab3lDckwxVWp1UDhQclhvSHc0OGQvOEpFSkxPNlZWdm84TUNPa3dIOFEvd0FLOHZ1bVh6dzM1ZTFQdEwrYlR0VGp1TGFWbGxoK2VJajE5UHBVenBxYXNWR1ZqMnpYL3dCOWFzZmw2OGZyWE4zaUFCZlRlQmpIU3B0RjhScDRnMFZabE80U2ZmWCs2dzZpcTE5TnNNZVA0cFZ4N0N1SGxhMFpzWjF4Rm0xTzdMTmwrTWRlRFZCRTNYQkN0akM5OGM4Vm8zcktJRDdNM2ZvTnRaaUxtVFB6YmxYZ0Q4cXVJRmtyL282cjF5ZlRxVFQ0TFJUakdHd0RrOUtobGtZbFYzTDAvQVZZaCtWV0htSGJ1N0FVbUJTdllQS2VQY041Wi9ya1VzMGJUcUQ4b1VaeFVkL0l6aFQ4dnl0blBmMHB1R052dTRVa25HRFY5QUd5UnlCaUZaTjNYaGFUTWtUN1dVdHRQWVZMRStaUHZZN2NDblN5N1N1N1BUR1A4L1NscUJuM1Z4SkROdVhuMjlLS2ptM0NWc1o2MFZYS0IwMWpwbjJpMWpXTm1rbWt3b1JNbGlUeGdkK2VtSy9RTC9nbUwrd3A0citGSGlpNDhWZUp0SGlqYTR0eDlsdDVKQjlvdGllY2xTTURJN1p5RG5pdWQvNEpVZnNLWFdyNjVaL0VMeGZZdkZhMllFMmpXbHduK3NicUxsbFBZRDdtZS96ZGxOZnBocG1sNXRsYmJpVEJBSGNnZjVOWnppcHhjRzl6V2pGcVNrZVk2M0RwdmdkN2o5eDloZlVKREs2dU5vWjlvSEdmWURnY1Y0MSswTDR6V0RRNW83Vm81cFpZOEFFL0tRQm5GZlQvQUk2OEsydmlmUzV0UHY3WmJpSjE1akk2SHJrSHFEN2l2aXY5bzc5blBXUGhOcmttcmFmZjNtcTZITU1LazN6UGE1N0U5MTdldjFyd2NibGpndVphbzlpaG1EaytWN255RCsxYjQyMWZ4VW1uL3dCb2JNTEh0WkJIamJrNUg1ZEs4bmhsVmJaZjcyTVY3ZjhBSHNXMnVRSXN1M09OcHdCa01LOTAvd0NDVzMvQk1KdmpmcUZyNDc4ZFdUcjRUdDVOK21hZktoSDlyc3AvMWpqL0FKNGpzUDR6L3MvZTlMQWNyb3BSMFBNeFhNNnp2dWVTZnNDZnNKZkVUNHVmR2Z3NzRzdFBET3NRK0ZiZTQ4NTlVOHhiWkNBcCs0V1lGd1R3U3VSZ25QZXYxVzhHK0ROVytIbXVUV2Q1cGEyMmsrUURGZEt4WVBJVytaV3hsUjJQQjVKTmUrZUZ0QXQ5RHNZYlcxaGh0N1czQ1FSeFJLRlNNY0RBQTZBREhIcFZ5NnRZNDUxaG1qajIzS0VCV0FJWUU0eCtmSHZuMnJMRzRPTmVhbTNaclE5VExjWlBDMDNUV3FrN3MrWS9pcmVYMCtueVE2ZmNMYjdneFdWaGtSQWM1eFg1NC9IWDlxbnhINHEwdUhSZEh2OEFXdEh1L3R5eENheHZKYmRDN3RqTE1EdElKNUdSM3I5TS93QnBqNEVhcStoM09wZUZjejVRazZmd3BteU9SR3hPQVdIUlR4bnVPbGZsbiswQjQzdGJhWDdIZDZGcUdpYWxZWEt6d0xlMnpXODBieEVCY2hnRHdRT0NLOEg2aFVoaUZLY1haUGRiSHZTelZWS1RqR1hUNW5yWHdZL1podTRmQk9uNmZxVndMcTQzazNkOFFHM003bG1BenlldlVqOWE5QThML0FUUVBDSGl4YmU0aCsxdzNSQmpSaUY4aVRCTFJ1T2hVN1dZRWRNTjF5SzlEdWZFVmovd2lHbFRJc01JdXJPSzVqS3NRaTdvd3paT01meFAxOUs4aCtNUHhZdDdEdzZ6UXpZdjdaSTdtMjJuTE04WTZ0MzZqcjN6Vzhwem5LOFYxTm8wS05PSHZkanZ2Q25qblMvZzc0eHVJN1c0dFlVdFNKb1k0bXl6S2pxMjNKNTRLaGNqSEJKNzRQNklmREg0aVdIeEg4RTZicVdqc2sxcmYyNlhFVG9jb0ViUEpJNEJCQkJIWElOZmhOOFNmano1dnhQdDUxaHpZM0NLNGN2Z2lOeDB4N3JnSE9jNCtsZnBYL3dTNS9hUDBYeEg4QmJYUzRiaUJadEZubmdraFEvTXlOSThpT1I3YmlNK3hyMjhMUmxUVnBiUFUrWnhtSWhWZnUvWmRqNnk4WmVNbzlCMG1WMmsrNkJ1UFRPU0FCK0ovclh4WjhTdmhGNFg4VGF0cWw1QnA4c2QxSGZYSDIySzBieTJJODluWEF3UnUyc2g2Y2ppdmIvanY0cG1LYVBwKzVsbTFyVllJOEhqQ0J3eFA0QmYxcjRUK01QN1VkeDhIUDJqUEdrRWd1SDAvV21TYUVBOEpLbzJuajNVRC92a1Y1ZkVOR1ZTaGFDMVRPekljWkdoaXJ6MmFQbzM0ZGF6YitEWUlaYk5YVzF1bFdSbGRjU2JTQnd3OVJtc2o0OC9DVFFQaTFIYm1YVXI3VGROaG5GN3FMcmN5aGJxSWRZeU4yMzNIR0JqUFhyNEQ4TS8ydDRmRXV2eHJmU0pHNm43dTduSDk0ajMvcFhXZkZ2OW83VDlJMFZ4SGJ5YWhjeWN3d3h4N2tVREJ5VjZIcDN6WHlQczZzR29MdGRQOHo3VDY5aEt0RnVTMVR0WTltOFplRU5JOFJmdGUvQi94SllOYjIwdGd0N2FPZGdWcElWczVtUmNlZ3d3K2ptdlJQalQ0SzA3NHorRnByVzZrTm5QQ3pQcDE2UDlaYnVCeS84QXV0d0NPaEJIZkZmbVQ4UC9BSTMrSXRQK04zL0NTTEpOcERhYmVDL0VSbGRZbVZ3VWtVeGNMODY3Z2VPaHI2RjhjZjhBQlNKTG15LzBCSW9wbWoybE51N2FlU2VmYzgvZ0srenkyaTNoblRxcTZiUGhNM3h0TjRsVmFQdTJTOWJyL2dHQjRyMGE4K0YvakpuOFVSMnNqeDdvWTdpSlZrU2RQN3d6MEo3ZzgxODEvSEtLeTFYeElsOXA3S3NKYVJGUlVFYW9vUG9NRHFmNTFGOFNQMnB0WStMSGpYWElwWm1OdkExdWlnZndzQTVMZW44V1B3cmw5UTFwOVRoQ05qY3JmTWNlMktkSEovcTlaVklQUTRzUm5EclVYVG1pcmFYQ3RNMkFXWHVoN1Y1RDhjYnlPNjhicXNUYnZLaENzTTV4bkp4K0ZkMzR2OGF4K0VkTnVtYkRYVU9Bb0orOEc2SC9BQkZlTVhOOUpxMTFOZFhFbVpKR0xOZ2V0ZlIwNDlUd1ViK202b3VvUnd4TEkzbUtuS25nOGQ2citPdFhrZ2lXM1FNclNEYytmU3NHMjFlU3oxRkpvV0N0YjVJSkdldkg2MUZpYTluYWFhUmpubG5ZOS84QTY5YkZFYVc1UmQzcDB5ZVdxSkltVjhzdTdQYjFxNHFoeDJYYitRcDF0QkRkVHhtZVJvWUdrVkpHUmR6SXZHU0Y0eWZiSXpRQlZzbVUzaW5MS3cvU3JUWENHNFZaR2J1L0h2MHI5Si9oRi93VHUrRGZ3eGtXTFZyciszdFN2U3Q1YjIvaVMyazArZGtDRDVGamJidUF5U1Jna1p3ZWxlQi90aWZBN3duOFFQQ054NGsrSC9obTA4TlRlSHJpVzF2cmUybTNSWHdCNFpSbmc4RWpnWkhIV3ZDcDhRWWVkYjJTVFM3dlJmNTcrUjlEVzRieE5LajdXVFRmWk83L0FBMDIxM1BraS9JRXAycnU5YzFXQlZ4M0RkeFZ2S3RGdTduMXFPQ3g4eHZUQTYxNzhaV1I4OFdOS3Z6WUNKUnR3MG14aVQwSEFOU1hDTGIzdTNkOG5UaXMrUWVVa2kvM2lNa2pwV25xVjJKMmlsQy82eFEyY2RhR0JSMU8weWR5dCtIcFZRRHlkci8zVGc0clhuVVhNYS8zc0VZcXJjVzMyYUo4amJuZ2pGT011Z0hRL0RVTjlwdU1NcXd5QmR5Wi9pejE5dU0xdWFpRjNLdjhLeUFqSjZDdUY4TDZ6L1lPckt6dCs2YytYSjlPeHJ1THE2VnlHM0x0R0RYSmlJdFN1YlFlaFV1LzlJVS9MaFdMRE9PK0JWRHpCRE9lcFZlbnZTWEY0RlVCV1pzbk9QU29vYmhSUC9FdnlrajYxaWlpNGc0eUNPdWNIdmlwa2RZNVdiREZTZVQwcXVrNGsyci9BSHVwQXF4RVI1ZzI3bTNESE5TQlYxRVpsalVBYk1rZ2VtY0hGUXBCNWtBWDVmdjVHZS9lcldxbHBKMTJzQUZKSDZDcTZRYmxicXpFanJXaTJBc1FSUnFyRnZsYjE3VkRxUi8wbmRucU1qTk9aeWdZYmNyL0FCZDZnbm5CZFF3WmNqRzQxTVFLMDBhcnQrYnF1VDdVVTZlWHk3anl5b0pDanZSVmE5QVB1cnduL3dBRmxibnduNGZoc3RQMFc2dkxxM3RsWGZMS2lSczRWUmsvS2VNNVBUUDlKZE8vNExlZU5vTDZCcC9EZG0xbkdCbU9LK2tWL3dEdm9najlQWDhQaFB3OFdHb0xoTnpNUXVDY1p6eC85ZjhBQ3R1OVNhMjFBS3hneXdHQUd6a1YwS2pCR2Z0Sjl6OUNmQlAvQUFYQTAvV05mc2wxL3dBUFhtbTI3a2lhV081RjBzWkk2NUlERWJ1MkRnWXI2SDhFZnRLK0RmMmhmQ1Z6SEhxT215TEpFSlFmTkhsN1crOHVUL0VNOVBxTUN2eGJ1ZzBqTnVqSys2OUttOE5lTHRVOEczYlhHbFgwMXF4SUxCRytWOGRNanYzL0FETlRPamZZcU5aby9UejRaL3NBYUQ4VlAyb3ZMOFFhbkd2aG5TOXQ5THB5bkVsK1MzeXJ1N1FubmNSejBYak9SK21uaDdRN0x3NXBVTnJhTGFXc0Z2R3NjVVVlMUVoakF3QUZIWUFZNDRBRmZnUjhBZjI1TmErSEhpKzExWnJ4dnRFVVhsWEVjNDNSenJ1QngxenhnSG5HRGpGZXYrTS8rQzRualI3UzUwN1J0S3QxWmtNYVhKWW9GUE9EanYxNzljQ3M0MGVWY2lSY2NSWjNaK3luakQ0eStFUGhUYXd6Ni9ydW1hYkJ2SVh6NTBqRWh3ZWhZZ0g4TTlxOHI4YWY4RkF2Zys2VzgwZnhBOEw3YmQvbUs2bEUyQnRiQVk1NCtZQS9oWDRpZU50ZDhWZkhRVCtKdkczaUdYVUxpTkM1VzRmZEhiSWZRZGo5Qms4ZFRYa2w3RkJMZXlOYmJ4YjUrVGNlY1ZYMWVMM0g5YmwwUDZIUEJmN2RYd3Y4ZFcxeGIyZml6Ukw1WjNKaGlpdVF6U1J0a2tBZFJ0WUVqMERESElCcmd2ajM4QVBBdjdWRmxtT1N4dnI1OC9acEdHeDdqQTZISGZIRzRlaDdZcjhGSGxhMmxFa2NqSXlITzVXS2xmZk5lMmZzOWZ0LytPUGdkY1IyNTFXNnZyQ00vSTByNzVyZjBJSnp1QS9IanBVMUtQdTJTdVZUeGNveXVmWm43V2ZpKy84QWc5Wnc2Yk5FZE5uMGZiQ2x0TG5hSWw0VTR4ajd1Y2V4OWhYeDc0NCtOTjU0amtWVnZIM3h5TWNzM0pVODQ2NVBwelhwMzdVUDdYT3FmdEovRGhXMUNhM3VtdDRvdHR5RkRTTjBEYzlRRG5PT21lMWZLOXpKTnExeG1Ga2FOT0RMMFVmVTF6NFhEdzFkdXAwWXpNS2xXeVQwc2FPb2VJVzFIZDVsd1pHdGpzUm1iMFBISDVmbFhvLzdLdjdWZXRmc3dmRm15OFFXOHMwMm03VEhxRm9yakZ4QWNGc1o0M0FxR0hxUml2Rlh1ZjNqeG8yVzNaM2pvYWRlWFQrU3NXNXBGVVlJSGJ1YTlCeFRWbWViek5hbjdvZUFQalpEKzFGZWVDZkVOaXJmWTdlM2t2aUdHMWxWNGxXTWtIL2VBL0ROZkZ2N2YybXh4L0ZPNlpsRzVVUWZpU1FmMXJHLzRKMC90NlhuaGZ3dGE2SHFzM212cFVZc1ZrbWxaaThIL0xNSE9mdXFBb3gwQ2dWdC90aytOTFg0aStMcm5WTFVSTWtrVWJzWXlTckhkazhIbnZqOEs4bXRDMHVWOXpxVlM2dWo0cjhmZUtkVDhFNjVhNnBwZDVjV2R6QTVqREk1dzRQUEk2SHYrZGJQdzYvYkY4UStIZkZGamRYMGdtaEVvRnc1eTM3c2tad3ZUOHF3ZjJoOVBOdGNXMGtaL2RMSXlzdWVySGtIOUdGZWN3dDV1MFk2OGZXdTU0V2pVZ3VlS2Z5TWFlSXF3ZDR5YVBvLzlvUDlvU0M5OFRhZnFGako1dHBmSWVVUFJlQ2ZyeVdybmZEbnhRdGRRalV5VC9NeHp5ZS9YK2xlWTNQaFcrTVZ0dGFPNGlqK1pVRFlJejFGSGpmUld0cmtYa2YrcnVNQmtIM2tiMyt0VFNwVTRSVk5FMU9hYmM1SGNmRGEvd0RPMWJ4Qk5KSW84MllBYy9lK1huK2RiL2lEeGpZK0gwYTRrdUkxRWtlUU4zUmg3ZmlhOFVzYjJXT1dTT0tTU1BqRFlQV283dU9TVS92V2FUbzN6SE9QcFhTNmFiTXJHajQ4OFpONHoxVVNxSFdLTWNCdUM1OWNDc1c1ayt6VyswZHhrKzFXb1lFWWJ1NmcrMmZTc3kra0VvL21SVnJRWjlkZnNhZjhFdzVQang0R3RmRW5pNisxTFNkTjFBZWJaV2Rqc0Z4Y1JubFpXWmd3UlQyRzBram5qak5QOXM3OWdPeC9aNzBHUFVOQjE2NHU0TXNzbGxxQVVUWVhrbFpGQVY4RCtFcXZUZ2s4Vjl0ZjhFNS9GVCtPdjJSUENlcFJOTkM4TnFMU1NUN3BaNE13bkI5UGt6eDNKOUsrYnY4QWdydnEyb2VGL0ZPajI5MzU5eHA5NUNaWUozRzRPNVB6SnUvaXhnSG5rZTR3QjVNYzFweXhYMVZYdjM2WFhROWlwazlXR0NXTWRyYWFkZGVwOE5SUVJ6WENRZzdWM2NuUGFtVDIza3c4ZmR5Y0FqbnJqODZzMmRqSEplc1ZmeTFHQ1NvenQ5ZjYwNjZoaysxdnVWVnh6ajcyUFRtdldQSFB2ajRDL0hieFZZZkJmUVdYWE5KK0xYZys0czQ3VFY3TFVvMGgxTHd4T1ZBK1ptSk1rU05uNWljN1JrY1Y1TDQzWCt5L0VWMUZiTDVmMnhmbkVVKzVabEp6a2djZjRnQSs5ZUEvRHJ4YmVmRC9BTVNXT29Xc2hPblNTQ0RVTGVPNFZYdW9NcjVpbE01NURjTVJqSU9PaHg2NmdSN1NPK3RabHZMTzZKTnRMR1F3WmUvdUNPNE9DSytOekhMWlVhdk9yV2ZaVysrMmwxM3RyNm4yR0R6UlZxU3B1OTEzZCtsdEw2MmZhK25UUThCK0lHZ253eDR6dmJNSXl3bVR6SWdSL0MzSS9Ma2ZoV1ZheStUSjk0Zk1PY1Y2WDRnMUc5MTNWSm80NFB0S00zeXdOSDVpL3dEZkpHTThkY1ZiK04vd3d0dkJQZ0R3dnFkMXBjT202bHFUT0prZ3pHcktBQ01ybkFQWG9CMXI2Mmh6T25IbjNzajVPdGJuZkx0YzhxbXNXbGprMjg4YmpTd2pPa3hQeTNsbDBQdDBQOWEySVpiZGwzZVhHcXNDTWRjZjV4V0hkekt0dFBIR2ZsMzd3dWVBZW5INTF1dGRETW10Sjk4SHpmTm5vZTlGMHpQQ3dZYnVPRFdmYTNMSSs3ZFY4M0ltREszcDY5YUpSc0JtengrWXJzZU1kQi9uOEswOUs4UlhWeGJ4Mjd6Qlk0eHRIeTg0SFROVWJtRnRwWldPRDFOVmJkaEhQdUo0eUJWdUtrdFFONkxVMWtsTWNpcm5HVmYxL0NuSmNOSFB2WGI2WTlxeVdRaWZZMmN0d00vcFYzU3BHYUJsWTlPRnowK2xZVmFhV3FOSXk2TTNMSi9PaytWc2J1RDZWY2psMkFMOHU3T2ZxS3dySzVhMlpsSy9MMnoycTlEUDg2L0x1WDdweU9CWEhLSm9UWEV2bjM2cnQ3OGNaNTRwdHpJM21xc2JiaG41c0RvUlVUcUJkWkRiZlRIQUhYdFRJTHhvZ1QvRm5CNHF1VUIwUmFjU0VzTXIxNTYrbEhsK1o1ZnA5TzlNczV5MjdhT2UrS3YyTm45cnZtaSs2d1YzQkgreXBPTWZoUnNCazMxdVpMcmNkeDI4VVU3NWx0R21sMk50T0R4amswVnB5c25tUlowWTRuYm43cDh2Y2ZYRmFsMXFOdDlvczVwSm9jc3VYQU81bDQ2WTVPYzFuMm1uTmIySzdlT2R4OTgxMlB3cG5qVzF2azJSN281dnZFQU1BM3pkZnFUWFFZbkpEVTdlM3UyRWp2NVpVOG1NcnorT0tvM3FlUytZL21qYm5JOWE3UHhwcDZwTjk2SnR3ejBITmNaZXI5amR2bFZWSTJrRHArRkFEN2VOWmNaWDd1T2Ftc0xnUE0zeXFkcjlmWC9QTlZiZVRiYkZ2VWdVNndMZWF6TDhxbHh5UjBIK2MwQWRScjNpK2JXTEVXTWNyTFpSa0ZsSEFrWWNEOHF3MFppdk9PdU9PMVBVaUZTb0EyL3lxSlRzbTJFL2VPUngrZjhBalFCSUJ4L3MxVXZyRldqM0syeVRzUjNxMzkxY3RVTnhJcmJsYmF5NHlSUUJKNFErSUZ6NGF0N3JUcmhYdU5OdWhpV0ZXMnNoL3ZLZnJ6ZzhIMjYxSElzU3k3cmQzYUY4N2NqREFkczFtM05yaVZaRlZuNDdEclM2ZmRBdHRVc3ZPUUQvQUEwV1MyQXZoVlFIYTI0dituNFU4eXgyNk1aQzN5cjM3bXRYd1I0VHVmSEdxZlo0bkVjYWN2SVI5d2ZUMXIyRFJ2ZzdvZmh2VEROSmFKZVRPZHUrNFVTc2VEZ0FOOG80Qk9lS3hxWWlNTkh1WEdtNUhpSGhIeDVQNFMxbU82dEMwWlhBWmQyQktQUTE2YmVmdExDOXN5clEzU3M0K1pCZ3FCOWMxOVgvQUFLL1pROEYvRWI0UFgzaWZ4bm9ra3k2SEpJUlpvMzJkYmdScHZ3ZHVHUFRnQWpKTmZMbjdSdjdNZmlENGVhbmNlSXo0ZHRkQThQNmdzYzl2WXRlTDVsdUdRTnMyTTIvSXljNUhINlZqR3RTcVN0SmFseXBTaXJubFB4RzhiM0hqWFZWa21qOG1GY1lVbkpPTzVybnRPa1dIVkkySDk0RGl0YTRXSFVyZFd5SThEQnJObnQxaks3ZjRlbnRYWGF5c2pFN3VFL2FQbTNNV1VZNFRibjJQOHEwb05DWFhMS1FUTnRSaHRaU1A1VmwvQ2Z3TDQrK0xtcHRiK0ZmRCtxZUlwb2NDVDdQYXRKSEY2YjM0VmYrQkVWNnhGK3g1OGNkSGpaZFErSG1vTERJQTI2Q2FDUm92cXF1VCtIV3VHcEJwN282bzFFMGZQdmlUVG9kSDFlZTNzejVxeFlCWjJ5V1BmSDBxbmMzamVRdTVXVXJuUHBYb043K3k5OFVMVzV1WnBmaC93Q01Ddm5NR2tHa1RzdWNrOVF1SzRqWE5OdWREdkpMTytzcml6dVlUdGVLZU14dWg5d2NFVjJ4a25zemx0M0trRXZtMkoyUnZOTklUOHFLV1lENkNzK1hTTDdHMDJWMnB4eG1Gcy95cjFYNFdhaHB1bCtGR1pySlpyckRzeDI4c1JuSDhnS3o3eWU4czdhUzd2bzd1MWlMWkJLc2lqUFFEaitWYzhzVmFUalk2b1libWp6WFAwUy80SjdhL3dEMjMrd1JvdWs2ZE10cnEyanJNczl2Qmg1NFMxektmbWpZWkJaVHVBSXdRM1gwcS9HL3dMRDhhL2hpdmdqeHhKTmVhajROdGhxNDFKR2pXT1VNNUVJblBIbEVvSDQzN25WbFlBWTUrSGYyYXZFM2l2US9GOC9pVFFMeldOSjBuVFFCZFMyek41bW9rYm5XMlZSbmN6ZVd4eDJDc2NnNEI1NzR4ZnRnZkVENHlhWmRhVHIyck10dE5lU1hOeXFSZVRMTXpOa3JJUmdzcTlsUEF4Z0FBQVY4N0xKYXNzVEtwVG1rMjcrYXU3LzhEZEgxVU0rcFJ3c2FOYW0ya3JlVXJMVDlIMS9FcWZGWFYvRDl6OFZ0Y2J3M0cwZWhtZkZzcFVLQ0FBTWdMMFVrRWdjOEhyV0xwMHFQZU8wcXVmTGlrY2JXQU9RallKOWdmMEJyQjA3ZmJIY3UxK09lZW9vMUcybFpGL2kzSGMyMC9sK1EvblgxVk9ITEZSdnNmRzFKYzBuTHViMzJlR0o1SkdrK1NLM2pDT3NaNVprREJCd09lVGtuakNuR2VBZER3TjQxMVg0UDY2dXBXY2NjczgxcXlMOXBqOHlFNStVT0Z5RmJCVTR6a1p6MXJqNU5VbWtiNS9tS2hWQkF4d0ZBSDZBVmViV0cxUzdXT1BjN2VVc1lUSEF3b0IvbG1uS0trclBZVVpOTzZQcHo0Ty90MytHNHR0djR1OEw2WHBWOXhqVXRQcy8zTW51MGFnc3A3L0prRS93clhDL3QwZkhEVGZqQjRqMEd3MEc5WFVOTjBtR1NkNTAzYlRMTHQrVUFnSDVVUmUzQmNqcURYbHVwYWxZYVdkb2dpbmwyS0hPMGJPQmpBSDllOVpFdXBXc2pib3JmeU9jZ3FlbjUvd0JNVTFwc0lxeXllWEQvQUJMZzFVRC9BTDVSMlpTTVZadTdocFpXWmd1M1BIRlZ0UVRjKzVWMjlPOVhFQnVBVy9FajZWTkV5cVNwSGJHYzBqT3NqcmpBM0RuNi93Q2MxRmREeTVQbGIwNTZVM3JvQk5NMjIzOWRwR2VPZ3pWRmwzZzQ0cTVJZjlHT2VtTUNtNlpBdjIxQnUzRE80ajlhY2RFQTBzMnlObSs4bzI5ZXRhMXFmdGkvWjBDN3BEa1ZGYzJuMmVQelB2SVRuNWs0ejZVYVZQSHl3QVhuK0hQNmVsVExVQ2Z6UE5ieVdYYkpFTUdybHBPeFJsYmNkdlQzckx2Ym5iZGZMbmR1emtuK2RYcmE0TWt1N3k5dTBBc1FhNWFrVWphTXJsaFpjM3VHRzNDNTVxZVhUWXB2bVV0SHpnbk5SVzdMZlhqRXI5MkliZTJSbi82OVhJaytUZHV4dGJKRllTWlJERkViWmxXRmZxM2JOYW5oeG1PdnhiMUg3eFh6N25ZMVpzUG1SeU15dU51Y2dDdERRSmpKNGl0ejk1Z3JaeC91R3Bsc3lxZnhJd1dnV1d4a2I3dlFZL0VVVllnaEl0cEpDckZWYkRGUm5IVC9BT3RSWFljL0t5OUdObG9jRGFwUFgwcWJ3anFEYVZyMGk3c0pQRUQxd0NRZi9yMVRqdlBPZ0czM3lLaG5IMmU5dFpsWTdOMjArcTVyUWs3elhiYUtmVDFrVnZOSTV5QjBOY0hxOGYybVZnZmw5SzdyUjc5RnMxU1JZMjQ3OGx2d3JsZkV0aVk3cGkwWDJjNTRCR00vaFFCaVd2NzYzOHR1eDVQcDFxZTBrVll0cWcrV3ZRZ2V4cXUwbmxySUEzWGtrZm9LTE5tekN1NC9VRC9QclFCZDgvY0ZQUHlxRG5HZW9GUjNsNTltc2QyQTB5bksvd0JhU1Z2SmhPRzlCMDlxenBwZDhqYy9MMEl6UUJjazFQejRGYmEzemNqMnFLZStReGJkdmJHNERwL25tcWNXNk9ReGRmTCs3eFRrbVVCaDFYMUo5Y1VBV3JlN1lXN0tuY2RTT29wdXp6MTh3TnRkV0hiclRJaUVEYmNaNHhUdDdlWVB6RkpnZWkvQWpXNGJEVnJ5R1NaSTJsVEtCdjRqMzVyNjQvWmwrRExmSGZ4RloyN09JYkd4a0U4OGc3anBqNjE4RXh5N1pCSXY3dVJEOTVUaXYwSS9ZSHZuOE5lSDdPNC90aWV4dDlVdGtrZ2ltV016M2k0SUxSZ0hKVlNEazR5TUhOZVpqSTh2dm5aaHZlOTFuM05vWGdqUmZEdWhSNlZwTVNXOEZxZDR3ZVdicmtuMXI1OThTZnM2K0gvaU40MzhWYXg0OHZJOVQxRU9rT21xNjdvN1JBQmh0blJpU1NQVHAxT01ldld2aU9hMmV6ZzA1WTlRdk5RT3lKWWpuZnhrazVPQUFNa250V3hwbjdPVnZjNnJKcTJzekRVTDZZZlBDT0xkUGJiL0FCZlZ1RDF3SzgrTlZ0KzRqMEpRVnRUODc5SC9BT0NVbW9mRjd4TmRYR2kzc1BoL3czSGRFVGFoZG96S1Y5SVloeTdjZ1lMS09velgxbjhNUCtDTEh3ZjhHK0dZVzFlejFQeFJxRWtZWnJpK3VwSWVjZnd4eEZWQTlqdUk5VFgxWDRZZTEweTJqaGlpaGpqakFWVkNqYW1LNlRUN2hkWm1aUTI2M2hISjJqNWlhMGVObnkyNWpKWVNLZDdIbkh3MStFbHI4Ti9EMGVrYVBiV21tYVRhS0VodDdXMlNGRkhzRkEvRTlUV2o0aThId2pUZk1ta1p0d3lQbU5lZ1IyMGM4TWpJdjNlZzlxeGZIV2tqemJlTTRVU1l3dWUvV3VHcE9iMWJPdUVZMnRZK2ZmRTF4cXZoelVGdEJDTHpURys4Rys4byt0Y0xkZUQvQUEvL0FNSk91clIyZW5YTjdCbFREZld5VHFBZTJHR1Y5Y2dnMTlSK0l2QTF2ZjIrMW94dUE3VjVSNDArRG4ydTVhYUNQeXJqR0E0SFB0bkhXczQxTGF4WkZTamM4MDhXK0hQQTNqS1cydkcweTEwWFd0TEpQa1JBd3gza2JjY0ZOdS9CSU8xdWd6MTZqd2Y0NytBZFcxU3prdFlmQytsNjVJbzh5SzNrK1NPNlhxTnBJWWJ2WTQ1NzE5WjZiNE51ckdNeDZycGNVeXA5MlNNYnZia2RSVjJYd2Q0WnNOWnRiUytYeWJ5OFhNYVJxZDQ2NEJ3ZS9wWGs0ekF6cVYvck1aYTZYV3RuYnJkYXJ6c2UvbGViZlZxUHNad1VsMGVsMWZ5YWFmelB6ZzhFZkgrMzhLM2QxWStLdkFPc2FYRlpwOW1oZ1NLYUZiRjg1bFlNQmpjMkV5U3YzWWtBNEdUUjhhK0EvaHIrMEJHMXhaNnZiMmVvZEZrZGtodVZKL2hKeCs5SCs4QWVPQ0svUmI0Zy9zczZacW1wcHFFVXl4WFNxQnUyS1dLLzNYL3Zmam4ycnlMeGYreTM5cmp2cnY4QXNIU2J4ZFBjQjdpWFQvSmhYZDBQbng4S2YrdWlEbnVlRFdGYXRPaEpWWTA1UmEyY0hmOEFDMTdkN251WVhHMDhURjBhczR5NXQxTlcrNXAyVDdXUGd6VWYrQ2RQam8yalhlZ1M2WDRqczErNzVFaGpuOWZtUmhoVDB5TThaRmNLUDJYdmlNM2lMK3l4NFMxWTNqZmRKai9kc1BhVDdoL0FtdjBLdHRNMVg0YlhWdkpkZUdkWjAyM2tLcXQzWVRMcU5xcW52bGRqSjE0eUN2ZkhHYTlLOGNEU0wzd0tOUzFDMjB2V0xkTnBXUmh0Y1AyVXN4R1FEeGpJSHFjOFY2T0Y0cXJ5aTByU2R0LytHUE14ZkN1RTlyRng1b3hiMVNzN2ZmdjVQVDBQeUw4VmZDVHhSNE52V3M5VTBHK2hsR00rWEg1cTVQdW1SK0dhNSs3Z3Z2REVvKzBXZDFadE11Vjg2Tm95NisyUU1qNlYrZ0hqbjRmYTFQcDk1cUdpNmkvaE9LQ1V1WG50bW1oVFBBemhVYVBHTWZ2QUJ4MzYxODgvdEdlQS9pbDRvOE9XOGQzWTJ2aVBSN2VYN1F1bzZVaHVaSm0ya1pmRE1Wd001Q2dMNms0cjNNc3p5V0lrbzFWRmZOcC9KTlcvRThMT09INmVGVGxTY3BMcG9tdm0wOVB1UEFvajlwUXNmbVBVa210bnd4OE9yenhmcHNsemIrVXNVTG1QTHNjc1FNbkg1MWt3Q1N4bWtoa2plR1NNbEhSMTJzcDc1RmR6OE5mSE5yNFgwMjR0cnRXRUVzZ2tqZFJuRFl3d3grRmU1aUpUVUwwOVdmTjBZdzU3Vk5qbXRjK0hXcWVHTGY3UmRSeC9aOXdHNVgzYy93Q2Y1VmszWGwzWWsyb3F5TDZlbGVtL0VUVm8vRW5oMUliZVhla2I3eXBibnBqcFhsME1TdnFiQXN5b296a0RucG5GR0hxU2xHOHR3cndqR1ZvN0RZbHhweXR0L2lLZy9nS2h1UG1HMC84QTF6Vmk0bHhDa1NrN1l5U2VPNS95S2p1dVZIdHpXNjN1WWxjcmlNTDcxWTBlRURVSTI2Zk1CK2RSSDVVM0RCYWlFNGxITlh6WFFHcnE4bjJPRVE1Vm1iUEEvbldZWXBGZjVUeGptcFk5MXhPVzNibXp4L1Nyc25oWFVIdUJHSUdhUmxMN2M4cUI2MUhOWUxObEFRN3B3TnhiSjYxYlc0WU54M0dUN1V5M0xvU3U0bVhQUURrSHZVMFVlNTFMTDk3MHJLbys1ckRZMHRQQWQxeG5sZno1RlhwSWxpWWZlMnZ3ZU04MVN0SVBLbVZmdTVCeHhXaTBqSGJ1L0N1V1c1WkRQT3NRWDVzYmZhdlZQaHo4QjJ2ZjdKdUwyU2RiKzhYelRhSmdHR000MkZ1RHl3K2JIR0FSK0hHL0Mvd3gvd0FKejhSOUxzM2plNGhXUVRUcDJaRStZci93STRYNnNLK3J2QVdsM21tZUpiMldTMWhlU0ZCTkk2bkxTazd0cUlPQW95dmM5TWV2SEhpYXJpdVdKMFVZSis4ejUrK1B1aHgvQ0x3NVA0WDArMyt6bmZDOXhPNEJrdWkzejdzNDllTWNZd2Z4SzZUOXVvUGVhVjRkMVNXTDdMZlhjV0pvTjI3YnRKeCtlNC9sUlhWZ1hlbGQ3bU9Jc3AyUEd0VmdVNlZ2QzdaRllZT1B6cksxSWcyc2NpOThFajB4MXJYMHZVVzFPd1JXQStiY0hYc0R4V2JyMXQ5Z3N6SHpuT2ZwWG9MWTVUU2gxUDdFVWRXVm0yZ2crbFU5YjFJVGw1cEc4dzdTTW5yL0FQcXJQa3YvQU55a2ZPNkZjTGtkUjFxaExJemx3VHVMREIvclFBa01xcnkzSWJKeUQwcWEzbWlpZmZ1VlczWUtrOGdmNU5aY2x1R0czY1J6ZzRxMVl4ckg5NVJ1emtrODUrbitlMUFGdTl2RkZuL2ZabVBJSFQyOUt5MnVHa1p0bytaam44SzAza2pkbFNSa1dOT1diYjM5L3dEUHBWZXg4dHJqYVlWYUtWaUkyUHQvWC9HbEtWbGNxTWJsV0NPUkpPU3lucWM5VFV5emIyMnF2M2ZYcDdmblRMMkg3UGM3VDl5VDdqWis3N1ZIY3U4TW45N2NQdkE1QnB4ZDFkRXROT3pMTU9VeTJGSzg4NXAzbWJobGZxYXB3eWI0eDllYW1Fbm5IZ1l4MXgwcFdBc1FUc1grYjlhOXcvWnIvYlQ4YWZzNGFUSmE2T3VrNmxab2MyOGVwVzVtYXkzSExpRmxZRlF4T1N1U3VjbkdTYytIMmtSa2tHN08zcm1ycjNna2dTT1BjcUtQKytxaWNVOUdWR1RUdWo5WS93RGdrMSswQjRWK00ybmFoWXNEYWVPTEdKcExxQ1o4dGNSUElXZVNEbkJRTVZCVUFGUUY2am12dGk3MC93QW8rWDJZY01CaXY1N3ZnWDhaZFcrQW54WjBIeGRvc2pSNmhvZDB0eWdaanRsWG84YlkvaGRTVkk3aGpYNzEvczUvSHJ3NyswLzhLN2Z4WDRadm83eXhiRWM4SitXZXhsd0NZcEY2aGhrYzlDT1JrVjQyTW8reWZOSFk5UENWT2ZTVzU1cDRsOGI2L3dDRFBqUmI2YmNSQlBEK3BSbERlQlR0U1hQeWJ1eXQxSG9mWTlmYzlFdll0TTB4UkUyWkNNRURyV1g0dzB6UzliczdtMTFEeS8zeWRHWEpiNlk2MTVKNEIrTDAvZ2J4MDNoSHhJWm9vMU9OSDFLWldXTzlUL25rekgrTlFRQVR5UVBVYytMS0xUdEU5UG0wMVBvV1BWUHNWbkN6SDUyQUdPNU5WL0VNYmF0YVJ5bG04eUU1QytsY3pjK0tCQzBjMGJDU2RSKzdCK1pSNzFYMC93QVh6YnBvK0pwcERsOEVZU2gzUzFEUjdIU0M1WXFFa2JiSUYzSG50VmNRMjkxTDgyMW02ZGptczNVYmlPTzJqdURJV20valhPZUtmYmFZTG0yam04MlNJdDBVanIrRmMvTjBScHk5V2JmL0FBaTFycU1ROHdzKzRZd1IwclAxcndCYXNJMzJLN1JOaGZsK1lINjFmMCsvYXlpWlQrODc3dDJDS3NXSDJyWGI5YmVDTHpwSHpoUXc2ZHlmUWZXcTFlaUoyMVBQL0ZXbkpGcDh2M2wyL01PT2xhWDdOUVRWTk0xWkx5UjRkdDR1SFB5NEhsL3FmYjNydjlTK0YwT2wyRFhXb3JMZFJ4amNVamZ5SVNmUm5Qekg2QUE0NlpyS3N0RDhTNnZjeHF1cVA0ZDBDTlAzVnBwa2ZrelRIMFVuN283bDJCSi91amsxNk5HbEtMdkk1cWxSTldSa2F6K3p0cFBpZzNETmEzMXZkM0JLcGRXUmUyQ2NFYmlQOVd4SUorOHJmcFh4L3dEdGpmQ3VUNFQ2S0gwdlVwYnF4anV5ejI3M0c1bWNjRjkyY0hJR04yT2h4Z2dqSDNJL2dxRzRTYWVXOHVJN1dGV1o3bTh2SkxqSUF5MjdMQk5veHlUbGV1Unh4NVBKOFlGOFltZUx3TG8ydGFwWXdTTkVOVnZieUxUOU1rWUVndEVnakxPdlhCVk1IMXFjUmc4Tk5OMUlyWHIxT25DNWhpNk1sS2pONmZkOXg4UCtCL0VPbi9FalJvOUgwTFdaTFhWTFJjbTB0WEVkemJIb2ZLeXdVb1NEbEpBcWtad1JuQXRlSi9oMXIrbGF0NWE2ZXFpM1EzRjlmZUg1YmUxbmpRZzVFdHZNU0Y0R1RzQnpucTNTdnBUNHlmcyszUHhjdC9PMXpUL0JON2RyR1Nzc21qeE5NcmY3TndGRW8rb09hOG4rRnY3RS9oZXd1NysvOFpXZHFOV2p2MGJUNDRiNmJFRU1lQ0Q1dkJabWZjZm1KSUFVY1Z3eHkraWx2ZGRtci81SGRMT0s4bnpOV2ZkTzMrZjRIekQ4VFA4QWdubjR3L2FadmJyeHBvMnUyRnhZejdZTk8vdENDTzJtdUlrSE8veUZJREI5dzVYUEF5YThEOGMvc1MvRkR3RHFNZHZlZUVkU3VsTW14SmJCQmRvZmY5M2txUDhBZUFyOW5yL1hQN1JUaFl2SzZnS1FWK29ybDliMVdLM0R2OHFzdlE0cjNNTGpuRktDU3N0RDUzRllkU2s1dDZzL0lmeHA4STdqUTVHanVyYTgweTlKL3dCVlBHMFcvbjBZZnlyeXkvc1JiWGttM0JLbnFLL1dyNHMrRnRHK0tPbHoyRjFEYjcyKzh6WTIvd0NSWHg5OGF2MkRMTzQxR1NidzFxRFc4aE9Ham1Ka2hiOGZ2TCtvOXE3TUxXNVhhYjBPZkVSVWt1V05tZkpjOFdUL0FKRlF5UThmNTVyMDd4Vit5cjQ0OEtsbWJUWXIxRjZtMm1WdjBiQlA0Q3ZQcjdTNzJ3MUpiRzRzN3ExdkpHQ0NLV014c1NUZ2NHdlNoVWkvaFp4dUxXNG5oand0TjRtdUdVTXNFTVl5MHpnN005bEI5ZWVsYjNpTHcxWlI2T1Z0NEZndXJRN1grYkpmanFmcitsYWpDUHdyb0s2ZmJ5T3p2bjdWRktBUjVoVVpJOXNqajJySGhTUzRXUWVaekpINWU1am5IR0tYTTM2R25MWkdQNE90dk44VGFmR2krWnVuVXVBUDRRY244c1pydVBFRVRuVkkyaEgzV0p5RDBHT2xOK0NmaDVyQkx2VXJxRUw1Z01OdXpEcmpPNGoyeUFQd05hV3QzS3BjS3dIOFBOWlNxM3FjcUtqRzBMbkIrSmJIeTdpT1pZMWpmT0pNZFRucFRkSGdXU1F0eGhlY0N0UHhyZWlGbzAyL2ZHNC9oMHFwcGNEUldhdDkweW5melZWSDdobXZpMEp3NnNZeC9FY2o2MDl6NWNmcDJIclVGeGlDNWpZSHB6ZzE3SCt6ZCt6RHFIeFQxQzExZlZJV2cwR09UOTNHK1ExK1J6Z2VpZXJlblR1Unh6a29ybVp0R0xrN0k3TDlsMzRiSHdoNElsOFMzMExMZGFvQ1lUczVndHdDUTNybHVTTzJBcDlLOWFsMXBVMExVWm1XT0hhUkVUNVpPRjh0ZHVRdkpBM2RQU3V3MVR3cmI2Zm9VTVB5bEN5Z29SdEFQcng5R09PL1N1WHVkT2pmUTlGaGhoa2IrMHB6NW01U3JNaXFUbGhrZEVBNjV6anBrMTVia3B5Y3BIWnl1S3NqNWwvYnB2SkxmeEJvdGh1Vmt0YkpUaEJ0VUhMRGdkaHdlT2FLNTM5cC93QVF0NHcrSytwQ1NURWRuSWJhUGI2SVNQMUlKL0dpdmN3a2VXa2t6Z3JhenVjcm9jcXhSS3E5V2ZIVHIwbzhieVJtMUtyekkwZ1ZpRDF3T240Y1ZRMHE1K3h6bDkyZG1Tbzk2bXZSc2hpbms0RVl5b1BWbko2L2gvUVYxR0JRMU9MeTI4bVRKdUFCZ2RsR0J3ZmVzOG55SW1adXBPMFZhdlpXamRYWmptWWs1SjdmNUpxamN6a25PTURuSHRRQTFjcDh5L2U3MUxiWEc1bE9GM0w2ZDZveVhRamo2Y2tqUEZKYjNKRW42YzVwOHJ0Y0M1ZlQrWkRzWEh6TnU2ZEIycXVwWlJHUVZWb3lDQVRqUCtjVXlXVlM3ZFBsR09lMU1YYXpIZUMyNEVaRGQ2ZkxwcUMzTk8vZysyUEdINFhkemlxZ2JCOGxoMzZFZGEwTEdNNmhZb2M4N2NiaDZqamo4TVZrM2MyNjZiOTRDRTRISEpyR2plemoyTktuY2RLRlIxWG90VElkanEzeXJ6ejdWVzgvZjh2M2x4MHhTTFA1ZWRwSUI2Y1Z0WXpMcXp0SDhweWQyUWNWUERNQXUzMUdQd3JOaXUyK1lLdWVNblBPS3NDOFh5bGJidDlTS21VZTRHa3NwK1lqYjA0NHI2Ti80SmsvdGU2bCt6Siswam84alRTdDRkOFJUUjZWckZwNW0yT1NLUmdxeTQ2YjQySVlIcmdNTWdNYStZb2JzT200Tjc5ZW5OWHJDNjJQdlplRkhyMXJPcFRVb3VNdGlvU2NaS1NQNlV0RkduK0k0Qk5iTkhlUnFjYjRzT0JWWHhSNEwwdnhEWkczdkxOTHFHUVlLU3hoZ2EvbmYrSDN4UjFyNForTUxLOHM3NjZodXRMdm9ycUhFckJkOGJCbFBCSG9COUsvWDc0R2Y4RlQ3SDRoYS9aNmY0ZzBtRFM1TDUvTCsyMjhwZTNSai9lUmh1VmZVN214bnB4WHkrWVU0NGFTNW5vLzBQb3NEejRsTndXM1M1N2xxL3d4dk5NajhuU3JxUzFoVWNSeVlrQ2oyenorcHJqcDlHOFRlRzd1UmQxcmR3ek44enFURzQ5ZUNPZndOZGI0aC9haDhMK0hiYVI1dGMwVmZMNm9zMjVzL1FBbXVWOEpmdEllRi9pM2Z5UTZUY0VYZHFOOG9hTW9yRE9PTTR5SzUzRlNSVjFleU9pMHJ4QlphVHBRV2FSbXVNRGR2UmxBNDV4a0RQNFpyb1BEZmpDd3VydmRIZFcwMC8zakdKQjVtQjFPM3J4WE5hck5iM3ZPRWFSVjNFSUFDd0hvZnhyemJYcDRibldKSTdXNCswTXJxeTZkZitaQTc1R1FiZVhnQnh5ZU4yQm5JSFdzL1lKYUl0MUhiVStrb1BGOXBmc3ltT0JtQjVIM1F3cjByd2ZwVm40YzAzeklZNDB1SmxFazdMengvZEh0blAxNjE4US9ERDlwZnczNFYxK08zOFUzTnhhYVA5dCt5dHFFMFo4eTFsNS9jWElHU3VUakVnNElZOXhrL1dtaytKWVBIRUc3VDcrejFDeHV1SVpiYVFTUmlMUE9HQk9UZy9yWFhoWU9MNXBIUFdsZlJIVVhNMy9DUXN0ekovcnBNaTNMRGNzTWZJREJUeGs4SFB1QldSNGp0RnVrRWswbTJHUmxpU1BuT3hjOFp6eDB5YWJyMTIxbGVydE8yUFoxQTRHQ1JYbmY3U3Z4dTAvNFAvQmZYdGF1cnlJM2tOaEtsbkZrWjNzdTNjUitJcnJuTFRVeWpIVTRUeGY4UTQvMmxQaWhxM2hPM21hSDRlK0R4RkRxeXcvTC9ibDhmbVcyTEQvbGpFdUN5akFKSzU5dWd2emEyTUVjTnVzTU1NS2hJNDBUYXNZQTRBQTlLOEovWkw4VjIyaGZCSFNWV1pHdk5VMzZwZXk1M05QUE9kN01UM3dNTC93R3RQeDU4YjRmRDI0eWJtQ2s1STdWNDFXcEtjN0hmYU1JNk03L0FGN1hGdGxiTTRabHozNkQ2VjUvNHA4Zkx2YVB5NDM1KzlYa3ZpZjlwYUs3THRiN2lCMTU3MXcrb2ZIaTQxTzdhT05adHZ1cE9LNmFkSm5IVXJYMlBVTlIxcStpbm5hRy92TFdHUTdpa1V6S3Yxd0s0dlZ2aWJyZmh6VS9NbWtYVkxUcEpISzJISDBJSFg2NXFsYWVMTGU5dHovcFRSdVI4MjQvMHJBMW1WWXc3TGNMTXJFRTVQZXUySzduSnpNMXZGSHhqdDliRFJRcDViQWN4c1FqVnpKMWUvakRQOWwvZHQwK2JkVk82anM1OHRNSTNiR09sYy9ybHhhMnpzWVhlSDBLT1Z4K1ZhNkUzTks5OFN6Zk1KWTJBeDNIeTE1eDhaTDNUYjNRSlBPczRwcmpQN3JLZzdIN01EMngxejdDcmVwZUlieUIyMjNheXI2U2pQOEFMRmNyNHp1bTFmVHk4M2xoMEdRRUJBNSt1YTBodmN6bEs1NVA0azB3UlhwbERHUnBzTVMzWStnck5odHpKZHJIR04wa2pCVkFIVW5pdG54SGNaa0tqa1Jpbi9EV3ppbTFXNnVaRytlMmlBalUrcmNFL2dCK3Rlbno4c09abWZMZVZqb2RkWk5OMG1PS0hDcmF4QlY5eVA2MXlNZDAwZzNQOHhISkpyZDhTNmdyS1J5MjQ4KzljbnFLeVhGdkpicEo1VFNuR2U0ckxDeGFqZG1sYVdwei9pVFUvd0MxdFhiRFpXTWJGOURYVGVEZkJ0MzRzTzJQZEhER3YzMkdCZ2Rmd0ZVZkJQd3l2TlIxVldhTnBvaklFVUlQOVlUMkg5ZlN2ZUxQU0xId1pvREc0MjdiVk16T0crU1E0eHN3UDRSNmY0NHBZcXNsYU1UT2pUYjFaNUhvSGhyUjdEeHJhcjRnMUtPUFM0WmQwNGlINzExSDhJQjQ1UEdRZTlmWVB3OC9hNytHZW1lRmJDM09xTmFmWTBZRlRiUDhwT1J4dFVxT1BROURpdmpEeHhialVaWHZwaDVUTndrSGw4NFBPV3gwUFBUdDA2am5CdW83aHd4VzFNaTU0d20zSDEvQ29saEZXaXVaczBqV2ROKzZqN1U4ZWZ0bmVDdFVzbXRiVFVEY1JpUm1MZVV3QnlEbGNFY2puSDByUzhGZnRCK0R2RW1qYWJidzZ0YXlhaGEyNGpWWk1SdWpGUXI0eUJucDI0OXErRVh1ZG84dG9vMVZlb1VjL3dCS2hqZGcrNWZNVnNaQkdhbit5NFdzbXlmcmtyM2FPMitOT25OcFB4SjFpTDd4KzB1VlkveGduZy9pT2FLNXU4OFNOcVVaYlVIbG1aRkNLNWJMOFl3TW50ak5GZDBJdFJzem5rMDNjWklmSmpDL2VPY2svcFVPcWFrOTY0VjI0SEFIb0tsbFh6SU92ZXMyY2xIL0FMM1d0ak1sMUdUejdrc1BsamhVSWdxaFBLWkVSZDNZZzFlY3N0a0daV0c3N3BJNFArUlZDNEEzWUNqNjFVZHdLa3JiZ3ZQL0FOZWtoTzU4SGdLTzFKS0R1cHl4R0ZOdjhSNjhkUDhBUDlLMkFkakF5M3paYkhYa1UwUHQydG51RDJwVS9lN2w5OG5IU29KQnRMZW1ld29BM05FdVd0aExia3F4amZPUWVvSXJQOFF4R0srWmxHSTVDV1hqaW5hTmVyRmRLcTVWcEJzUFBROWpXaHJWZ0xuU3ZtT1pJdVFmclhLL2NxMzdtM3hRTVd6azhzN2p1eG5vS3RSU3RKQVcrOHk4c0c3VlJ0bHlRdWZteUJVaG1iek9yRHRYUTQzTVFqTGJ6SDgzekhHS2RjU3lNRlhjZG9HQnhqSGVuTXJFcnRHTnc2a2MwMVZZSnZIemJEam4vUDRWUUZxSzIzUmpIeThjRS9kWTFidEo1THA0WWM4OGtub0Z3TzUveHFnYmt5UmNyOTc3dm9QU25mYUJFRzZydDQ0enpuakdNL3JXTmdOaTFrYWJXb2R6WjN0bGp5ZHZyWHJYd3g4ZlM2ZjRwc04xeVpQTGtEY2M1d2U5ZVErSHRpRnBBemVidHdBNVA1ZzVyWTBtOWFPK2prVnRyRExsd2VNZDY4L0hZV05lRGcreDZHQ3hNcUUxT0ord243S2Z3QitHL3dBY2ZnN0RxM2pidzlwTjlkWGx3MzJhZWN2SEpQRW9DNUpWaGtiZ1FNK2g3WXIwRFJQMkcvaFA0TzFmKzB2Q2RyL3dqK3Bidmttc3RVbjJuL1phTjVHalpmWXI5TWNHdnlNK0RuL0JRWDRrZkEvVDV0TjBYV29aZE1rbk1xMmwzQ3R4SENUMTJGdVZCNDRCeG5udlh2dmdmL2dzUlBjNlB0OFNlRzR2dGtaSTh5d21aRWtIKzQyN0Rmano3VitXNDdodlBzUEp5dzB1YU45RkdUVFM4MDNiOHo3S2xubVdZaDNyUjVYNXhWdnZXcDkrZU5QaHQ0KzBxZUZkSnRkRjFXelU1a2xGNUphekVjWUlUWXlrOGYzeG12TmZGdGw0ZzhNYXVScjEzRzNoMjRQK2s2WnF0djVjOERFNDNXdHhGa1B6aks0Y2pJd1FlSzhIOEgvOEZPUERmaVpXYVA4QXRDems2dkZ4dUErblZ2cml1bzAzL2dvOW85czNsMi9pdlZMUEIrNndsQUg0Y2cxbkhNczR3ODNIRVVHL2xyOTYwL0FyNnBnS3NiMGFuNC81L3dDWjFuN1VId0s4VGZFL1FKdkQraTZMcmw1cnYyUWkydm10dkxqZEZkQXNGNU14V04xQUxNQ3BkL2w5ZVc5YS9aRnZOTi9aTThEdytHOWI4YzJWOUpEQ2t6Ulg5aEpZWEtTRUFNaTczSWtIYkl3U1FNQTlhOERQL0JRbDdxTm5oOFlXN3F4enNZSUdKOXdRRFhPYXovd1VKMXFCWkpMZlZJWnR2SzRYNzMvZk5kRkRpTE1PYTBxR256VHY2Nm1OVEtjTHVwNi9KbjNONHUvYXU4TytJdE1oc2ZDZDh2aUhXcjV2TGdoMC9lK3dkMmtsYjVJd08rVG5CUEhGZkxuN2JmZ254SjR4OEIzUjEvWGRMdElaQWZzMW5wUm4xRzZ2bUdSaDNLb1JqMENrYysxZk52aW4vZ29ENGpudnJpU0JZWVhuQjgxcmVlVzM4M3RsZ2pxQ2UyVHpYTjNQN2MzaWUwMFpkUHRyaFliV0ljS1ZFNGp6eWNHUU1ldVRqUFVtdnBzUGpKMUxPZE54ZnlmOWZjZVhXd3FqZmxrbitIOWZlUytEL2pCOFFQaFA1SGgvK3hkVmtaSWpMYlJ0dFZoRG51Q1FlTncvL1ZWYnhOKzBuNHN1SkN0OXAycVFyem45eXNtUCsrV05jSHEveHh1N3ZYNU5ZM1RUYWhJcklKMmNzVVE0SkNybmFvNEhRRG9LeWRSK0tzbDQ2eVROY01lckVnWUp6VzBxbFJ6OXlDNWZ4dVpMRHg1YnlscitCMzMvQUExWHFHbTJwaFdLNFFyMUJ0R1V0K09PYTV1Ni9iRDFEU0xyY3R2Tkl2VXFZeUFQenJtcFBpQkhNZnZOdTlHU294NGxzN29mdnZMYmpvYTZxZFMyOU4vZi93QUF3bFFYU2FPcHR2MjBJNzI4aisxUWJjbjVzcGpGZWlhTjhkOUI4UTJTK1U4YXpZenRidlhndW9XR2thanVCamlYUDkwaXNWdEhYVHBkdG5jTXE1eUZibkgrRmRrZlpUV2wwemxsVG5Ic3o2UTFmNGsyY0NaMmhjajd3YmFCWEo2dDhRTGVVTTYzU3F2cHV5VFhqdjJyVmtVNWo4NlAybTZmaFdmZi93QnBYUlhaRERDdlFra25INlZ0SERSNnlNSlNmWTlTMUh4cEhOSHVqbVlCVGpJNmZsV2RxL2pxMWtzSDh1WnBKQndVSXhtdk9MK0RWRW1XT0thUEk2K1d1N05aclE2cEZNeGFSbjlBNjlhNkk0ZUM2a1hPNTFXMlcrMDFybGYxckYwKzQvc3dQTXNubGNZWTlPRC9BUHFxakQ0Nmtpc1JieTJ6ZktPY2ZkT0t6TlExeVhWSVdpampWSTIrOW10NHgwc3liNjNPcm0xRnIyMytZN2lPY2c5YzFTMGZUUnJtcWpjWkRCQ2QwcFFmTWM5Rkh1VHgrWjdWeitsV0YxZFR4MnRzc20rUnNLb2NqNmsvcWM5cStndmhIOE1vOUIwT0MrdVk5ckw4OENzY0YySTVsYjY4QlFlZ0hja0d1ZkVWbzBvMk5JUmMyV1BDMmlMNEY4T1RYMXdrYVR4eGViTXhIeTJrZlFSci93Qk5HSkM0SGNuME5ZZmpEVzRBWS9PWE1Jd0k0RjVhVitNY0hyejNQR2ZVREZibnhJdld2YjZHRlZXUFI3V1FNa0tFTkpkeTRPQzM5NGpIQTZEbjYxNWI0ejhUVFdHcEZZViswYTFkS1JzVS9KYXIyQStuUE5lZlRpNmtyblJKOGlzVi9GUGlHeXNMZHJXUlpMN1VyNWlQS1g3aTQ5Q2VnQnp6alBCNXprMXhsN05pV1dOeGFqcjJMbGZ4emcvbFZ2VjRCNGNnWnBaZnRHb1hRL2V5RS9kSFRBL2xXU0lmTStadHBQNml2WHBwUldoeVNpNWJraUNQY0dCM2hlcHgxcVJyaUlTL0t2emZXbXBiUm1KdDJTTytEVm0wMGFHTzRYNWZtWThGdWNVU3FXRjdPSkhITjV2K3JoVU5qN3c1UDRab3JiZXlqYURidDJrY1pXaXNmYU0wakJkRVlseE9CYnFxL3dCNG1xMG5NZzZkT2F0T0kyM0Z0ek4wQUE0RlVYbDNNYTdEakprbXhDc1pKSVVZSHNPYXB6cVFGM0Viai9LcDB5eWZMbmNRZjVWV2QyVjFadnU5ajdWVWRRSzd4L2VmZHptZzdneXVTdVdPYzFZdGxNaXpJNk1XMjdzQTlCMTVxaTBVZ0xaNVZoMXJSQVRSL3VwL3ZLZWVCNjAwcHNIK3IrYmxlVDE1cHBHQzJkM2M5T25GUnlqa2Z4Y0FtcUFrRVJTUE1mM1RnNFBVRWY4QTY2M0xtZmZhR2JQeXVEa1p3T2F3NExjdmdCOXU0YnVoN1ZwMnNUSFRGUi85WHl1UU9RYzF6NGhhSm10SjYyTXU1VFkrNzVsM1pKL00weFgzS0dYazFvYWxBcXBFMzNlQ0ZJNXpqLzhBWFZFeEQ3d1Fzbzl6VzBKWGpjaVNzeDMycGd2QjlzWi96eFNqNUZaaVJqakl6bmcxQW84MlVnQnNaT0I2Q3JEb3MwalpYQ3IwOXFva2R0TXJLM0hsNHg3Vkkwb0g5N25CNTlPS2hTTEVEREtoQjZIbi9QRk9RcVZZTTdmTU1ZQzR6ajFxYklEWWp2STVFV2FIajVTcEJIWWRCVElkV2tTMWNiVldSK3BJN0h0ai9QV3FjWSt6eTd2dW5vd0lBMjl2OGFWNTFabVZsMmJ4ajZEL0FQWFdLaFlxVHVRRzczbmtCaWVwenorZFRpYVcyakRMaGxiNVRodDJHOS8xcXJCRDltbWZheXNudi9QRlMzOGkyM2w3WkZrM0huSFRqcFduS3JrbXJwZXJ5V0VrZDFEOGswSTNBK2h5TWQ2OVMxaFYxbXdoMUMzRnVmTWpWajVSQlhkamtERmVMK2F4a1ZXK1ZRdk9EejNyb3ZDWGlxNDBlMzhrUEp0M2ZNclo1L3ppdURHNFp6U25IZGZrZG1EcmNrbW4xTzBtdk44QUxZRzBaK3Z0WE42eHlITWJNcHoyT01WZm12dlB0MW1qYmhzN3M5ajlLenRSbitWdU1sQjI5YTRxTlBsT3F0VWJNZGRVdWxSU2x4S3Z5NU9IUEZXTFB4QnFNSlV6WE1rbVJuSFhQMXpWR1ZFRXJMOXc0M2NIcUtUWXJRcHVrWTdod0YrZy93QS9oWGR5UmEyT2Zta3RtZEczaUhVSm9COHpGT3dJWCtsVlo5ZHVvMUdWaGZqbjVRUDVWUXRaMmdnWk5yS3JFaFQzUDRmalV0dkJ2TE0zM2VDU1JXZnNvcm9QMmtuMUxsdHFsMU12K3BpNDdZTlU5UThiZllwTnF3bVQxWWNjKzFWdnRwUzNrZGVHTGJPRDB6VlNkSTNoYUxLdXpjbmpwV2thYXZxaE9VdTVxUS9FQlpFNWhreDNJUEpxYTI4WldieUhmSE1kM0hBQnJtVHBvdGp1WiszQUF6aXJHbDZXOHR3UEwrWmowN0FlK2EwbFRodWllWnZjNmhmRXRyRjkxWkY2NUxBWkhQMXFFK003T1dOZHp2bk9COHZINkgvT0t5bFZyU1dRU2NxZU9sSWxpdHl6REVaallaeDZHb1VJOVExT2trMUdDUm9wb1M1RERkMFA1ZjFweDEySno5NHJ6MUk0RllXblMrVlp4cTdmTkVTdVBidCtkSTB5U0RkdUcwbjBwY3ZZVmpjRjdwY3JqemJpRnZmWTFTUlhHa3pYZmxXdTI1bWs0VlVoSk9hcmVCUGhwclh4TzFGYmZSYk15amR0ZVkvTEVnNzVQZkE1T00xOU8vQ1g5bXJSZmc1WmZiYndwZjZvVXk4c2dHMUc5QU93SDF6K09LNDhWaWFkSldiZCt5TjZORnoyMjduTC9DUDROdnAxdjl2dmJYbVFMdGhkQW9QKzAzZkdlZzZzUjZjVnRlTDllVzFtYU9FczNPMWdHMmdudVB3N2tjQW5BeWE2TFZmRThja3MwY2ZtYkZCWm5QQTRHT3ZiL0QwR2NlRy9GcjR2TWwyMms2YXkzbDFNTmg4dGVQcDlQYittUWZOcFJuV21kRStXbkV3L2lUNHZtc0xxSzF0ZGt0NUxuWXNiZmRVbjh3TTUvd0I3QXh4aXNpMXRGOE0yRTAxd2ZPdkp2bnVKdDNMZjdJL0grVldkTjBaUERTeVhsNDVtMUtiTFRTc2Z1ZXdyamZGL2lKdFptMnF6ZVdwOWZ2VjdOR0thNVk3ZCs1eHp1bmQ3L2wvd1NHNXZqckdwdk5LZXJkQWVncDZsa2taVmliYmpIU3Fla09wdUdDcVd5TWZMMUZhcGxJaCthWlZiT01COGRmYXVtV21oSlZ0b3R6WVpkcmNqbi9QZXRLSXJGS201aDgzT00vblZlM3R6S2MvNnhjWk9NRTFkdGJHSzRsMnZhYzllWGIvNHFzNVNYVUMzRmM3V3g4cXJnYzRvcHQxcFVTamFQTVVLY1lFaDQ5dWMwVmpvVXBOSFArYzBmNTVvdTdieWhISU9WZmo2RVV6NzdlK2VCVnViNTdIYTJPT25QSU5lZ2NKVmhKVnd5amtlbFZaYmZ6QjgyUW5QRldFTzJISVk3czFCY3llWGhjTXpZSlB0VFYrZ0VFYnZENW1lQzRJQTYxQUhiZnl3L3dBS2xHWlhIYk5WczVibjhLMVFFOGpNRTZlMk1kcWpqTEErdTNucFRvNUF3L0h2VDVjT3VCMTY0SFFqTlVBLytKZjd1TWM5cTJiUVIyMXBoU0c1enlNVmlRYmxYY3k3bHo2WU9hdldpN2JVU011OVdPM0o3Y2V2NGY1NlZoV2plTmlxYnRJcVhCWnRpY3NWeXdDL3duZzFBMGthN2xYY3E0R01jL1dyVTFpeEJiK0hCWmY0VHQ1NmY1NzFWbVhaNVorWXQxOTgxZFA0UW51T2lqMnlaR1dUbkhISXAxME1zcHl2WEhXbk1yYjhxdXdZM0hJNHBueTRZdnUrOXVCUGY4cXJyY2tSUzdMdDIrdVB6NC96NzAwS0RHSGJnK3c2aXBIdUkvTVZseHRBQUxmZVA0VTFtTXlLY2tiODRIVDhjL25SeWdPaGtLZk1HS2xobkk0elViTXcyc3JMN2c0RkF1TWhGWnR5NE9QOC9uVUlWYmVadDN6ZXUza1VjdmNDWlZ3cExmS2M4bjBwOGpiL0FDeWkvTjk0ZzlLTG02TTF2bFZZNVBwNlZIRk8waXJIaFZCSkp4d2FhQVZ4dm41eDVtN0FQWVZhdDlRWkdVN1R1WWtsaWUvMXFxSFVqL1YvTnllZWVlZzRxUVREdi9DZVNGOVFCL2pRd09tMEhVSlhpa2ozQlZBempHYWt2THhraUVpN1N5bnFSbnY2VlQ4S3pNZ2szYmwzS01FRGdENjQrbFdidTRqaWliYnVmSXdEdEl4enpYbVRqYWVpT3lNMjBqTTFDNWtsRzcrOE1ydE9BZTlSYWZjelN4Y2VXRkI0eWVSVnVEYjVwM2JZMjI0d1V6L250UkZNSVpOc2VKR0p6MHdNZjU1clRwWkFMRXdjSGRzWUR0My9BQ29uY29tNVpQa1VFQWUvcGp2Vis2c3ZMUWZLcXZJM1QwenlNMVhPN2J0bVJReXR4a1pINFZOd0t1czJvdDdCY2ZMSXpqY1FQYi82MVo2c1doWEc3SVA5M05hV29ocDdSbi9oVmh1T1B3OWFwR3ozcjF3TTVQSGF0S2Uyb0VwRy9BMmpnWTY5QjAveUtudEVhSm5SbFZlaEcxczkvU3FEbFVpTE16SGpPQjYxYTA5TmhadU9nSjU2VVMyQWZxRU1rMXhIS1dPSk9DQ2M4ai9JcEMzbHlzdTdhM3BqSFNwTDBNOW1wWG41bDQ2NXFGN1ZtdU4zVG5rbjN6VXJWYWdTM00yM1Bvb3dEWHVmdzkvWkdzcnZVTE9YVXI2Uzc0VjJnZGZKak9lMkFTellPUnRKUW5IcnhYZzBjVW1vM01kdkRHODBzcmJRcWpsalgxbnAvajdUOUIwaTF0N3k0TUsyc1lqU0x5Z0ZFWVViaXVUdWNIUFZodDR5RkhTdUxHVG5GSlFlck42TVk3eU93MG0xdGZCdG10cmJMQmF3cTVnUklCdExxT21jRG9NSGhjNDRPUmdpdVQrSS93QVVMSFNMR1l6bFhXSVpFWG1iWVkrMlhZZTNZWnowR1FjVjU3NDgrTzEvcTk4MW40YXQ1cjBTRmdxMmhaa0FQVHpKczRKNzRCeDlPbGNyWmZCblVOYkp2dkZkNThxbmNMT0Yva1RQOTV4eDZjTG5wMXJ6L3E4SWU5WGR2THEva2RIUE9mdTAxL2tSK0l2aTNyWHhIdXBMSFFXa0ZybkUxMjY3WTQvOTMrbmZ2Z0hOVGVGZkFNSGhLeGU0bXVBWm0rYVc0ays4M3NQN285NnRYV3U2Wm9LZjJmcFl0NXBiY0Vxa1oyeHhEMVBwOWVTYTQ3eHY0aGsxTzMrenpYRzVXSWY1QjhneDZpdXVQUFVYSkJjc2Z4WkhMVHArOU44MHZ3S1BqWHhXUEVHb3lXOXMzK2pvM0xBZmYrbnRXRGRhUThsdnVqNUZhZGdzSStaRmhhUTlGSis5OVBmMnFSTlZWNHBGMmhOcWphTWNDdlFqN2l0RkhIS1YzZGxMUjdQN0xBU0dHNzBQV3BSTUhrM0dOdmw5T2NVK1Q3UklBM3lzck5uS3JWYTV0UWo3L002a2dnam5IK2MxUzExWUZ5MG5qQ2xtUlIyeS9VL2hWN1NYamxsMnRJcWJzSGdZclB0dEtrdUlsSW1mc0FldTNIWHRWdXgwdVJsYytkSHVRWTJrYzVPT00vNFZuSzNjQy9md3d4azdicVF0a1pCUEhUL1A1MFZueVdzMGNhbVJ0M09PUlJVV0F5cFlndlB0bXBMYVBlY2MwVVYzbkdLMklwT0ZYN3RWZFJoWDVXeDgyT3ZyUlJWUjNBejFKTTJjL2Q1RlFDUEVuKzZjMFVWc0E2SlJJU3BBK1hwZ1ZOZnNZYjNqK0hDZ24wb29xZW9Fc1V2MmxVREpIOHE0NFVESXpubXJVRGVSQzIzK0VoUjdaelJSV1lFa0ZxcjdXT2QyU2R4NTdlOVVab0ZWdVBsNHpnY1VVVlRZRHJpempTR1BBeHZiQlBjMURjS3JXc1oyL2VKeU1uQjZVVVZVUUhQYkxCSklGL3ZFVkg1Q3BHc21QbWsrVSsxRkZOQVJyR0REc2I1Z0FTTS93NDlLYkMva3NNS3A1N2pQcUtLS1lEcFRzYVAwWUFFWjRQTkVEZWFaRk9NWnh3UDYwVVVBU0JkeVJ5Znhaeit0RnZHR1gvZUdLS0t4azNjRGU4T1JoR0s5bUdEK1pOYmJxSVZXTlJ0V1VaYjN5S0tLNGEzeG5WUytFZzE0TGJhVXZseFFxMHhYTGlOZHd6MXdjWnJKMFpjNmhIN2s1OThVVVZWUDRTaXhlM2pYbDhza2dVbmw4WTRKN1ZIbnpabTNldEZGS1d3RHRSbllXQVR0SVFUK0hOUnlSTFBiTXpMeXNaWWNrNFA0L1NpaW5IWUN2R3FtMnp0WE80ak9QU285Ty8xamZRSHIzOWFLS3FXekFudmwyYlZIUmlTZmVsRVN5UVpiK0RnZm5SUlV4MkF2K0djYVo0alJvMVZ0bTdHN3Z3YTZHNStLbDNNQ3JhYm9KSllzWE9ub1haczV5U2VTZmVpaXViRVJUM05JU2FlaFIxVDR6YStkcXgzTVZ1RnhqeTRWR1AwT1B3cm5kYzhYNnI0Z2xQMnpVYnlaUi9DWlR0L0tpaXRxRkduRlhVVjl3VHFTbDhUS2R0SDVOeEp0TERBSTRZODBNbTZXUGxzdGs1Sm9vcnBNbVdGaFZabWJhTXgvTXYxelFzdU53Q3FPQjI2VVVWUFFYVVVYVWtNMHFMSTIzSS96K2dxVzB1V3VJTU50L3dCWnQ2ZHFLS1V0aWpTdHJscmZjWThSN1NRTm94U2J5WW1rL2lZNFA1MFVWem9CbC9LeGZsbWI2bWlpaWxjRC85az1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wcm9qZWN0LWltYWdlcy90dWxwLmpwZ1xuICoqIG1vZHVsZSBpZCA9IDIwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==');
},function(module,exports,__webpack_require__){eval('module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAlCAYAAAAjt+tHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAhdEVYdENyZWF0aW9uIFRpbWUAMjAxNTowNToyMyAxMToyODo0MFNtqGcAAASrSURBVFhH3VddbFRFGD27263dLba41Jq2UitBEoVKpZpaMRVkCwqmYqI2McbE+GR8MPbJB8VEecDEv8TIi388+GCNkmoRlFZTjNAYbQmxpqRB07QU3FIWdt2/7q9zPu7Uu9u728V0Y+JJTmbm3s2cM99899sZWyaTAdHZ2VmmGrtiudFyvJxIKqYV42wHBgY4hhgwxClcYZB9bWg5QGEKUjxmME4TNq/Xq8XdilVGSxOliACFI4pBo43TAMVXKK5UrN09PDis2pKhr93brppZxcuKIRqgOFfuUeK/NjW54HY7UFHhUI+WD7FYCpFICpOTUZpoVo/8ikHusU48hr0k4gTn5NwGdJ7ZdbZrlkRcwzT3gqbO8uXK9quBaP4Xwln4fxuYmgpk0QrLYsDvj8LnC2F6OiA0C3ZPZvDYGRZAaxQ0EI0mEA7HcelSFGfPBrNWY2YoFMeGl9/FfZ8MYse3Y3jg6Bge/uVPESfsZU5prcBC5FFtjSIL0fCmTdXygqvixHVbd6LMzVoFrH9+D65ds67ghPnQ22RDY2M1RkcDuhqyEM1ZRuDChbCIt+7dj46Pv8Y97/UKq9et/1fihWBpIBpN4t73+7D2yWeNJ/9gbvTKX8XMwJfSXh4/Je0fvR8Kx95+RVaby3yw3AJGoGs8IT8wI/FXAMlICOlkEq4b6pEIBZFR/fH9+zDx0TtwOu0oL3egTNW36mqp7ItQ1BYwArnOzw8dgcPlhu/49zi0uQlzIyfQ11KDazw1aHnpDRF1uZxYtcqNQGA+K0kLwdIAk4UktJHr2zow9IQXU/2fYvWux1FZ34iOA4dx8HYPzn13CLf27JWvRuPR0xHhUij4GZqN2OwONOzYjQ09r0pCVq6+GXVbHsTGF/chNnsOdR3bkUplFlbsqHAJCT5LJFLSz0VeAxcvRrJCaHc6MX34c4y9tUfGRCo+j5Ov9aBq7W1IJxKwqR27rvlO+f4DE78J2a+6Rb1PX6kJubA0QNFwOIG7Xv9AJiCTYZV88Tjqtz2EE891Izbnw08vPIUGbxdsznIMPtIuEShTeUKk5mNCwlGhcscXln4u8kaAomu6n5F+1DeDg80rse2LH6UQzRztQ/D30zh/7Bu0vXkAlQ03yeq39g7h/s+O4Yend8HT3Cpkf3v/zzKPFQrmAEPMBPyq7UYZ9zdXovbuLdg5NIGaljZ0DU8heGZcvW8AT/e6YjJaGua+FSzrgN53DZ2IfO5w2CTUGlw5P0EikUgvek/U1lZidjYs8+TWAW1ATJj/C0oFk4E5RT+t87yuKafXUsE094ImDejrkqQsj86lMKGP5QbkZqSY5hYUdTHhfcHj4U+Xht8fl/O/FYzwZ11MeDzmzPmuZpJhytjxYkxocSW02XjECBMM+eKrWRGXUzm/k8rESCETJvFWNVzYZ8X8l9Mlrue61ebcysRJKxMm8TvUkKvT+2w2oPMt+3peCIYxijNPSJo4ZTZhEt+ohhRn9SFjWigfljRAWJhYoSNBmFauhYsSJ4oyQOSYYLLSxIhq9Z5TlMlVtDhRtAHCZIJfCqkTgfvK0MveFytOXJUBwjChk5J9goILmS1PigLwN89ydamBCbZGAAAAAElFTkSuQmCC"//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy93YXJfMS5wbmc/NWQxZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQ0FBaUMiLCJmaWxlIjoiMjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBbENBWUFBQUFqdCt0SEFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBaGRFVllkRU55WldGMGFXOXVJRlJwYldVQU1qQXhOVG93TlRveU15QXhNVG95T0RvME1GTnRxR2NBQUFTclNVUkJWRmhIM1ZkZGJGUkZHRDI3MjYzZExiYTQxSnEyVWl0QkVvVktwWnBhTVJWa0N3cW1ZcUkyTWNiRStHUjhNUGJKQjhWRWVjREV2OFRJaTM4OCtHQ05rbW9SbEZaVGpOQVliUW14cHFSQjA3UVUzRklXZHQyLzdxOXpQdTdVdTl1NzI4VjBZK0pKVG1ibTNzMmNNOTk4OTlzWld5YVRBZEhaMlZtbUdydGl1ZEZ5dkp4SUtxWVY0MndIQmdZNGhoZ3d4Q2xjWVpCOWJXZzVRR0VLVWp4bU1FNFROcS9YcThYZGlsVkdTeE9saUFDRkk0cEJvNDNUQU1WWEtLNVVyTjA5UERpczJwS2hyOTNicnBwWnhjdUtJUnFnT0ZmdVVlSy9Oalc1NEhZN1VGSGhVSStXRDdGWUNwRklDcE9UVVpwb1ZvLzhpa0h1c1U0OGhyMGs0Z1RuNU53R2RKN1pkYlpybGtSY3d6VDNncWJPOHVYSzlxdUJhUDRYd2xuNGZ4dVltZ3BrMFFyTFlzRHZqOExuQzJGNk9pQTBDM1pQWnZEWUdSWkFheFEwRUkwbUVBN0hjZWxTRkdmUEJyTldZMllvRk1lR2w5L0ZmWjhNWXNlM1kzamc2QmdlL3VWUEVTZnNaVTVwcmNCQzVGRnRqU0lMMGZDbVRkWHlncXZpeEhWYmQ2TE16Vm9Gckg5K0Q2NWRzNjdnaFBuUTIyUkRZMk0xUmtjRHVocXlFTTFaUnVEQ2hiQ0l0KzdkajQ2UHY4WTk3L1VLcTlldC8xZmloV0JwSUJwTjR0NzMrN0QyeVdlTkovOWdidlRLWDhYTXdKZlNYaDQvSmUwZnZSOEt4OTUrUlZhYnkzeXczQUpHb0dzOElUOHdJL0ZYQU1sSUNPbGtFcTRiNnBFSUJaRlIvZkg5K3pEeDBUdHdPdTBvTDNlZ1ROVzM2bXFwN0l0UTFCWXdBcm5Penc4ZGdjUGxodS80OXppMHVRbHpJeWZRMTFLRGF6dzFhSG5wRFJGMXVaeFl0Y3FOUUdBK0swa0x3ZElBazRVa3RKSHIyem93OUlRWFUvMmZZdld1eDFGWjM0aU9BNGR4OEhZUHpuMTNDTGYyN0pXdlJ1UFIweEhoVWlqNEdacU4yT3dPTk96WWpRMDlyMHBDVnE2K0dYVmJIc1RHRi9jaE5uc09kUjNia1VwbEZsYnNxSEFKQ1Q1TEpGTFN6MFZlQXhjdlJySkNhSGM2TVgzNGM0eTl0VWZHUkNvK2o1T3Y5YUJxN1cxSUp4S3dxUjI3cnZsTytmNERFNzhKMmErNlJiMVBYNmtKdWJBMFFORndPSUc3WHY5QUppQ1RZWlY4OFRqcXR6MkVFODkxSXpibncwOHZQSVVHYnhkc3puSU1QdEl1RVNoVGVVS2s1bU5Dd2xHaGNzY1hsbjR1OGthQW9tdTZuNUYrMURlRGc4MHJzZTJMSDZVUXpSenRRL0QzMHpoLzdCdTB2WGtBbFEwM3llcTM5ZzdoL3MrTzRZZW5kOEhUM0Nwa2Yzdi96ektQRlFybUFFUE1CUHlxN1VZWjl6ZFhvdmJ1TGRnNU5JR2FsalowRFU4aGVHWmN2VzhBVC9lNllqSmFHdWErRlN6cmdONTNEWjJJZk81dzJDVFVHbHc1UDBFaWtVZ3Zlay9VMWxaaWRqWXM4K1RXQVcxQVRKai9DMG9GazRFNVJUK3Q4N3l1S2FmWFVzRTA5NEltRGVqcmtxUXNqODZsTUtHUDVRYmtacVNZNWhZVWRUSGhmY0hqNFUrWGh0OGZsL08vRll6d1oxMU1lRHptelBtdVpwSmh5dGp4WWt4b2NTVzAyWGpFQ0JNTStlS3JXUkdYVXptL2s4ckVTQ0VUSnZGV05WellaOFg4bDlNbHJ1ZTYxZWJjeXNSSkt4TW04VHZVa0t2VCsydzJvUE10KzNwZUNJWXhpak5QU0pvNFpUWmhFdCtvaGhSbjlTRmpXaWdmbGpSQVdKaFlvU05CbUZhdWhZc1NKNG95UU9TWVlMTFN4SWhxOVo1VGxNbFZ0RGhSdEFIQ1pJSmZDcWtUZ2Z2SzBNdmVGeXRPWEpVQndqQ2hrNUo5Z29JTG1TMVBpZ0x3Tjg5eWRhbUJDYlpHQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3Byb2plY3QtaW1hZ2VzL3dhcl8xLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDIxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAlCAYAAAAjt+tHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAhdEVYdENyZWF0aW9uIFRpbWUAMjAxNTowNToyMyAxMTozMjowOGsHLIUAAASqSURBVFhH3VdrbFRFGD376LZdWlq3D0hL6qLiE2gpBmwMSLTVIEaJJtVEQwz6B1QSyg81GjT2T0MIkphAJCL8Ax8RiAiGKhEjoCEtoiE1Vg1pA6YPVrbd7ru7zvm4U++Wu4+a3Zh4kpOZubs758w33/12xpZMJkG0tbU5VWNXdBktx/lEXDGhGGXb3d3NMcSAIU7hEoPsa0P5AIUpSPGwwShN2FpbW7W4W3G20dJEISJA4aDimNFGaYDiZYqVirU/FH91VrUFw/JIa4tqhhWvKQZogOJcuUeJ/+z1lsPtdqKkJL8BCIfjCAbjuHRpnCYWqUc+xTHusU48hr0g4gTn5NwGdJ7ZdbZrFkRcwzT3lKbO8nxl+0wgmv+FcAr+3wYGBkZSaIW8GPD5xjE0dA2Dg6OKqYJ/7E/i170sgNZgHfCotlqRdeBsc3ONfECEQhEkEklEo3FMTISlnw6d63Zh/tzbUVMxV8Y3lVejevYc6RO3PG9DQ0MNentHdDFiHRhNa4CrCgTCWLX4UcwqYa0CNj2xVUScjiIZzwTpDFhuwciIX8S5qg87vsB7Gz8SLqi/51+JZ4KlgVAoivc3HcazD24wnvyD879d/6vo7j0ibd/gBWk//navcOeht2S105kOllvACFzcHZEvmDEe8iMYDiCeiGNOZR0CoTHp7z7ahX0ndqKoyAmXywmnqm8VFbOMX6Uipy1gBKY7P/XTcZS63DjTdxIrtnjR038GzS9Xw1NWjTee2a5EHSgtLUJVVTn8/mDW10/D0gCThSS0kWV3rMRz21rx+fcHsWZZO+qrGrCv4xiaNnrw9Y9HsXltpzIek98QfXuCwmzIWAfMRux2Bx5uXouOJ9+RhJxXMx8PLF6NV9u7MOz/EysWPoLJycmpFRe7SoUEn8VicgK7AWkNXL06nhLCIpX9x859ih2fbZUxEY1H0HmgAwvq7kJsMgqbzY5F3nul+PRfvihk/7a6u9PWEEsDFGXh6Vr/gUxATkQCiMWjeKjpMbyy62mMjg1hy551aFvyuDLnwlOdLRKB0mKe6IBILCwkmDuslFZIGwGKtq98QfpDf11G44ZKfPLmd1KITvQcxu9XflGJ+SW2v7gfdVU3q9UDB177BgdfP4X1O9ZgoXepkP0jb5+TeayQMQcYYiZgy+Z5Mm58qRz33bkKJ7f1o+nW5Tj97gD6r/Spz+vB072umEEVLQ1z3wqWdUDvu4ZORD53OOwq1DxlX4dNLZ2vIMFEczgcshVm1NZWYHjYL/Ok+y8QE9P/jAoBk4FRRR+3gO+HppxeCwXT3FOaNKCvS5KyPDoXwoQ+lhuQm5FigluQ08WE9wWPR07uWeHzheX8bwUj/CkXEx6PM13N5E1Rxk7nYkKLK6H7jUc6Y7n8G69mOVxO5fxOKhM9mUyYxJeq4dQ+K6a/nGa5nutWm3MrE+etTJjEl6ghV6f32WxA51vq9TwTDGNUY56QNHHBbMIk3qiGFGf1IcNaKB2yGiAsTJTpSBCmlWvhnMSJnAwQ00wwWWmiR7V6zynK5MpZnMjZAGEywTeFZG4Q3FeGXvY+V3FiRgYIw4ROSvYJCk5ltjzJCcDf0Q1nywe9yGAAAAAASUVORK5CYII="//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wcm9qZWN0LWltYWdlcy93YXJfMi5wbmc/OTA0NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQ0FBaUMiLCJmaWxlIjoiMjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBbENBWUFBQUFqdCt0SEFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBaGRFVllkRU55WldGMGFXOXVJRlJwYldVQU1qQXhOVG93TlRveU15QXhNVG96TWpvd09Hc0hMSVVBQUFTcVNVUkJWRmhIM1ZkcmJGUkZHRDM3NkxaZFdscTNEMGhMNnFMaUUyZ3BCbXdNU0xUVklFYUpKdFZFUXd6NkIxUVN5ZzgxR2pUMlQwTUlrcGhBSkNMOEF4OFJpQWlHS2hFam9DRXRvaUUxVmcxcEE2WVBWcmJkN3J1N3p2bTRVKytXdTQrYTNaaDRrcE9adWJzNzU4dzMzLzEyeHBaTUprRzB0YlU1VldOWGRCa3R4L2xFWERHaEdHWGIzZDNOTWNTQUlVN2hFb1BzYTBQNUFJVXBTUEd3d1NoTjJGcGJXN1c0VzNHMjBkSkVJU0pBNGFEaW1ORkdhWURpWllxVmlyVS9GSDkxVnJVRncvSklhNHRxaGhXdktRWm9nT0pjdVVlSi8rejFsc1B0ZHFLa0pMOEJDSWZqQ0FianVIUnBuQ1lXcVVjK3hUSHVzVTQ4aHIwZzRnVG41TndHZEo3WmRiWnJGa1Jjd3pUM2xLYk84bnhsKzB3Z212K0ZjQXIrM3dZR0JrWlNhSVc4R1BENXhqRTBkQTJEZzZPS3FZSi83RS9pMTcwc2dOWmdIZkNvdGxxUmRlQnNjM09OZkVDRVFoRWtFa2xFbzNGTVRJU2xudzZkNjNaaC90emJVVk14VjhZM2xWZWpldlljNlJPM1BHOURRME1OZW50SGRERmlIUmhOYTRDckNnVENXTFg0VWN3cVlhMENOajJ4VlVTY2ppSVp6d1RwREZodXdjaUlYOFM1cWc4N3ZzQjdHejhTTHFpLzUxK0paNEtsZ1ZBb2l2YzNIY2F6RDI0d252eUQ4NzlkLzZ2bzdqMGliZC9nQldrLy9uYXZjT2VodDJTMTA1a09sbHZBQ0Z6Y0haRXZtREVlOGlNWURpQ2VpR05PWlIwQ29USHA3ejdhaFgwbmRxS295QW1YeXdtbnFtOFZGYk9NWDZVaXB5MWdCS1k3UC9YVGNaUzYzRGpUZHhJcnRualIwMzhHelM5WHcxTldqVGVlMmE1RUhTZ3RMVUpWVlRuOC9tRFcxMC9EMGdDVGhTUzBrV1Yzck1SejIxcngrZmNIc1daWk8rcXJHckN2NHhpYU5ucnc5WTlIc1hsdHB6SWVrOThRZlh1Q3dteklXQWZNUnV4MkJ4NXVYb3VPSjkrUmhKeFhNeDhQTEY2TlY5dTdNT3ovRXlzV1BvTEp5Y21wRlJlN1NvVUVuOFZpY2dLN0FXa05YTDA2bmhMQ0lwWDl4ODU5aWgyZmJaVXhFWTFIMEhtZ0F3dnE3a0pzTWdxYnpZNUYzbnVsK1BSZnZpaGsvN2E2dTlQV0VFc0RGR1hoNlZyL2dVeEFUa1FDaU1XamVLanBNYnl5NjJtTWpnMWh5NTUxYUZ2eXVETG53bE9kTFJLQjBtS2U2SUJJTEN3a21EdXNsRlpJR3dHS3RxOThRZnBEZjExRzQ0WktmUExtZDFLSVR2UWN4dTlYZmxHSitTVzJ2N2dmZFZVM3E5VURCMTc3QmdkZlA0WDFPOVpnb1hlcGtQMGpiNStUZWF5UU1RY1lZaVpneStaNU1tNThxUnozM2JrS0o3ZjFvK25XNVRqOTdnRDZyL1Nweit2QjA3MnVtRUVWTFExejN3cVdkVUR2dTRaT1JENTNPT3dxMUR4bFg0ZE5MWjJ2SU1GRWN6Z2NzaFZtMU5aV1lIallML09rK3k4UUU5UC9qQW9CazRGUlJSKzNnTytIcHB4ZUN3WFQzRk9hTktDdlM1S3lQRG9Yd29RK2xodVFtNUZpZ2x1UTA4V0U5d1dQUjA3dVdlSHpoZVg4YndVai9Da1hFeDZQTTEzTjVFMVJ4azduWWtLTEs2SDdqVWM2WTduOEc2OW1PVnhPNWZ4T0toTTltVXlZeEplcTRkUStLNmEvbkdhNW51dFdtM01yRStldFRKakVsNmdoVjZmMzJXeEE1MXZxOVR3VERHTlVZNTZRTkhIQmJNSWszcWlHRkdmMUljTmFLQjJ5R2lBc1RKVHBTQkNtbFd2aG5NU0puQXdRMDB3d1dXbWlSN1Y2enluSzVNcFpuTWpaQUdFeXdUZUZaRzRRM0ZlR1h2WStWM0ZpUmdZSXc0Uk9TdllKQ2s1bHRqekpDY0RmMFExbnl3ZTl5R0FBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3Byb2plY3QtaW1hZ2VzL3dhcl8yLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDIxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(__resourceQuery) {var io = __webpack_require__(213);\r\nvar stripAnsi = __webpack_require__(244);\r\nvar scriptElements = document.getElementsByTagName("script");\r\nio = io.connect(true ?\r\n	__resourceQuery.substr(1) :\r\n	scriptElements[scriptElements.length-1].getAttribute("src").replace(/\\/[^\\/]+$/, "")\r\n);\r\n\r\nvar hot = false;\r\nvar initial = true;\r\nvar currentHash = "";\r\n\r\nio.on("hot", function() {\r\n	hot = true;\r\n	console.log("[WDS] Hot Module Replacement enabled.");\r\n});\r\n\r\nio.on("invalid", function() {\r\n	console.log("[WDS] App updated. Recompiling...");\r\n});\r\n\r\nio.on("hash", function(hash) {\r\n	currentHash = hash;\r\n});\r\n\r\nio.on("still-ok", function() {\r\n	console.log("[WDS] Nothing changed.")\r\n});\r\n\r\nio.on("ok", function() {\r\n	if(initial) return initial = false;\r\n	reloadApp();\r\n});\r\n\r\nio.on("warnings", function(warnings) {\r\n	console.log("[WDS] Warnings while compiling.");\r\n	for(var i = 0; i < warnings.length; i++)\r\n		console.warn(stripAnsi(warnings[i]));\r\n	if(initial) return initial = false;\r\n	reloadApp();\r\n});\r\n\r\nio.on("errors", function(errors) {\r\n	console.log("[WDS] Errors while compiling.");\r\n	for(var i = 0; i < errors.length; i++)\r\n		console.error(stripAnsi(errors[i]));\r\n	if(initial) return initial = false;\r\n	reloadApp();\r\n});\r\n\r\nio.on("proxy-error", function(errors) {\r\n	console.log("[WDS] Proxy error.");\r\n	for(var i = 0; i < errors.length; i++)\r\n		console.error(stripAnsi(errors[i]));\r\n	if(initial) return initial = false;\r\n	reloadApp();\r\n});\r\n\r\nio.on("disconnect", function() {\r\n	console.error("[WDS] Disconnected!");\r\n});\r\n\r\nfunction reloadApp() {\r\n	if(hot) {\r\n		console.log("[WDS] App hot update...");\r\n		window.postMessage("webpackHotUpdate" + currentHash, "*");\r\n	} else {\r\n		console.log("[WDS] App updated. Reloading...");\r\n		window.location.reload();\r\n	}\r\n}\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, "?http://localhost:8080"))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50P2E3MTUiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudD9jZDE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHVEQ0FBLFNEQUEsbUJDQUEsQ0RBQSxHQ0FBO0FBQ0EsZ0JEQUEsbUJDQUEsQ0RBQSxHQ0FBO0FBQ0E7QUFDQSxnQkRBQSxJQ0FBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibnVsbFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudD9odHRwOi9sb2NhbGhvc3Q6ODA4MFxuICoqLyIsInZhciBpbyA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tY2xpZW50XCIpO1xyXG52YXIgc3RyaXBBbnNpID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpO1xyXG52YXIgc2NyaXB0RWxlbWVudHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcclxuaW8gPSBpby5jb25uZWN0KHR5cGVvZiBfX3Jlc291cmNlUXVlcnkgPT09IFwic3RyaW5nXCIgJiYgX19yZXNvdXJjZVF1ZXJ5ID9cclxuXHRfX3Jlc291cmNlUXVlcnkuc3Vic3RyKDEpIDpcclxuXHRzY3JpcHRFbGVtZW50c1tzY3JpcHRFbGVtZW50cy5sZW5ndGgtMV0uZ2V0QXR0cmlidXRlKFwic3JjXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCJcIilcclxuKTtcclxuXHJcbnZhciBob3QgPSBmYWxzZTtcclxudmFyIGluaXRpYWwgPSB0cnVlO1xyXG52YXIgY3VycmVudEhhc2ggPSBcIlwiO1xyXG5cclxuaW8ub24oXCJob3RcIiwgZnVuY3Rpb24oKSB7XHJcblx0aG90ID0gdHJ1ZTtcclxuXHRjb25zb2xlLmxvZyhcIltXRFNdIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgZW5hYmxlZC5cIik7XHJcbn0pO1xyXG5cclxuaW8ub24oXCJpbnZhbGlkXCIsIGZ1bmN0aW9uKCkge1xyXG5cdGNvbnNvbGUubG9nKFwiW1dEU10gQXBwIHVwZGF0ZWQuIFJlY29tcGlsaW5nLi4uXCIpO1xyXG59KTtcclxuXHJcbmlvLm9uKFwiaGFzaFwiLCBmdW5jdGlvbihoYXNoKSB7XHJcblx0Y3VycmVudEhhc2ggPSBoYXNoO1xyXG59KTtcclxuXHJcbmlvLm9uKFwic3RpbGwtb2tcIiwgZnVuY3Rpb24oKSB7XHJcblx0Y29uc29sZS5sb2coXCJbV0RTXSBOb3RoaW5nIGNoYW5nZWQuXCIpXHJcbn0pO1xyXG5cclxuaW8ub24oXCJva1wiLCBmdW5jdGlvbigpIHtcclxuXHRpZihpbml0aWFsKSByZXR1cm4gaW5pdGlhbCA9IGZhbHNlO1xyXG5cdHJlbG9hZEFwcCgpO1xyXG59KTtcclxuXHJcbmlvLm9uKFwid2FybmluZ3NcIiwgZnVuY3Rpb24od2FybmluZ3MpIHtcclxuXHRjb25zb2xlLmxvZyhcIltXRFNdIFdhcm5pbmdzIHdoaWxlIGNvbXBpbGluZy5cIik7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHdhcm5pbmdzLmxlbmd0aDsgaSsrKVxyXG5cdFx0Y29uc29sZS53YXJuKHN0cmlwQW5zaSh3YXJuaW5nc1tpXSkpO1xyXG5cdGlmKGluaXRpYWwpIHJldHVybiBpbml0aWFsID0gZmFsc2U7XHJcblx0cmVsb2FkQXBwKCk7XHJcbn0pO1xyXG5cclxuaW8ub24oXCJlcnJvcnNcIiwgZnVuY3Rpb24oZXJyb3JzKSB7XHJcblx0Y29uc29sZS5sb2coXCJbV0RTXSBFcnJvcnMgd2hpbGUgY29tcGlsaW5nLlwiKTtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSsrKVxyXG5cdFx0Y29uc29sZS5lcnJvcihzdHJpcEFuc2koZXJyb3JzW2ldKSk7XHJcblx0aWYoaW5pdGlhbCkgcmV0dXJuIGluaXRpYWwgPSBmYWxzZTtcclxuXHRyZWxvYWRBcHAoKTtcclxufSk7XHJcblxyXG5pby5vbihcInByb3h5LWVycm9yXCIsIGZ1bmN0aW9uKGVycm9ycykge1xyXG5cdGNvbnNvbGUubG9nKFwiW1dEU10gUHJveHkgZXJyb3IuXCIpO1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBlcnJvcnMubGVuZ3RoOyBpKyspXHJcblx0XHRjb25zb2xlLmVycm9yKHN0cmlwQW5zaShlcnJvcnNbaV0pKTtcclxuXHRpZihpbml0aWFsKSByZXR1cm4gaW5pdGlhbCA9IGZhbHNlO1xyXG5cdHJlbG9hZEFwcCgpO1xyXG59KTtcclxuXHJcbmlvLm9uKFwiZGlzY29ubmVjdFwiLCBmdW5jdGlvbigpIHtcclxuXHRjb25zb2xlLmVycm9yKFwiW1dEU10gRGlzY29ubmVjdGVkIVwiKTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiByZWxvYWRBcHAoKSB7XHJcblx0aWYoaG90KSB7XHJcblx0XHRjb25zb2xlLmxvZyhcIltXRFNdIEFwcCBob3QgdXBkYXRlLi4uXCIpO1xyXG5cdFx0d2luZG93LnBvc3RNZXNzYWdlKFwid2VicGFja0hvdFVwZGF0ZVwiICsgY3VycmVudEhhc2gsIFwiKlwiKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Y29uc29sZS5sb2coXCJbV0RTXSBBcHAgdXBkYXRlZC4gUmVsb2FkaW5nLi4uXCIpO1xyXG5cdFx0d2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xyXG5cdH1cclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudD9odHRwOi8vbG9jYWxob3N0OjgwODBcbiAqKiBtb2R1bGUgaWQgPSAyMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval("\nmodule.exports = __webpack_require__(214);\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L2luZGV4LmpzPzE5YTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBIiwiZmlsZSI6IjIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi8nKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n/**\n * Module dependencies.\n */\n\nvar url = __webpack_require__(96);\nvar parser = __webpack_require__(68);\nvar Manager = __webpack_require__(93);\nvar debug = __webpack_require__(31)('socket.io-client');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = lookup;\n\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup(uri, opts) {\n  if (typeof uri == 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var io;\n\n  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n    io = cache[id];\n  }\n\n  return io.socket(parsed.path);\n}\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = parser.protocol;\n\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = __webpack_require__(93);\nexports.Socket = __webpack_require__(95);\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9pbmRleC5qcz9iOTMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCcuL3VybCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbG9va3VwO1xuXG4vKipcbiAqIE1hbmFnZXJzIGNhY2hlLlxuICovXG5cbnZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblxuLyoqXG4gKiBMb29rcyB1cCBhbiBleGlzdGluZyBgTWFuYWdlcmAgZm9yIG11bHRpcGxleGluZy5cbiAqIElmIHRoZSB1c2VyIHN1bW1vbnM6XG4gKlxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYScpO2BcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2InKTtgXG4gKlxuICogV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlIGJhc2VkIG9uIHNhbWUgc2NoZW1lL3BvcnQvaG9zdCxcbiAqIGFuZCB3ZSBpbml0aWFsaXplIHNvY2tldHMgZm9yIGVhY2ggbmFtZXNwYWNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9va3VwKHVyaSwgb3B0cykge1xuICBpZiAodHlwZW9mIHVyaSA9PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHBhcnNlZCA9IHVybCh1cmkpO1xuICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICB2YXIgaW87XG5cbiAgaWYgKG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fCBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXgpIHtcbiAgICBkZWJ1ZygnaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgaW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgIGRlYnVnKCduZXcgaW8gaW5zdGFuY2UgZm9yICVzJywgc291cmNlKTtcbiAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICB9XG4gICAgaW8gPSBjYWNoZVtpZF07XG4gIH1cblxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoKTtcbn1cblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuLyoqXG4gKiBgY29ubmVjdGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cbi8qKlxuICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xuZXhwb3J0cy5Tb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n/**\n * Expose `Backoff`.\n */\n\nmodule.exports = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMin = function(min){\n  this.ms = min;\n};\n\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMax = function(max){\n  this.max = max;\n};\n\n/**\n * Set the jitter\n *\n * @api public\n */\n\nBackoff.prototype.setJitter = function(jitter){\n  this.jitter = jitter;\n};\n\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vYmFja28yL2luZGV4LmpzPzFkMzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L2JhY2tvMi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\nmodule.exports =  __webpack_require__(217);\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9pbmRleC5qcz9mMjE2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSIsImZpbGUiOiIyMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbm1vZHVsZS5leHBvcnRzID0gIHJlcXVpcmUoJy4vbGliLycpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\nmodule.exports = __webpack_require__(218);\n\n/**\n * Exports parser\n *\n * @api public\n *\n */\nmodule.exports.parser = __webpack_require__(24);\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanM/MzY5YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0cyBwYXJzZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies.\n */\n\nvar transports = __webpack_require__(98);\nvar Emitter = __webpack_require__(23);\nvar debug = __webpack_require__(42)('engine.io-client:socket');\nvar index = __webpack_require__(100);\nvar parser = __webpack_require__(24);\nvar parseuri = __webpack_require__(235);\nvar parsejson = __webpack_require__(234);\nvar parseqs = __webpack_require__(67);\n\n/**\n * Module exports.\n */\n\nmodule.exports = Socket;\n\n/**\n * Noop function.\n *\n * @api private\n */\n\nfunction noop(){}\n\n/**\n * Socket constructor.\n *\n * @param {String|Object} uri or options\n * @param {Object} options\n * @api public\n */\n\nfunction Socket(uri, opts){\n  if (!(this instanceof Socket)) return new Socket(uri, opts);\n\n  opts = opts || {};\n\n  if (uri && 'object' == typeof uri) {\n    opts = uri;\n    uri = null;\n  }\n\n  if (uri) {\n    uri = parseuri(uri);\n    opts.host = uri.host;\n    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';\n    opts.port = uri.port;\n    if (uri.query) opts.query = uri.query;\n  }\n\n  this.secure = null != opts.secure ? opts.secure :\n    (global.location && 'https:' == location.protocol);\n\n  if (opts.host) {\n    var pieces = opts.host.split(':');\n    opts.hostname = pieces.shift();\n    if (pieces.length) {\n      opts.port = pieces.pop();\n    } else if (!opts.port) {\n      // if no port is specified manually, use the protocol default\n      opts.port = this.secure ? '443' : '80';\n    }\n  }\n\n  this.agent = opts.agent || false;\n  this.hostname = opts.hostname ||\n    (global.location ? location.hostname : 'localhost');\n  this.port = opts.port || (global.location && location.port ?\n       location.port :\n       (this.secure ? 443 : 80));\n  this.query = opts.query || {};\n  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);\n  this.upgrade = false !== opts.upgrade;\n  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n  this.forceJSONP = !!opts.forceJSONP;\n  this.jsonp = false !== opts.jsonp;\n  this.forceBase64 = !!opts.forceBase64;\n  this.enablesXDR = !!opts.enablesXDR;\n  this.timestampParam = opts.timestampParam || 't';\n  this.timestampRequests = opts.timestampRequests;\n  this.transports = opts.transports || ['polling', 'websocket'];\n  this.readyState = '';\n  this.writeBuffer = [];\n  this.callbackBuffer = [];\n  this.policyPort = opts.policyPort || 843;\n  this.rememberUpgrade = opts.rememberUpgrade || false;\n  this.binaryType = null;\n  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx || null;\n  this.key = opts.key || null;\n  this.passphrase = opts.passphrase || null;\n  this.cert = opts.cert || null;\n  this.ca = opts.ca || null;\n  this.ciphers = opts.ciphers || null;\n  this.rejectUnauthorized = opts.rejectUnauthorized || null;\n\n  this.open();\n}\n\nSocket.priorWebsocketSuccess = false;\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nSocket.protocol = parser.protocol; // this is an int\n\n/**\n * Expose deps for legacy compatibility\n * and standalone browser access.\n */\n\nSocket.Socket = Socket;\nSocket.Transport = __webpack_require__(65);\nSocket.transports = __webpack_require__(98);\nSocket.parser = __webpack_require__(24);\n\n/**\n * Creates transport of the given type.\n *\n * @param {String} transport name\n * @return {Transport}\n * @api private\n */\n\nSocket.prototype.createTransport = function (name) {\n  debug('creating transport \"%s\"', name);\n  var query = clone(this.query);\n\n  // append engine.io protocol identifier\n  query.EIO = parser.protocol;\n\n  // transport name\n  query.transport = name;\n\n  // session id if we already have one\n  if (this.id) query.sid = this.id;\n\n  var transport = new transports[name]({\n    agent: this.agent,\n    hostname: this.hostname,\n    port: this.port,\n    secure: this.secure,\n    path: this.path,\n    query: query,\n    forceJSONP: this.forceJSONP,\n    jsonp: this.jsonp,\n    forceBase64: this.forceBase64,\n    enablesXDR: this.enablesXDR,\n    timestampRequests: this.timestampRequests,\n    timestampParam: this.timestampParam,\n    policyPort: this.policyPort,\n    socket: this,\n    pfx: this.pfx,\n    key: this.key,\n    passphrase: this.passphrase,\n    cert: this.cert,\n    ca: this.ca,\n    ciphers: this.ciphers,\n    rejectUnauthorized: this.rejectUnauthorized\n  });\n\n  return transport;\n};\n\nfunction clone (obj) {\n  var o = {};\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      o[i] = obj[i];\n    }\n  }\n  return o;\n}\n\n/**\n * Initializes transport to use and starts probe.\n *\n * @api private\n */\nSocket.prototype.open = function () {\n  var transport;\n  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {\n    transport = 'websocket';\n  } else if (0 == this.transports.length) {\n    // Emit error on next tick so it can be listened to\n    var self = this;\n    setTimeout(function() {\n      self.emit('error', 'No transports available');\n    }, 0);\n    return;\n  } else {\n    transport = this.transports[0];\n  }\n  this.readyState = 'opening';\n\n  // Retry with the next transport if the transport is disabled (jsonp: false)\n  var transport;\n  try {\n    transport = this.createTransport(transport);\n  } catch (e) {\n    this.transports.shift();\n    this.open();\n    return;\n  }\n\n  transport.open();\n  this.setTransport(transport);\n};\n\n/**\n * Sets the current transport. Disables the existing one (if any).\n *\n * @api private\n */\n\nSocket.prototype.setTransport = function(transport){\n  debug('setting transport %s', transport.name);\n  var self = this;\n\n  if (this.transport) {\n    debug('clearing existing transport %s', this.transport.name);\n    this.transport.removeAllListeners();\n  }\n\n  // set up transport\n  this.transport = transport;\n\n  // set up transport listeners\n  transport\n  .on('drain', function(){\n    self.onDrain();\n  })\n  .on('packet', function(packet){\n    self.onPacket(packet);\n  })\n  .on('error', function(e){\n    self.onError(e);\n  })\n  .on('close', function(){\n    self.onClose('transport close');\n  });\n};\n\n/**\n * Probes a transport.\n *\n * @param {String} transport name\n * @api private\n */\n\nSocket.prototype.probe = function (name) {\n  debug('probing transport \"%s\"', name);\n  var transport = this.createTransport(name, { probe: 1 })\n    , failed = false\n    , self = this;\n\n  Socket.priorWebsocketSuccess = false;\n\n  function onTransportOpen(){\n    if (self.onlyBinaryUpgrades) {\n      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n      failed = failed || upgradeLosesBinary;\n    }\n    if (failed) return;\n\n    debug('probe transport \"%s\" opened', name);\n    transport.send([{ type: 'ping', data: 'probe' }]);\n    transport.once('packet', function (msg) {\n      if (failed) return;\n      if ('pong' == msg.type && 'probe' == msg.data) {\n        debug('probe transport \"%s\" pong', name);\n        self.upgrading = true;\n        self.emit('upgrading', transport);\n        if (!transport) return;\n        Socket.priorWebsocketSuccess = 'websocket' == transport.name;\n\n        debug('pausing current transport \"%s\"', self.transport.name);\n        self.transport.pause(function () {\n          if (failed) return;\n          if ('closed' == self.readyState) return;\n          debug('changing transport and sending upgrade packet');\n\n          cleanup();\n\n          self.setTransport(transport);\n          transport.send([{ type: 'upgrade' }]);\n          self.emit('upgrade', transport);\n          transport = null;\n          self.upgrading = false;\n          self.flush();\n        });\n      } else {\n        debug('probe transport \"%s\" failed', name);\n        var err = new Error('probe error');\n        err.transport = transport.name;\n        self.emit('upgradeError', err);\n      }\n    });\n  }\n\n  function freezeTransport() {\n    if (failed) return;\n\n    // Any callback called by transport should be ignored since now\n    failed = true;\n\n    cleanup();\n\n    transport.close();\n    transport = null;\n  }\n\n  //Handle any error that happens while probing\n  function onerror(err) {\n    var error = new Error('probe error: ' + err);\n    error.transport = transport.name;\n\n    freezeTransport();\n\n    debug('probe transport \"%s\" failed because of error: %s', name, err);\n\n    self.emit('upgradeError', error);\n  }\n\n  function onTransportClose(){\n    onerror(\"transport closed\");\n  }\n\n  //When the socket is closed while we're probing\n  function onclose(){\n    onerror(\"socket closed\");\n  }\n\n  //When the socket is upgraded while we're probing\n  function onupgrade(to){\n    if (transport && to.name != transport.name) {\n      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n      freezeTransport();\n    }\n  }\n\n  //Remove all listeners on the transport and on self\n  function cleanup(){\n    transport.removeListener('open', onTransportOpen);\n    transport.removeListener('error', onerror);\n    transport.removeListener('close', onTransportClose);\n    self.removeListener('close', onclose);\n    self.removeListener('upgrading', onupgrade);\n  }\n\n  transport.once('open', onTransportOpen);\n  transport.once('error', onerror);\n  transport.once('close', onTransportClose);\n\n  this.once('close', onclose);\n  this.once('upgrading', onupgrade);\n\n  transport.open();\n\n};\n\n/**\n * Called when connection is deemed open.\n *\n * @api public\n */\n\nSocket.prototype.onOpen = function () {\n  debug('socket open');\n  this.readyState = 'open';\n  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;\n  this.emit('open');\n  this.flush();\n\n  // we check for `readyState` in case an `open`\n  // listener already closed the socket\n  if ('open' == this.readyState && this.upgrade && this.transport.pause) {\n    debug('starting upgrade probes');\n    for (var i = 0, l = this.upgrades.length; i < l; i++) {\n      this.probe(this.upgrades[i]);\n    }\n  }\n};\n\n/**\n * Handles a packet.\n *\n * @api private\n */\n\nSocket.prototype.onPacket = function (packet) {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\n    this.emit('packet', packet);\n\n    // Socket is live - any packet counts\n    this.emit('heartbeat');\n\n    switch (packet.type) {\n      case 'open':\n        this.onHandshake(parsejson(packet.data));\n        break;\n\n      case 'pong':\n        this.setPing();\n        break;\n\n      case 'error':\n        var err = new Error('server error');\n        err.code = packet.data;\n        this.emit('error', err);\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with socket readyState \"%s\"', this.readyState);\n  }\n};\n\n/**\n * Called upon handshake completion.\n *\n * @param {Object} handshake obj\n * @api private\n */\n\nSocket.prototype.onHandshake = function (data) {\n  this.emit('handshake', data);\n  this.id = data.sid;\n  this.transport.query.sid = data.sid;\n  this.upgrades = this.filterUpgrades(data.upgrades);\n  this.pingInterval = data.pingInterval;\n  this.pingTimeout = data.pingTimeout;\n  this.onOpen();\n  // In case open handler closes socket\n  if  ('closed' == this.readyState) return;\n  this.setPing();\n\n  // Prolong liveness of socket on heartbeat\n  this.removeListener('heartbeat', this.onHeartbeat);\n  this.on('heartbeat', this.onHeartbeat);\n};\n\n/**\n * Resets ping timeout.\n *\n * @api private\n */\n\nSocket.prototype.onHeartbeat = function (timeout) {\n  clearTimeout(this.pingTimeoutTimer);\n  var self = this;\n  self.pingTimeoutTimer = setTimeout(function () {\n    if ('closed' == self.readyState) return;\n    self.onClose('ping timeout');\n  }, timeout || (self.pingInterval + self.pingTimeout));\n};\n\n/**\n * Pings server every `this.pingInterval` and expects response\n * within `this.pingTimeout` or closes connection.\n *\n * @api private\n */\n\nSocket.prototype.setPing = function () {\n  var self = this;\n  clearTimeout(self.pingIntervalTimer);\n  self.pingIntervalTimer = setTimeout(function () {\n    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n    self.ping();\n    self.onHeartbeat(self.pingTimeout);\n  }, self.pingInterval);\n};\n\n/**\n* Sends a ping packet.\n*\n* @api public\n*/\n\nSocket.prototype.ping = function () {\n  this.sendPacket('ping');\n};\n\n/**\n * Called on `drain` event\n *\n * @api private\n */\n\nSocket.prototype.onDrain = function() {\n  for (var i = 0; i < this.prevBufferLen; i++) {\n    if (this.callbackBuffer[i]) {\n      this.callbackBuffer[i]();\n    }\n  }\n\n  this.writeBuffer.splice(0, this.prevBufferLen);\n  this.callbackBuffer.splice(0, this.prevBufferLen);\n\n  // setting prevBufferLen = 0 is very important\n  // for example, when upgrading, upgrade packet is sent over,\n  // and a nonzero prevBufferLen could cause problems on `drain`\n  this.prevBufferLen = 0;\n\n  if (this.writeBuffer.length == 0) {\n    this.emit('drain');\n  } else {\n    this.flush();\n  }\n};\n\n/**\n * Flush write buffers.\n *\n * @api private\n */\n\nSocket.prototype.flush = function () {\n  if ('closed' != this.readyState && this.transport.writable &&\n    !this.upgrading && this.writeBuffer.length) {\n    debug('flushing %d packets in socket', this.writeBuffer.length);\n    this.transport.send(this.writeBuffer);\n    // keep track of current length of writeBuffer\n    // splice writeBuffer and callbackBuffer on `drain`\n    this.prevBufferLen = this.writeBuffer.length;\n    this.emit('flush');\n  }\n};\n\n/**\n * Sends a message.\n *\n * @param {String} message.\n * @param {Function} callback function.\n * @return {Socket} for chaining.\n * @api public\n */\n\nSocket.prototype.write =\nSocket.prototype.send = function (msg, fn) {\n  this.sendPacket('message', msg, fn);\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {String} packet type.\n * @param {String} data.\n * @param {Function} callback function.\n * @api private\n */\n\nSocket.prototype.sendPacket = function (type, data, fn) {\n  if ('closing' == this.readyState || 'closed' == this.readyState) {\n    return;\n  }\n\n  var packet = { type: type, data: data };\n  this.emit('packetCreate', packet);\n  this.writeBuffer.push(packet);\n  this.callbackBuffer.push(fn);\n  this.flush();\n};\n\n/**\n * Closes the connection.\n *\n * @api private\n */\n\nSocket.prototype.close = function () {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    this.readyState = 'closing';\n\n    var self = this;\n\n    function close() {\n      self.onClose('forced close');\n      debug('socket closing - telling transport to close');\n      self.transport.close();\n    }\n\n    function cleanupAndClose() {\n      self.removeListener('upgrade', cleanupAndClose);\n      self.removeListener('upgradeError', cleanupAndClose);\n      close();\n    }\n\n    function waitForUpgrade() {\n      // wait for upgrade to finish since we can't send packets while pausing a transport\n      self.once('upgrade', cleanupAndClose);\n      self.once('upgradeError', cleanupAndClose);\n    }\n\n    if (this.writeBuffer.length) {\n      this.once('drain', function() {\n        if (this.upgrading) {\n          waitForUpgrade();\n        } else {\n          close();\n        }\n      });\n    } else if (this.upgrading) {\n      waitForUpgrade();\n    } else {\n      close();\n    }\n  }\n\n  return this;\n};\n\n/**\n * Called upon transport error\n *\n * @api private\n */\n\nSocket.prototype.onError = function (err) {\n  debug('socket error %j', err);\n  Socket.priorWebsocketSuccess = false;\n  this.emit('error', err);\n  this.onClose('transport error', err);\n};\n\n/**\n * Called upon transport close.\n *\n * @api private\n */\n\nSocket.prototype.onClose = function (reason, desc) {\n  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {\n    debug('socket close with reason: \"%s\"', reason);\n    var self = this;\n\n    // clear timers\n    clearTimeout(this.pingIntervalTimer);\n    clearTimeout(this.pingTimeoutTimer);\n\n    // clean buffers in next tick, so developers can still\n    // grab the buffers on `close` event\n    setTimeout(function() {\n      self.writeBuffer = [];\n      self.callbackBuffer = [];\n      self.prevBufferLen = 0;\n    }, 0);\n\n    // stop event from firing again for transport\n    this.transport.removeAllListeners('close');\n\n    // ensure transport won't stay open\n    this.transport.close();\n\n    // ignore further transport communication\n    this.transport.removeAllListeners();\n\n    // set ready state\n    this.readyState = 'closed';\n\n    // clear session id\n    this.id = null;\n\n    // emit close event\n    this.emit('close', reason, desc);\n  }\n};\n\n/**\n * Filters upgrades, returning only those matching client transports.\n *\n * @param {Array} server upgrades\n * @api private\n *\n */\n\nSocket.prototype.filterUpgrades = function (upgrades) {\n  var filteredUpgrades = [];\n  for (var i = 0, j = upgrades.length; i<j; i++) {\n    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\n  }\n  return filteredUpgrades;\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzPzQ2OGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIHBhcnNlanNvbiA9IHJlcXVpcmUoJ3BhcnNlanNvbicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogTm9vcCBmdW5jdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fVxuXG4vKipcbiAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQodXJpLCBvcHRzKXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgdXJpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSBudWxsO1xuICB9XG5cbiAgaWYgKHVyaSkge1xuICAgIHVyaSA9IHBhcnNldXJpKHVyaSk7XG4gICAgb3B0cy5ob3N0ID0gdXJpLmhvc3Q7XG4gICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT0gJ3dzcyc7XG4gICAgb3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG4gICAgaWYgKHVyaS5xdWVyeSkgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlIDpcbiAgICAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sKTtcblxuICBpZiAob3B0cy5ob3N0KSB7XG4gICAgdmFyIHBpZWNlcyA9IG9wdHMuaG9zdC5zcGxpdCgnOicpO1xuICAgIG9wdHMuaG9zdG5hbWUgPSBwaWVjZXMuc2hpZnQoKTtcbiAgICBpZiAocGllY2VzLmxlbmd0aCkge1xuICAgICAgb3B0cy5wb3J0ID0gcGllY2VzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoIW9wdHMucG9ydCkge1xuICAgICAgLy8gaWYgbm8gcG9ydCBpcyBzcGVjaWZpZWQgbWFudWFsbHksIHVzZSB0aGUgcHJvdG9jb2wgZGVmYXVsdFxuICAgICAgb3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8XG4gICAgKGdsb2JhbC5sb2NhdGlvbiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogJ2xvY2FsaG9zdCcpO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQgfHwgKGdsb2JhbC5sb2NhdGlvbiAmJiBsb2NhdGlvbi5wb3J0ID9cbiAgICAgICBsb2NhdGlvbi5wb3J0IDpcbiAgICAgICAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5jYWxsYmFja0J1ZmZlciA9IFtdO1xuICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCB8fCBudWxsO1xuXG4gIHRoaXMub3BlbigpO1xufVxuXG5Tb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7IC8vIHRoaXMgaXMgYW4gaW50XG5cbi8qKlxuICogRXhwb3NlIGRlcHMgZm9yIGxlZ2FjeSBjb21wYXRpYmlsaXR5XG4gKiBhbmQgc3RhbmRhbG9uZSBicm93c2VyIGFjY2Vzcy5cbiAqL1xuXG5Tb2NrZXQuU29ja2V0ID0gU29ja2V0O1xuU29ja2V0LlRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0Jyk7XG5Tb2NrZXQudHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cycpO1xuU29ja2V0LnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHF1ZXJ5ID0gY2xvbmUodGhpcy5xdWVyeSk7XG5cbiAgLy8gYXBwZW5kIGVuZ2luZS5pbyBwcm90b2NvbCBpZGVudGlmaWVyXG4gIHF1ZXJ5LkVJTyA9IHBhcnNlci5wcm90b2NvbDtcblxuICAvLyB0cmFuc3BvcnQgbmFtZVxuICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuXG4gIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAodGhpcy5pZCkgcXVlcnkuc2lkID0gdGhpcy5pZDtcblxuICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNbbmFtZV0oe1xuICAgIGFnZW50OiB0aGlzLmFnZW50LFxuICAgIGhvc3RuYW1lOiB0aGlzLmhvc3RuYW1lLFxuICAgIHBvcnQ6IHRoaXMucG9ydCxcbiAgICBzZWN1cmU6IHRoaXMuc2VjdXJlLFxuICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgZm9yY2VKU09OUDogdGhpcy5mb3JjZUpTT05QLFxuICAgIGpzb25wOiB0aGlzLmpzb25wLFxuICAgIGZvcmNlQmFzZTY0OiB0aGlzLmZvcmNlQmFzZTY0LFxuICAgIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUixcbiAgICB0aW1lc3RhbXBSZXF1ZXN0czogdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyxcbiAgICB0aW1lc3RhbXBQYXJhbTogdGhpcy50aW1lc3RhbXBQYXJhbSxcbiAgICBwb2xpY3lQb3J0OiB0aGlzLnBvbGljeVBvcnQsXG4gICAgc29ja2V0OiB0aGlzLFxuICAgIHBmeDogdGhpcy5wZngsXG4gICAga2V5OiB0aGlzLmtleSxcbiAgICBwYXNzcGhyYXNlOiB0aGlzLnBhc3NwaHJhc2UsXG4gICAgY2VydDogdGhpcy5jZXJ0LFxuICAgIGNhOiB0aGlzLmNhLFxuICAgIGNpcGhlcnM6IHRoaXMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IHRoaXMucmVqZWN0VW5hdXRob3JpemVkXG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc3BvcnQ7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgb1tpXSA9IG9ialtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFuc3BvcnQ7XG4gIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPSAtMSkge1xuICAgIHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuICB9IGVsc2UgaWYgKDAgPT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsICdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG4gIH1cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG4gIC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcbiAgdmFyIHRyYW5zcG9ydDtcbiAgdHJ5IHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbih0cmFuc3BvcnQpe1xuICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzJywgdGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gIHRyYW5zcG9ydFxuICAub24oJ2RyYWluJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uRHJhaW4oKTtcbiAgfSlcbiAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbihwYWNrZXQpe1xuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfSlcbiAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcihlKTtcbiAgfSlcbiAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pXG4gICAgLCBmYWlsZWQgPSBmYWxzZVxuICAgICwgc2VsZiA9IHRoaXM7XG5cbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3Blbigpe1xuICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcbiAgICB9XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PSBtc2cudHlwZSAmJiAncHJvYmUnID09IG1zZy5kYXRhKSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGluZycsIHRyYW5zcG9ydCk7XG4gICAgICAgIGlmICghdHJhbnNwb3J0KSByZXR1cm47XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0cmFuc3BvcnQubmFtZTtcblxuICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3InKTtcbiAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQoKSB7XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQW55IGNhbGxiYWNrIGNhbGxlZCBieSB0cmFuc3BvcnQgc2hvdWxkIGJlIGlnbm9yZWQgc2luY2Ugbm93XG4gICAgZmFpbGVkID0gdHJ1ZTtcblxuICAgIGNsZWFudXAoKTtcblxuICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICAvL0hhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcbiAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSgpe1xuICAgIG9uZXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuICB9XG5cbiAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25jbG9zZSgpe1xuICAgIG9uZXJyb3IoXCJzb2NrZXQgY2xvc2VkXCIpO1xuICB9XG5cbiAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUodG8pe1xuICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICBmdW5jdGlvbiBjbGVhbnVwKCl7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG4gIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG5cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIHRoaXMuZmx1c2goKTtcblxuICAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG4gIC8vIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VkIHRoZSBzb2NrZXRcbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG4gICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShwYXJzZWpzb24ocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignc2VydmVyIGVycm9yJyk7XG4gICAgICAgIGVyci5jb2RlID0gcGFja2V0LmRhdGE7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgcGFja2V0LmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ3BhY2tldCByZWNlaXZlZCB3aXRoIHNvY2tldCByZWFkeVN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gaGFuZHNoYWtlIGNvbXBsZXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhhbmRzaGFrZSBvYmpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IYW5kc2hha2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIGRhdGEpO1xuICB0aGlzLmlkID0gZGF0YS5zaWQ7XG4gIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGRhdGEuc2lkO1xuICB0aGlzLnVwZ3JhZGVzID0gdGhpcy5maWx0ZXJVcGdyYWRlcyhkYXRhLnVwZ3JhZGVzKTtcbiAgdGhpcy5waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IGRhdGEucGluZ1RpbWVvdXQ7XG4gIHRoaXMub25PcGVuKCk7XG4gIC8vIEluIGNhc2Ugb3BlbiBoYW5kbGVyIGNsb3NlcyBzb2NrZXRcbiAgaWYgICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgdGhpcy5zZXRQaW5nKCk7XG5cbiAgLy8gUHJvbG9uZyBsaXZlbmVzcyBvZiBzb2NrZXQgb24gaGVhcnRiZWF0XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuICB0aGlzLm9uKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbn07XG5cbi8qKlxuICogUmVzZXRzIHBpbmcgdGltZW91dC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGVhcnRiZWF0ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5waW5nVGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xufTtcblxuLyoqXG4gKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtcycsIHNlbGYucGluZ1RpbWVvdXQpO1xuICAgIHNlbGYucGluZygpO1xuICAgIHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG4gIH0sIHNlbGYucGluZ0ludGVydmFsKTtcbn07XG5cbi8qKlxuKiBTZW5kcyBhIHBpbmcgcGFja2V0LlxuKlxuKiBAYXBpIHB1YmxpY1xuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRHJhaW4gPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByZXZCdWZmZXJMZW47IGkrKykge1xuICAgIGlmICh0aGlzLmNhbGxiYWNrQnVmZmVyW2ldKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrQnVmZmVyW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcbiAgdGhpcy5jYWxsYmFja0J1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblxuICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuXG4gIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCA9PSAwKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAhdGhpcy51cGdyYWRpbmcgJiYgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICBkZWJ1ZygnZmx1c2hpbmcgJWQgcGFja2V0cyBpbiBzb2NrZXQnLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG4gICAgLy8gc3BsaWNlIHdyaXRlQnVmZmVyIGFuZCBjYWxsYmFja0J1ZmZlciBvbiBgZHJhaW5gXG4gICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIGZuKSB7XG4gIGlmICgnY2xvc2luZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWNrZXQgPSB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbiAgdGhpcy5lbWl0KCdwYWNrZXRDcmVhdGUnLCBwYWNrZXQpO1xuICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgdGhpcy5jYWxsYmFja0J1ZmZlci5wdXNoKGZuKTtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcbiAgICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG4gICAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSgpIHtcbiAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgIGNsb3NlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUoKSB7XG4gICAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuICAgICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgIHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgZXJyb3JcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGRlYnVnKCdzb2NrZXQgZXJyb3IgJWonLCBlcnIpO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLm9uQ2xvc2UoJ3RyYW5zcG9ydCBlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAocmVhc29uLCBkZXNjKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gY2xlYXIgdGltZXJzXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuXG4gICAgLy8gY2xlYW4gYnVmZmVycyBpbiBuZXh0IHRpY2ssIHNvIGRldmVsb3BlcnMgY2FuIHN0aWxsXG4gICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgIHNlbGYuY2FsbGJhY2tCdWZmZXIgPSBbXTtcbiAgICAgIHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG4gICAgfSwgMCk7XG5cbiAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cbiAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cbiAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG4gIH1cbn07XG5cbi8qKlxuICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2VydmVyIHVwZ3JhZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuICB2YXIgZmlsdGVyZWRVcGdyYWRlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IHVwZ3JhZGVzLmxlbmd0aDsgaTxqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMjE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module requirements.\n */\n\nvar Polling = __webpack_require__(99);\nvar inherit = __webpack_require__(41);\n\n/**\n * Module exports.\n */\n\nmodule.exports = JSONPPolling;\n\n/**\n * Cached regular expressions.\n */\n\nvar rNewline = /\\n/g;\nvar rEscapedNewline = /\\\\n/g;\n\n/**\n * Global JSONP callbacks.\n */\n\nvar callbacks;\n\n/**\n * Callbacks count.\n */\n\nvar index = 0;\n\n/**\n * Noop.\n */\n\nfunction empty () { }\n\n/**\n * JSONP Polling constructor.\n *\n * @param {Object} opts.\n * @api public\n */\n\nfunction JSONPPolling (opts) {\n  Polling.call(this, opts);\n\n  this.query = this.query || {};\n\n  // define global callbacks array if not present\n  // we do this here (lazily) to avoid unneeded global pollution\n  if (!callbacks) {\n    // we need to consider multiple engines in the same page\n    if (!global.___eio) global.___eio = [];\n    callbacks = global.___eio;\n  }\n\n  // callback identifier\n  this.index = callbacks.length;\n\n  // add callback to jsonp global\n  var self = this;\n  callbacks.push(function (msg) {\n    self.onData(msg);\n  });\n\n  // append to query string\n  this.query.j = this.index;\n\n  // prevent spurious errors from being emitted when the window is unloaded\n  if (global.document && global.addEventListener) {\n    global.addEventListener('beforeunload', function () {\n      if (self.script) self.script.onerror = empty;\n    }, false);\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(JSONPPolling, Polling);\n\n/*\n * JSONP only supports binary as base64 encoded strings\n */\n\nJSONPPolling.prototype.supportsBinary = false;\n\n/**\n * Closes the socket.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doClose = function () {\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  if (this.form) {\n    this.form.parentNode.removeChild(this.form);\n    this.form = null;\n    this.iframe = null;\n  }\n\n  Polling.prototype.doClose.call(this);\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doPoll = function () {\n  var self = this;\n  var script = document.createElement('script');\n\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  script.async = true;\n  script.src = this.uri();\n  script.onerror = function(e){\n    self.onError('jsonp poll error',e);\n  };\n\n  var insertAt = document.getElementsByTagName('script')[0];\n  insertAt.parentNode.insertBefore(script, insertAt);\n  this.script = script;\n\n  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);\n  \n  if (isUAgecko) {\n    setTimeout(function () {\n      var iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      document.body.removeChild(iframe);\n    }, 100);\n  }\n};\n\n/**\n * Writes with a hidden iframe.\n *\n * @param {String} data to send\n * @param {Function} called upon flush.\n * @api private\n */\n\nJSONPPolling.prototype.doWrite = function (data, fn) {\n  var self = this;\n\n  if (!this.form) {\n    var form = document.createElement('form');\n    var area = document.createElement('textarea');\n    var id = this.iframeId = 'eio_iframe_' + this.index;\n    var iframe;\n\n    form.className = 'socketio';\n    form.style.position = 'absolute';\n    form.style.top = '-1000px';\n    form.style.left = '-1000px';\n    form.target = id;\n    form.method = 'POST';\n    form.setAttribute('accept-charset', 'utf-8');\n    area.name = 'd';\n    form.appendChild(area);\n    document.body.appendChild(form);\n\n    this.form = form;\n    this.area = area;\n  }\n\n  this.form.action = this.uri();\n\n  function complete () {\n    initIframe();\n    fn();\n  }\n\n  function initIframe () {\n    if (self.iframe) {\n      try {\n        self.form.removeChild(self.iframe);\n      } catch (e) {\n        self.onError('jsonp polling iframe removal error', e);\n      }\n    }\n\n    try {\n      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n      var html = '<iframe src=\"javascript:0\" name=\"'+ self.iframeId +'\">';\n      iframe = document.createElement(html);\n    } catch (e) {\n      iframe = document.createElement('iframe');\n      iframe.name = self.iframeId;\n      iframe.src = 'javascript:0';\n    }\n\n    iframe.id = self.iframeId;\n\n    self.form.appendChild(iframe);\n    self.iframe = iframe;\n  }\n\n  initIframe();\n\n  // escape \\n to prevent it from being converted into \\r\\n by some UAs\n  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n  data = data.replace(rEscapedNewline, '\\\\\\n');\n  this.area.value = data.replace(rNewline, '\\\\n');\n\n  try {\n    this.form.submit();\n  } catch(e) {}\n\n  if (this.iframe.attachEvent) {\n    this.iframe.onreadystatechange = function(){\n      if (self.iframe.readyState == 'complete') {\n        complete();\n      }\n    };\n  } else {\n    this.iframe.onload = complete;\n  }\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzPzYzODgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwiZmlsZSI6IjIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKlxuICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKi9cblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG4vKipcbiAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG4gKi9cblxudmFyIGNhbGxiYWNrcztcblxuLyoqXG4gKiBDYWxsYmFja3MgY291bnQuXG4gKi9cblxudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG4vKipcbiAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEpTT05QUG9sbGluZyAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cbiAgLy8gZGVmaW5lIGdsb2JhbCBjYWxsYmFja3MgYXJyYXkgaWYgbm90IHByZXNlbnRcbiAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cbiAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuICAgIGlmICghZ2xvYmFsLl9fX2VpbykgZ2xvYmFsLl9fX2VpbyA9IFtdO1xuICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW87XG4gIH1cblxuICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG4gIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG4gICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgfSk7XG5cbiAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcbiAgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG4vKlxuICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmZvcm0pIHtcbiAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICB9XG5cbiAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcbiAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLGUpO1xuICB9O1xuXG4gIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG4gIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG4gIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIFxuICBpZiAoaXNVQWdlY2tvKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSwgMTAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5mb3JtKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSAnZWlvX2lmcmFtZV8nICsgdGhpcy5pbmRleDtcbiAgICB2YXIgaWZyYW1lO1xuXG4gICAgZm9ybS5jbGFzc05hbWUgPSAnc29ja2V0aW8nO1xuICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGZvcm0uc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnRhcmdldCA9IGlkO1xuICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY2NlcHQtY2hhcnNldCcsICd1dGYtOCcpO1xuICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gIH1cblxuICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuICBmdW5jdGlvbiBjb21wbGV0ZSAoKSB7XG4gICAgaW5pdElmcmFtZSgpO1xuICAgIGZuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcbiAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicrIHNlbGYuaWZyYW1lSWQgKydcIj4nO1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcbiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICB9XG5cbiAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG4gICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gIH1cblxuICBpbml0SWZyYW1lKCk7XG5cbiAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gIH0gY2F0Y2goZSkge31cblxuICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcbiAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG4gIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module requirements.\n */\n\nvar XMLHttpRequest = __webpack_require__(66);\nvar Polling = __webpack_require__(99);\nvar Emitter = __webpack_require__(23);\nvar inherit = __webpack_require__(41);\nvar debug = __webpack_require__(42)('engine.io-client:polling-xhr');\n\n/**\n * Module exports.\n */\n\nmodule.exports = XHR;\nmodule.exports.Request = Request;\n\n/**\n * Empty function\n */\n\nfunction empty(){}\n\n/**\n * XHR Polling constructor.\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction XHR(opts){\n  Polling.call(this, opts);\n\n  if (global.location) {\n    var isSSL = 'https:' == location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    this.xd = opts.hostname != global.location.hostname ||\n      port != opts.port;\n    this.xs = opts.secure != isSSL;\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(XHR, Polling);\n\n/**\n * XHR supports binary\n */\n\nXHR.prototype.supportsBinary = true;\n\n/**\n * Creates a request.\n *\n * @param {String} method\n * @api private\n */\n\nXHR.prototype.request = function(opts){\n  opts = opts || {};\n  opts.uri = this.uri();\n  opts.xd = this.xd;\n  opts.xs = this.xs;\n  opts.agent = this.agent || false;\n  opts.supportsBinary = this.supportsBinary;\n  opts.enablesXDR = this.enablesXDR;\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  return new Request(opts);\n};\n\n/**\n * Sends data.\n *\n * @param {String} data to send.\n * @param {Function} called upon flush.\n * @api private\n */\n\nXHR.prototype.doWrite = function(data, fn){\n  var isBinary = typeof data !== 'string' && data !== undefined;\n  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\n  var self = this;\n  req.on('success', fn);\n  req.on('error', function(err){\n    self.onError('xhr post error', err);\n  });\n  this.sendXhr = req;\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nXHR.prototype.doPoll = function(){\n  debug('xhr poll');\n  var req = this.request();\n  var self = this;\n  req.on('data', function(data){\n    self.onData(data);\n  });\n  req.on('error', function(err){\n    self.onError('xhr poll error', err);\n  });\n  this.pollXhr = req;\n};\n\n/**\n * Request constructor\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Request(opts){\n  this.method = opts.method || 'GET';\n  this.uri = opts.uri;\n  this.xd = !!opts.xd;\n  this.xs = !!opts.xs;\n  this.async = false !== opts.async;\n  this.data = undefined != opts.data ? opts.data : null;\n  this.agent = opts.agent;\n  this.isBinary = opts.isBinary;\n  this.supportsBinary = opts.supportsBinary;\n  this.enablesXDR = opts.enablesXDR;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n\n  this.create();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Creates the XHR object and sends the request.\n *\n * @api private\n */\n\nRequest.prototype.create = function(){\n  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  var xhr = this.xhr = new XMLHttpRequest(opts);\n  var self = this;\n\n  try {\n    debug('xhr open %s: %s', this.method, this.uri);\n    xhr.open(this.method, this.uri, this.async);\n    if (this.supportsBinary) {\n      // This has to be done after open because Firefox is stupid\n      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension\n      xhr.responseType = 'arraybuffer';\n    }\n\n    if ('POST' == this.method) {\n      try {\n        if (this.isBinary) {\n          xhr.setRequestHeader('Content-type', 'application/octet-stream');\n        } else {\n          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        }\n      } catch (e) {}\n    }\n\n    // ie6 check\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    if (this.hasXDR()) {\n      xhr.onload = function(){\n        self.onLoad();\n      };\n      xhr.onerror = function(){\n        self.onError(xhr.responseText);\n      };\n    } else {\n      xhr.onreadystatechange = function(){\n        if (4 != xhr.readyState) return;\n        if (200 == xhr.status || 1223 == xhr.status) {\n          self.onLoad();\n        } else {\n          // make sure the `error` event handler that's user-set\n          // does not throw in the same tick and gets caught here\n          setTimeout(function(){\n            self.onError(xhr.status);\n          }, 0);\n        }\n      };\n    }\n\n    debug('xhr data %s', this.data);\n    xhr.send(this.data);\n  } catch (e) {\n    // Need to defer since .create() is called directly fhrom the constructor\n    // and thus the 'error' event can only be only bound *after* this exception\n    // occurs.  Therefore, also, we cannot throw here at all.\n    setTimeout(function() {\n      self.onError(e);\n    }, 0);\n    return;\n  }\n\n  if (global.document) {\n    this.index = Request.requestsCount++;\n    Request.requests[this.index] = this;\n  }\n};\n\n/**\n * Called upon successful response.\n *\n * @api private\n */\n\nRequest.prototype.onSuccess = function(){\n  this.emit('success');\n  this.cleanup();\n};\n\n/**\n * Called if we have data.\n *\n * @api private\n */\n\nRequest.prototype.onData = function(data){\n  this.emit('data', data);\n  this.onSuccess();\n};\n\n/**\n * Called upon error.\n *\n * @api private\n */\n\nRequest.prototype.onError = function(err){\n  this.emit('error', err);\n  this.cleanup(true);\n};\n\n/**\n * Cleans up house.\n *\n * @api private\n */\n\nRequest.prototype.cleanup = function(fromError){\n  if ('undefined' == typeof this.xhr || null === this.xhr) {\n    return;\n  }\n  // xmlhttprequest\n  if (this.hasXDR()) {\n    this.xhr.onload = this.xhr.onerror = empty;\n  } else {\n    this.xhr.onreadystatechange = empty;\n  }\n\n  if (fromError) {\n    try {\n      this.xhr.abort();\n    } catch(e) {}\n  }\n\n  if (global.document) {\n    delete Request.requests[this.index];\n  }\n\n  this.xhr = null;\n};\n\n/**\n * Called upon load.\n *\n * @api private\n */\n\nRequest.prototype.onLoad = function(){\n  var data;\n  try {\n    var contentType;\n    try {\n      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];\n    } catch (e) {}\n    if (contentType === 'application/octet-stream') {\n      data = this.xhr.response;\n    } else {\n      if (!this.supportsBinary) {\n        data = this.xhr.responseText;\n      } else {\n        data = 'ok';\n      }\n    }\n  } catch (e) {\n    this.onError(e);\n  }\n  if (null != data) {\n    this.onData(data);\n  }\n};\n\n/**\n * Check if it has XDomainRequest.\n *\n * @api private\n */\n\nRequest.prototype.hasXDR = function(){\n  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;\n};\n\n/**\n * Aborts the request.\n *\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  this.cleanup();\n};\n\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\n\nif (global.document) {\n  Request.requestsCount = 0;\n  Request.requests = {};\n  if (global.attachEvent) {\n    global.attachEvent('onunload', unloadHandler);\n  } else if (global.addEventListener) {\n    global.addEventListener('beforeunload', unloadHandler, false);\n  }\n}\n\nfunction unloadHandler() {\n  for (var i in Request.requests) {\n    if (Request.requests.hasOwnProperty(i)) {\n      Request.requests[i].abort();\n    }\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcz8xZDk0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsaURBQWlEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyREFBMkQ7QUFDM0Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0Jyk7XG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSgpe31cblxuLyoqXG4gKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBYSFIob3B0cyl7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9IG9wdHMuaG9zdG5hbWUgIT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4vKipcbiAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAqL1xuXG5YSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihvcHRzKXtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGZuKXtcbiAgdmFyIGlzQmluYXJ5ID0gdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnICYmIGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdzdWNjZXNzJywgZm4pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb3N0IGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMuc2VuZFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCd4aHIgcG9sbCcpO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgc2VsZi5vbkRhdGEoZGF0YSk7XG4gIH0pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb2xsIGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMucG9sbFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogUmVxdWVzdCBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3Qob3B0cyl7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9IG9wdHMuZGF0YSA/IG9wdHMuZGF0YSA6IG51bGw7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50O1xuICB0aGlzLmlzQmluYXJ5ID0gb3B0cy5pc0JpbmFyeTtcbiAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IG9wdHMuc3VwcG9ydHNCaW5hcnk7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgdGhpcy5jcmVhdGUoKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICBpZiAodGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgZG9uZSBhZnRlciBvcGVuIGJlY2F1c2UgRmlyZWZveCBpcyBzdHVwaWRcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMyMTY5MDMvZ2V0LWJpbmFyeS1kYXRhLXdpdGgteG1saHR0cHJlcXVlc3QtaW4tYS1maXJlZm94LWV4dGVuc2lvblxuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgfVxuXG4gICAgaWYgKCdQT1NUJyA9PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICg0ICE9IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT0geGhyLnN0YXR1cyB8fCAxMjIzID09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKGZyb21FcnJvcil7XG4gIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaChlKSB7fVxuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gJ29rJztcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLm9uRXJyb3IoZSk7XG4gIH1cbiAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG4gKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG4gKiBlbWl0dGVkLlxuICovXG5cbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgUmVxdWVzdC5yZXF1ZXN0c0NvdW50ID0gMDtcbiAgUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuICBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzXG4gKiogbW9kdWxlIGlkID0gMjIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("/**\n * Module dependencies.\n */\n\nvar Transport = __webpack_require__(65);\nvar parser = __webpack_require__(24);\nvar parseqs = __webpack_require__(67);\nvar inherit = __webpack_require__(41);\nvar debug = __webpack_require__(42)('engine.io-client:websocket');\n\n/**\n * `ws` exposes a WebSocket-compatible interface in\n * Node, or the `WebSocket` or `MozWebSocket` globals\n * in the browser.\n */\n\nvar WebSocket = __webpack_require__(236);\n\n/**\n * Module exports.\n */\n\nmodule.exports = WS;\n\n/**\n * WebSocket transport constructor.\n *\n * @api {Object} connection options\n * @api public\n */\n\nfunction WS(opts){\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(WS, Transport);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nWS.prototype.name = 'websocket';\n\n/*\n * WebSockets support binary\n */\n\nWS.prototype.supportsBinary = true;\n\n/**\n * Opens socket.\n *\n * @api private\n */\n\nWS.prototype.doOpen = function(){\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n\n  var self = this;\n  var uri = this.uri();\n  var protocols = void(0);\n  var opts = { agent: this.agent };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  this.ws = new WebSocket(uri, protocols, opts);\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  this.ws.binaryType = 'arraybuffer';\n  this.addEventListeners();\n};\n\n/**\n * Adds event listeners to the socket\n *\n * @api private\n */\n\nWS.prototype.addEventListeners = function(){\n  var self = this;\n\n  this.ws.onopen = function(){\n    self.onOpen();\n  };\n  this.ws.onclose = function(){\n    self.onClose();\n  };\n  this.ws.onmessage = function(ev){\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function(e){\n    self.onError('websocket error', e);\n  };\n};\n\n/**\n * Override `onData` to use a timer on iOS.\n * See: https://gist.github.com/mloughran/2052006\n *\n * @api private\n */\n\nif ('undefined' != typeof navigator\n  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {\n  WS.prototype.onData = function(data){\n    var self = this;\n    setTimeout(function(){\n      Transport.prototype.onData.call(self, data);\n    }, 0);\n  };\n}\n\n/**\n * Writes data to socket.\n *\n * @param {Array} array of packets.\n * @api private\n */\n\nWS.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n  // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n  for (var i = 0, l = packets.length; i < l; i++) {\n    parser.encodePacket(packets[i], this.supportsBinary, function(data) {\n      //Sometimes the websocket has already been closed but the browser didn't\n      //have a chance of informing us about it yet, in that case send will\n      //throw an error\n      try {\n        self.ws.send(data);\n      } catch (e){\n        debug('websocket closed before onclose event');\n      }\n    });\n  }\n\n  function ondrain() {\n    self.writable = true;\n    self.emit('drain');\n  }\n  // fake drain\n  // defer to next tick to allow Socket to clear writeBuffer\n  setTimeout(ondrain, 0);\n};\n\n/**\n * Called upon close\n *\n * @api private\n */\n\nWS.prototype.onClose = function(){\n  Transport.prototype.onClose.call(this);\n};\n\n/**\n * Closes socket.\n *\n * @api private\n */\n\nWS.prototype.doClose = function(){\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nWS.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  // avoid port if default for schema\n  if (this.port && (('wss' == schema && this.port != 443)\n    || ('ws' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  // append timestamp to URI\n  if (this.timestampRequests) {\n    query[this.timestampParam] = +new Date;\n  }\n\n  // communicate binary support capabilities\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  return schema + '://' + this.hostname + port + this.path + query;\n};\n\n/**\n * Feature detection for WebSocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nWS.prototype.check = function(){\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanM/NjI1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXQnKTtcblxuLyoqXG4gKiBgd3NgIGV4cG9zZXMgYSBXZWJTb2NrZXQtY29tcGF0aWJsZSBpbnRlcmZhY2UgaW5cbiAqIE5vZGUsIG9yIHRoZSBgV2ViU29ja2V0YCBvciBgTW96V2ViU29ja2V0YCBnbG9iYWxzXG4gKiBpbiB0aGUgYnJvd3Nlci5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdTO1xuXG4vKipcbiAqIFdlYlNvY2tldCB0cmFuc3BvcnQgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSB7T2JqZWN0fSBjb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gV1Mob3B0cyl7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChXUywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5uYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8qXG4gKiBXZWJTb2NrZXRzIHN1cHBvcnQgYmluYXJ5XG4gKi9cblxuV1MucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBPcGVucyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuICB2YXIgcHJvdG9jb2xzID0gdm9pZCgwKTtcbiAgdmFyIG9wdHMgPSB7IGFnZW50OiB0aGlzLmFnZW50IH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzb2NrZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICAgIHNlbGYub25PcGVuKCk7XG4gIH07XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkNsb3NlKCk7XG4gIH07XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpe1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgb25EYXRhYCB0byB1c2UgYSB0aW1lciBvbiBpT1MuXG4gKiBTZWU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21sb3VnaHJhbi8yMDUyMDA2XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3JcbiAgJiYgL2lQYWR8aVBob25lfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gIFdTLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEuY2FsbChzZWxmLCBkYXRhKTtcbiAgICB9LCAwKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBXcml0ZXMgZGF0YSB0byBzb2NrZXQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgcGFja2V0cy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhY2tldHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXRzW2ldLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAvL1NvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgIC8vaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAvL3Rocm93IGFuIGVycm9yXG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9XG4gIC8vIGZha2UgZHJhaW5cbiAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICBzZXRUaW1lb3V0KG9uZHJhaW4sIDApO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oKXtcbiAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ3dzcycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA0NDMpXG4gICAgfHwgKCd3cycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSArbmV3IERhdGU7XG4gIH1cblxuICAvLyBjb21tdW5pY2F0ZSBiaW5hcnkgc3VwcG9ydCBjYXBhYmlsaXRpZXNcbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIHRoaXMuaG9zdG5hbWUgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG4vKipcbiAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhIVdlYlNvY2tldCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMjIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(223);\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2RlYnVnL2RlYnVnLmpzPzdiY2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cbiAgICAgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuZm9ybWF0QXJncykge1xuICAgICAgYXJncyA9IGV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vZGVidWcvZGVidWcuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  var match = /^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2RlYnVnL34vbXMvaW5kZXguanM/YTNjZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuICByZXR1cm4gb3B0aW9ucy5sb25nXG4gICAgPyBsb25nKHZhbClcbiAgICA6IHNob3J0KHZhbCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobXN8c2Vjb25kcz98c3xtaW51dGVzP3xtfGhvdXJzP3xofGRheXM/fGR8eWVhcnM/fHkpPyQvaS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybjtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JylcbiAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG4gICAgfHwgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikgcmV0dXJuO1xuICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2RlYnVnL34vbXMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("\n/**\n * Gets the keys for an object.\n *\n * @return {Array} keys\n * @api private\n */\n\nmodule.exports = Object.keys || function keys (obj){\n  var arr = [];\n  var has = Object.prototype.hasOwnProperty;\n\n  for (var i in obj) {\n    if (has.call(obj, i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvbGliL2tleXMuanM/MWZlNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9lbmdpbmUuaW8tcGFyc2VyL2xpYi9rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMjI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("module.exports = after\n\nfunction after(count, callback, err_cb) {\n    var bail = false\n    err_cb = err_cb || noop\n    proxy.count = count\n\n    return (count === 0) ? callback() : proxy\n\n    function proxy(err, result) {\n        if (proxy.count <= 0) {\n            throw new Error('after called too many times')\n        }\n        --proxy.count\n\n        // after first error, rest are passed to err_cb\n        if (err) {\n            bail = true\n            callback(err)\n            // future error callbacks will go to error handler\n            callback = err_cb\n        } else if (proxy.count === 0 && !bail) {\n            callback(null, result)\n        }\n    }\n}\n\nfunction noop() {}\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvfi9hZnRlci9pbmRleC5qcz80YjQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gYWZ0ZXJcblxuZnVuY3Rpb24gYWZ0ZXIoY291bnQsIGNhbGxiYWNrLCBlcnJfY2IpIHtcbiAgICB2YXIgYmFpbCA9IGZhbHNlXG4gICAgZXJyX2NiID0gZXJyX2NiIHx8IG5vb3BcbiAgICBwcm94eS5jb3VudCA9IGNvdW50XG5cbiAgICByZXR1cm4gKGNvdW50ID09PSAwKSA/IGNhbGxiYWNrKCkgOiBwcm94eVxuXG4gICAgZnVuY3Rpb24gcHJveHkoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKHByb3h5LmNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWZ0ZXIgY2FsbGVkIHRvbyBtYW55IHRpbWVzJylcbiAgICAgICAgfVxuICAgICAgICAtLXByb3h5LmNvdW50XG5cbiAgICAgICAgLy8gYWZ0ZXIgZmlyc3QgZXJyb3IsIHJlc3QgYXJlIHBhc3NlZCB0byBlcnJfY2JcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgYmFpbCA9IHRydWVcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgICAgICAgIC8vIGZ1dHVyZSBlcnJvciBjYWxsYmFja3Mgd2lsbCBnbyB0byBlcnJvciBoYW5kbGVyXG4gICAgICAgICAgICBjYWxsYmFjayA9IGVycl9jYlxuICAgICAgICB9IGVsc2UgaWYgKHByb3h5LmNvdW50ID09PSAwICYmICFiYWlsKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vZW5naW5lLmlvLXBhcnNlci9+L2FmdGVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("/**\n * An abstraction for slicing an arraybuffer even when\n * ArrayBuffer.prototype.slice is not supported\n *\n * @api public\n */\n\nmodule.exports = function(arraybuffer, start, end) {\n  var bytes = arraybuffer.byteLength;\n  start = start || 0;\n  end = end || bytes;\n\n  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }\n\n  if (start < 0) { start += bytes; }\n  if (end < 0) { end += bytes; }\n  if (end > bytes) { end = bytes; }\n\n  if (start >= bytes || start >= end || bytes === 0) {\n    return new ArrayBuffer(0);\n  }\n\n  var abv = new Uint8Array(arraybuffer);\n  var result = new Uint8Array(end - start);\n  for (var i = start, ii = 0; i < end; i++, ii++) {\n    result[ii] = abv[i];\n  }\n  return result.buffer;\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvfi9hcnJheWJ1ZmZlci5zbGljZS9pbmRleC5qcz83Y2Y3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsc0NBQXNDOztBQUVoRSxrQkFBa0IsZ0JBQWdCO0FBQ2xDLGdCQUFnQixjQUFjO0FBQzlCLG9CQUFvQixhQUFhOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIyNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG4gKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGVuZCA9IGVuZCB8fCBieXRlcztcblxuICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBieXRlczsgfVxuICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cbiAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gIH1cblxuICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG4gICAgcmVzdWx0W2lpXSA9IGFidltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9lbmdpbmUuaW8tcGFyc2VyL34vYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval('/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function(chars){\n  "use strict";\n\n  exports.encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer),\n    i, len = bytes.length, base64 = "";\n\n    for (i = 0; i < len; i+=3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + "=";\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + "==";\n    }\n\n    return base64;\n  };\n\n  exports.decode =  function(base64) {\n    var bufferLength = base64.length * 0.75,\n    len = base64.length, i, p = 0,\n    encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === "=") {\n      bufferLength--;\n      if (base64[base64.length - 2] === "=") {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i+=4) {\n      encoded1 = chars.indexOf(base64[i]);\n      encoded2 = chars.indexOf(base64[i+1]);\n      encoded3 = chars.indexOf(base64[i+2]);\n      encoded4 = chars.indexOf(base64[i+3]);\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n  };\n})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvfi9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcz85MDY1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbihjaGFycyl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcbiAgICBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICBlbmNvZGVkMSA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2ldKTtcbiAgICAgIGVuY29kZWQyID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsxXSk7XG4gICAgICBlbmNvZGVkMyA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMl0pO1xuICAgICAgZW5jb2RlZDQgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzNdKTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KShcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIik7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9lbmdpbmUuaW8tcGFyc2VyL34vYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Create a blob builder even when vendor prefixes exist\n */\n\nvar BlobBuilder = global.BlobBuilder\n  || global.WebKitBlobBuilder\n  || global.MSBlobBuilder\n  || global.MozBlobBuilder;\n\n/**\n * Check if Blob constructor is supported\n */\n\nvar blobSupported = (function() {\n  try {\n    var b = new Blob(['hi']);\n    return b.size == 2;\n  } catch(e) {\n    return false;\n  }\n})();\n\n/**\n * Check if BlobBuilder is supported\n */\n\nvar blobBuilderSupported = BlobBuilder\n  && BlobBuilder.prototype.append\n  && BlobBuilder.prototype.getBlob;\n\nfunction BlobBuilderConstructor(ary, options) {\n  options = options || {};\n\n  var bb = new BlobBuilder();\n  for (var i = 0; i < ary.length; i++) {\n    bb.append(ary[i]);\n  }\n  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();\n};\n\nmodule.exports = (function() {\n  if (blobSupported) {\n    return global.Blob;\n  } else if (blobBuilderSupported) {\n    return BlobBuilderConstructor;\n  } else {\n    return undefined;\n  }\n})();\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvfi9ibG9iL2luZGV4LmpzP2E5ZTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyMjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2JCdWlsZGVyID0gZ2xvYmFsLkJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTW96QmxvYkJ1aWxkZXI7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFsnaGknXSk7XG4gICAgcmV0dXJuIGIuc2l6ZSA9PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmIuYXBwZW5kKGFyeVtpXSk7XG4gIH1cbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGlmIChibG9iU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CbG9iO1xuICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufSkoKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvfi9ibG9iL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {\n/*\n * Module requirements.\n */\n\nvar isArray = __webpack_require__(230);\n\n/**\n * Module exports.\n */\n\nmodule.exports = hasBinary;\n\n/**\n * Checks for binary data.\n *\n * Right now only Buffer and ArrayBuffer are supported..\n *\n * @param {Object} anything\n * @api public\n */\n\nfunction hasBinary(data) {\n\n  function _hasBinary(obj) {\n    if (!obj) return false;\n\n    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||\n         (global.Blob && obj instanceof Blob) ||\n         (global.File && obj instanceof File)\n        ) {\n      return true;\n    }\n\n    if (isArray(obj)) {\n      for (var i = 0; i < obj.length; i++) {\n          if (_hasBinary(obj[i])) {\n              return true;\n          }\n      }\n    } else if (obj && 'object' == typeof obj) {\n      if (obj.toJSON) {\n        obj = obj.toJSON();\n      }\n\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key) && _hasBinary(obj[key])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return _hasBinary(data);\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvfi9oYXMtYmluYXJ5L2luZGV4LmpzPzdlZmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjIyOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBSaWdodCBub3cgb25seSBCdWZmZXIgYW5kIEFycmF5QnVmZmVyIGFyZSBzdXBwb3J0ZWQuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG4gIGZ1bmN0aW9uIF9oYXNCaW5hcnkob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBmYWxzZTtcblxuICAgIGlmICggKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICAgIChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoX2hhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgICBpZiAob2JqLnRvSlNPTikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvfi9oYXMtYmluYXJ5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvfi9oYXMtYmluYXJ5L34vaXNhcnJheS9pbmRleC5qcz9kMGIyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L2VuZ2luZS5pby1jbGllbnQvfi9lbmdpbmUuaW8tcGFyc2VyL34vaGFzLWJpbmFyeS9+L2lzYXJyYXkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! http://mths.be/utf8js v2.0.0 by @mathias */\n;(function(root) {\n\n	// Detect free variables `exports`\n	var freeExports = typeof exports == 'object' && exports;\n\n	// Detect free variable `module`\n	var freeModule = typeof module == 'object' && module &&\n		module.exports == freeExports && module;\n\n	// Detect free variable `global`, from Node.js or Browserified code,\n	// and use it as `root`\n	var freeGlobal = typeof global == 'object' && global;\n	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n		root = freeGlobal;\n	}\n\n	/*--------------------------------------------------------------------------*/\n\n	var stringFromCharCode = String.fromCharCode;\n\n	// Taken from http://mths.be/punycode\n	function ucs2decode(string) {\n		var output = [];\n		var counter = 0;\n		var length = string.length;\n		var value;\n		var extra;\n		while (counter < length) {\n			value = string.charCodeAt(counter++);\n			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n				// high surrogate, and there is a next character\n				extra = string.charCodeAt(counter++);\n				if ((extra & 0xFC00) == 0xDC00) { // low surrogate\n					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n				} else {\n					// unmatched surrogate; only append this code unit, in case the next\n					// code unit is the high surrogate of a surrogate pair\n					output.push(value);\n					counter--;\n				}\n			} else {\n				output.push(value);\n			}\n		}\n		return output;\n	}\n\n	// Taken from http://mths.be/punycode\n	function ucs2encode(array) {\n		var length = array.length;\n		var index = -1;\n		var value;\n		var output = '';\n		while (++index < length) {\n			value = array[index];\n			if (value > 0xFFFF) {\n				value -= 0x10000;\n				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n				value = 0xDC00 | value & 0x3FF;\n			}\n			output += stringFromCharCode(value);\n		}\n		return output;\n	}\n\n	/*--------------------------------------------------------------------------*/\n\n	function createByte(codePoint, shift) {\n		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n	}\n\n	function encodeCodePoint(codePoint) {\n		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n			return stringFromCharCode(codePoint);\n		}\n		var symbol = '';\n		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n		}\n		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n			symbol += createByte(codePoint, 6);\n		}\n		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n			symbol += createByte(codePoint, 12);\n			symbol += createByte(codePoint, 6);\n		}\n		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n		return symbol;\n	}\n\n	function utf8encode(string) {\n		var codePoints = ucs2decode(string);\n\n		// console.log(JSON.stringify(codePoints.map(function(x) {\n		// 	return 'U+' + x.toString(16).toUpperCase();\n		// })));\n\n		var length = codePoints.length;\n		var index = -1;\n		var codePoint;\n		var byteString = '';\n		while (++index < length) {\n			codePoint = codePoints[index];\n			byteString += encodeCodePoint(codePoint);\n		}\n		return byteString;\n	}\n\n	/*--------------------------------------------------------------------------*/\n\n	function readContinuationByte() {\n		if (byteIndex >= byteCount) {\n			throw Error('Invalid byte index');\n		}\n\n		var continuationByte = byteArray[byteIndex] & 0xFF;\n		byteIndex++;\n\n		if ((continuationByte & 0xC0) == 0x80) {\n			return continuationByte & 0x3F;\n		}\n\n		// If we end up here, it’s not a continuation byte\n		throw Error('Invalid continuation byte');\n	}\n\n	function decodeSymbol() {\n		var byte1;\n		var byte2;\n		var byte3;\n		var byte4;\n		var codePoint;\n\n		if (byteIndex > byteCount) {\n			throw Error('Invalid byte index');\n		}\n\n		if (byteIndex == byteCount) {\n			return false;\n		}\n\n		// Read first byte\n		byte1 = byteArray[byteIndex] & 0xFF;\n		byteIndex++;\n\n		// 1-byte sequence (no continuation bytes)\n		if ((byte1 & 0x80) == 0) {\n			return byte1;\n		}\n\n		// 2-byte sequence\n		if ((byte1 & 0xE0) == 0xC0) {\n			var byte2 = readContinuationByte();\n			codePoint = ((byte1 & 0x1F) << 6) | byte2;\n			if (codePoint >= 0x80) {\n				return codePoint;\n			} else {\n				throw Error('Invalid continuation byte');\n			}\n		}\n\n		// 3-byte sequence (may include unpaired surrogates)\n		if ((byte1 & 0xF0) == 0xE0) {\n			byte2 = readContinuationByte();\n			byte3 = readContinuationByte();\n			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n			if (codePoint >= 0x0800) {\n				return codePoint;\n			} else {\n				throw Error('Invalid continuation byte');\n			}\n		}\n\n		// 4-byte sequence\n		if ((byte1 & 0xF8) == 0xF0) {\n			byte2 = readContinuationByte();\n			byte3 = readContinuationByte();\n			byte4 = readContinuationByte();\n			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |\n				(byte3 << 0x06) | byte4;\n			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n				return codePoint;\n			}\n		}\n\n		throw Error('Invalid UTF-8 detected');\n	}\n\n	var byteArray;\n	var byteCount;\n	var byteIndex;\n	function utf8decode(byteString) {\n		byteArray = ucs2decode(byteString);\n		byteCount = byteArray.length;\n		byteIndex = 0;\n		var codePoints = [];\n		var tmp;\n		while ((tmp = decodeSymbol()) !== false) {\n			codePoints.push(tmp);\n		}\n		return ucs2encode(codePoints);\n	}\n\n	/*--------------------------------------------------------------------------*/\n\n	var utf8 = {\n		'version': '2.0.0',\n		'encode': utf8encode,\n		'decode': utf8decode\n	};\n\n	// Some AMD build optimizers, like r.js, check for specific condition patterns\n	// like the following:\n	if (\n		true\n	) {\n		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n			return utf8;\n		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n	}	else if (freeExports && !freeExports.nodeType) {\n		if (freeModule) { // in Node.js or RingoJS v0.8.0+\n			freeModule.exports = utf8;\n		} else { // in Narwhal or RingoJS v0.7.0-\n			var object = {};\n			var hasOwnProperty = object.hasOwnProperty;\n			for (var key in utf8) {\n				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);\n			}\n		}\n	} else { // in Rhino or a web browser\n		root.utf8 = utf8;\n	}\n\n}(this));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(103)(module), (function() { return this; }())))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvfi91dGY4L3V0ZjguanM/ZWNiZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoia0NBQUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxLQUFLO0FBQ0wsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGLG1CQUFtQjtBQUNuQjtBQUNBLEdBQUcsT0FBTztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsT0FBTztBQUNUO0FBQ0E7O0FBRUEsQ0FBQyIsImZpbGUiOiIyMzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgaHR0cDovL210aHMuYmUvdXRmOGpzIHYyLjAuMCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHQvLyBUYWtlbiBmcm9tIGh0dHA6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRha2VuIGZyb20gaHR0cDovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0dmFyIHN5bWJvbCA9ICcnO1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7IC8vIDMtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdHJldHVybiBzeW1ib2w7XG5cdH1cblxuXHRmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZykge1xuXHRcdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXG5cdFx0Ly8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoY29kZVBvaW50cy5tYXAoZnVuY3Rpb24oeCkge1xuXHRcdC8vIFx0cmV0dXJuICdVKycgKyB4LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRcdC8vIH0pKSk7XG5cblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVQb2ludDtcblx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbCgpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0dmFyIGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuXHR9XG5cblx0dmFyIGJ5dGVBcnJheTtcblx0dmFyIGJ5dGVDb3VudDtcblx0dmFyIGJ5dGVJbmRleDtcblx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nKSB7XG5cdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHR2YXIgdG1wO1xuXHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKCkpICE9PSBmYWxzZSkge1xuXHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0fVxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHV0ZjggPSB7XG5cdFx0J3ZlcnNpb24nOiAnMi4wLjAnLFxuXHRcdCdlbmNvZGUnOiB1dGY4ZW5jb2RlLFxuXHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdXRmODtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwodXRmOCwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHV0Zjhba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC51dGY4ID0gdXRmODtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2VuZ2luZS5pby1wYXJzZXIvfi91dGY4L3V0ZjguanNcbiAqKiBtb2R1bGUgaWQgPSAyMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval("\n/**\n * Module dependencies.\n */\n\nvar global = __webpack_require__(233);\n\n/**\n * Module exports.\n *\n * Logic borrowed from Modernizr:\n *\n *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n */\n\ntry {\n  module.exports = 'XMLHttpRequest' in global &&\n    'withCredentials' in new global.XMLHttpRequest();\n} catch (err) {\n  // if XMLHttp support is disabled in IE then it will throw\n  // when trying to create\n  module.exports = false;\n}\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2hhcy1jb3JzL2luZGV4LmpzP2E1ZmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJ2dsb2JhbCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gJ1hNTEh0dHBSZXF1ZXN0JyBpbiBnbG9iYWwgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KCk7XG59IGNhdGNoIChlcnIpIHtcbiAgLy8gaWYgWE1MSHR0cCBzdXBwb3J0IGlzIGRpc2FibGVkIGluIElFIHRoZW4gaXQgd2lsbCB0aHJvd1xuICAvLyB3aGVuIHRyeWluZyB0byBjcmVhdGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2hhcy1jb3JzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval('\n/**\n * Returns `this`. Execute this without a "context" (i.e. without it being\n * attached to an object of the left-hand side), and `this` points to the\n * "global" scope of the current JS execution.\n */\n\nmodule.exports = (function () { return this; })();\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2hhcy1jb3JzL34vZ2xvYmFsL2luZGV4LmpzPzE5MDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLGFBQWEsRUFBRSIsImZpbGUiOiIyMzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogUmV0dXJucyBgdGhpc2AuIEV4ZWN1dGUgdGhpcyB3aXRob3V0IGEgXCJjb250ZXh0XCIgKGkuZS4gd2l0aG91dCBpdCBiZWluZ1xuICogYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBsZWZ0LWhhbmQgc2lkZSksIGFuZCBgdGhpc2AgcG9pbnRzIHRvIHRoZVxuICogXCJnbG9iYWxcIiBzY29wZSBvZiB0aGUgY3VycmVudCBKUyBleGVjdXRpb24uXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L2hhcy1jb3JzL34vZ2xvYmFsL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * JSON parse.\n *\n * @see Based on jQuery#parseJSON (MIT) and JSON2\n * @api private\n */\n\nvar rvalidchars = /^[\\],:{}\\s]*$/;\nvar rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\nvar rvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nvar rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g;\nvar rtrimLeft = /^\\s+/;\nvar rtrimRight = /\\s+$/;\n\nmodule.exports = function parsejson(data) {\n  if ('string' != typeof data || !data) {\n    return null;\n  }\n\n  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');\n\n  // Attempt to parse using the native JSON parser first\n  if (global.JSON && JSON.parse) {\n    return JSON.parse(data);\n  }\n\n  if (rvalidchars.test(data.replace(rvalidescape, '@')\n      .replace(rvalidtokens, ']')\n      .replace(rvalidbraces, ''))) {\n    return (new Function('return ' + data))();\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L3BhcnNlanNvbi9pbmRleC5qcz9lYzc4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0IsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEUiLCJmaWxlIjoiMjM0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBKU09OIHBhcnNlLlxuICpcbiAqIEBzZWUgQmFzZWQgb24galF1ZXJ5I3BhcnNlSlNPTiAoTUlUKSBhbmQgSlNPTjJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvO1xudmFyIHJ2YWxpZGVzY2FwZSA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7XG52YXIgcnZhbGlkdG9rZW5zID0gL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nO1xudmFyIHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcbnZhciBydHJpbUxlZnQgPSAvXlxccysvO1xudmFyIHJ0cmltUmlnaHQgPSAvXFxzKyQvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlanNvbihkYXRhKSB7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSB8fCAhZGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGF0YSA9IGRhdGEucmVwbGFjZShydHJpbUxlZnQsICcnKS5yZXBsYWNlKHJ0cmltUmlnaHQsICcnKTtcblxuICAvLyBBdHRlbXB0IHRvIHBhcnNlIHVzaW5nIHRoZSBuYXRpdmUgSlNPTiBwYXJzZXIgZmlyc3RcbiAgaWYgKGdsb2JhbC5KU09OICYmIEpTT04ucGFyc2UpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgfVxuXG4gIGlmIChydmFsaWRjaGFycy50ZXN0KGRhdGEucmVwbGFjZShydmFsaWRlc2NhcGUsICdAJylcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZHRva2VucywgJ10nKVxuICAgICAgLnJlcGxhY2UocnZhbGlkYnJhY2VzLCAnJykpKSB7XG4gICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgZGF0YSkpKCk7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vcGFyc2Vqc29uL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("/**\n * Parses an URI\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\n\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nvar parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\n\nmodule.exports = function parseuri(str) {\n    var src = str,\n        b = str.indexOf('['),\n        e = str.indexOf(']');\n\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n\n    var m = re.exec(str || ''),\n        uri = {},\n        i = 14;\n\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n\n    return uri;\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L3BhcnNldXJpL2luZGV4LmpzPzE3ZmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlHQUF5RyxJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUk7O0FBRWpJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdFQUF3RTtBQUN4RTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSxrRkFBa0Y7QUFDbEY7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjIzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGFyc2VzIGFuIFVSSVxuICpcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xuXG52YXIgcGFydHMgPSBbXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xuICAgIHZhciBzcmMgPSBzdHIsXG4gICAgICAgIGIgPSBzdHIuaW5kZXhPZignWycpLFxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcblxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcbiAgICAgICAgdXJpID0ge30sXG4gICAgICAgIGkgPSAxNDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gICAgfVxuXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xuICAgICAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5hdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5LnJlcGxhY2UoJ1snLCAnJykucmVwbGFjZSgnXScsICcnKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L3BhcnNldXJpL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\n/**\n * Module dependencies.\n */\n\nvar global = (function() { return this; })();\n\n/**\n * WebSocket constructor.\n */\n\nvar WebSocket = global.WebSocket || global.MozWebSocket;\n\n/**\n * Module exports.\n */\n\nmodule.exports = WebSocket ? ws : null;\n\n/**\n * WebSocket constructor.\n *\n * The third `opts` options object gets ignored in web browsers, since it's\n * non-standard, and throws a TypeError if passed to the constructor.\n * See: https://github.com/einaros/ws/issues/227\n *\n * @param {String} uri\n * @param {Array} protocols (optional)\n * @param {Object) opts (optional)\n * @api public\n */\n\nfunction ws(uri, protocols, opts) {\n  var instance;\n  if (protocols) {\n    instance = new WebSocket(uri, protocols);\n  } else {\n    instance = new WebSocket(uri);\n  }\n  return instance;\n}\n\nif (WebSocket) ws.prototype = WebSocket.prototype;\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vZW5naW5lLmlvLWNsaWVudC9+L3dzL2xpYi9icm93c2VyLmpzPzhjYTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsYUFBYSxFQUFFOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIyMzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZ2xvYmFsID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSkoKTtcblxuLyoqXG4gKiBXZWJTb2NrZXQgY29uc3RydWN0b3IuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldCA/IHdzIDogbnVsbDtcblxuLyoqXG4gKiBXZWJTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogVGhlIHRoaXJkIGBvcHRzYCBvcHRpb25zIG9iamVjdCBnZXRzIGlnbm9yZWQgaW4gd2ViIGJyb3dzZXJzLCBzaW5jZSBpdCdzXG4gKiBub24tc3RhbmRhcmQsIGFuZCB0aHJvd3MgYSBUeXBlRXJyb3IgaWYgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2VpbmFyb3Mvd3MvaXNzdWVzLzIyN1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3RvY29scyAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge09iamVjdCkgb3B0cyAob3B0aW9uYWwpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHdzKHVyaSwgcHJvdG9jb2xzLCBvcHRzKSB7XG4gIHZhciBpbnN0YW5jZTtcbiAgaWYgKHByb3RvY29scykge1xuICAgIGluc3RhbmNlID0gbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scyk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UgPSBuZXcgV2ViU29ja2V0KHVyaSk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5pZiAoV2ViU29ja2V0KSB3cy5wcm90b3R5cGUgPSBXZWJTb2NrZXQucHJvdG90eXBlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9lbmdpbmUuaW8tY2xpZW50L34vd3MvbGliL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {\n/*\n * Module requirements.\n */\n\nvar isArray = __webpack_require__(238);\n\n/**\n * Module exports.\n */\n\nmodule.exports = hasBinary;\n\n/**\n * Checks for binary data.\n *\n * Right now only Buffer and ArrayBuffer are supported..\n *\n * @param {Object} anything\n * @api public\n */\n\nfunction hasBinary(data) {\n\n  function _hasBinary(obj) {\n    if (!obj) return false;\n\n    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||\n         (global.Blob && obj instanceof Blob) ||\n         (global.File && obj instanceof File)\n        ) {\n      return true;\n    }\n\n    if (isArray(obj)) {\n      for (var i = 0; i < obj.length; i++) {\n          if (_hasBinary(obj[i])) {\n              return true;\n          }\n      }\n    } else if (obj && 'object' == typeof obj) {\n      if (obj.toJSON) {\n        obj = obj.toJSON();\n      }\n\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return _hasBinary(data);\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vaGFzLWJpbmFyeS9pbmRleC5qcz8xYjE5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIyMzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpIHtcblxuICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgaWYgKG9iai50b0pTT04pIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vaGFzLWJpbmFyeS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vaGFzLWJpbmFyeS9+L2lzYXJyYXkvaW5kZXguanM/YjQxYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9oYXMtYmluYXJ5L34vaXNhcnJheS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("\n/**\n * HOP ref.\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Return own keys in `obj`.\n *\n * @param {Object} obj\n * @return {Array}\n * @api public\n */\n\nexports.keys = Object.keys || function(obj){\n  var keys = [];\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      keys.push(key);\n    }\n  }\n  return keys;\n};\n\n/**\n * Return own values in `obj`.\n *\n * @param {Object} obj\n * @return {Array}\n * @api public\n */\n\nexports.values = function(obj){\n  var vals = [];\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      vals.push(obj[key]);\n    }\n  }\n  return vals;\n};\n\n/**\n * Merge `b` into `a`.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api public\n */\n\nexports.merge = function(a, b){\n  for (var key in b) {\n    if (has.call(b, key)) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n};\n\n/**\n * Return length of `obj`.\n *\n * @param {Object} obj\n * @return {Number}\n * @api public\n */\n\nexports.length = function(obj){\n  return exports.keys(obj).length;\n};\n\n/**\n * Check if `obj` is empty.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api public\n */\n\nexports.isEmpty = function(obj){\n  return 0 == exports.length(obj);\n};//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vb2JqZWN0LWNvbXBvbmVudC9pbmRleC5qcz82NzYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEhPUCByZWYuXG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogUmV0dXJuIG93biBrZXlzIGluIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvYmope1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gb3duIHZhbHVlcyBpbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy52YWx1ZXMgPSBmdW5jdGlvbihvYmope1xuICB2YXIgdmFscyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFscy5wdXNoKG9ialtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHM7XG59O1xuXG4vKipcbiAqIE1lcmdlIGBiYCBpbnRvIGBhYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24oYSwgYil7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgaWYgKGhhcy5jYWxsKGIsIGtleSkpIHtcbiAgICAgIGFba2V5XSA9IGJba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIFJldHVybiBsZW5ndGggb2YgYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmxlbmd0aCA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiBleHBvcnRzLmtleXMob2JqKS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGVtcHR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiAwID09IGV4cG9ydHMubGVuZ3RoKG9iaik7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vb2JqZWN0LWNvbXBvbmVudC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/**\n * Parses an URI\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\n\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nvar parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'\n  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\n\nmodule.exports = function parseuri(str) {\n  var m = re.exec(str || '')\n    , uri = {}\n    , i = 14;\n\n  while (i--) {\n    uri[parts[i]] = m[i] || '';\n  }\n\n  return uri;\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vcGFyc2V1cmkvaW5kZXguanM/MjRhZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUdBQXlHLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSTs7QUFFakk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMjQwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQYXJzZXMgYW4gVVJJXG4gKlxuICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHJlID0gL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87XG5cbnZhciBwYXJ0cyA9IFtcbiAgICAnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnXG4gICwgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xuICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKVxuICAgICwgdXJpID0ge31cbiAgICAsIGkgPSAxNDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gIH1cblxuICByZXR1cm4gdXJpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vcGFyc2V1cmkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = __webpack_require__(102);\nvar isBuf = __webpack_require__(101);\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet){\n  var buffers = [];\n  var packetData = packet.data;\n\n  function _deconstructPacket(data) {\n    if (!data) return data;\n\n    if (isBuf(data)) {\n      var placeholder = { _placeholder: true, num: buffers.length };\n      buffers.push(data);\n      return placeholder;\n    } else if (isArray(data)) {\n      var newData = new Array(data.length);\n      for (var i = 0; i < data.length; i++) {\n        newData[i] = _deconstructPacket(data[i]);\n      }\n      return newData;\n    } else if ('object' == typeof data && !(data instanceof Date)) {\n      var newData = {};\n      for (var key in data) {\n        newData[key] = _deconstructPacket(data[key]);\n      }\n      return newData;\n    }\n    return data;\n  }\n\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {packet: pack, buffers: buffers};\n};\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function(packet, buffers) {\n  var curPlaceHolder = 0;\n\n  function _reconstructPacket(data) {\n    if (data && data._placeholder) {\n      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\n      return buf;\n    } else if (isArray(data)) {\n      for (var i = 0; i < data.length; i++) {\n        data[i] = _reconstructPacket(data[i]);\n      }\n      return data;\n    } else if (data && 'object' == typeof data) {\n      for (var key in data) {\n        data[key] = _reconstructPacket(data[key]);\n      }\n      return data;\n    }\n    return data;\n  }\n\n  packet.data = _reconstructPacket(packet.data);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((global.Blob && obj instanceof Blob) ||\n        (global.File && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanM/NjY1OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEMsS0FBSyx5QkFBeUI7QUFDOUIscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EsS0FBSyx5REFBeUQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBCbG9iLEZpbGUqL1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuXG4gIGZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICAgIGlmIChpc0J1ZihkYXRhKSkge1xuICAgICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xufTtcblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgdmFyIGN1clBsYWNlSG9sZGVyID0gMDtcblxuICBmdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuICAgIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgICB2YXIgYnVmID0gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBlbHNlIGlmIChkYXRhICYmICdvYmplY3QnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhKTtcbiAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gIHJldHVybiBwYWNrZXQ7XG59O1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuICogRmlsZVJlYWRlcidzIHJlYWRBc0FycmF5QnVmZmVyIG1ldGhvZC4gVXNlZCBiZWZvcmUgZW5jb2RpbmdcbiAqIGRhdGEgYXMgbXNncGFjay4gQ2FsbHMgY2FsbGJhY2sgd2l0aCB0aGUgYmxvYmxlc3MgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucmVtb3ZlQmxvYnMgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBfcmVtb3ZlQmxvYnMob2JqLCBjdXJLZXksIGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuICAgIC8vIGNvbnZlcnQgYW55IGJsb2JcbiAgICBpZiAoKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgcGVuZGluZ0Jsb2JzKys7XG5cbiAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcbiAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7IC8vIHRoaXMucmVzdWx0ID09IGFycmF5YnVmZmVyXG4gICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG4gICAgICAgICAgY29udGFpbmluZ09iamVjdFtjdXJLZXldID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYmxvYmxlc3NEYXRhID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcbiAgICAgICAgaWYoISAtLXBlbmRpbmdCbG9icykge1xuICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIob2JqKTsgLy8gYmxvYiAtPiBhcnJheWJ1ZmZlclxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7IC8vIGhhbmRsZSBhcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3RcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG4gIHZhciBibG9ibGVzc0RhdGEgPSBkYXRhO1xuICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcbiAgaWYgKCFwZW5kaW5nQmxvYnMpIHtcbiAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_RESULT__;/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */\n;(function (window) {\n  // Convenience aliases.\n  var getClass = {}.toString, isProperty, forEach, undef;\n\n  // Detect the `define` function exposed by asynchronous module loaders. The\n  // strict `define` check is necessary for compatibility with `r.js`.\n  var isLoader = "function" === "function" && __webpack_require__(246);\n\n  // Detect native implementations.\n  var nativeJSON = typeof JSON == "object" && JSON;\n\n  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if\n  // available.\n  var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;\n\n  if (JSON3 && nativeJSON) {\n    // Explicitly delegate to the native `stringify` and `parse`\n    // implementations in CommonJS environments.\n    JSON3.stringify = nativeJSON.stringify;\n    JSON3.parse = nativeJSON.parse;\n  } else {\n    // Export for web browsers, JavaScript engines, and asynchronous module\n    // loaders, using the global `JSON` object if available.\n    JSON3 = window.JSON = nativeJSON || {};\n  }\n\n  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n  var isExtended = new Date(-3509827334573292);\n  try {\n    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n    // results for certain dates in Opera >= 10.53.\n    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n      // Safari < 2.0.2 stores the internal millisecond time value correctly,\n      // but clips the values returned by the date methods to the range of\n      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n  } catch (exception) {}\n\n  // Internal: Determines whether the native `JSON.stringify` and `parse`\n  // implementations are spec-compliant. Based on work by Ken Snyder.\n  function has(name) {\n    if (has[name] !== undef) {\n      // Return cached feature test result.\n      return has[name];\n    }\n\n    var isSupported;\n    if (name == "bug-string-char-index") {\n      // IE <= 7 doesn\'t support accessing string characters using square\n      // bracket notation. IE 8 only supports this for primitives.\n      isSupported = "a"[0] != "a";\n    } else if (name == "json") {\n      // Indicates whether both `JSON.stringify` and `JSON.parse` are\n      // supported.\n      isSupported = has("json-stringify") && has("json-parse");\n    } else {\n      var value, serialized = \'{"a":[1,true,false,null,"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t"]}\';\n      // Test `JSON.stringify`.\n      if (name == "json-stringify") {\n        var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;\n        if (stringifySupported) {\n          // A test function object with a custom `toJSON` method.\n          (value = function () {\n            return 1;\n          }).toJSON = value;\n          try {\n            stringifySupported =\n              // Firefox 3.1b1 and b2 serialize string, number, and boolean\n              // primitives as object literals.\n              stringify(0) === "0" &&\n              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n              // literals.\n              stringify(new Number()) === "0" &&\n              stringify(new String()) == \'""\' &&\n              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n              // does not define a canonical JSON representation (this applies to\n              // objects with `toJSON` properties as well, *unless* they are nested\n              // within an object or array).\n              stringify(getClass) === undef &&\n              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and\n              // FF 3.1b3 pass this test.\n              stringify(undef) === undef &&\n              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n              // respectively, if the value is omitted entirely.\n              stringify() === undef &&\n              // FF 3.1b1, 2 throw an error if the given value is not a number,\n              // string, array, object, Boolean, or `null` literal. This applies to\n              // objects with custom `toJSON` methods as well, unless they are nested\n              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n              // methods entirely.\n              stringify(value) === "1" &&\n              stringify([value]) == "[1]" &&\n              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of\n              // `"[null]"`.\n              stringify([undef]) == "[null]" &&\n              // YUI 3.0.0b1 fails to serialize `null` literals.\n              stringify(null) == "null" &&\n              // FF 3.1b1, 2 halts serialization if an array contains a function:\n              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3\n              // elides non-JSON values from objects and arrays, unless they\n              // define custom `toJSON` methods.\n              stringify([undef, getClass, null]) == "[null,null,null]" &&\n              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n              // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n              stringify({ "a": [value, true, false, null, "\\x00\\b\\n\\f\\r\\t"] }) == serialized &&\n              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n              stringify(null, value) === "1" &&\n              stringify([1, 2], null, 1) == "[\\n 1,\\n 2\\n]" &&\n              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n              // serialize extended years.\n              stringify(new Date(-8.64e15)) == \'"-271821-04-20T00:00:00.000Z"\' &&\n              // The milliseconds are optional in ES 5, but required in 5.1.\n              stringify(new Date(8.64e15)) == \'"+275760-09-13T00:00:00.000Z"\' &&\n              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n              // four-digit years instead of six-digit years. Credits: @Yaffle.\n              stringify(new Date(-621987552e5)) == \'"-000001-01-01T00:00:00.000Z"\' &&\n              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n              // values less than 1000. Credits: @Yaffle.\n              stringify(new Date(-1)) == \'"1969-12-31T23:59:59.999Z"\';\n          } catch (exception) {\n            stringifySupported = false;\n          }\n        }\n        isSupported = stringifySupported;\n      }\n      // Test `JSON.parse`.\n      if (name == "json-parse") {\n        var parse = JSON3.parse;\n        if (typeof parse == "function") {\n          try {\n            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n            // Conforming implementations should also coerce the initial argument to\n            // a string prior to parsing.\n            if (parse("0") === 0 && !parse(false)) {\n              // Simple parsing test.\n              value = parse(serialized);\n              var parseSupported = value["a"].length == 5 && value["a"][0] === 1;\n              if (parseSupported) {\n                try {\n                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                  parseSupported = !parse(\'"\\t"\');\n                } catch (exception) {}\n                if (parseSupported) {\n                  try {\n                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                    // certain octal literals.\n                    parseSupported = parse("01") !== 1;\n                  } catch (exception) {}\n                }\n                if (parseSupported) {\n                  try {\n                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                    // points. These environments, along with FF 3.1b1 and 2,\n                    // also allow trailing commas in JSON objects and arrays.\n                    parseSupported = parse("1.") !== 1;\n                  } catch (exception) {}\n                }\n              }\n            }\n          } catch (exception) {\n            parseSupported = false;\n          }\n        }\n        isSupported = parseSupported;\n      }\n    }\n    return has[name] = !!isSupported;\n  }\n\n  if (!has("json")) {\n    // Common `[[Class]]` name aliases.\n    var functionClass = "[object Function]";\n    var dateClass = "[object Date]";\n    var numberClass = "[object Number]";\n    var stringClass = "[object String]";\n    var arrayClass = "[object Array]";\n    var booleanClass = "[object Boolean]";\n\n    // Detect incomplete support for accessing string characters by index.\n    var charIndexBuggy = has("bug-string-char-index");\n\n    // Define additional utility methods if the `Date` methods are buggy.\n    if (!isExtended) {\n      var floor = Math.floor;\n      // A mapping between the months of the year and the number of days between\n      // January 1st and the first of the respective month.\n      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n      // Internal: Calculates the number of days between the Unix epoch and the\n      // first day of the given month.\n      var getDay = function (year, month) {\n        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n      };\n    }\n\n    // Internal: Determines if a property is a direct property of the given\n    // object. Delegates to the native `Object#hasOwnProperty` method.\n    if (!(isProperty = {}.hasOwnProperty)) {\n      isProperty = function (property) {\n        var members = {}, constructor;\n        if ((members.__proto__ = null, members.__proto__ = {\n          // The *proto* property cannot be set multiple times in recent\n          // versions of Firefox and SeaMonkey.\n          "toString": 1\n        }, members).toString != getClass) {\n          // Safari <= 2.0.3 doesn\'t implement `Object#hasOwnProperty`, but\n          // supports the mutable *proto* property.\n          isProperty = function (property) {\n            // Capture and break the object\'s prototype chain (see section 8.6.2\n            // of the ES 5.1 spec). The parenthesized expression prevents an\n            // unsafe transformation by the Closure Compiler.\n            var original = this.__proto__, result = property in (this.__proto__ = null, this);\n            // Restore the original prototype chain.\n            this.__proto__ = original;\n            return result;\n          };\n        } else {\n          // Capture a reference to the top-level `Object` constructor.\n          constructor = members.constructor;\n          // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n          // other environments.\n          isProperty = function (property) {\n            var parent = (this.constructor || constructor).prototype;\n            return property in this && !(property in parent && this[property] === parent[property]);\n          };\n        }\n        members = null;\n        return isProperty.call(this, property);\n      };\n    }\n\n    // Internal: A set of primitive types used by `isHostType`.\n    var PrimitiveTypes = {\n      \'boolean\': 1,\n      \'number\': 1,\n      \'string\': 1,\n      \'undefined\': 1\n    };\n\n    // Internal: Determines if the given object `property` value is a\n    // non-primitive.\n    var isHostType = function (object, property) {\n      var type = typeof object[property];\n      return type == \'object\' ? !!object[property] : !PrimitiveTypes[type];\n    };\n\n    // Internal: Normalizes the `for...in` iteration algorithm across\n    // environments. Each enumerated key is yielded to a `callback` function.\n    forEach = function (object, callback) {\n      var size = 0, Properties, members, property;\n\n      // Tests for bugs in the current environment\'s `for...in` algorithm. The\n      // `valueOf` property inherits the non-enumerable flag from\n      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n      (Properties = function () {\n        this.valueOf = 0;\n      }).prototype.valueOf = 0;\n\n      // Iterate over a new instance of the `Properties` class.\n      members = new Properties();\n      for (property in members) {\n        // Ignore all properties inherited from `Object.prototype`.\n        if (isProperty.call(members, property)) {\n          size++;\n        }\n      }\n      Properties = members = null;\n\n      // Normalize the iteration algorithm.\n      if (!size) {\n        // A list of non-enumerable properties inherited from `Object.prototype`.\n        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];\n        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n        // properties.\n        forEach = function (object, callback) {\n          var isFunction = getClass.call(object) == functionClass, property, length;\n          var hasProperty = !isFunction && typeof object.constructor != \'function\' && isHostType(object, \'hasOwnProperty\') ? object.hasOwnProperty : isProperty;\n          for (property in object) {\n            // Gecko <= 1.0 enumerates the `prototype` property of functions under\n            // certain conditions; IE does not.\n            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {\n              callback(property);\n            }\n          }\n          // Manually invoke the callback for each non-enumerable property.\n          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n        };\n      } else if (size == 2) {\n        // Safari <= 2.0.4 enumerates shadowed properties twice.\n        forEach = function (object, callback) {\n          // Create a set of iterated properties.\n          var members = {}, isFunction = getClass.call(object) == functionClass, property;\n          for (property in object) {\n            // Store each property name to prevent double enumeration. The\n            // `prototype` property of functions is not enumerated due to cross-\n            // environment inconsistencies.\n            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n              callback(property);\n            }\n          }\n        };\n      } else {\n        // No bugs detected; use the standard `for...in` algorithm.\n        forEach = function (object, callback) {\n          var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n          for (property in object) {\n            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {\n              callback(property);\n            }\n          }\n          // Manually invoke the callback for the `constructor` property due to\n          // cross-environment inconsistencies.\n          if (isConstructor || isProperty.call(object, (property = "constructor"))) {\n            callback(property);\n          }\n        };\n      }\n      return forEach(object, callback);\n    };\n\n    // Public: Serializes a JavaScript `value` as a JSON string. The optional\n    // `filter` argument may specify either a function that alters how object and\n    // array members are serialized, or an array of strings and numbers that\n    // indicates which properties should be serialized. The optional `width`\n    // argument may be either a string or number that specifies the indentation\n    // level of the output.\n    if (!has("json-stringify")) {\n      // Internal: A map of control characters and their escaped equivalents.\n      var Escapes = {\n        92: "\\\\\\\\",\n        34: \'\\\\"\',\n        8: "\\\\b",\n        12: "\\\\f",\n        10: "\\\\n",\n        13: "\\\\r",\n        9: "\\\\t"\n      };\n\n      // Internal: Converts `value` into a zero-padded string such that its\n      // length is at least equal to `width`. The `width` must be <= 6.\n      var leadingZeroes = "000000";\n      var toPaddedString = function (width, value) {\n        // The `|| 0` expression is necessary to work around a bug in\n        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.\n        return (leadingZeroes + (value || 0)).slice(-width);\n      };\n\n      // Internal: Double-quotes a string `value`, replacing all ASCII control\n      // characters (characters with code unit values between 0 and 31) with\n      // their escaped equivalents. This is an implementation of the\n      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n      var unicodePrefix = "\\\\u00";\n      var quote = function (value) {\n        var result = \'"\', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;\n        if (isLarge) {\n          symbols = value.split("");\n        }\n        for (; index < length; index++) {\n          var charCode = value.charCodeAt(index);\n          // If the character is a control character, append its Unicode or\n          // shorthand escape sequence; otherwise, append the character as-is.\n          switch (charCode) {\n            case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n              result += Escapes[charCode];\n              break;\n            default:\n              if (charCode < 32) {\n                result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                break;\n              }\n              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];\n          }\n        }\n        return result + \'"\';\n      };\n\n      // Internal: Recursively serializes an object. Implements the\n      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n        try {\n          // Necessary for host object support.\n          value = object[property];\n        } catch (exception) {}\n        if (typeof value == "object" && value) {\n          className = getClass.call(value);\n          if (className == dateClass && !isProperty.call(value, "toJSON")) {\n            if (value > -1 / 0 && value < 1 / 0) {\n              // Dates are serialized according to the `Date#toJSON` method\n              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n              // for the ISO 8601 date time string format.\n              if (getDay) {\n                // Manually compute the year, month, date, hours, minutes,\n                // seconds, and milliseconds if the `getUTC*` methods are\n                // buggy. Adapted from @Yaffle\'s `date-shim` project.\n                date = floor(value / 864e5);\n                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n                date = 1 + date - getDay(year, month);\n                // The `time` value specifies the time within the day (see ES\n                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                // to compute `A modulo B`, as the `%` operator does not\n                // correspond to the `modulo` operation for negative numbers.\n                time = (value % 864e5 + 864e5) % 864e5;\n                // The hours, minutes, seconds, and milliseconds are obtained by\n                // decomposing the time within the day. See section 15.9.1.10.\n                hours = floor(time / 36e5) % 24;\n                minutes = floor(time / 6e4) % 60;\n                seconds = floor(time / 1e3) % 60;\n                milliseconds = time % 1e3;\n              } else {\n                year = value.getUTCFullYear();\n                month = value.getUTCMonth();\n                date = value.getUTCDate();\n                hours = value.getUTCHours();\n                minutes = value.getUTCMinutes();\n                seconds = value.getUTCSeconds();\n                milliseconds = value.getUTCMilliseconds();\n              }\n              // Serialize extended years correctly.\n              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n                "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +\n                // Months, dates, hours, minutes, and seconds should have two\n                // digits; milliseconds should have three.\n                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +\n                // Milliseconds are optional in ES 5.0, but required in 5.1.\n                "." + toPaddedString(3, milliseconds) + "Z";\n            } else {\n              value = null;\n            }\n          } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {\n            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n            // ignores all `toJSON` methods on these objects unless they are\n            // defined directly on an instance.\n            value = value.toJSON(property);\n          }\n        }\n        if (callback) {\n          // If a replacement function was provided, call it to obtain the value\n          // for serialization.\n          value = callback.call(object, property, value);\n        }\n        if (value === null) {\n          return "null";\n        }\n        className = getClass.call(value);\n        if (className == booleanClass) {\n          // Booleans are represented literally.\n          return "" + value;\n        } else if (className == numberClass) {\n          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n          // `"null"`.\n          return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";\n        } else if (className == stringClass) {\n          // Strings are double-quoted and escaped.\n          return quote("" + value);\n        }\n        // Recursively serialize objects and arrays.\n        if (typeof value == "object") {\n          // Check for cyclic structures. This is a linear search; performance\n          // is inversely proportional to the number of unique nested objects.\n          for (length = stack.length; length--;) {\n            if (stack[length] === value) {\n              // Cyclic structures cannot be serialized by `JSON.stringify`.\n              throw TypeError();\n            }\n          }\n          // Add the object to the stack of traversed objects.\n          stack.push(value);\n          results = [];\n          // Save the current indentation level and indent one additional level.\n          prefix = indentation;\n          indentation += whitespace;\n          if (className == arrayClass) {\n            // Recursively serialize array elements.\n            for (index = 0, length = value.length; index < length; index++) {\n              element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n              results.push(element === undef ? "null" : element);\n            }\n            result = results.length ? (whitespace ? "[\\n" + indentation + results.join(",\\n" + indentation) + "\\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";\n          } else {\n            // Recursively serialize object members. Members are selected from\n            // either a user-specified list of property names, or the object\n            // itself.\n            forEach(properties || value, function (property) {\n              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n              if (element !== undef) {\n                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}\n                // is not the empty string, let `member` {quote(property) + ":"}\n                // be the concatenation of `member` and the `space` character."\n                // The "`space` character" refers to the literal space\n                // character, not the `space` {width} argument provided to\n                // `JSON.stringify`.\n                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);\n              }\n            });\n            result = results.length ? (whitespace ? "{\\n" + indentation + results.join(",\\n" + indentation) + "\\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";\n          }\n          // Remove the object from the traversed object stack.\n          stack.pop();\n          return result;\n        }\n      };\n\n      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n      JSON3.stringify = function (source, filter, width) {\n        var whitespace, callback, properties, className;\n        if (typeof filter == "function" || typeof filter == "object" && filter) {\n          if ((className = getClass.call(filter)) == functionClass) {\n            callback = filter;\n          } else if (className == arrayClass) {\n            // Convert the property names array into a makeshift set.\n            properties = {};\n            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n          }\n        }\n        if (width) {\n          if ((className = getClass.call(width)) == numberClass) {\n            // Convert the `width` to an integer and create a string containing\n            // `width` number of space characters.\n            if ((width -= width % 1) > 0) {\n              for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");\n            }\n          } else if (className == stringClass) {\n            whitespace = width.length <= 10 ? width : width.slice(0, 10);\n          }\n        }\n        // Opera <= 7.54u2 discards the values associated with empty string keys\n        // (`""`) only if they are used directly within an object member list\n        // (e.g., `!("" in { "": 1})`).\n        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);\n      };\n    }\n\n    // Public: Parses a JSON source string.\n    if (!has("json-parse")) {\n      var fromCharCode = String.fromCharCode;\n\n      // Internal: A map of escaped control characters and their unescaped\n      // equivalents.\n      var Unescapes = {\n        92: "\\\\",\n        34: \'"\',\n        47: "/",\n        98: "\\b",\n        116: "\\t",\n        110: "\\n",\n        102: "\\f",\n        114: "\\r"\n      };\n\n      // Internal: Stores the parser state.\n      var Index, Source;\n\n      // Internal: Resets the parser state and throws a `SyntaxError`.\n      var abort = function() {\n        Index = Source = null;\n        throw SyntaxError();\n      };\n\n      // Internal: Returns the next token, or `"$"` if the parser has reached\n      // the end of the source string. A token may be a string, number, `null`\n      // literal, or Boolean literal.\n      var lex = function () {\n        var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n        while (Index < length) {\n          charCode = source.charCodeAt(Index);\n          switch (charCode) {\n            case 9: case 10: case 13: case 32:\n              // Skip whitespace tokens, including tabs, carriage returns, line\n              // feeds, and space characters.\n              Index++;\n              break;\n            case 123: case 125: case 91: case 93: case 58: case 44:\n              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n              // the current position.\n              value = charIndexBuggy ? source.charAt(Index) : source[Index];\n              Index++;\n              return value;\n            case 34:\n              // `"` delimits a JSON string; advance to the next character and\n              // begin parsing the string. String tokens are prefixed with the\n              // sentinel `@` character to distinguish them from punctuators and\n              // end-of-string tokens.\n              for (value = "@", Index++; Index < length;) {\n                charCode = source.charCodeAt(Index);\n                if (charCode < 32) {\n                  // Unescaped ASCII control characters (those with a code unit\n                  // less than the space character) are not permitted.\n                  abort();\n                } else if (charCode == 92) {\n                  // A reverse solidus (`\\`) marks the beginning of an escaped\n                  // control character (including `"`, `\\`, and `/`) or Unicode\n                  // escape sequence.\n                  charCode = source.charCodeAt(++Index);\n                  switch (charCode) {\n                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n                      // Revive escaped control characters.\n                      value += Unescapes[charCode];\n                      Index++;\n                      break;\n                    case 117:\n                      // `\\u` marks the beginning of a Unicode escape sequence.\n                      // Advance to the first character and validate the\n                      // four-digit code point.\n                      begin = ++Index;\n                      for (position = Index + 4; Index < position; Index++) {\n                        charCode = source.charCodeAt(Index);\n                        // A valid sequence comprises four hexdigits (case-\n                        // insensitive) that form a single hexadecimal value.\n                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                          // Invalid Unicode escape sequence.\n                          abort();\n                        }\n                      }\n                      // Revive the escaped character.\n                      value += fromCharCode("0x" + source.slice(begin, Index));\n                      break;\n                    default:\n                      // Invalid escape sequence.\n                      abort();\n                  }\n                } else {\n                  if (charCode == 34) {\n                    // An unescaped double-quote character marks the end of the\n                    // string.\n                    break;\n                  }\n                  charCode = source.charCodeAt(Index);\n                  begin = Index;\n                  // Optimize for the common case where a string is valid.\n                  while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                    charCode = source.charCodeAt(++Index);\n                  }\n                  // Append the string as-is.\n                  value += source.slice(begin, Index);\n                }\n              }\n              if (source.charCodeAt(Index) == 34) {\n                // Advance to the next character and return the revived string.\n                Index++;\n                return value;\n              }\n              // Unterminated string.\n              abort();\n            default:\n              // Parse numbers and literals.\n              begin = Index;\n              // Advance past the negative sign, if one is specified.\n              if (charCode == 45) {\n                isSigned = true;\n                charCode = source.charCodeAt(++Index);\n              }\n              // Parse an integer or floating-point value.\n              if (charCode >= 48 && charCode <= 57) {\n                // Leading zeroes are interpreted as octal literals.\n                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n                  // Illegal octal literal.\n                  abort();\n                }\n                isSigned = false;\n                // Parse the integer component.\n                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n                // Floats cannot contain a leading decimal point; however, this\n                // case is already accounted for by the parser.\n                if (source.charCodeAt(Index) == 46) {\n                  position = ++Index;\n                  // Parse the decimal component.\n                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                  if (position == Index) {\n                    // Illegal trailing decimal.\n                    abort();\n                  }\n                  Index = position;\n                }\n                // Parse exponents. The `e` denoting the exponent is\n                // case-insensitive.\n                charCode = source.charCodeAt(Index);\n                if (charCode == 101 || charCode == 69) {\n                  charCode = source.charCodeAt(++Index);\n                  // Skip past the sign following the exponent, if one is\n                  // specified.\n                  if (charCode == 43 || charCode == 45) {\n                    Index++;\n                  }\n                  // Parse the exponential component.\n                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                  if (position == Index) {\n                    // Illegal empty exponent.\n                    abort();\n                  }\n                  Index = position;\n                }\n                // Coerce the parsed value to a JavaScript number.\n                return +source.slice(begin, Index);\n              }\n              // A negative sign may only precede numbers.\n              if (isSigned) {\n                abort();\n              }\n              // `true`, `false`, and `null` literals.\n              if (source.slice(Index, Index + 4) == "true") {\n                Index += 4;\n                return true;\n              } else if (source.slice(Index, Index + 5) == "false") {\n                Index += 5;\n                return false;\n              } else if (source.slice(Index, Index + 4) == "null") {\n                Index += 4;\n                return null;\n              }\n              // Unrecognized token.\n              abort();\n          }\n        }\n        // Return the sentinel `$` character if the parser has reached the end\n        // of the source string.\n        return "$";\n      };\n\n      // Internal: Parses a JSON `value` token.\n      var get = function (value) {\n        var results, hasMembers;\n        if (value == "$") {\n          // Unexpected end of input.\n          abort();\n        }\n        if (typeof value == "string") {\n          if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {\n            // Remove the sentinel `@` character.\n            return value.slice(1);\n          }\n          // Parse object and array literals.\n          if (value == "[") {\n            // Parses a JSON array, returning a new JavaScript array.\n            results = [];\n            for (;; hasMembers || (hasMembers = true)) {\n              value = lex();\n              // A closing square bracket marks the end of the array literal.\n              if (value == "]") {\n                break;\n              }\n              // If the array literal contains elements, the current token\n              // should be a comma separating the previous element from the\n              // next.\n              if (hasMembers) {\n                if (value == ",") {\n                  value = lex();\n                  if (value == "]") {\n                    // Unexpected trailing `,` in array literal.\n                    abort();\n                  }\n                } else {\n                  // A `,` must separate each array element.\n                  abort();\n                }\n              }\n              // Elisions and leading commas are not permitted.\n              if (value == ",") {\n                abort();\n              }\n              results.push(get(value));\n            }\n            return results;\n          } else if (value == "{") {\n            // Parses a JSON object, returning a new JavaScript object.\n            results = {};\n            for (;; hasMembers || (hasMembers = true)) {\n              value = lex();\n              // A closing curly brace marks the end of the object literal.\n              if (value == "}") {\n                break;\n              }\n              // If the object literal contains members, the current token\n              // should be a comma separator.\n              if (hasMembers) {\n                if (value == ",") {\n                  value = lex();\n                  if (value == "}") {\n                    // Unexpected trailing `,` in object literal.\n                    abort();\n                  }\n                } else {\n                  // A `,` must separate each object member.\n                  abort();\n                }\n              }\n              // Leading commas are not permitted, object property names must be\n              // double-quoted strings, and a `:` must separate each property\n              // name and value.\n              if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {\n                abort();\n              }\n              results[value.slice(1)] = get(lex());\n            }\n            return results;\n          }\n          // Unexpected token encountered.\n          abort();\n        }\n        return value;\n      };\n\n      // Internal: Updates a traversed object member.\n      var update = function(source, property, callback) {\n        var element = walk(source, property, callback);\n        if (element === undef) {\n          delete source[property];\n        } else {\n          source[property] = element;\n        }\n      };\n\n      // Internal: Recursively traverses a parsed JSON object, invoking the\n      // `callback` function for each value. This is an implementation of the\n      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n      var walk = function (source, property, callback) {\n        var value = source[property], length;\n        if (typeof value == "object" && value) {\n          // `forEach` can\'t be used to traverse an array in Opera <= 8.54\n          // because its `Object#hasOwnProperty` implementation returns `false`\n          // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).\n          if (getClass.call(value) == arrayClass) {\n            for (length = value.length; length--;) {\n              update(value, length, callback);\n            }\n          } else {\n            forEach(value, function (property) {\n              update(value, property, callback);\n            });\n          }\n        }\n        return callback.call(source, property, value);\n      };\n\n      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n      JSON3.parse = function (source, callback) {\n        var result, value;\n        Index = 0;\n        Source = "" + source;\n        result = get(lex());\n        // If a JSON string contains multiple tokens, it is invalid.\n        if (lex() != "$") {\n          abort();\n        }\n        // Reset the parser state.\n        Index = Source = null;\n        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;\n      };\n    }\n  }\n\n  // Export for asynchronous module loaders.\n  if (isLoader) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n      return JSON3;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}(this));\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vc29ja2V0LmlvLXBhcnNlci9+L2pzb24zL2xpYi9qc29uMy5qcz83NDI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLGlEQUFpRDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQW9EO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw4QkFBOEI7QUFDckU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCw2QkFBNkI7QUFDM0YscUVBQXFFLGlDQUFpQztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EscUNBQXFDLFVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixzREFBc0QsMEVBQTBFLE9BQU8sMEJBQTBCLFNBQVM7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsOERBQThELGdCQUFnQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwyQkFBMkI7QUFDMUY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0JBQWtCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkZBQTZGO0FBQ25ILGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtR0FBbUc7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtR0FBbUc7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDIiwiZmlsZSI6IjI0Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBKU09OIHYzLjIuNiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDEzLCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKHdpbmRvdykge1xuICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICB2YXIgZ2V0Q2xhc3MgPSB7fS50b1N0cmluZywgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIERldGVjdCBuYXRpdmUgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgbmF0aXZlSlNPTiA9IHR5cGVvZiBKU09OID09IFwib2JqZWN0XCIgJiYgSlNPTjtcblxuICAvLyBTZXQgdXAgdGhlIEpTT04gMyBuYW1lc3BhY2UsIHByZWZlcnJpbmcgdGhlIENvbW1vbkpTIGBleHBvcnRzYCBvYmplY3QgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICB2YXIgSlNPTjMgPSB0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICBpZiAoSlNPTjMgJiYgbmF0aXZlSlNPTikge1xuICAgIC8vIEV4cGxpY2l0bHkgZGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBpbiBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgSlNPTjMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgSlNPTjMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzLCBKYXZhU2NyaXB0IGVuZ2luZXMsIGFuZCBhc3luY2hyb25vdXMgbW9kdWxlXG4gICAgLy8gbG9hZGVycywgdXNpbmcgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGlmIGF2YWlsYWJsZS5cbiAgICBKU09OMyA9IHdpbmRvdy5KU09OID0gbmF0aXZlSlNPTiB8fCB7fTtcbiAgfVxuXG4gIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gIHRyeSB7XG4gICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgfVxuXG4gICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICB2YXIgc3RyaW5naWZ5ID0gSlNPTjMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgfVxuICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICB2YXIgcGFyc2UgPSBKU09OMy5wYXJzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiO1xuICAgIHZhciBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIjtcbiAgICB2YXIgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiO1xuICAgIHZhciBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCI7XG4gICAgdmFyIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgdmFyIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgaWYgKCEoaXNQcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5KSkge1xuICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSW50ZXJuYWw6IEEgc2V0IG9mIHByaW1pdGl2ZSB0eXBlcyB1c2VkIGJ5IGBpc0hvc3RUeXBlYC5cbiAgICB2YXIgUHJpbWl0aXZlVHlwZXMgPSB7XG4gICAgICAnYm9vbGVhbic6IDEsXG4gICAgICAnbnVtYmVyJzogMSxcbiAgICAgICdzdHJpbmcnOiAxLFxuICAgICAgJ3VuZGVmaW5lZCc6IDFcbiAgICB9O1xuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgdGhlIGdpdmVuIG9iamVjdCBgcHJvcGVydHlgIHZhbHVlIGlzIGFcbiAgICAvLyBub24tcHJpbWl0aXZlLlxuICAgIHZhciBpc0hvc3RUeXBlID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICByZXR1cm4gdHlwZSA9PSAnb2JqZWN0JyA/ICEhb2JqZWN0W3Byb3BlcnR5XSA6ICFQcmltaXRpdmVUeXBlc1t0eXBlXTtcbiAgICB9O1xuXG4gICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gJ2Z1bmN0aW9uJyAmJiBpc0hvc3RUeXBlKG9iamVjdCwgJ2hhc093blByb3BlcnR5JykgPyBvYmplY3QuaGFzT3duUHJvcGVydHkgOiBpc1Byb3BlcnR5O1xuICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCBpc0xhcmdlID0gbGVuZ3RoID4gMTAgJiYgY2hhckluZGV4QnVnZ3ksIHN5bWJvbHM7XG4gICAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgICAgc3ltYm9scyA9IHZhbHVlLnNwbGl0KFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBpc0xhcmdlID8gc3ltYm9sc1tpbmRleF0gOiBjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdChpbmRleCkgOiB2YWx1ZVtpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgIEpTT04zLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgZmlsdGVyID09IFwib2JqZWN0XCIgJiYgZmlsdGVyKSB7XG4gICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgIDM0OiAnXCInLFxuICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbihzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgIEpTT04zLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0odGhpcykpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3NvY2tldC5pby1jbGllbnQvfi9zb2NrZXQuaW8tcGFyc2VyL34vanNvbjMvbGliL2pzb24zLmpzXG4gKiogbW9kdWxlIGlkID0gMjQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9');
},function(module,exports,__webpack_require__){eval("module.exports = toArray\n\nfunction toArray(list, index) {\n    var array = []\n\n    index = index || 0\n\n    for (var i = index || 0; i < list.length; i++) {\n        array[i - index] = list[i]\n    }\n\n    return array\n}\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zb2NrZXQuaW8tY2xpZW50L34vdG8tYXJyYXkvaW5kZXguanM/Y2FjNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjI0My5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gW11cblxuICAgIGluZGV4ID0gaW5kZXggfHwgMFxuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS1kZXYtc2VydmVyL34vc29ja2V0LmlvLWNsaWVudC9+L3RvLWFycmF5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\nvar ansiRegex = __webpack_require__(245)();\n\nmodule.exports = function (str) {\n	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zdHJpcC1hbnNpL2luZGV4LmpzPzllZjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjQ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyLnJlcGxhY2UoYW5zaVJlZ2V4LCAnJykgOiBzdHI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3N0cmlwLWFuc2kvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\nmodule.exports = function () {\n	return /(?:(?:\\u001b\\[)|\\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\\u001b[A-M]/g;\n};\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvfi9zdHJpcC1hbnNpL34vYW5zaS1yZWdleC9pbmRleC5qcz80ZTA3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSw0Q0FBNEMsSUFBSSxTQUFTLE1BQU0sSUFBSTtBQUNuRSIsImZpbGUiOiIyNDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIC8oPzooPzpcXHUwMDFiXFxbKXxcXHUwMDliKSg/Oig/OlswLTldezEsM30pPyg/Oig/OjtbMC05XXswLDN9KSopP1tBLU18Zi1tXSl8XFx1MDAxYltBLU1dL2c7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjayktZGV2LXNlcnZlci9+L3N0cmlwLWFuc2kvfi9hbnNpLXJlZ2V4L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanM/NWY3MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIyNDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval('/*\r\n	MIT License http://www.opensource.org/licenses/mit-license.php\r\n	Author Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(updatedModules, renewedModules) {\r\n	var unacceptedModules = updatedModules.filter(function(moduleId) {\r\n		return renewedModules && renewedModules.indexOf(moduleId) < 0;\r\n	});\r\n\r\n	if(unacceptedModules.length > 0) {\r\n		console.warn("[HMR] The following modules couldn\'t be hot updated: (They would need a full reload!)");\r\n		unacceptedModules.forEach(function(moduleId) {\r\n			console.warn("[HMR]  - " + moduleId);\r\n		});\r\n	}\r\n\r\n	if(!renewedModules || renewedModules.length === 0) {\r\n		console.log("[HMR] Nothing hot updated.");\r\n	} else {\r\n		console.log("[HMR] Updated modules:");\r\n		renewedModules.forEach(function(moduleId) {\r\n			console.log("[HMR]  - " + moduleId);\r\n		});\r\n	}\r\n};\r\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9sb2ctYXBwbHktcmVzdWx0LmpzP2Q3NjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EiLCJmaWxlIjoiMjQ3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cGRhdGVkTW9kdWxlcywgcmVuZXdlZE1vZHVsZXMpIHtcclxuXHR2YXIgdW5hY2NlcHRlZE1vZHVsZXMgPSB1cGRhdGVkTW9kdWxlcy5maWx0ZXIoZnVuY3Rpb24obW9kdWxlSWQpIHtcclxuXHRcdHJldHVybiByZW5ld2VkTW9kdWxlcyAmJiByZW5ld2VkTW9kdWxlcy5pbmRleE9mKG1vZHVsZUlkKSA8IDA7XHJcblx0fSk7XHJcblxyXG5cdGlmKHVuYWNjZXB0ZWRNb2R1bGVzLmxlbmd0aCA+IDApIHtcclxuXHRcdGNvbnNvbGUud2FybihcIltITVJdIFRoZSBmb2xsb3dpbmcgbW9kdWxlcyBjb3VsZG4ndCBiZSBob3QgdXBkYXRlZDogKFRoZXkgd291bGQgbmVlZCBhIGZ1bGwgcmVsb2FkISlcIik7XHJcblx0XHR1bmFjY2VwdGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG1vZHVsZUlkKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybihcIltITVJdICAtIFwiICsgbW9kdWxlSWQpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRpZighcmVuZXdlZE1vZHVsZXMgfHwgcmVuZXdlZE1vZHVsZXMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRjb25zb2xlLmxvZyhcIltITVJdIE5vdGhpbmcgaG90IHVwZGF0ZWQuXCIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRjb25zb2xlLmxvZyhcIltITVJdIFVwZGF0ZWQgbW9kdWxlczpcIik7XHJcblx0XHRyZW5ld2VkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG1vZHVsZUlkKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVJZCk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL2hvdC9sb2ctYXBwbHktcmVzdWx0LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval('/*\r\n	MIT License http://www.opensource.org/licenses/mit-license.php\r\n	Author Tobias Koppers @sokra\r\n*/\r\n/*globals window __webpack_hash__ */\r\nif(true) {\r\n	var lastData;\r\n	var upToDate = function upToDate() {\r\n		return lastData.indexOf(__webpack_require__.h()) >= 0;\r\n	};\r\n	var check = function check() {\r\n		module.hot.check(function(err, updatedModules) {\r\n			if(err) {\r\n				if(module.hot.status() in {abort: 1, fail: 1}) {\r\n					console.warn("[HMR] Cannot check for update. Need to do a full reload!");\r\n					console.warn("[HMR] " + err.stack || err.message);\r\n				} else {\r\n					console.warn("[HMR] Update check failed: " + err.stack || err.message);\r\n				}\r\n				return;\r\n			}\r\n\r\n			if(!updatedModules) {\r\n				console.warn("[HMR] Cannot find update. Need to do a full reload!");\r\n				console.warn("[HMR] (Probably because of restarting the webpack-dev-server)");\r\n				return;\r\n			}\r\n\r\n			module.hot.apply({\r\n				ignoreUnaccepted: true\r\n			}, function(err, renewedModules) {\r\n				if(err) {\r\n					if(module.hot.status() in {abort: 1, fail: 1}) {\r\n						console.warn("[HMR] Cannot apply update. Need to do a full reload!");\r\n						console.warn("[HMR] " + err.stack || err.message);\r\n					} else {\r\n						console.warn("[HMR] Update failed: " + err.stack || err.message);\r\n					}\r\n					return;\r\n				}\r\n\r\n				if(!upToDate()) {\r\n					check();\r\n				}\r\n\r\n				__webpack_require__(247)(updatedModules, renewedModules);\r\n\r\n				if(upToDate()) {\r\n					console.log("[HMR] App is up to date.");\r\n				}\r\n			});\r\n		});\r\n	};\r\n	var addEventListener = window.addEventListener ? function(eventName, listener) {\r\n		window.addEventListener(eventName, listener, false);\r\n	} : function (eventName, listener) {\r\n		window.attachEvent("on" + eventName, listener);\r\n	};\r\n	addEventListener("message", function(event) {\r\n		if(typeof event.data === "string" && event.data.indexOf("webpackHotUpdate") === 0) {\r\n			lastData = event.data;\r\n			if(!upToDate() && module.hot.status() === "idle") {\r\n				console.log("[HMR] Checking for updates on the server...");\r\n				check();\r\n			}\r\n		}\r\n	});\r\n	console.log("[HMR] Waiting for update signal from WDS...");\r\n} else {\r\n	throw new Error("[HMR] Hot Module Replacement is disabled.");\r\n}\r\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9vbmx5LWRldi1zZXJ2ZXIuanM/MmY4NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJmaWxlIjoiMjQ4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLypnbG9iYWxzIHdpbmRvdyBfX3dlYnBhY2tfaGFzaF9fICovXHJcbmlmKG1vZHVsZS5ob3QpIHtcclxuXHR2YXIgbGFzdERhdGE7XHJcblx0dmFyIHVwVG9EYXRlID0gZnVuY3Rpb24gdXBUb0RhdGUoKSB7XHJcblx0XHRyZXR1cm4gbGFzdERhdGEuaW5kZXhPZihfX3dlYnBhY2tfaGFzaF9fKSA+PSAwO1xyXG5cdH07XHJcblx0dmFyIGNoZWNrID0gZnVuY3Rpb24gY2hlY2soKSB7XHJcblx0XHRtb2R1bGUuaG90LmNoZWNrKGZ1bmN0aW9uKGVyciwgdXBkYXRlZE1vZHVsZXMpIHtcclxuXHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0aWYobW9kdWxlLmhvdC5zdGF0dXMoKSBpbiB7YWJvcnQ6IDEsIGZhaWw6IDF9KSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJbSE1SXSBDYW5ub3QgY2hlY2sgZm9yIHVwZGF0ZS4gTmVlZCB0byBkbyBhIGZ1bGwgcmVsb2FkIVwiKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIFwiICsgZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gVXBkYXRlIGNoZWNrIGZhaWxlZDogXCIgKyBlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKCF1cGRhdGVkTW9kdWxlcykge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIENhbm5vdCBmaW5kIHVwZGF0ZS4gTmVlZCB0byBkbyBhIGZ1bGwgcmVsb2FkIVwiKTtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oXCJbSE1SXSAoUHJvYmFibHkgYmVjYXVzZSBvZiByZXN0YXJ0aW5nIHRoZSB3ZWJwYWNrLWRldi1zZXJ2ZXIpXCIpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bW9kdWxlLmhvdC5hcHBseSh7XHJcblx0XHRcdFx0aWdub3JlVW5hY2NlcHRlZDogdHJ1ZVxyXG5cdFx0XHR9LCBmdW5jdGlvbihlcnIsIHJlbmV3ZWRNb2R1bGVzKSB7XHJcblx0XHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0XHRpZihtb2R1bGUuaG90LnN0YXR1cygpIGluIHthYm9ydDogMSwgZmFpbDogMX0pIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gQ2Fubm90IGFwcGx5IHVwZGF0ZS4gTmVlZCB0byBkbyBhIGZ1bGwgcmVsb2FkIVwiKTtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gXCIgKyBlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gVXBkYXRlIGZhaWxlZDogXCIgKyBlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYoIXVwVG9EYXRlKCkpIHtcclxuXHRcdFx0XHRcdGNoZWNrKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXF1aXJlKFwiLi9sb2ctYXBwbHktcmVzdWx0XCIpKHVwZGF0ZWRNb2R1bGVzLCByZW5ld2VkTW9kdWxlcyk7XHJcblxyXG5cdFx0XHRcdGlmKHVwVG9EYXRlKCkpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiW0hNUl0gQXBwIGlzIHVwIHRvIGRhdGUuXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cdHZhciBhZGRFdmVudExpc3RlbmVyID0gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyBmdW5jdGlvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XHJcblx0fSA6IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcblx0XHR3aW5kb3cuYXR0YWNoRXZlbnQoXCJvblwiICsgZXZlbnROYW1lLCBsaXN0ZW5lcik7XHJcblx0fTtcclxuXHRhZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0aWYodHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiYgZXZlbnQuZGF0YS5pbmRleE9mKFwid2VicGFja0hvdFVwZGF0ZVwiKSA9PT0gMCkge1xyXG5cdFx0XHRsYXN0RGF0YSA9IGV2ZW50LmRhdGE7XHJcblx0XHRcdGlmKCF1cFRvRGF0ZSgpICYmIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09IFwiaWRsZVwiKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJbSE1SXSBDaGVja2luZyBmb3IgdXBkYXRlcyBvbiB0aGUgc2VydmVyLi4uXCIpO1xyXG5cdFx0XHRcdGNoZWNrKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHRjb25zb2xlLmxvZyhcIltITVJdIFdhaXRpbmcgZm9yIHVwZGF0ZSBzaWduYWwgZnJvbSBXRFMuLi5cIik7XHJcbn0gZWxzZSB7XHJcblx0dGhyb3cgbmV3IEVycm9yKFwiW0hNUl0gSG90IE1vZHVsZSBSZXBsYWNlbWVudCBpcyBkaXNhYmxlZC5cIik7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvaG90L29ubHktZGV2LXNlcnZlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==')}]);